#! /usr/local/bin/python     # for *nix runs
# ===== Header =====
# Filename: module_accessMySQL.py
# Author: dwbarne@sandia.gov
# Creation date: Sat, 11-08-2008

'''
Purpose:
    provides access to MySQL servers and databases for analyses and plotting
'''

# ===== Global Imports =====
from Tkinter import *           # Tkinter widgets
from tkMessageBox import *      # dialogs such as askokcancel, showinfo, showerror, etc.
from math import *              # for sqrt
import tkFileDialog             # askopenfilename, asksaveasfilename, askdirectory
import tkFont                   # fonts
import os                       # environment variables, current directory, username, etc.
import string                   # process standard Python strings
import errno                    # for error handling
import sys                      # for sys.exit()
import time                     # for time to execute commands
import webbrowser               # for accessing PYLOTDB home page, help page
import re                       # for pattern matching in command line for new buffer rows
import csv                      # for reading and writing CSV files (Comma Separated Values)
import pickle                   # for saving Storage Buffer rows
import platform                 # portable interface to platform information
import subprocess               # for database/table backup and restore
import pylab
import copy                     # to make deep copies (copy.deepcopy()) of objects (i.e., separate copies, not references)
import math                     # for tangent
import socket			# to get hostname

# import external modules
stringErrorExternalModules = ''
errflagExternalModules = 0

# ========== Pmw ==========
try:
    import Pmw                    # Python megawidgets
except:
    errflagExternalModules = 1
    stringErrorExternalModules += (
        'The Python Megawidget package "Pmw" must be installed ' + 
        'for PylotDB to run.\n'
        )
        
# ========== MySQLdb ==========
try:
    import MySQLdb                # MySQL database connectivity
except:
    errflagExternalModules = 1
    stringErrorExternalModules += (
        'The package "MySQLdb" must be installed for PylotDB to run.\n\n'
        )
        
# ============= YAML ===============
try:
    import yaml                 # for "extract and fill" button
except:
    errflagExternalModules = 1
    stringErrorExternalModules += (
        'The package "YAML" must be installed for PylotDB to run.\n\n'
        )

# ========== module_read_csv_file ==========
try:
    import module_read_csv_file as readCsv
except:
    errflagExternalModules = 1
    stringErrorExternalModules += (
        'The module "module_read_csv_file" cannot be imported.\n\n'
        )    
        
# ========== import PylotDB's bar chart plotting modules ==========
stringErrorPlotModules = ''
errflagPlotModules = 0
try:
    import module_PylabPlotMySQL_BarChart
except:
    errflagPlotModules = 1
    stringErrorPlotModules += (
        'Plot module "module_PylabPlotMySQL_BarChart" cannot be imported.\n\n'
        )
        
# ========== import PylotDB's pie chart plotting modules ==========
try:   
    import module_PylabPlotMySQL_PieChart
except:
    errflagPlotModules = 1
    stringErrorPlotModules += (
        'Plot module "module_PylabPlotMySQL_PieChart" cannot be imported.\n\n'
        )
        
# ========== import PylotDB's X-Y Plot modules for single plots ==========
try:
    import module_PylabPlotMySQL_Single
except:
    errflagPlotModules = 1
    stringErrorPlotModules += (
        'Plot module "module_PylabPlotMySQL_Single" cannot be imported.\n\n'
        )
        
# ========== import PylotDB's X-Y Plot modules for multiple plots ==========
try:
    import module_PylabPlotMySQL_All
except:
    errflagPlotModules = 1
    stringErrorPlotModules += (
        'Plot module "module_PylabPlotMySQL_All" cannot be imported.\n\n'
        )
        
# ========== import PylotDB's Kiviat plotting modules for all groups per window ==========
try:
    import module_KiviatMySQL_AllGroupsPerWindow as module_Kiviat_1
except:
    errflagPlotModules = 1
    stringErrorPlotModules += (
        'Plot module "module_KiviatMySQL_AllGroupsPerWindow" cannot be imported.\n\n'
        )
        
# ========== import PylotDB's Kiviat plotting modules for one group per window ==========
try:
    import module_KiviatMySQL_OneGroupPerWindow as module_Kiviat_2
except:
    errflagPlotModules = 1
    stringErrorPlotModules += (
        'Plot module "module_KiviatMySQL_AllGroupsPerWindow" cannot be imported.\n\n'
        )
        
# ========== import PylotDB's Kiviat plotting modules for one curve per plot ==========
try:
    import module_KiviatMySQL_OneCurvePerPlot as module_Kiviat_3
except:
    errflagPlotModules = 1
    stringErrorPlotModules += (
        'Plot module "module_KiviatMySQL_AllGroupsPerWindow" cannot be imported.\n\n'
        )
        
# ========== import PylotDB's Scatter Plot modules for multiple plots ==========
try:
    import module_PylabPlotMySQL_ScatterPlot
except:
    errflagPlotModules = 1
    stringErrorPlotModules += (
        'Plot module "module_PylabPlotMySQL_ScatterPlot" cannot be imported.\n\n'
        )
        
# ===== END OF IMPORTS =====
       
# ERROR CHECKING
# if errors in import, print errors and quit
if errflagPlotModules or errflagExternalModules:
    print stringErrorExternalModules + stringErrorPlotModules
    showerror(
        'Error: importing modules',
        '\n' + 
        stringErrorExternalModules + 
        stringErrorPlotModules + 
        'Possible reasons:\n' + 
        '1. module or package cannot be found\n' +
        '2. an error was found in the module\n\n' +
        'PylotDB must exit.'
        )
    sys.exit()
# ----- end of import plot modules -----

# Globals
# ... DEBUG
DEBUG_ALLROWSCLEARORSELECT_BUFFER = 0 # = 1 print variables related to clearing or selecting rows in storage buffer
DEBUG_AUTOINDEX = 0                     # = 1 print that autoindex has been found
DEBUG_BACKUP = 0                        # = 1 print variables related to database/table backup
DEBUG_BUFFER_COMMAND_LINE = 0           # = 1 detailed printout; = 0 suppress printout
DEBUG_BUFFER_MOVE = 0                   # = 1 print variables for moving selected row in buffer
DEBUG_BUFFER_PICKLE = 0                 # = 1 detailed printout; = 0 supress printout
DEBUG_BUFFER_ROW_GENERATOR = 0          # = 1 detailed printout; = 0 suppress printout
DEBUG_CHECKMARKS_RESTORED = 0   # = 1 print that checkmarks have been restored; with index
DEBUG_CLEARSELECTALL = 0                # = 1 print value of variable used to track whether all rows are checked or cleared
DEBUG_COLUMN_HEADERS = 0                # = 1 print column headers
DEBUG_COMMAND_PEEK = 0          # = 1 print variables related to initially showing table values, checked fields
DEBUG_CSV = 0                           # = 1 detailed printout;  = 0 supress printout
DEBUG_DELETEROWSFROMBUFFER = 0 # = 1 print variables related to deleting selected rows from buffer
DEBUG_DISPLAYMESSAGE = 0        # = 1 print variables related to displaying msgs in text box below table in main window
DEBUG_EDITSELECTEDROWS = 0              # = 1 print variables from editing selected rows
DEBUG_EXTRACT_FILL_TEXT = 0             # = 1 print variables from Extract & Fill using text
DEBUG_EXTRACT_FILL_YAML = 0             # = 1 print variables from Extract & Fill using yaml
DEBUG_FINDHOMEDIR = 0                   # = 1 print home directory where pylotdb.py resides
DEBUG_FORMNEWROWS_BUFFER = 0    # = 1 print variables related to forming a new row in buffer
DEBUG_INSERT = 0                        # = 1 print variables related to inserting new rows into database
DEBUG_INSERTROW = 0                     # = 1 print variables related to inserting rows into database table
DEBUG_ISNUMERICALFIELD = 0          # = 1 print variables related to whether selected field is numerical for plotting
DEBUG_KIVIAT = 0                        # = 1 print variables related to kiviat plots: handlerPlotKiviatSelect(self)
DEBUG_KIVIAT_BUFFER = 0                 # = 1 print variables for adding buffer rows to Kiviat diagrams
DEBUG_KIVIAT_TABLE = 0                  # = 1 print variables for adding table columns to Kiviat diagrams
DEBUG_MAXLINESTODISPLAY = 0     # = 1 print variables related to max lines to display in main table window
DEBUG_PLOT_XY = 0                       # = 1 print variables related to X-Y Plot specs
DEBUG_PLOT_SCATTER = 0              # = 1 print variables related to Scatter Plot specs
DEBUG_PRINTFIRSTFEWROWS = 0      # = 1 print first few rows of table to command window
DEBUG_PRINT_METHOD = 0                 # = 1 print which method PylotDB calls
DEBUG_PRINT_MISC = 0                    # = 1 print miscellaneous output
DEBUG_PRINT_MYSQLCOMMANDFORINSERT = 0   # = 1 print variables for inserting mysql command from co-PylotDB
DEBUG_PRINT_PREVIEW_KIVIAT = 0          # = 1 print variables related to previewing kiviat diagram labels
DEBUG_PYLOTDB_CONF_FILE = 0               # = 1 print variables from pylotdb.conf file
DEBUG_PYLOTDB_CONF_LOCATIONS_FILE = 0     # = 1 print variables from pylotdb_conf_locations.conf
DEBUG_QUIKSELECT = 0                # = 1 print variables related to Quik Select window
DEBUG_REFRESHFIELDS = 0         # = 1 print MySQL Fields for selected Database and Table
DEBUG_REFRESHREFERENCECURVELIST_SCATTER = 0 # = 1 print variable related to reference curve list for scatter plots
DEBUG_REPLACE = 0                       # = 1 print variables from replacing a row in a table
DEBUG_REPLACECHAR = 0              # = 1 print new string with substituted special characters for YAML fill & extraction
DEBUG_RESEQUENCE_AUTO_INDEX = 0         # = 1 print variables from resequencing auto_index primary key field
DEBUG_RESTORE = 0                       # = 1 print variables related to database/table restore
DEBUG_RESTORE_CHECKED_FIELD_NAMES = 0 # =1 print variables related to restoring fields to checked status
DEBUG_ROWSELECT_TABLE = 0                 # = 1 print variables related to row selection for table
DEBUG_ROWSELECT_BUFFER = 0      # = 1 print variables related to row selection for buffer
DEBUG_SANDBOX = 0                       # = 1 print variables related to 'sandbox' table creation
DEBUG_SAVE_CHECKED_FIELD_NAMES = 0 # = 1 print variables related to saving checked field names for re-displaying table
DEBUG_SCATTER = 0                       # = 1 print variables related to scatter plots
DEBUG_SCATTER_LEGEND = 0            # = 1 print variables related to legend for scatter plots
DEBUG_SELECTFIELD = 0                   # = 1 print variables related to select and display ordered fields
DEBUG_SHOWLEGENDLABELSBUFFER_NOERRMSG_SCATTER = 0 # = 1 print variables for showing legend labels in scatter plots
DEBUG_SHOWNUMERICFIELDSONLY = 0 # = 1 print field values having numeric datatypes
DEBUG_SHOWTEXTFIELDSONLY = 0    # = 1 print field values having text datatypes
DEBUG_SHOW_VALUES = 0                   # = 1 print variables related to showing table values
DEBUG_SHOWWHENDISPLAYISFROZEN = 0  # = 1 print when display in main window is frozen
DEBUG_STATISTICS = 0                    # = 1 print variables related to summary and statistics for selected field in table
DEBUG_TABLEISMAPPED = 0                 # = 1 print whether table is mapped (is displayed) to screen
DEBUG_TABLES_REFRESH = 0                # = 1 print tables after refresh
DEBUG_TABLE_VALUES = 0                  # = 1 print table values in output window
DEBUG_TEXT_REGEX = 0                    # = 1 detailed printout of regex (regular expressions) extraction process; 0 = suppress
DEBUG_USER_DEFINED_FIELDS = 0           # = 1 print some variables for user-defined fields for storage buffer for XY plots
DEBUG_USER_DEFINED_FIELDS_SCATTER = 0           # = 1 print some variables for user-defined fields for storage buffer from scatter plots
DEBUG_VARXYSELECT = 0                   # = 1 prints variables related to re-defining self.varXSelect and self.varYSelect when reading in new table
DEBUG_XY = 0                                # = yam print variables related to X-Y plots
DEBUG_XY_LABELS = 0                     # = 1 print variables related to labels for X-Y plots
DEBUG_YAML = 0                          # = 1 detailed printout of yaml extraction process; = 0 suppress detailed output

# ... Stats
DEBUG_THREAD_STATS = 0                  # = 1 print variables related to stats thread
DEBUG_THREAD_VARS = 0                   # = 1 print more variables related to stats thread
THREAD_STATS_MYSQLACCESS = 1      # = 1 start thread for MySQLAccess stats info to database

# for clearing selections from table after plotting specs window
#   is displayed: 
# ... for x-y plots
clearSelectionsFromTable_XY = 0
# ... for scatter plots
clearSelectionsFromTable_Scatter = 0
# ... for kiviat diagrams
clearSelectionsFromTable_Kiviat = 0

# name of this module
MODULE = 'module_accessMySQL'

# >> INSERT: Geometry <<

# ===== Geometry =====
# Define global geometry values
# ... Text frame width and height
w_frameText = 80
h_frameText = 35
# ... Main-window placement relative to top left of screen
x_Windows = 100
y_Windows = 150
# ... Sub-window placement relative to top left of screen
x_subWindows = 10
y_subWindows = 20
# ... button width and height
buttonWidth = 10
buttonHeight = 1
# ===== For MySQL_Output
prefix = '>$ '
# ===== Lines to Display in Database Table display =====
linesDisplayMax = 50
# maximum number of individual X-Y plots
plotsMaxNumber = 25
# maximum number of individual Kiviat plots
plotsMaxNumber_Kiviat = 25

# max number of rows to initially list when using PEEK
rowsMaxNumber_Peek = 25

# for 'Values For Table' window
# table widgets heights and widths; 
#   can adjust table width with the table header and table widths
# ... table header
#widthTableHeader = 1025
#widthTableHeader = 1100
#widthTableHeader = 1050
widthTableHeader = 1100
heightTableHeader = 110
# ... table
#widthTable = 1025 
#widthTable = 1100 
widthTable = 1050 
widthTable = 1100
heightTable = 400
# ... row selection to left of table
widthTableRows = 70
heightTableRows = 400        

# MESSAGES TO USER
# ... typically displayed as mouse is rolled over a particular button, except
# ...    MSG_INITIAL is displayed when the table window is first opened
MSG_INITIAL = (
    'INITIALIZE USING PEEK\n\n' +
    'NOTE: PEEK does not function with "Max lines to display" set to zero.\n\n' +
    'PylotDB initializes table display using the PEEK function to load into memory ' +
    'only the number of displayed lines shown in "Max lines to display".  This allows ' +
    'a cursory examination of large tables without loading the entire table directly. ' +
    'The next step is typically to select a column using X-Select, examine the Stats ' +
    'of the selected column to see what to filter from the entire table on the server, ' +
    'and then use "Table Filtering Options" to filter and display.\n\n' +
    'Note that some buttons generate Python calls on ' +
    'in-memory data without generating MySQL server calls, such as "Show Numerical ' +
    'Fields Only", "Show Text Fields Only", and "Show Selected Rows Only".\n\n' +
    'Other buttons generate MySQL server calls for a table update, such as ' +
    '"Peek loads partial table", "Load All loads complete table", and "Table Filtering Options...".\n\n' +
    'The button "Stats for X-Select Field ..." allows the user to examine either in-memory or ' +
    'on-server data.'
    )

# MAIN button group    
MSG_PEEK = (
    'PEEK LOADS PARTIAL TABLE\n\n' +
    'NOTE: PEEK does not function with "Max lines to display" set to zero.\n\n' +
    'PEEK loads into memory only the number of displayed lines shown in "Max lines to display". ' +
    'This allows a cursory examination of large tables without loading the entire table directly. ' +
    'The next step is typically to select a column using X-Select, examine the Stats ' +
    'of the table to see what to filter from the entire table on the server, and then use ' +
    '"TableFiltering Options" to filter and display.'
    )
MSG_LOAD = (
    'LOAD ALL LOADS COMPLETE TABLE\n\n' +
    'LOAD loads the complete table into memory from the server. However, only the ' +
    '"Max lines to display" number of lines is shown in the table.\n\n' +
    'To display ALL lines in the table, first set "Max lines to display" to zero.'
    )
MSG_SHOWNUMERICALFIELDS = (
    'SHOW NUMERICAL FIELDS ONLY\n\n' +
    'Display fields with numerical datatypes only. Fields are taken from currently displayed table.'
    )
MSG_SHOWTEXTFIELDS = (
    'SHOW TEXT FIELDS ONLY\n\n' +
    'Display fields with text datatypes only. Fields are taken from currently displayed table.'
    )
MSG_SHOWSELECTEDROWS = (
    'SHOW SELECTED ROWS ONLY\n\n' +
    'Display user-selected rows of currently displayed table. Provides another level of filering data ' +
    'in the table.'
    )
MSG_STATS = (
    'STATS FOR X-SELECT FIELD ...\n\n' +
    'Generate statistics for X-Select field. Valid for both text and numerical field datatypes.'
    )
MSG_FILTER = (
    'TABLE FILTERING OPTIONS AND DELETE DISPLAYED ROWS ...\n\n' +
    'Filter table to extract desired data. This command uses the complete table as stored on the server, ' +
    'not the displayed table.\n\n' +
    'If the table is only partially displayed, click on "Stats for X-Select Field" first to determine exactly ' +
    'what fields to filter. You do NOT have to display the entire table in order to filter through the entire ' +
    'table.\n\n' +
    'This option also provides for the capability to delete rows. Filter the table to display the rows to be ' +
    'deleted. Once the table is filtered, the button "Delete displayed rows ..." will activate, and the user ' +
    'can proceed to remove the displayed rows from the table. This operation cannot be undone!'
    )    
# --- end of MAIN button group ---
    
# PLOTS button group
MSG_XYPLOTS = (
    'X-Y PLOTS USING X-Y-SELECT FIELDS\n\n' +
    'Plot single or multiple Y-Select data versus X-Select values. Plots can be cartesian, semi-log, or ' +
    'log-log, and can be saved in various formats for inclusion in documents or vu-graphs.\n\n' +
    'Although many options are available to the user to generate the desired graph, all options have ' +
    'default values so that just clicking on "Plot" generates a graph.'
    )
MSG_KIVIATPLOTS = (
    'KIVIAT PLOTS USING Y-SELECT FIELDS AND SELECT ROWS\n\n' +
    'Plot a Kiviat  graph (aka, radar chart) using data from the displayed table. Must ' +
    'select at least 3 Y-Select fields to generate a valid plot. The X-Select data will be used in the legend.\n\n' + 
    'This function does not use any Storage Buffer data; only displayed table values can be used to generate ' +
    'a Kiviat plot.'
    )
MSG_SCATTERPLOTS = (
    'SCATTER PLOTS WITH CURVE FITS USING X-Y-SELECT FIELDS\n\n' +
    'Plot any number of Y-Select fields as a scatter plot. Has the option to fit all the data with polynomial ' +
    'curve fits all the way up to 5-th degree polynomials. Fitted curves can be stored in Storage Buffer for ' +
    'plotting with other X-Y Plots from table and/or buffer.\n' +
    'Although many options are available to the user to generate the desired graph, all options have ' +
    'default values so that just clicking on "Plot" generates a graph.'
    )
# --- end of PLOTS button group ---

# IMPORT/EXPORT/EDIT button group 
MSG_IMPORTCOPYLOTDATA = (
    'IMPORT CO-PYLOTDB DATA FILE\n\n' +
    'Companion code Co-PylotDB can be used to send data to a database, or it can save the complete ' +
    'command to later be executed by PylotDB, this code. This is handy if for some reason a user of ' +
    'Co-PylotDB does not have access to a remote server, but another user who is running PylotDB does. '  +
    'Then, the Co-PylotDB user sends the data to the PylotDB user who can run this command to insert ' +
    'the data into an accessible (local or remote) database.'
    )
MSG_IMPORTCSVDATA = (
    'IMPORT CSV DATA\n\n' +
    'Imports CSV data from, say, saved spreadsheet data, or from PylotDB data saved as a CSV file.'
    )
MSG_EDITSELECTROWS = (
    'EDIT SELECTED ROWS\n\n' +
    'Allows the user to sequentially edit selected rows in the currently displayed table.'
    )
MSG_INSERTNEWROWS = (
    'INSERT NEW ROWS MANUALLY\n\n' +
    'Allows the user to manually insert new rows of data into the currently displayed table.'
    )
MSG_EXPORTTOCSV = (
    'EXPORT Y-SELECT FIELDS TO CSV FILE\n\n' +
    'Writes currently displayed table fields in CSV format to a user-specified file.'
    )
MSG_EXTRACTDATAANDFILLTABLE = (
    'EXTRACT DATA & FILL TABLE USING X-SELECT FIELD\n\n' +
    'Parses data in specified fields. If the field contains data that is formatted ' +
    'using YAML, the parser automatically extracts the data, creates a field by ' +
    'the name of the variable extracted, and inserts the value of variable into that ' +
    'field. If the field contains simple text data, the user manually creates a new ' +
    'field and then extracts the data using regular expressions to pattern match. '+
    'This method is much slower than the automatic parsing of YAML files, of course.'
    )
# --- end of IMPORT/EXPORT/EDIT button group ---

# misc buttons
MSG_BUFFERSTORE = (
    'BUFFER: STORE X-Y FIELDS\n\n' +
    'Store X-Select and Y-Select data as X-Y paired fields in the Storage Buffer. This is handy for selecting ' +
    'and storing data from several database tables, or even data from several tables from different servers, ' +
    'for plotting.\n\n' +
    'The Storage Buffer is persistent between logins and logouts from different servers. Data from the ' +
    'Storage Buffer is destroyed only when exiting PylotDB or the user purposefully deletes data. However, ' +
    'the Storage Buffer also has the option to save and restore Buffer data as desired.'
    )
MSG_BUFFERDISPLAY = (
    'BUFFER: DISPLAY\n\n' +
    'Display Storage Buffer content.'
    )
MSG_UPDATEPLOTWINDOW = (
    'UPDATE PLOT WINDOW\n\n' +
    'Updates selected plot window with new selections from the displayed table. The new selections REPLACE ' +
    'previous ones. The new selections are NOT added to the previous ones.\n\n' +
    'If it is desired to plot new AND previous selections, save previous selections to the Storage Buffer as they ' +
    'are selected. The newest selections can then be made and easily plotted along with all those in the Storage Buffer.'
    )
MSG_DESELECTALLY = (
    'DE-SELECT ALL Y\n\n' +
    'De-selects all Y-Selected fields, rather than having to manually de-select fields one at a time.'
    )
MSG_SELECTALLYORNUMERICALY = (
    'SELECT NUMERICAL Y FIELDS ONLY / SELECT ALL Y FIELDS\n\n' +
    'Useful for plotting, this dual-purpose button allows the user to select numerical Y-Select fields only or select ' +
    'all Y-Select fields for the displayed table with one click. If a field is checked as X-Select, that field is skipped.\n\n' +
    'This allows the user to easily select only the numerical fields for plotting when both text fields and numerical ' +
    'fields are displayed. Also, if only numerical fields are displayed, the user can select all of those fields at once.'
    )
MSG_DESELECTX = (
    'DE-SELECT X\n\n' +
    'De-selects the X-Select field.'
    )
MSG_QUIKSELECTXY = (
    'QUIK-SELECT X & Y\n\n' +
    'Gives the user the ability to check X and Y header values in a scroll-down list rather than horizontally scrolling ' +
    'through the entire table. Checking a header here checks the header in the table values, and vice-versa.'
    )
MSG_CLEARSELECTALL = (
    'CLEAR/SELECT DISPLAYED ROWS\n\n' +
    'Toggles whether to select or de-select all the displayed table rows.'
    )
MSG_TOP = (
    'TOP\n\n' +
    'Display only the top "Max lines to display" rows of the currently displayed table.\n\n' +
    'Handy for large tables.\n\n' +
    'Row selection is NOT available for this function. Instead, filter the data to display ' +
    'what is needed for plots.'
    )
MSG_MIDDLE = (
    'MIDDLE\n\n' +
    'Display only the middle "Max lines to display" rows of the currently displayed table.\n\n' +
    'Handy for large tables.\n\n' +
    'Row selection is NOT available for this function. Instead, filter the data to display ' +
    'what is needed for plots.'
    )
MSG_BOTTOM = (
    'BOTTOM\n\n' +
    'Display only the bottom "Max lines to display" rows of the currently displayed table.\n\n' +
    'Handy for large tables.\n\n' +
    'Row selection is NOT available for this function. Instead, filter the data to display ' +
    'what is needed for plots.'
    )
MSG_RANGE = (
    'RANGE...\n\n' +
    'Displays a user-selected range of the currently displayed table.\n\n' +
    'Ignores the "Max lines to display" value.\n\n' +
    'Row selection is NOT available for this function. Instead, filter the data to display ' +
    'what is needed for plots.'
    )
MSG_REORDERAUTOINDEX = (
    'RE-ORDER AUTO_INDEX\n\n' +
    'Re-orders "auto_index" field for currently displayed table as stored on server.\n\n' +
    'This comes in handy after deleting rows, for example. The server never ' +
    're-orders this key field unless directed to do so, which is what this button does.'
    )
MSG_RESETFIELDSIZEDEFAULTS = (
    'RESET\n\n' +
    'Clicking on "Reset" button simply re-displays the current table with ' +
    'the default field width, field height, and field font values, subject to the ' +
    '"Maxlines to display" value. The MySQL database table is NOT accessed ' +
    'to perform this operation.'
    )
            
# --- end of misc buttons ---


# LABELS FOR BUTTONS IN MAIN WINDOWS
#   -- also used to display last button pressed
#   -- not all labels are used for button labels; 
#         all labels ARE used for "last button pressed"
# ... MAIN button group
BUTTONLABEL_PEEK = 'Peek\nloads partial table'
BUTTONLABEL_LOAD = 'Load All\nloads complete table'
BUTTONLABEL_SHOWNUMERICALFIELDS = 'Show Numerical\nFields Only'
BUTTONLABEL_SHOWTEXTFIELDS = 'Show Text\nFields Only'
BUTTONLABEL_SHOWSELECTEDROWS = 'Show\nSelected Rows Only'
BUTTONLABEL_STATS = 'Stats\nfor X-Select Field ...'
BUTTONLABEL_FILTER = 'Table Filtering Options\nand Delete Displayed Rows ...' 
# ... PLOTS button group
BUTTONLABEL_XYPLOTS = 'X-Y Plots\nusing X-Y-Select Fields'
BUTTONLABEL_KIVIATPLOTS = 'Kiviat Plots\nusing Y-Select Fields\n and Select Rows'
BUTTONLABEL_SCATTERPLOTS = 'Scatter Plots with Curve Fits\nusing X-Y-Select Fields'
# ... IMPORT/EXPORT/EDIT button group
BUTTONLABEL_IMPORTCOPYLOTDATA = 'Import Co-PylotDB\nData File'
BUTTONLABEL_IMPORTCSVDATA = 'Import\nCSV Data'
BUTTONLABEL_EDITSELECTROWS = 'Edit\nSelected Rows'
BUTTONLABEL_INSERTNEWROWS = 'Insert\nNew Rows Manually'
BUTTONLABEL_EXPORTTOCSV = 'Export Y-Select\nFields to CSV File'
BUTTONLABEL_EXTRACTDATAANDFILLTABLE = 'Extract Data & Fill Table\nUsing X-Select Field'
# ... misc buttons
BUTTONLABEL_BUFFERSTORE = 'BUFFER: Store X-Y Fields'
BUTTONLABEL_BUFFERDISPLAY = 'BUFFER: Display'
BUTTONLABEL_UPDATEPLOTWINDOW = 'UPDATE PLOT WINDOW'
BUTTONLABEL_DESELECTALLY = 'De-select all Y'
BUTTONLABEL_DESELECTX = 'De-select X'
BUTTONLABEL_QUIKSELECTXY = 'Quik-Select X-Y...'
BUTTONLABEL_CLEARSELECTALL = 'Clear/Select displayed rows'
BUTTONLABEL_TOP = 'Top'
BUTTONLABEL_MIDDLE = 'Middle'
BUTTONLABEL_BOTTOM = 'Bottom'
BUTTONLABEL_RANGE = 'Range ...'
BUTTONLABEL_REORDERAUTOINDEX = 'Re-order\nauto_index'
BUTTONLABEL_RESET = 'Reset'

# ===== main class ===== # 
class AccessMySQL(Frame):
    def __init__(self, 
        parent, 
        xself,
        colorbg,
        textMySQLOutputWindows_IO,
        textMySQLCommandsWindows_IO,
#        shell
        ):
        
        Frame.__init__(self)
        
# attributes of the constructor

        self.frameParent = parent
        self.textMySQLOutputWindows_IO = textMySQLOutputWindows_IO
        self.textMySQLCommandsWindows_IO = textMySQLCommandsWindows_IO
            
        self.colorbg = colorbg
        
# define the 'self' instance from pylotdb as a local instance as well;
#  then, we can easily define attributes in this module that are
#  defined in the pylotdb module -- kinda neat, but a little tricky.
#  We can now define attributes in this module as follows:
#    self.pylotdb.myAttribute = 5  (for example)
#  and in the pylotdb module this can now be used as "self.myAttribute".
# Used mainly to get pylotdb.conf file parameters back to pylotdb.py.  
        self.pylotdb = xself
        
# define default values
        self.pylotdb.pylotdb_stats_server_valid = False
        self.pylotdb.pylotdb_stats_server = ''
        self.pylotdb.pylotdb_stats_database = ''
        self.pylotdb.pylotdb_stats_table = ''
        self.pylotdb.pylotdb_stats_server_username = ''
        self.pylotdb.pylotdb_stats_server_password = ''
        self.pylotdb.pylotdb_stats_server_port = ''
        
# environment parameters
        if os.name == 'nt':
            self.userName = os.environ['USERNAME']
        elif os.name == 'posix':
            self.userName = os.environ['USER']
        else:
            try:
                self.userName = os.environ['USER']
            except:
                self.userName = 'UNK'
# server connection        
        self.myDbConnection = 0
        
# initialize number of plot figures;
        self.numberPylabPlotFigure = 0
        self.numberPylabPlotFigure_Kiviat = 200
        self.numberPylabPlotFigure_Scatter = 400

# initialize number of rows in Storage Buffer
        self.bufferRowStore_NumRows = 0

# initialize list of buffer rows        
        self.bufferRowStore = []
        
# initialize saved X-Select and Y-Select field names
        self.saveXSelectFieldName = ''
        self.saveYSelectFieldNames = []
        
# define title font 
        self.titleFont = tkFont.Font(
            family='arial',
            size='8',
            weight='bold',
            )
# define sub-title font
        self.subtitleFont = tkFont.Font(
            family='arial',
            size='8',
            weight='bold',
            )
# define title font big
        self.titleFontBig = tkFont.Font(
            family='arial',
            size='10',
            )
# define title font big bold
        self.titleFontBigBold = tkFont.Font(
            family='arial',
            size='10',
            weight='bold'
            )
# define header font
        self.headerFont = tkFont.Font(
            family='arial',
            size='10',
            weight='bold',
            )
# define header font small
        self.headerFontSmall = tkFont.Font(
            family='arial',
            size='8',
            weight='bold',
            )
# define regular button font
        self.buttonFont = tkFont.Font(
            family='arial',
            size='9',
            )
# define small button font
        self.buttonFontSmall = tkFont.Font(
            family='arial',
            size='8',
            )
# define smallest button font
        self.buttonFontSmallest = tkFont.Font(
            family='arial',
            size='8',
            )
# define data font
        self.dataFont = tkFont.Font(
            family='lucida console',
            size='8',
            )
# define data font bold
        self.dataFontBold = tkFont.Font(
            family='lucida console',
            size='8',
            weight='bold',
            )
# define table font
        self.tableFont = tkFont.Font(
            family='terminal',
            size='9',
            )
# define table font large
        self.tableFontLarge = tkFont.Font(
            family='terminal',
            size='12',
            )
# define smaller table font
        self.tableFont8 = tkFont.Font(
            family='terminal',
            size='8',
            )
# define medium text font for labels
        self.labelFontMedium = tkFont.Font(
            family='arial',
            size='9',
            )
# define medium text bold font for titles
        self.labelFontMediumBold = tkFont.Font(
            family='arial',
            size='9',
            weight='bold',
            )
# define label font
        self.labelFont = tkFont.Font(
            family='arial',
            size='8',
            )
# define default 'Entry' widget font, used in window 'EDIT SELECTED ROWS FOR TABLE'
# get default Entry font, to use with Text font below, since
#  default font for Text is different than Entry, but we want them the same.
# NOTE: cannot use 'font=entry_font.actual()' in font settings in widget; will give wrong font settings!
#  Ref:
#    http://bytes.com/topic/python/answers/827516-tkinter-entry-widgets-font-property-api-changed-python-2-5-2-a
        entryFontDescr = Entry()["font"]
        entry_font = tkFont.Font(font=entryFontDescr)   # gives the instance
#        print('\nDefault font for Entry: %s' % entry_font.actual()) # prints font settings as dictionary
        self.entryDefaultFont = tkFont.Font(
#            family='Tahoma',
#            size=8,
#            weight='normal',
            family=entry_font.actual()['family'],
            size=entry_font.actual()['size'],
            weight=entry_font.actual()['weight']
            )
# Window location offset - used to slightly correct redisplaying a window to its prior location
#     since rootx and root y define the window as the upper left corner of the window without the
#     title bar, but windows manager re-displays the window according to the far upper left corner 
#     of the title bar. Hence, re-display is always offset the height of the title bar, causing the window
#     to creep downwards each time it is displayed. The offset value helps to mitigate or, if set to the 
#     precise height of the title bar, prevent this.
        self.offsetWindowX = 8
        self.offsetWindowY = 30
# Initial window locations            
# ... 'Plot single curve per plot'
        self.labels_xWindowLocationSingle = 850
        self.labels_yWindowLocationSingle = 25
# ... 'Plot all curves' for X-Y Plots
        self.labels_xWindowLocationAll = 850
        self.labels_yWindowLocationAll = 25
# ... 'Plot all curves' for Scatter Plots
        self.labels_xWindowLocationAll_Scatter = 820
        self.labels_yWindowLocationAll_Scatter = 25
# ... kiviat labels
        self.labels_xWindowLocation_AllGroupsPerWindow_Kiviat = 850
        self.labels_yWindowLocation_AllGroupsPerWindow_Kiviat = 25
        self.labels_xWindowLocation_OneGroupPerWindow_Kiviat = 850
        self.labels_yWindowLocation_OneGroupPerWindow_Kiviat = 50
        self.labels_xWindowLocation_OneCurvePerPlot_Kiviat = 850
        self.labels_yWindowLocation_OneCurvePerPlot_Kiviat = 75
        
# ... 'X-Y Plot Specs' window
        self.plottingspecs_xWindowLocation_XY= 20
        self.plottingspecs_yWindowLocation_XY= 0
# ... 'Kiviat Plotting Specs' window
        self.plottingspecs_xWindowLocation_Kiviat = 5
        self.plottingspecs_yWindowLocation_Kiviat = 0
# ... Kiviat plots window
        self.plots_xWindowLocation_Kiviat = 250
        self.plots_yWindowLocation_Kiviat = 100
# ... 'Scatter Plot Specs' window
        self.plottingspecs_xWindowLocation_Scatter = 25
        self.plottingspecs_yWindowLocation_Scatter = 50
# ... Scatter plots window
        self.plots_xWindowLocation_Scatter = 100
        self.plots_yWindowLocation_Scatter = 100
# ... 'Storage Buffer'
        self.buffer_xWindowLocation = 200
        self.buffer_yWindowLocation = 50
# ... 'Storage Buffer' move row
        self.bufferMoveRow_xWindowLocation = 300
        self.bufferMoveRow_yWindowLocation = 400
# ... 'Form New Row'
        self.formNewRow_xWindowLocation = self.buffer_xWindowLocation + 100
        self.formNewRow_yWindowLocation = self.buffer_yWindowLocation + 40
# ... 'Values for Table'
        self.tableValues_xWindowLocation = 50
        self.tableValues_yWindowLocation = 0
# ... 'Values for Table Structure ...'
        self.tablestructure_xWindowLocation = 500
        self.tablestructure_yWindowLocation = 90
# ... Values for 'Input New Rows Manually'
        self.inputnewrowsmanually_xWindowLocation = 500
        self.inputnewrowsmanually_yWindowLocation = 40
# ... Values for 'Create Table From Scratch'
        self.createTableFromScratch_xWindowLocation = 350
        self.createTableFromScratch_yWindowLocation = 100
# ... Values for 'Edit Selected Rows'
        self.editselectedrows_xWindowLocation = 450
        self.editselectedrows_yWindowLocation = 20
# ... 'pickle buffer'
        self.pickleBuffer_xWindowLocation = self.buffer_xWindowLocation + 100
        self.pickleBuffer_yWindowLocation = self.buffer_yWindowLocation + 40
# ... 'unpickle file'
        self.unpickleFile_xWindowLocation = self.buffer_xWindowLocation + 120
        self.unpickleFile_yWindowLocation = self.buffer_yWindowLocation + 60
# ... 'backup and restore databses and tables'
        self.backuprestore_xWindowLocation = 150
        self.backuprestore_yWindowLocation = 10
# ... 'Import MySQL Command File Generated by Co-PylotDB
        self.importCoPylotDBMySQLFile_xWindowLocation = 175
        self.importCoPylotDBMySQLFile_yWindowLocation = 50
# ... window location for 'CREATE TABLE -- 3 METHODS'
        self.createTableTwoMethods_xWindowLocation = 50
        self.createTableTwoMethods_yWindowLocation = 10
# ... window location of 'Edit Field Name'
        self.editFieldName_xWindowLocation = 525
        self.editFieldName_yWindowLocation = 100
# ... window location for 'Create Database'
        self.createDatabase_xWindowLocation = 400
        self.createDatabase_yWindowLocation = 400
# ... window location for 'Delete Database'
        self.deleteDatabase_xWindowLocation = 400
        self.deleteDatabase_yWindowLocation = 500
# ... window location for 'Database Rename'
        self.renameDatabase_xWindowLocation = 400
        self.renameDatabase_yWindowLocation = 280
# ... window location for 'Delete Table'
        self.deleteTable_xWindowLocation = 200
        self.deleteTable_yWindowLocation = 500
# ... window location for 'Add Field'
        self.addField_xWindowLocation = 700
        self.addField_yWindowLocation = 50
# ... window location for 'Delete Field'
        self.deleteField_xWindowLocation = 850
        self.deleteField_yWindowLocation = 240
# ... window location for 'Display Ordered Fields'
        self.displayOrderedFields_xWindowLocation = 100
        self.displayOrderedFields_yWindowLocation = 400
# ... window location for 'Summary'
        self.summarizeField_xWindowLocation = 500
        self.summarizeField_yWindowLocation = 10
# ... window location for 'Range Entry'
        self.rangeEntry_xWindowLocation = 280
        self.rangeEntry_yWindowLocation = 500
# ... window location for 'User Defined Fields' for table values
        self.userDefinedFields_xWindowLocation = 550
        self.userDefinedFields_yWindowLocation = 10
# ... window location for 'User Defined Fields' for scatter plot values
        self.userDefinedFields_Scatter_xWindowLocation = 550
        self.userDefinedFields_Scatter_yWindowLocation = 10
# ... window location for 'Table Functions'
        self.tableFunctions_xWindowLocation = 150
        self.tableFunctions_yWindowLocation = 60
        
# define list of plot windows for main table window
        self.listOfPlotWindowsAvailable = [
            'X-Y',
            'Kiviat',
            'Scatter',
#            'Bar',
            ]
            
# define list of plot windows for buffer storage window
        self.listOfPlotWindowsAvailable_Buffer = [
            'X-Y',
            'Scatter',
#            'Bar',
            ]
        
# define empty list for Table header names
        self.headerNames_X_Table = []
        self.headerNames_Y_Table = []

# define empty list for Buffer header names
        self.headerNames_X_Buffer = []
        self.headerNames_Y_Buffer = []
            
# define empty list for headers for plot file data, x column
        self.headers_PlotFileData_X_Column = []
# define empty list for headers for plot file data, y column
        self.headers_PlotFileData_Y_Column = []
        
# define empty buffer and table plot counts for X-Y plots
        self.jcountBuffer = 0
        self.jcountTable = 0
# define no buffer rows initially checked
        self.listWhichBufferRowsAreChecked = []
        
# define empty buffer and table plot counts for Scatter plots
        self.jcountBuffer_Scatter = 0
        self.jcountTable_Scatter = 0
# define no buffer rows initially checked
        self.listWhichBufferRowsAreChecked_Scatter = []
        
# define empty buffer and table plot counts for Kiviat diagrams
        self.jcountBuffer_Kiviat = 0
        self.jcountTable_Kiviat = 0
        
# flag for adding auto_increment Primary Key
        self.addPrimaryKey = 1
        
# get current directory
        self.currentDirectory = os.getcwd().split('\\').pop()
        self.currentDirectoryFullPath = os.getcwd()        
        
#        print('self.currentDirectoryFullPath = %s' % self.currentDirectoryFullPath)
#        print('self.userName = %s' % self.userName)

# if posix (any *nix version), find which directory pylotdb.py is in, so that
#   new ".conf" file can be written to that directory   
        if os.name == 'posix':
            pylotdbHomeDir = ''
            homeDir = '/home/' + self.userName
            file2find = 'pylotdb.py'
            foundPylotDB = 0
# start in current directory
            if os.path.exists(file2find):
                pylotdbHomeDir = os.getcwd() + '/'
                foundPylotDB = 1
                if DEBUG_FINDHOMEDIR:
                    print('\npylotdbHomeDir found in current directory (posix): %s' % pylotdbHomeDir)
            if not foundPylotDB:
# do a directory tree walk, starting in home directory
                for root, dirs, files in os.walk(homeDir):
                        for file in files:
                            if file2find == file:
                                pylotdbHomeDir = root + '/'
                                foundPylotDB = 1
                                if DEBUG_FINDHOMEDIR:
                                    print('\npylotdbHomeDir found thru directory walk (posix): %s' % pylotdbHomeDir)
                                break
                        if foundPylotDB:
                            break
# for windows, just use current directory; will be ok most of the time, unless
#   an alias is used for "pylotdb.py"
        else:
            pylotdbHomeDir = './'
            if DEBUG_FINDHOMEDIR:
                print('\npylotdbHomeDir found in current directory (windows): %s' % pylotdbHomeDir)
            
        if pylotdbHomeDir == '':
            stringNoPylotDBHomeDir = (
                'No home directory was found for pylotdb.py\n\n' + 
                'This should not have happened, since pylotdb is running!\n\n' +
                'Please contact code administrator with this error.'
                )
            print(stringNoPylotDBHomeDir)
            self.MySQL_Output(
                0,
                stringNoPylotDBHomeDir
                )
            showerror(
                'PYLOTDB home dir not found',
                stringNoPylotDBHomeDir
                )
            sys.exit()
               
        else:
            print('\nOS type: '),
            print(os.name)
            print('pylotdbHomeDir: '),
            print(pylotdbHomeDir)
        
# ------- read "conf" files ---------

# 1. pylotdb_conf_locations.conf
        pylotdbConfLocationsFile_Exists = 0
        try:
            pylotdbConfLocationsFile = open(pylotdbHomeDir + 'pylotdb_conf_locations.conf','r')
            pylotdbConfLocationsFile_Exists = 1
        except:
            stringNoPylotDBConfLocationsFile = (
                'The required file "pylotdb_conf_location.conf" could not be found\n' +
                'or cannot be opened.\n' +
                '\n' +
                'This file should be located in the same directory as "pylotdb.py".\n' +
                '\n' +
                'The file "pylotdb_conf_location.conf" contains information for finding\n' +
                'two other files: "pylotdb.conf" and "pylotdb_stats.conf". PylotDB will\n' +
                'look for both.\n' +
                '\n' +
                'If you wish to continue, click YES. PylotDB will continue to run but\n' +
                'you will need to manually input parameters where needed, and no usage\n' +
                'statistics will be captured for this run.\n\n' +
                'If you do NOT wish to continue, click NO. PylotDB will then generate a\n' +
                'generic template, save it as "pylotdb_conf_locations.conf_template", and exit.\n\n' +
                'Next, edit the file to define appropriate parameters so PylotDB will\n' +
                'be able to find the "pylotdb.conf" and "pylotdb_stats.conf" files. These\n' +
                'files will typically be in the same directory as "pylotdb_conf_locations.conf"\n' +
                'unless security demands otherwise.\n' + 
                '\n' +
                'Next, rename the file to "pylotdb_conf_locations.conf" and make sure this file\n' +
                'is in the same directory as "pylotdb.py".\n' +
                '\n' +
                'Finally, re-run "pylotdb.py".'
                )
            print('\n' + stringNoPylotDBConfLocationsFile + '\n')
            self.MySQL_Output(
                0,
                stringNoPylotDBConfLocationsFile
                )
            pylotdbDotConfLocationsFile_Continue = askyesno(
                'QUESTION',
                stringNoPylotDBConfLocationsFile
                )
            if not pylotdbDotConfLocationsFile_Continue:
                stringConfLocationsFile = (
                    '# file: pylotdb_conf_locations.conf\n' +
                    '# called by: module_accessMySQL.py\n' +
                    '# author: Daniel W. Barnette, dwbarne@sandia.gov\n' +
                    '# date created: May 2011 with modifications made afterward\n' +
                    '\n' +
                    '# COMMENTS\n' +
                    '# 1. The file contains information for locating the files\n' +
                    '#   a) pylotdb.conf           contains user-specified information for\n' +
                    '#                               accessing the main database\n' +
                    '#   b) pylotdb_stats.conf     contains user-specified information\n' +
                    '#                               for tracking usage of "pylotdb.py" and\n' +
                    '#                               the module "module_accessMySQL.py"\n' +
                    '# 2. Using this approach, the two files above may be located by the\n' +
                    '#       user or administrator in any directory desired as long as\n' +
                    '#       the present file contains the correct information as to their\n' +
                    '#       location.\n' +
                    '# 3. This approach enhances security if used properly. For example, the\n' +
                    '#       file "pylotdb.conf" may be left in the same directory as "pylotdb.py",\n' +
                    '#       and the file "pylotdb_stats.conf" may be located in a directory\n' +
                    '#       with permissions set to be inaccessible to general users but still\n' +
                    '#       accessible to "pylotdb.py". For example, permissions set by\n' +
                    '#               chmod <directory_holding_"pylotdb_stats.conf"> 111\n' +
                    '#       will give the directory "executable" permissions but no access.\n' +
                    '# 4. Of course, both "pylotdb.conf" and "pylotdb_stats.conf" may be\n' +
                    '#       located in the same directory as "pylotdb.py", but this may not\n' +
                    '#       be desirable from a security standpoint.\n' +
                    '\n' +
                    '\n' +
                    '# LOCATION OF CONFIGURATION FILE "pylotdb.conf" for pylotdb.py\n' +
                    '# note: a period like "." means the current directory; quotes are not needed here\n' +
                    '# ... directory_pylotdb_conf: directory in which pylotdb configuration file is located;\n' +
                    '#       usually the same as pylotdb.py\n' +
                    '# ... filename_pylotdb_conf: filename used for pylotdb configuration file; usually \'pylotdb.conf\'\n' +
                    '\n' +
                    'directory_pylotdb_conf:\n' +
                    '    - .\n' +
                    '\n' +
                    'filename_pylotdb_conf:\n' +
                    '    - pylotdb.conf\n' +
                    '\n' +
                    '\n' +
                    '# LOCATION OF STATS CONFIGURATION FILE "pylotdb_stats.conf" for pylotdb.py\n' +
                    '# note: a period like "." means the current directory; quotes are not needed here\n' +
                    '# ... directory_pylotdb_stats_conf: directory in which pylotdb stats configuration file is located;\n' +
                    '#       usually the same as pylotdb.py\n' +
                    '# ... filename_pylotdb_stats_conf: filename used for pylotdb stats configuration file;\n' +
                    '         usually \'pylotdb_stats.conf\'\n' +
                    '\n' +
                    'directory_pylotdb_stats_conf:\n' +
                    '    - .\n' +
                    '\n' +
                    'filename_pylotdb_stats_conf:\n' +
                    '    - pylotdb_stats.conf\n'
                    )
                                  
                stringWriteConfLocationsFile_Template = (
                    '\nWriting following to "pylotdb_conf_locations.conf_template" as template\n' +
                    'for file "pylotdb_conf_locations.conf":\n%s\n' 
                    )
                print(
                    stringWriteConfLocationsFile_Template % stringConfLocationsFile
                    )
                self.MySQL_Output(
                    0,
                    stringWriteConfLocationsFile_Template % stringConfLocationsFile
                    )
                try:
                    fileConf = open(pylotdbHomeDir + 'pylotdb_conf_locations.conf_template','w')
                    fileConf.write(stringConfLocationsFile)
                    fileConf.close()
                except:
                    stringCantOpenConfLocationsFile = (
                        '\nCan\t open "pylotdb_conf_locations.conf_template" file\n' +
                        'in directory\n%s\n' +
                        'to write template.\n\n' +
                        'Likely reason is you don\'t have permission to write\n' +
                        'the file to this directory.\n\n' +
                        'Program exiting.'
                        ) % (
                        pylotdbHomeDir
                        )
                    print('\n' + stringCantOpenConfLocationsFile + '\n')
                    self.MySQL_Output(
                        0,
                        stringCantOpenConfLocationsFile
                        )
                    showerror(
                        'Error: cannot open file',
                        stringCantOpenConfLocationsFile
                        )
                    sys.exit()
                else:
                    stringConfLocationsFileWritten = (
                        'A configuration template has been written to file\n\n' +
                        '  "%s/pylotdb_conf_locations.conf_template".\n\n' +
                        'Edit this file to fill in directory locations of noted files,\n' +
                        'then copy the file to "pylotdb_conf_locations.conf" which will\n' +
                        'be read by PylotDB the next time it\'s run.\n\n' +
                        'Program exiting'
                        ) % (
                        pylotdbHomeDir
                        )
                    print('\n' + stringConfLocationsFileWritten + '\n')
                    self.MySQL_Output(
                        0,
                        stringConfLocationsFileWritten
                        )
                    showinfo(
                        'Info: conf file written',
                        stringConfLocationsFileWritten
                        )
                    sys.exit()            
                   
# read the file if it exists          
        if pylotdbConfLocationsFile_Exists:
            self.yamlDotLoad_ConfLocationsFile = yaml.load(pylotdbConfLocationsFile)
            if DEBUG_PYLOTDB_CONF_LOCATIONS_FILE:
                print(
                    '\nself.yamlDotLoadConfLocationsFile:\n%s\n' % 
                    self.yamlDotLoad_ConfLocationsFile
                    )
# define parameters pylotdb.conf
            stringNoLocation_PylotDBDotConf = ''
            directory_pylotdb_conf = self.yamlDotLoad_ConfLocationsFile['directory_pylotdb_conf'][0]
            filename_pylotdb_conf = self.yamlDotLoad_ConfLocationsFile['filename_pylotdb_conf'][0]
            filepath_pylotdb_conf = directory_pylotdb_conf + '/' + filename_pylotdb_conf
            if DEBUG_PYLOTDB_CONF_LOCATIONS_FILE:
                print('\n directory_pylotdb_conf = %s' % directory_pylotdb_conf)
                print(' filename_pylotdb_conf = %s' % filename_pylotdb_conf)
                print(' filepath_pylotdb_conf = %s' % filepath_pylotdb_conf)
                
            if(
            directory_pylotdb_conf == None
            or
            filename_pylotdb_conf == None
            ):
                stringNoLocation_PylotDBDotConf = (
                    'Cannot determine filepath to "pylotdb.conf".\n\n' +
                    'PylotDB will continue running, but with no default values.'
                    )
                print('\n' + stringNoLocation_PylotDBDotConf)
                self.MySQL_Output(
                    0,
                    stringNoLocation_PylotDBDotConf
                    ) 
                
# define parameters for pylotdb_stats.conf
            stringNoLocation_PylotDBStatsDotConf = ''
            directory_pylotdb_stats_conf = self.yamlDotLoad_ConfLocationsFile['directory_pylotdb_stats_conf'][0]
            filename_pylotdb_stats_conf = self.yamlDotLoad_ConfLocationsFile['filename_pylotdb_stats_conf'][0]
            filepath_pylotdb_stats_conf = directory_pylotdb_stats_conf + '/' + filename_pylotdb_stats_conf
            if DEBUG_PYLOTDB_CONF_LOCATIONS_FILE:
                print('\n directory_pylotdb_stats_conf = %s' % directory_pylotdb_stats_conf)
                print(' filename_pylotdb_stats_conf = %s' % filename_pylotdb_stats_conf)
                print(' filepath_pylotdb_stats_conf = %s' % filepath_pylotdb_stats_conf)
                
            if(
            directory_pylotdb_stats_conf == None
            or
            filename_pylotdb_stats_conf == None
            ):
                stringNoLocation_PylotDBStatsDotConf = (
                    'Cannot determine filepath to "pylotdb_stats.conf".\n\n' +
                    'PylotDB will continue running, but with no default values.'
                    )
                print('\n' + stringNoLocation_PylotDBStatsDotConf)
                self.MySQL_Output(
                    0,
                    stringNoLocation_PylotDBStatsDotConf
                    ) 
        
# 2. pylotdb.conf

# define servers from conf file it conf file exists;
#  otherwise, default to blank entries and user has to input values
        self.pylotdbDotConf_Exists = 0
        self.servers = []
        self.usernameForRemoteServer = ''
        try:
            pylotdbDotConf = open(filepath_pylotdb_conf,'r')
            self.pylotdbDotConf_Exists = 1
        except:
            stringNoConfFile = (
                'The required file "pylotdb.conf" could not be found or cannot be opened.\n\n' +
                'The location specified for "pylotdb.conf" as specified in file\n' +
                '"pylotdb_conf_location.conf" is\n\n' +
                '    %s\n\n' +
                '"pylotdb.conf" allows the user to define parameters like username\n' +
                'and server names that would otherwise need to be manually entered\n' +
                'each time PylotDB is run.\n\n' +
                'If you wish to continue, click YES. PylotDB will continue to run but\n' +
                'you will need to manually input parameters where needed.\n\n' +
                'If you do NOT wish to continue, click NO. PylotDB will then generate a \n' +
                'generic template, save it as "pylotdb.conf_template", and exit.\n' +
                'Next, edit the file to define appropriate parameters so these will\n' +
                'not have to be entered every time PylotDB is run.\n\n' +
                'Next, "move" (not copy!) the file to "pylotdb.conf" in the directory specified\n' +
                'in file "pylotdb_conf_location.conf". This directory should be accessible only\n' +
                'to the code administrator and not to the general user population, as site-specific\n' +
                'data and some of the database passwords are stored in the file.\n\n' +
                'The file "pylotdb.conf" should now be ready next time "pylotdb.py" is run.'
                ) % (
                filepath_pylotdb_conf
                )
            if DEBUG_PYLOTDB_CONF_FILE:
                print('\n' + stringNoConfFile + '\n')
                self.MySQL_Output(
                    0,
                    stringNoConfFile
                    )
            pylotdbDotConf_Continue = askyesno(
                'QUESTION',
                stringNoConfFile
                )
            if not pylotdbDotConf_Continue:
                stringConfFileTemplate = (
                    '# file: pylotdb.conf\n' +
                    '# called by: module_accessMySQL.py\n' +
                    '# author: Daniel W. Barnette, dwbarne@sandia.gov\n' +
                    '# date created: May 2011 with modifications made afterward\n' +
                    '\n' +
                    '# COMMENTS\n' +
                    '# 1. If this is a recently created template file, rename this file from\n' +
                    '#    "pylotdb.conf_template" to "pylotdb.conf" after filling in data below.\n' +
                    '# 2. This file is used to define various default parameters for pylotdb;\n' +
                    '#    as such, the widgets in which the parameters appear allow the displayed\n' + 
                    '#    default value to be readily changed if necessary.\n' +
                    '# 3. This file is read and used as object self.yamlDotLoad[<key>] where <key>\n' +
                    '#    is "main_database_servers", for example, to access list of servers.\n' +
                    '# 4. This file\'s location is specified in the file "pylotdb_conf_locations.conf" which\n' +
                    '#    must be located in the same directory as "pylotdb.py".\n' +
                    '# 5. "main_database_servers" below should contain all of the database servers\n' +
                    '#    you are most likely to access; top value is the default value for the\n' +
                    '#    database server login widgets in the MySQL Access Tab in PylotDB.\n' +
                    '# 6. blank fields ARE allowed; however, the user will then have to enter the\n' + 
                    '#    corresponding values when prompted.\n' +
                    '\n' +
                    '# MAIN DATABASE ACCESS - DEFAULT VALUES\n' +
                    '# ... add as many servers as you have access to; one should be \'localhost\'\n' +
                    '# ... username_for_remote_server: can leave blank for security purposes, but will\n' +
                    '#      need to enter each time PylotDB is launched\n' +
                    '# ... username_for_localhost_server: username when server \'localhost\' is selected;\n' +
                    '#      can leave blank, but will need to enter each time PylotDB is launched\n' +
                    '# ... main_database_servers_port: default MySQL value is 3306\n' +
                    '\n' +
                    'main_database_servers:\n' +
                    '   - <server1>\n' +
                    '   - <server2>\n' +
                    '   - <server3>\n' +
                    '\n' +
                    'username_for_remote_server:\n' +
                    '   - <myusername>\n' +
                    '\n' +
                    'username_for_localhost_server:\n' +
                    '   - <myusername>\n' +
                    '\n' +
                    'main_database_servers_port:\n' +
                    '   - 3306'  
                    )
                stringWriteTemplate = (
                    '\nWriting following to "pylotdb.conf_template" as template\n' +
                    'for file "pylotdb.conf":\n%s\n' 
                    )
                print(
                    stringWriteTemplate % stringConfFileTemplate
                    )
                self.MySQL_Output(
                    0,
                    stringWriteTemplate % stringConfFileTemplate
                    )
                try:
                    fileConf = open(directory_pylotdb_conf + '/' + 'pylotdb.conf_template','w')
                    fileConf.write(stringConfFileTemplate)
                    fileConf.close()
                except:
                    stringCantOpenConfFile = (
                        '\nCan\t open "pylotdb.conf_template" file to write template.\n\n' +
                        'Likely reason is you don\'t have permission to write\n' +
                        'the file to this directory.\n\n' +
                        'Program exiting.'
                        )
                    print('\n' + stringCantOpenConfFile + '\n')
                    self.MySQL_Output(
                        0,
                        stringCantOpenConfFile
                        )
                    showerror(
                        'Error: cannot open file',
                        stringCantOpenConfFile
                        )
                    sys.exit()
                else:
                    stringConfFileWritten = (
                        'A configuration template has been written to file\n\n' +
                        '  "%s/pylotdb.conf_template"\n\n' +
                        'Edit this file to fill in data specific to your environment, then\n' +
                        'copy the file to "pylotdb.conf" and place it in the directory specified in file\n' +
                        '"pylotdb_conf_locations.conf". The file will be read by PylotDB the next\n' +
                        'time PylotDB is run.\n\n' +
                        'Program exiting.'
                        ) % (
                        directory_pylotdb_conf
                        )
                    print('\n' + stringConfFileWritten + '\n')
                    self.MySQL_Output(
                        0,
                        stringConfFileWritten
                        )
                    showinfo(
                        'Info: conf file written',
                        stringConfFileWritten
                        )
                    sys.exit()                    
                
# pylotdbDotConf does exist
        if self.pylotdbDotConf_Exists:
            self.yamlDotLoad = yaml.load(pylotdbDotConf)
            if DEBUG_PYLOTDB_CONF_FILE:
                print('\nself.yamlDotLoad:\n%s\n' % self.yamlDotLoad)
# define parameters for main database
            self.servers = self.yamlDotLoad['main_database_servers']
            if self.servers == None:
                self.servers = ''
#            self.servers.sort()
            self.portForServer = self.yamlDotLoad['main_database_servers_port'][0]
            if self.portForServer == None:
                self.portForServer = ''
            self.usernameForRemoteServer = self.yamlDotLoad['username_for_remote_server'][0]
            if self.usernameForRemoteServer == None:
                self.usernameForRemoteServer = ''
            self.usernameForLocalHostServer = self.yamlDotLoad['username_for_localhost_server'][0]
            if self.usernameForLocalHostServer == None:
                self.usernameForLocalHostServer = ''
            if DEBUG_PYLOTDB_CONF_FILE:
                stringForRemoteServer = (
                    'For remote server:\n' +
                    '  username = %s\n' +
                    '  port = %s\n' +
                    '  servers = %s\n'
                    ) % (
                    self.usernameForRemoteServer,
                    self.portForServer,
                    self.servers
                    )
                print('\n' + stringForRemoteServer)
                self.MySQL_Output(
                    1,
                    stringForRemoteServer
                    )
                stringForLocalHostServer = (
                    'For local host server:\n' +
                    '  username = %s\n' +
                    '  port = %s\n' +
                    '  servers = %s\n' 
                    ) % (
                    self.usernameForLocalHostServer,
                    self.portForServer,
                    'localhost'
                    )
                print('\n' + stringForLocalHostServer)
                self.MySQL_Output(
                    1,
                    stringForLocalHostServer
                    )

                    
# 3. pylotdb_stats.conf                     
                    
        self.pylotdbStatsDotConf_Exists = 0
        self.mysql_access_stats_server_username = ''
        try:
            pylotdbStatsDotConf = open(filepath_pylotdb_stats_conf,'r')
            self.pylotdbStatsDotConf_Exists = 1
        except:
            stringNoStatsConfFile = (
                'The required file "pylotdb_stats.conf" could not be found or cannot be opened.\n\n' +
                'The location specified for "pylotdb_stats.conf" as specified in file\n' +
                '"pylotdb_conf_location.conf" is\n' +
                '    %s\n\n' +
                '"pylotdb_stats.conf" allows user to define parameters like username\n' +
                'and server name for tracking usage of "pylotdb.py" that would otherwise\n' +
                'need to be manually entered each time PylotDB is run.\n\n' +
                'If you wish to continue, click YES. PylotDB will continue to run but\n' +
                'no tracking data will be generated or stored.\n\n' +
                'If you do NOT wish to continue, click NO. PylotDB will generate a generic\n' +
                'template, save it as "pylotdb_stats.conf_template", and exit. Next, edit the\n' +
                'file to define appropriate parameters so these will not have to be entered\n' +
                'every time PylotDB is run.\n\n' +
                'Finally, rename the file to "pylotdb_stats.conf" in the directory specified\n' +
                'in file "pylotdb_conf_location.conf". This file should be accessible only\n' +
                'to the code administrator as site-specific data and database passwords are stored\n' +
                'in the file.\n\n' +
                'The file "pylotdb_stats.conf" should now be ready next time "pylotdb.py" is run.'
                ) % (
                filepath_pylotdb_stats_conf
                )
            if DEBUG_PYLOTDB_CONF_FILE:
                print('\n' + stringNoStatsConfFile + '\n')
                self.MySQL_Output(
                    0,
                    stringNoStatsConfFile
                    )
            pylotdbStatsDotConf_Continue = askyesno(
                'QUESTION',
                stringNoStatsConfFile
                )
            if not pylotdbStatsDotConf_Continue:
                stringStatsConfFileTemplate = (
                    '# file: pylotdb_stats.conf\n' +
                    '# called by: module_accessMySQL.py\n' +
                    '# author: Daniel W. Barnette, dwbarne@sandia.gov\n' +
                    '# date created: May 2011 with modifications made afterward\n' +
                    '\n' +
                    '# COMMENTS\n' +
                    '# 1. If this is a recently created template file,, rename this file from\n' +
                    '#    "pylotdb_stats.conf_template" to "pylotdb_stats.conf" after filling in data below.\n' +
                    '# 2. This file is used to define various parameters for pylotdb that should\n' +
                    '#    not be available to general users. As such, this file should be placed\n' +
                    '#    in a directory with proper permissions that protect access. For example, \n' +
                    '#    on a *nix system, permissions set by \n' +
                    '#               chmod <directory_holding_\'pylotdb_stats.conf\'> 111\n' +
                    '#    will give the directory "executable" permissions but no access. Hence, \n' +
                    '#    "pylotdb.py" will be able to read the file, but users cannot access the file.\n' +
                    '# 3. This file\'s location is specified in the file "pylotdb_conf_locations.conf" which\n' +
                    '#    must be located in the same directory as "pylotdb.py".\n' +
                    '# 4. This file is read and used as object self.yamlDotLoadStats[<key>] where <key>\n' +
                    '#    is "mysql_access_stats_server", for example, to access the proper server.\n' +
                    '# 5. blank fields ARE NOT allowed; if any field is blank, the stats corresponding\n' +
                    '#    to the related module are not captured.\n' +
                    '\n' +
                    '\n' +
                    '# MySQL ACCESS STATS DATABASE - tracks MySQL database access\n' +
                    '# ... used to track when \'pylotdb.py\' accesses the MySQL database per database login;\n' +
                    '#       may be different than the number of times \'pylotdb.py\' is launched\n' +
                    '\n' +
                    'mysql_access_stats_server:\n' +
                    '# examples: localhost, myserver.mycompany.mydomain \n' +
                    '   - <server>\n' +
                    '\n' +
                    'mysql_access_stats_database:\n' +
                    '# examples: usage_stats\n' +
                    '   - <database_name>\n' +
                    '\n' +
                    'mysql_access_stats_table:\n' +
                    '# examples: stats_pylotdb_mysql_access\n' +
                    '   - <table_name>\n' +
                    '\n' +
                    'mysql_access_stats_server_username:\n' +
                    '   - <your_server_username>\n' +
                    '\n' +
                    'mysql_access_stats_server_password:\n' +
                    '   - <your_server_password>\n' +
                    '\n' +
                    'mysql_access_stats_server_port:\n' +
                    '# examples: 3306 (default for MySQL server)\n' +
                    '   - 3306\n' +
                    '\n' +
                    '\n' +
                    '# PYLOTDB STATS DATABASE - tracks usage of pylotdb.py\n' +
                    '# ... used to track when \'pylotdby.py\' is launched; may be different than the number\n' +
                    '#      of accesses to MySQL database access\n' +
                    '\n' +
                    'pylotdb_stats_server:\n' +
                    '# examples: localhost, myserver.mycompany.mydomain\n' +
                    '   - <server>\n' +
                    '\n' +
                    'pylotdb_stats_database:\n' +
                    '# examples: usage_stats\n' +
                    '   - <database_name>\n' +
                    '\n' +
                    'pylotdb_stats_table:\n' +
                    '# examples: stats_pylotdb\n' +
                    '   - <table_name>\n' +
                    '\n' +
                    'pylotdb_stats_server_username:\n' +
                    '    - <your_server_username>\n' +
                    '\n' +
                    'pylotdb_stats_server_password:\n' +
                    '    - <your_server_password>\n' +
                    '\n' +
                    'pylotdb_stats_server_port:\n' +
                    '# examples: 3306 (default for MySQL server)\n' +
                    '    - 3306'  
                    )
                    
                stringWriteStatsTemplate = (
                    '\nWriting following to\n' +
                    '  "%s/pylotdb_stats.conf_template" \n' +
                    'as template for file "pylotdb_stats.conf":\n%s\n' 
                    ) % (
                    directory_pylotdb_stats_conf,
                    stringStatsConfFileTemplate
                    )
                print(
                    stringWriteStatsTemplate
                    )
                self.MySQL_Output(
                    0,
                    stringWriteStatsTemplate
                    )
                    
                try:
                    fileStatsConf = open(directory_pylotdb_stats_conf + '/' + 'pylotdb_stats.conf_template','w')
                    fileStatsConf.write(stringStatsConfFileTemplate)
                    fileStatsConf.close()
                except:
                    stringCantOpenStatsConfFile = (
                        '\nCan\t open "pylotdb_stats.conf_template" file to write template.\n\n' +
                        'Likely reason is you don\'t have permission to write\n' +
                        'the file to this directory.\n\n' +
                        'Program exiting.'
                        )
                    print('\n' + stringCantOpenStatsConfFile + '\n')
                    self.MySQL_Output(
                        0,
                        stringCantOpenStatsConfFile
                        )
                    showerror(
                        'Error: cannot open file',
                        stringCantOpenStatsConfFile
                        )
                    sys.exit()
                else:
                    stringStatsConfFileWritten = (
                        'A configuration template has been written to file\n\n' +
                        '  "%s/pylotdb_stats.conf_template"\n\n' +
                        'Edit this file to fill in data specific to your environment, then\n' +
                        'copy the file to "pylotdb_stats.conf" and place it in the directory specified in\n' +
                        'file "pylotdb_conf_locations.conf". The file will be read by PylotDB the next\n' +
                        'time PylotDB is run.\n\n' +
                        'Program exiting.'
                        ) % (
                        directory_pylotdb_stats_conf
                        )
                    print('\n' + stringStatsConfFileWritten + '\n')
                    self.MySQL_Output(
                        0,
                        stringStatsConfFileWritten
                        )
                    showinfo(
                        'Info: conf file written',
                        stringStatsConfFileWritten
                        )
                    sys.exit()                    
                
# pylotdbStatsDotConf does exist
        if self.pylotdbStatsDotConf_Exists:
            self.yamlStatsDotLoad = yaml.load(pylotdbStatsDotConf)
            if DEBUG_PYLOTDB_CONF_FILE:
                print('\nself.yamlStatsDotLoad:\n%s\n' % self.yamlStatsDotLoad)
# define parameters for mysql stats database
            self.mysql_access_stats_server = self.yamlStatsDotLoad['mysql_access_stats_server'][0]
            if self.mysql_access_stats_server == None:
                self.mysql_access_stats_server = ''
            self.mysql_access_stats_server_port = self.yamlStatsDotLoad['mysql_access_stats_server_port'][0]
            if self.mysql_access_stats_server_port == None:
                self.mysql_access_stats_server_port = ''
            self.mysql_access_stats_server_username = self.yamlStatsDotLoad['mysql_access_stats_server_username'][0]
            if self.mysql_access_stats_server_username == None:
                self.mysql_access_stats_server_username = ''
            self.mysql_access_stats_server_password = self.yamlStatsDotLoad['mysql_access_stats_server_password'][0]
          
            if DEBUG_PYLOTDB_CONF_FILE:
                stringForRemoteStatsServer = (
                    'For remote mysql stats server:\n' +
                    '  username = %s\n' +
                    '  port = %s\n' +
                    '  server = %s\n'
                    ) % (
                    self.mysql_access_stats_server_username,
                    self.mysql_access_stats_server_port,
                    self.mysql_access_stats_server
                    )
                print('\n' + stringForRemoteStatsServer)
                self.MySQL_Output(
                    1,
                    stringForRemoteStatsServer
                    )    
                    
# define other parameters for mysql stats database
            self.mysql_access_stats_database = self.yamlStatsDotLoad['mysql_access_stats_database'][0]
            self.mysql_access_stats_table = self.yamlStatsDotLoad['mysql_access_stats_table'][0]

# set 'valid' parameter; any blank parameter will mean pylotdb stats are not collected
            if(
            (self.mysql_access_stats_server == '' or self.mysql_access_stats_server == None)
            or
            (self.mysql_access_stats_database == '' or self.mysql_access_stats_database == None)
            or
            (self.mysql_access_stats_table == '' or self.mysql_access_stats_table == None)
            or
            (self.mysql_access_stats_server_username == '' or self.mysql_access_stats_server_username == None)
            or
            (self.mysql_access_stats_server_password == '' or self.mysql_access_stats_server_password == None)
            or
            (self.mysql_access_stats_server_port == '' or self.mysql_access_stats_server_port == None)
            ):
                self.mysql_access_stats_server_valid = False
            else:
                self.mysql_access_stats_server_valid = True

            if DEBUG_PYLOTDB_CONF_FILE:
                stringForMySQLAccessStats = (
                    'For mysql access stats:\n' +
                    '  username = %s\n' +
#                    '  password = %s\n' +
                    '  port = %s\n' +
                    '  server = %s\n'
                    '  database = %s\n' +
                    '  table = %s\n' 
                    ) % (
                    self.mysql_access_stats_server_username,
#                    self.mysql_access_stats_server_password,
                    self.mysql_access_stats_server_port,
                    self.mysql_access_stats_server,
                    self.mysql_access_stats_database,
                    self.mysql_access_stats_table
                    )
                print('\n' + stringForMySQLAccessStats)
                self.MySQL_Output(
                    1,
                    stringForMySQLAccessStats
                    )
                    
# define parameters for pylotdb stats database
            self.pylotdb.pylotdb_stats_server = self.yamlStatsDotLoad['pylotdb_stats_server'][0]
            self.pylotdb.pylotdb_stats_database = self.yamlStatsDotLoad['pylotdb_stats_database'][0]
            self.pylotdb.pylotdb_stats_table = self.yamlStatsDotLoad['pylotdb_stats_table'][0]
            self.pylotdb.pylotdb_stats_server_username = self.yamlStatsDotLoad['pylotdb_stats_server_username'][0]
            self.pylotdb.pylotdb_stats_server_password = self.yamlStatsDotLoad['pylotdb_stats_server_password'][0]
            self.pylotdb.pylotdb_stats_server_port = self.yamlStatsDotLoad['pylotdb_stats_server_port'][0]
# set 'valid' parameter; any blank parameter will mean pylotdb stats are not collected
            if(
            (self.pylotdb.pylotdb_stats_server == '' or self.pylotdb.pylotdb_stats_server == None)
            or
            (self.pylotdb.pylotdb_stats_database == '' or self.pylotdb.pylotdb_stats_database == None)
            or
            (self.pylotdb.pylotdb_stats_table == '' or self.pylotdb.pylotdb_stats_table == None)
            or
            (self.pylotdb.pylotdb_stats_server_username == '' or self.pylotdb.pylotdb_stats_server_username == None)
            or
            (self.pylotdb.pylotdb_stats_server_password == '' or self.pylotdb.pylotdb_stats_server_password == None)
            or
            (self.pylotdb.pylotdb_stats_server_port == '' or self.pylotdb.pylotdb_stats_server_port == None)
            ):
                self.pylotdb.pylotdb_stats_server_valid = False
            else:
                self.pylotdb.pylotdb_stats_server_valid = True

            if DEBUG_PYLOTDB_CONF_FILE:
                stringForPylotDBStats = (
                    'For pylotdb stats:\n' +
                    '  username = %s\n' +
#                    '  password = %s\n' +
                    '  port = %s\n' +
                    '  server = %s\n'
                    '  database = %s\n' +
                    '  table = %s\n' 
                    ) % (
                    self.pylotdb.pylotdb_stats_server_username,
#                    self.pylotdb.pylotdb_stats_server_password,
                    self.pylotdb.pylotdb_stats_server_port,
                    self.pylotdb.pylotdb_stats_server,
                    self.pylotdb.pylotdb_stats_database,
                    self.pylotdb.pylotdb_stats_table
                    )
                print('\n' + stringForPylotDBStats)
                self.MySQL_Output(
                    1,
                    stringForPylotDBStats
                    )
                    
# ------- end of reading 'conf' file ----------
                
# define line start and end for extracting data from table field 
        self.scrolledlistExtractAndFill_SearchLimited_Start = [
            '1','2','3','4','5','10','15','20','25','50','100','200'
            ]
        self.scrolledlistExtractAndFill_SearchLimited_End = [
            '1','2','3','4','5','10','15','20','25','50','100','200'
            ]
# define nth occurrence of word used as marker to start extracting data
        self.scrolledlistExtractAndFill_NthOccurrences = [
            '1','2','3','4','5','6','7','8','9','10'
            ]
# define delimiter to stop extracting data from table field
        self.scrolledlistExtractAndFill_StopExtractingDelimiter = [
            '<whitespace>',
            ', comma',
            ': colon',
            '; semi-colon',
            '/ forward slash',
            '\ backward slash',
            '- dash or minus',
            '+ plus',
            '_ underscore',
            ]
            
# options for line widths for single curve per plot
# ... for X-Y plots
        self.lineWidth_Plots_XY = (1,2,3,4,5)
        
# ... lists for Scatter Plots
# ...   line widths
        self.listLineWidth_Plots_Scatter = (1,2,3,4,5)  
# ...   marker size for scatter plots; default to 8
        self.listDataMarkerSize = (5,6,7,8,9,10,11,12)
# ... For Polynomial Curve Fit      
# ...   polynomial degrees available to user
        self.listPolynomialDegreesAvailable = (1,2,3,4,5)
# ...   number of points used to plot curve fit - default to 20
        self.listNumberOfPointsForCurveFit = (10,20,30,40,50,100)
# ...   number of decimal places for polynomial coefficients - default to 3
        self.listNumberOfDecimalPlacesForCurveFit = (1,2,3,4,5,6)
# ...   format for polynomial coefficients - default to 'g'
        self.listFormatPolynomialCoefficients = ('g','f','e')
       
# text for selecting just numerical Y fields or all Y fields
#   by setting self.varstringSelectYNumericalOrAll.set('text')
        self.buttontextYNumerical = 'Select numerical Y fields only'
        self.buttontextYAll = 'Select all Y fields'
# ... and for Quik Select window
        self.buttontextQuikSelectYNumerical = self.buttontextYNumerical
        self.buttontextQuikSelectYAll = self.buttontextYAll
            
# define table field widths (in units of character widths)
        self.mytableFieldWidths = []
        self.mytableFieldWidths = [
            '5','10','15','20','30','40','50'
            ]
# define table field heights (in units of lines)
        self.mytableFieldHeights = []
        self.mytableFieldHeights = [
            '1','2','4','6','8','10','15','20','25','50','100'
            ]
# define table field fonts
        self.mytableFieldFonts = []
        self.mytableFieldFonts = [
            '6','8','10','12'
            ]
            
# define height for text widgets in Edit Selected Rows
        self.heightsForEntryWidgets_NoScrollbar = []
        self.heightsForEntryWidgets_WithScrollbar = []
# ... used when no scrollbars are displayed
        self.heightsForEntryWidgets_NoScrollbar = [
            '1','2','3','4','5','10','15','20','25','50','75','100'
            ]
# ... used when either horizontal or vertical scrollbar is displayed
        self.heightsForEntryWidgets_WithScrollbar = [
            '3','4','5','10','15','20','25','50','75','100'
            ]
# define height for text widgets in Input New Rows
        self.heightsForInputWidgets_NoScrollbar = []
        self.heightsForInputWidgets_WithScrollbar = []
        self.heightsForInputWidgets_NoScrollbar = self.heightsForEntryWidgets_NoScrollbar
        self.heightsForInputWidgets_WithScrollbar = self.heightsForEntryWidgets_WithScrollbar

# define field datatypes for MySQL entries:
        self.fieldDataTypes = []
        self.fieldDataTypes = [
            'BIGINT',
            'CHAR',
            'DATE',
            'DECIMAL',
            'DOUBLE',
            'FLOAT',
            'INTEGER',
            'INTEGER UNSIGNED',
            'LONGTEXT',
            'MEDIUMTEXT',
            'SMALLINT',
            'SMALLINT UNSIGNED',
            'TEXT',
            'TIME',
            'TIMESTAMP',
            'TINYTEXT',
            'VARCHAR',
            ] 
            
# define
            
# define field datatype lengths for MySQL entries:
        self.dictFieldDataTypesLength = {}
        self.dictFieldDataTypesLength = {
                       'setvalue_BIGINT' : '20',        # 0
                         'setvalue_CHAR' : '255',       # 1
                         'setvalue_DATE' : '',          # 2
                      'setvalue_DECIMAL' : '20,10',     # 3
                       'setvalue_DOUBLE' : '',          # 4
                        'setvalue_FLOAT' : '',          # 5
                      'setvalue_INTEGER' : '12',        # 6
             'setvalue_INTEGER_UNSIGNED' : '12',        # 7
                     'setvalue_LONGTEXT' : '',          # 8
                   'setvalue_MEDIUMTEXT' : '',          # 9
                     'setvalue_SMALLINT' : '6',         # 10
            'setvalue_SMALLINT_UNSIGNED' : '6',         # 11
                         'setvalue_TEXT' : '',          # 12
                         'setvalue_TIME' : '',          # 13
                    'setvalue_TIMESTAMP' : '',          # 14
                     'setvalue_TINYTEXT' : '',          # 15
                      'setvalue_VARCHAR' : '5000',      # 16
            }
            
# allow following options for MySQL fields
        self.fieldOptions = []
        self.fieldOptions = [
            'DEFAULT NULL',
            'NOT NULL',
            ''
            ] 

# sort types for 'Select & Display Ordered Fields'
        self.fieldSort = []
        self.fieldSort = [
            '=',
            '<',
            '>',
            '<=',
            '>=',
            '!=',
            'LIKE',
            'NOT LIKE'
            ]
            
# options for max lines to display for table
        self.statuslineMaxLinesToDisplay = []
        self.statuslineMaxLinesToDisplay = [
            '0',
            '5',
            '10',
            '25',
            '50',
            '75',
            '100',
            '150',
            '200'
            ]
            
# options for plotting reference curve when all curves are plotted on one plot
        self.multipliersReferenceCurve = [
            '1/10',
            '1/9',
            '1/8',
            '1/7',
            '1/6',
            '1/5',
            '1/4',
            '1/3',
            '1/2',
            '2',
            '3',
            '4',
            '5',
            '6',
            '7',
            '8',
            '9',
            '10'
            ]
            
# options for locating plot legends
        self.legendLocations = [
            'best',
            'upper right',
            'upper left',
            'lower left',
            'lower right',
            'right',
            'center left',
            'center right',
            'lower center',
            'upper center',
            'center',
            ]
            
# options for font weights
# ... for kiviat diagram titles
        self.weightFonts_Kiviat = ['bold','normal']
        
# options for locating titles and subtitles
# ... for kiviat diagrams
# .... title
        self.xLocationTitle_Kiviat = [
            0.,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0
            ]
        self.yLocationTitle_Kiviat = [
            0.,0.01,0.02,0.03,0.04,0.05,0.1,0.2,0.3,0.4,
            0.5,0.6,0.7,0.8,0.9,0.95,0.96,0.97,0.98,0.99,1.0
            ]
# .... subtitles
        self.xLocationSubTitle_Kiviat = [
            0.,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0
            ]
        self.yLocationSubTitle_Kiviat = [
            0.,0.01,0.02,0.03,0.04,0.05,0.1,0.2,0.3,0.4,
            0.5,0.6,0.7,0.8,0.9,0.95,0.96,0.97,0.98,0.99,1.0
            ]
# .... legend
        self.xLocationLegend_Kiviat = [
            0.,0.05,0.1,0.15,0.2,0.25,0.3,0.35,0.4,0.45,0.5,0.55,
            0.6,0.65,0.7,0.75,0.8,0.85,0.9,0.95,1.0
            ]
        self.yLocationLegend_Kiviat = [
            0.,0.01,0.02,0.03,0.04,0.05,0.1,0.2,0.3,0.4,
            0.5,0.6,0.7,0.8,0.9,0.95,0.96,0.97,0.98,0.99,1.0
            ]
        self.legendLabelSpacing_Kiviat = [0.,0.2,0.4,0.6,0.8,1.0]
        self.legendBorderPadding_Kiviat = [0.,0.2,0.4,0.6,0.8,1.0]
            
# options for specifying base for log plots
        self.baseForLogPlots = [
            'e','log_e','log_10','2','4','8','10','16','32','64'
            ]
            
# options for bar/pie chart title font sizes (tuple)
        self.fontsizesChartTitle = (
            '8', '10', '12', '14', '16', '18', '20', '24', '28', '32'
            )
# options for bar/pie chart label font sizes (tuple)
        self.fontsizesChartLabels = (
            '8', '10', '12', '14', '16', '18', '20', '24'
            )
# options for legends
        self.fontsizesLegend = (
            '8', '10', '12', '14', '16', '18', '20'
            )
# options for bar/pie chart 'explode wedges' factor (tuple)
        self.factorsChartExplodeWedges = (
            '0.01', '0.03', '0.05', '0.07', '0.09', '0.11', '0.15', '0.20'
            )
# options for bar chart: width of bar chart bars
        self.widthsChartBar = (
            '0.1', '0.15', '0.2', '0.25', '0.3', '0.35', '0.4', '0.45', '0.5'
            )
        self.widthsChartBarEdge = (
            '1', '1.5', '2', '2.5', '3', '3.5', '4.0'
            )
            
# options for Kiviat plots
# ... spoke labels, at end of spokes
        self.legendNumColumns = [1,2,3,4]
        self.fontsizesKiviatLegend = [
            '8', '10', '12', '14', '16', '18', '20', '24', '28', '32'
            ]
        self.fontsizesKiviatSpokeLabels = [
            '8', '10', '12', '14', '16', '18', '20', '24', '28', '32'
            ]
# ... plot title
        self.fontsizesKiviatTitle = [
            '8', '10', '12', '14', '16', '18', '20', '24', '28', '32'
            ]
# ... plot subtitles
        self.fontsizesKiviatSubTitle = [
            '8', '10', '12', '14', '16', '18', '20', '24', '28', '32'
            ]
# ... grid labels showing grid increments within plot
        self.fontsizesKiviatGridLabels = [
            '8', '10', '12', '14', '16', '18', '20', '24', '28', '32'
            ]
# ... radial tick marks for Kiviat plots
        self.fontsizesTickRadial = self.fontsizesChartLabels
# ... number of chars for spoke labels from y headers
# ...   include number of first chars
        self.listSpokeLabel_IncludeFirstChars = (
            '1','2','3','4','5','6','7','8','9','10','15','20','25','30'
            )
# ...   include number of last chars
        self.listSpokeLabel_IncludeLastChars = self.listSpokeLabel_IncludeFirstChars
# ...   exclude number of first chars
        self.listSpokeLabel_ExcludeFirstChars = self.listSpokeLabel_IncludeFirstChars

# options for bar charts        
# ... for y tick marks on bar charts
        self.fontsizesTickY = self.fontsizesChartLabels
        self.fontsizesTickX = self.fontsizesChartLabels
# ... bar/pie chart background colors (tuple)
        self.colorsChartBackground = (
            'white','black','blue','green','red','cyan','magenta','yellow','gray',
            'lightblue','lightgreen','lightpink','lightyellow',
            'tan','beige',
            )
        self.colorsChartBorder = self.colorsChartBackground
        self.colorsChartTitle = self.colorsChartBackground
        self.colorsChartLabels = self.colorsChartBackground
        self.colorsTickY = self.colorsChartBackground
        self.colorsTickX = self.colorsChartBackground
        self.colorsBar = self.colorsChartBackground
        self.colorsBarEdge = self.colorsChartBackground
        self.colorsLegendPieChart = self.colorsChartBackground
        self.colorsLabelsPieChart = self.colorsChartBackground
# for Kiviat plots
        self.colorsChartLabels_Kiviat = self.colorsChartBackground
        self.colorsTickRadial = self.colorsChartBackground
        self.colorsChartBackground_Kiviat = self.colorsChartBackground
        self.colorsChartInterior_Kiviat = self.colorsChartBackground
        self.lineEnclosedOpacity_Kiviat = (0.,0.2,0.4,0.6,0.8,1.0)
        self.lineWidth_Kiviat = (1,2,3,4,5)
        self.sizeFigure_Kiviat = (10,12,14,16,18,20)
        self.sizeGridLabels_Kiviat = (10,12,14,16,18,20)
        self.widthGridLine_Kiviat = (0.0,0.2,0.4,0.6,0.8,1.0)
        self.styleGridLine_Kiviat = ('solid','dash','dot','dash-dot')
        self.incrementGrid_Kiviat = (0.1,0.2,0.5,1.0)
        self.colorGrid_Kiviat = self.colorsChartBackground
        self.colorGridTick_Kiviat = self.colorsChartBackground
        self.setMaxPlotRadius_Kiviat = (0.5,1.0,1.1,1.2,1.3,1.4,1.5,2.0)

# for matplotlib plots        
        self.dictColorsChart = {
            'white'   : 'w',
            'black'   : 'k',
            'blue'    : 'b',
            'green'   : 'g',
            'red'     : 'r',
            'cyan'    : 'c',
            'magenta' : 'm',
            'yellow'  : 'y'
            }
# options for bar/pie chart axes width, height, left, and bottom (tuple)
        self.widthsChartAxes = (
            '0.5', '0.6', '0.7', '0.8', '0.9', '1.0'
            )
        self.heightsChartAxes = self.widthsChartAxes
        self.leftsChartAxes = (
            '0.0', '0.1', '0.2', '0.3', '0.4', '0.5'
            )
        self.bottomsChartAxes = self.leftsChartAxes
# optins for bar/pie chart figure width and height
        self.widthsChartFigure = (
            '4', '6', '8', '10', '12'
            )
        self.heightChartFigure = self.widthsChartFigure
# bar chart plot default values    

        self.dictBarChartPlotParams_Defaults = {
            'showTitle' : 1,
            'showYLabel' : 1,
            'showGrid' : 0,
            'useLogScale' : 0,
            'orientBarsHorizontal' : 0,
            'titleBarChart' : '',
            'labelYBarChart' : '',
            'fontsizeChartTitle' : 16,
            'fontsizeChartLabels' : 14,
            'fontsizeGeneral' : 12,
            'fontsizeXTickLabels' : 12,   #'medium',
            'fontsizeYTickLabels' : 12,   #'medium',
            'fontsizeLegend' : 14,  #'large',
            'colorChartTitle' : 'black',
            'colorChartBackground' : 'white',
            'colorChartBorder' : 'white',
            'colorChartLabels' : 'black',
            'colorXTickLabels' : 'black',
            'colorYTickLabels' : 'black',
            'widthChartFigure' : 6,
            'heightChartFigure' : 6,
            'widthBars' : 0.35,
            'widthBarsEdge' : 0.01,
            'colorBars' : 'blue',
            'colorBarsEdge' : 'black',
            'alignBars' : 'edge',
            'axesLeft' : 0.1,
            'axesBottom' : 0.1,
            'axesWidth' : 0.9,
            'axesHeight' : 0.9,
            }
# pie chart plot default values
        self.dictPieChartPlotParams_Defaults = {
            'showTitle' : 1,
            'titlePieChart' : '',
            'colorTitle' : 'black',
            'fontsizeTitle' : 16,
#            'showLegend' : 1,
#            'fontsizeLegend' : 14,
            'showExplodedView' : 1,
            'factorExplodeWedges' : 0.05,
#            'colorChartBackground' : 'white',
            'fontsizeLabels' : 14,
            'colorLabels' : 'black',
            }
            
# X-Y single curve per plot default values
        self.dictSingleCurvePerChartPlotParams_Defaults = {
            'showMainTitle' : 0,
            'textMainTitle' : 'SINGLE CURVE PER PLOT',
            'fontsizeMainTitle' : 18,
            'colorMainTitle' : 'black',
            'showTitles' : 0,
            'showGrids' : 1,
            'fontsizeTitle' : 16,
            'fontsizeXYLabels' : 14,
            'colorXYLabels' : 'black',
            'fontsizeXTicks' : 12,
            'colorXTicks' : 'black',
            'fontsizeYTicks' : 12,
            'colorYTicks' : 'black',
            'colorChartBackground' : 'white',
            'colorPlotBorder' : 'white',
            'plotStyle' : '',
            'plotBaseX' : '',
            'plotBaseY' : ''
            }
            
# X-Y multi-curve plot default values
        self.dictMultiCurvePerChartPlotParams_Defaults = {
            'showTitle' : 0,
            'showYLabel' : 0,
            'showXLabel' : 1,
            'showLegend' : 1,
            'showGrid' : 1,
            'showReferenceCurve' : 0,
            'colorBackground' : 'white',
            'colorPlotBorder' : 'white',
            'colorXYLabels' : 'black',
            'colorXTicks' : 'black',
            'colorYTicks' : 'black',
            'colorTitle' : 'blue',
            'fontsizeTitle' : 16,
            'fontsizeXYLabels' : 14,
            'fontsizeXTicks' : 12,
            'fontsizeYTicks' : 12,           
            'fontsizeLegend' : 10,
            'valueTitle' : '',
            'valueLabelY' : '',
            'valueLabelX' : '',
            'valueLegendLocation' : '',
            'valuesLegendLabels' : [],
            'valueRefCurveMultiplier' : '',
            'valueRefCurveLabel' : '',
            'valueRefCurvePlotYList' : [],
            'valueRefCurvePlotXList' : [],
            'plotStyle' : '',
            'plotBase' : '',
            'plotBaseY' : ''
            }
            
# Kiviat plot default values
        self.dictPlotParams_Defaults_Kiviat = {
        # GLOBAL PLOT PARAMETERS
            'colorChartBackground' : 'white', #'lightblue',
            'colorChartInterior' : 'white',
            'lineWidth' : 2,
            'fillColorOpacity' : 0.2,
            'figureSize' : (16,12),
        # NORMALIZATION METHOD
            'normalizationMethod' : 'localNorm',
        # PLOT FORMAT - ASIS OR COMPLEMENT
            'plotFormat' : 'asIs',
        # REPLOT
            'replotInCurrentWindows' : 0,
        # MAIN TITLE
            'showTitle' : 1,
            'defaultTitle' : 'Kiviat Diagrams',
            'fontsizeTitle' : 24,
            'colorTitle' : 'blue',
            'weightTitle' : 'bold',
            'xLocationTitle' : 0.50,
            'yLocationTitle' : 0.98,
        # SUBTITLES (above each plot)
            'showSubTitles' : 1,
            'entrySubTitles' : 'Normalized by max table value',
            'fontsizeSubTitles' : 16,
            'colorSubTitles' : 'black',
            'weightSubTitles' : 'bold',
            'xlocationSubTitles' : 0.5,
            'ylocationSubTitles' : 1.15,
        # SPOKE LABELS
            'showSpokeLabels' : 1,
            'fontsizeSpokeLabels' : 14,
            'colorSpokeLabels' : 'black',
        # GRID
            'showGrid' : 1,
            'colorGrid' : 'black',
            'colorGridTicks' : 'red',
            'fontsizeGridTicks' : 12,
            'lineWidthGrid' : 0.6,
            'lineStyleGrid' : 'dot',
            'incrementGrid' : 0.5,     
        # LEGEND
            'showLegend' : 1,
            'titleLegend' : 'LEGEND',    # optional
            'locationLegend' : 'best', # do not allow option for user to change
            'fontsizeLegend' : 14,
            'columnsLegend' : 1,
            'labelspacingLegend' : 0.2,
            'borderpaddingLegend' : 0.5,
            'modeExpandOrNoneLegend' : 'expand',
            'locationBoundingBoxLegend' : (0.55, 0.95), # use for x- and y-location values
        # SET MAX PLOT RADIUS
            'setMaxPlotRadius' : 0,
            'valueMaxPlotRadius' : 1.0,
        # PLOTS
            'plot_Selection_Kiviat' : 'plot_all_groups_per_window',
            'plot_local_global_maxima_AllGroupsPerWindow' : 'local',
            'plot_local_global_maxima__OneGroupPerWindow' : 'local',
            'plot_choice_group_1' : 'plot_all_groups_per_window',       # for self.varGroupsSelection_Kiviat.get()
            'plot_choice_group_2' : 'plot_one_group_per_window',
            'plot_choice_group_3' : 'plot_one_curve_per_window',
            }
            
# X-Y multi-curve plot default values
        self.dictMultiCurvePerChartPlotParams_Scatter_Defaults = {
            'showTitle' : True,
            'showTitle_title' : 'Scatter Plot',
            'showYLabel' : True,
            'showYLabel_label' : 'Y',
            'showXLabel' : True,
            'showXLabel_label' : 'X',
            'showLegend' : True,
            'showLegendShadow' : True,
            'showGrid' : True,
            'showCurveFit' : False,
            'showReferenceCurve' : False,
            'showSlopedStraightLineReferenceCurve' : False,
            'showHorizontalStraightLineReferenceCurve' : False,
            'showVerticalStraightLineReferenceCurve' : False,
            'colorBackground' : 'white',
            'colorXYLabels' : 'black',
            'colorXTicks' : 'black',
            'colorYTicks' : 'black',
            'colorTitle' : 'black',
            'colorPlotBorder' : 'white',
            'fontsizeTitle' : 16,
            'fontsizeXYLabels' : 12,
            'fontsizeXTicks' : 12,
            'fontsizeYTicks' : 12, 
            'fontsizeLegend' : 10,
            'valueTitle' : '',
            'valueLabelY' : '',
            'valueLabelX' : '',
            'valueLegendLocation' : '',
            'valuesLegendLabels' : [],
            'valueRefCurveMultiplier' : '',
            'valueRefCurveLabel' : '',
            'valueSlopedStraightLineRefCurveLabel' : '',
            'valueHorizontalStraightLineRefCurveLabel' : '',
            'valueVerticalStraightLineRefCurveLabel' : '',
            'valuesRefCurvePlotYList' : [],
            'valuesRefCurvePlotXList' : [],
            'valuesSlopedStraightLineRefCurvePlotYList' : [],
            'valuesSlopedStraightLineRefCurvePlotXList' : [],
            'valuesHorizontalStraightLineRefCurvePlotYList' : [],
            'valuesHorizontalStraightLineRefCurvePlotXList' : [],
            'valuesVerticalStraightLineRefCurvePlotYList' : [],
            'valuesVerticalStraightLineRefCurvePlotXList' : [],
            'plotStyle' : '',
            'plotBaseX' : '',
            'plotBaseY' : '',
            'lineWidth' : '',
            'numPointsForCurveFit' : 20,
            'markerSize' : 8,
            'connectDataPoints' : True,
            'polyDegree' : 3,
            'plotPolyDegree' : False,
            'plotAllLesserDegrees' : False,
            'numberDecimalPlacesInEqn' : 3 ,   # 0 for integers; otherwise, range is 1 to 10, editable
            'formatPolyCoefs' : 'g',
            }
            
# header names for buffer storage
# ... Note: last two are listed only for completeness
        self.headerNamesBufferStorage = [
            'user comment',
            'user_field_1',
            'user_field_2',
            'user_field_3',
            'user_field_4',
            'x_header',
            'y_header',
            'first (x,y) pair',
            'last (x,y) pair',
            'database',
            'table',
            'num_points',
            'timestamp',
#            'xValues',
#            'yValues'
            ]   

# plot label options from header names for buffer storage
        self.labelNamesBufferStorage = self.headerNamesBufferStorage[0:5]
        self.labelNamesBufferStorage.append(self.headerNamesBufferStorage[9])
        self.labelNamesBufferStorage.append(self.headerNamesBufferStorage[10])
# dictionary of same
# ... format: {storage : index}
        self.dictNamesBufferStorage = {
            self.labelNamesBufferStorage[0] : 0,    # user comment
            self.labelNamesBufferStorage[1] : 1,    # user field 1
            self.labelNamesBufferStorage[2] : 2,    # user field 2
            self.labelNamesBufferStorage[3] : 3,    # user field 3
            self.labelNamesBufferStorage[4] : 4,    # user field 4
            self.labelNamesBufferStorage[5] : 9,    # database
            self.labelNamesBufferStorage[6] : 10    # table
            }
            

# plot label separators
        self.separatorsPlotLabelsAndLegends = [
            ', (comma+space)',
            '  (space)',
            '\ (backward slash)',
            '/ (forward slash)',
            '- (dash)',
            '_ (underscore)',
            '+ (plus)',
            '* (asterisk)',
            '> (greater than)',
            '< (less than)'
            ]

# for buffer groups
        self.bufferGroupNumbers = [
            '1','2','3','4','5','6','7','8','9','10'
            ]
        self.bufferGroupLabels = [
            'Group 1',
            'Group 2',
            'Group 3',
            'Group 4',
            'Group 5',
            'Group 6',
            'Group 7',
            'Group 8',
            'Group 9',
            'Group 10'
            ]
            
# scrolled list items for Show Label X, Plot All Curves section of X-Y Plot Specs
        self.listitemsShowLabelX_AllCurvesOnePlot = []
# scrolled list items for Show Label X, Plot All Curves section of Scatter Plot Specs
        self.listitemsShowLabelX_AllCurvesOnePlot_Scatter = []
        
# for kiviat plots
        self.headernames_X_Table_Kiviat = []
        self.headerNames_Y_Table_Kiviat = []
        self.headerNames_X_Buffer_Kiviat = []
        self.headerNames_Y_Buffer_Kiviat = []
        
# for scatter plots
        self.headerNames_X_Table_Scatter = []
        self.headerNames_Y_Table_Scatter = []
        self.headerNames_X_Buffer_Scatter = []
        self.headerNames_Y_Buffer_Scatter = []

# start creating widgets        
        self.createWidgets()
        
        
#===================================================================
        
    def createWidgets(self):
        '''
        defines widgets for accessing MySQL
        
        Output:
            username:   self.varUserMySQL
            password:   self.varPasswordMySQL
            server:     self.comboServerMySQL
            port:       self.varPortMySQL
            
            total databases:    self.varDbTotal
            total tables:       self.varDbTablesTotal
            total fields:       self.varDbFieldsTotal
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'createWidgets')
            
# FRAMES
# ... mainframe_00
        self.frameMySQL_00 = Frame(
            self.frameParent,
            bg=self.colorbg,
            )
        self.frameMySQL_00.grid(
            row=0,
            column=0,
            padx=10,
            pady=10,
            sticky=N,
            )

# ... subframe_00_00 Left
        self.frameMySQL_00_00 = Frame(
            self.frameMySQL_00,
            bg=self.colorbg,
            )
        self.frameMySQL_00_00.grid(
            row=0,
            column=0,
            stick=N,
            )

# ... subframe_00_10 Left
        self.frameMySQL_00_10 = Frame(
            self.frameMySQL_00,
            bg=self.colorbg
            )
        self.frameMySQL_00_10.grid(
            row=1,
            column=0,
            pady=2,
            )
          
# ... main_01
        self.frameMySQL_01 = Frame(
            self.frameParent,
            bg=self.colorbg,
            )
        self.frameMySQL_01.grid(
            row=0,
            column=1,
            padx=5,
            pady=10,
            sticky=N,
            )
# ... subframe_01_00
        self.frameMySQL_01_00 = Frame(
            self.frameMySQL_01,
            bg=self.colorbg,
            )
        self.frameMySQL_01_00.grid(
            row=0,
            column=0,
            )
# ... subframe_01_10
        self.frameMySQL_01_10 = Frame(
            self.frameMySQL_01,
            bg=self.colorbg,
            )
        self.frameMySQL_01_10.grid(
            row=1,
            column=0,
            )        

# ... main_02
        self.frameMySQL_02 = Frame(
            self.frameParent,
            bg=self.colorbg,
            )
        self.frameMySQL_02.grid(
            row=0,
            column=2,
            padx=5,
            pady=10,
            sticky=N,
            )
# ... subframe_02_00
        self.frameMySQL_02_00 = Frame(
            self.frameMySQL_02,
            bg=self.colorbg,
            )
        self.frameMySQL_02_00.grid(
            row=0,
            column=0,
            )
# ... subframe_02_10
        self.frameMySQL_02_10 = Frame(
            self.frameMySQL_02,
            bg=self.colorbg,
            )
        self.frameMySQL_02_10.grid(
            row=1,
            column=0,
            )                    

# ... main_03
        self.frameMySQL_03 = Frame(
            self.frameParent,
            bg=self.colorbg,
            )
        self.frameMySQL_03.grid(
            row=0,
            column=3,
            padx=5,
            pady=10,
            sticky=N,
            )
# ... subframe_03_00
        self.frameMySQL_03_00 = Frame(
            self.frameMySQL_03,
            bg=self.colorbg,
            )
        self.frameMySQL_03_00.grid(
            row=0,
            column=0,
            ) 
# ... subframe_03_10
        self.frameMySQL_03_10 = Frame(
            self.frameMySQL_03,
            bg=self.colorbg,
            )
        self.frameMySQL_03_10.grid(
            row=1,
            column=0,
            ) 

# ... main_11
        self.frameMySQL_11 = Frame(
            self.frameParent,
            bg=self.colorbg,
            )
        self.frameMySQL_11.grid(
            row=1,
            column=1,
            columnspan=3,
            padx=5,
            pady=5,
            sticky=N,
            )    

# WIDGETS
# ... LEFT TOP       
        labelConnect = Label(
            self.frameMySQL_00_00,
            text='CONNECT TO MySQL SERVER',
            bg=self.colorbg,
            )
        labelConnect.grid(
            row=0,
            column=0,
            columnspan=99,
            padx=0,
            pady=10,
            )
# ... label for server            
        labelConnect = Label(
            self.frameMySQL_00_00,
            text='Server: ',
            bg=self.colorbg,
            )
        labelConnect.grid(
            row=1,
            column=0,
            sticky=E,
            pady=2
            ) 
# servers
        self.comboServerMySQL = Pmw.ComboBox(
            self.frameMySQL_00_00,
            scrolledlist_items=self.servers,
            listheight=100,
            entry_width=20,
            scrolledlist_hull_width=500,
            selectioncommand=self.handlerAssignUserName,
            )
        self.comboServerMySQL.grid(
            row=1,
            column=1,
            sticky=W,
            pady=2,
            ) 
# ... label for username            
        labelConnect = Label(
            self.frameMySQL_00_00,
            text='Username: ',
            bg=self.colorbg,
            )
        labelConnect.grid(
            row=2,
            column=0,
            sticky=E,
            pady=2
            ) 
# ... entry field for username
        self.varUserMySQL = StringVar()
        self.entryUserMySQL = Entry(
            self.frameMySQL_00_00,
            width=20,
            textvariable=self.varUserMySQL,
            )
        self.entryUserMySQL.grid(
            row=2,
            column=1,
            sticky=W,
            pady=2
            )
# ... label for password            
        labelConnect = Label(
            self.frameMySQL_00_00,
            text='Password: ',
            bg=self.colorbg,
            )
        labelConnect.grid(
            row=3,
            column=0,
            sticky=E,
            pady=2
            ) 
# ... entry for password
        self.varPasswordMySQL = StringVar()
        self.varPasswordMySQL.set('')
        self.entryPasswordMySQL = Entry(
            self.frameMySQL_00_00,
            width=20,
            show='*',
            textvariable=self.varPasswordMySQL
            )
        self.entryPasswordMySQL.grid(
            row=3,
            column=1,
            sticky=W,
            pady=2
            )
        self.entryPasswordMySQL.bind(
            "<KeyPress-Return>",
            self.handlerConnectAfterPassword,
            )
# ... label for Port     
        labelPort = Label(
            self.frameMySQL_00_00,
            text='Port: ',
            bg=self.colorbg,
            )
        labelPort.grid(
            row=4,
            column=0,
            sticky=E,
            pady=2
            ) 
# ... entry for port
        self.varPortMySQL = StringVar()
        if self.pylotdbDotConf_Exists:
            self.varPortMySQL.set(
                self.portForServer
#                self.yamlDotLoad['main_database_servers_port'][0]
                )
        else:
            self.varPortMySQL.set('3306')
            
        self.entryPortMySQL = Entry(
            self.frameMySQL_00_00,
            width=20,
            textvariable=self.varPortMySQL,
            )
        self.entryPortMySQL.grid(
            row=4,
            column=1,
            sticky=W,
            )
            
# set some parameters
        try:
            self.comboServerMySQL.selectitem(self.servers[0])
        except:
            self.comboServerMySQL.setentry(' ')
        if self.comboServerMySQL.get().strip() == 'localhost':
#            self.varUserMySQL.set('root')
            self.varUserMySQL.set(self.usernameForLocalHostServer)
        else:
            self.varUserMySQL.set(self.usernameForRemoteServer)
            
# ... reset
        self.buttonResetInputsMySQL = Button(
            self.frameMySQL_00_00,
            text='Reset',
            font=self.buttonFontSmall,
            borderwidth=5,
            relief=RAISED,
            command=self.handlerResetValuesMySQL,
            )
        self.buttonResetInputsMySQL.grid(
            row=5,
            column=0,
            columnspan=99,
            )

# ... connect button
        self.buttonConnectToMySQL = Button(
            self.frameMySQL_00_10,
            text='Connect',
#            bg=self.colorbg,
            borderwidth=5,
            relief=RAISED,
            command=self.handlerMySQLConnect,
#            command=self.handlerOracleConnect, # method needs editing
            )
        self.buttonConnectToMySQL.grid(
            row=1,
            column=0,
            padx=10,
            )
            
# ... status label
        labelStatus = Label(
            self.frameMySQL_00_10,
            text=' STATUS: ',
            font=self.titleFont,
            bg=self.colorbg,
            )
        labelStatus.grid(
            row=1,
            column=1,
            pady=5,
            )
            
# ... status buttons
#       not connected
        self.varStatusDbNotConnected = StringVar()
        self.varStatusDbNotConnected.set(0)
        self.radiobuttonStatusDbNotConnected = Radiobutton(
            self.frameMySQL_00_10,
            text='Not connected',
            justify=LEFT,
            variable=self.varStatusDbNotConnected,
            indicatoron=1,
            selectcolor='red',
            bg=self.colorbg,
            fg='black',
            disabledforeground='black',
            )
        self.radiobuttonStatusDbNotConnected.grid(
            row=0,
            column=2,
            sticky=W,
            )

#       attempting to connect
        self.varStatusDbAttemptConnect = StringVar()
        self.varStatusDbAttemptConnect.set(0)
        self.radiobuttonStatusDbAttemptConnect = Radiobutton(
            self.frameMySQL_00_10,
            text='Attempting to connect',
            justify=LEFT,
            variable=self.varStatusDbAttemptConnect,
            indicatoron=1,
            selectcolor='yellow',
            bg=self.colorbg,
            fg='black',
            disabledforeground='black',
            )
        self.radiobuttonStatusDbAttemptConnect.grid(
            row=1,
            column=2,
            sticky=W,
            )

#       connected
        self.varStatusDbConnected = StringVar()
        self.varStatusDbConnected.set(0)
        self.radiobuttonStatusDbConnected = Radiobutton(
            self.frameMySQL_00_10,
            text='Connected',
            justify=LEFT,
            variable=self.varStatusDbConnected,
            indicatoron=1,
            selectcolor='green',
            bg=self.colorbg,
            fg='black',
            disabledforeground='black',
            )
        self.radiobuttonStatusDbConnected.grid(
            row=2,
            column=2,
            sticky=W,
            )
 
# disable all but the 'Not connected' indicator
        self.radiobuttonStatusDbNotConnected.configure(state='normal')
        self.radiobuttonStatusDbAttemptConnect.configure(state='disabled')
        self.radiobuttonStatusDbConnected.configure(state='disabled')

# button to disconnect from server        
        self.buttonMySQLDisconnect = Button(
            self.frameMySQL_00_10,
#            text='Disconnect from MYSQL server',
            text='Disconnect from server',
            borderwidth=5,
            relief=RAISED,
            command=self.handlerMySQLDisconnect,
            )
        self.buttonMySQLDisconnect.grid(
            row=3,
            column=0,
            columnspan=99,
            pady=10,
            )
        
# DATABASES ON SERVER
# initialize myDatabases as empty       
        self.myDatabases = []
# graph combobox widget
        self.mysql_ComboDatabases()
# buttons for modifying DATABASES
# ... add
        self.buttonDatabaseAdd = Button(
            self.frameMySQL_01_10,
            text='Create',
            borderwidth=5,
            relief=RAISED,
            font=self.buttonFontSmall,
            width=8,
            command=self.handlerDatabaseAdd,
            )
        self.buttonDatabaseAdd.grid(
            row=0,
            column=0,
            columnspan=1,
            padx=2,
            pady=2,
            sticky=E,
            )
# ... delete
        self.buttonDatabaseDelete = Button(
            self.frameMySQL_01_10,
            text='Delete',
            borderwidth=5,
            relief=RAISED,
            font=self.buttonFontSmall,
            width=8,
            command=self.handlerDatabaseDelete,
            )
        self.buttonDatabaseDelete.grid(
            row=0,
            column=1,
            columnspan=1,
            padx=2,
            pady=2,
            sticky=W,
            )
# ... functions
        self.buttonDatabaseFunctions = Button(
            self.frameMySQL_01_10,
            text='Rename database',
            borderwidth=5,
            relief=RAISED,
            font=self.buttonFontSmall,
            width=20,
            command=self.handlerDatabaseFunctions,
            )
        self.buttonDatabaseFunctions.grid(
            row=1,
            column=0,
            columnspan=2,
            pady=2,
            )


# TABLES IN DATABASE
# initialize myDatabaseTables as empty
        self.myDatabaseTables = []
# graph combobox widget
        self.mysql_ComboDatabaseTables()
# buttons for modifying TABLES IN DATABASE
# ... add
        self.buttonDatabaseTablesAdd = Button(
            self.frameMySQL_02_10,
            text='Create',
            borderwidth=5,
            relief=RAISED,
            font=self.buttonFontSmall,
            width=8,
            command=self.handlerDatabaseTablesAdd,
            )
        self.buttonDatabaseTablesAdd.grid(
            row=0,
            column=0,
            columnspan=1,
            padx=2,
            pady=2,
            sticky=E,
            )
# ... delete
        self.buttonDatabaseTablesDelete = Button(
            self.frameMySQL_02_10,
            text='Delete',
            borderwidth=5,
            relief=RAISED,
            font=self.buttonFontSmall,
            width=8,
            command=self.handlerDatabaseTablesDelete,
            )
        self.buttonDatabaseTablesDelete.grid(
            row=0,
            column=1,
            columnspan=1,
            padx=2,
            pady=2,
            sticky=W,
            )
# ... functions
        self.buttonDatabaseTablesFunctions = Button(
            self.frameMySQL_02_10,
            text='Table functions',
            borderwidth=5,
            relief=RAISED,
            font=self.buttonFontSmall,
            width=20,
            command=self.handlerDatabaseTableFunctions,
            )
        self.buttonDatabaseTablesFunctions.grid(
            row=1,
            column=0,
            columnspan=2,
            pady=2,
            )


# FIELDS IN TABLE    
# initialize myDatabaseFields as empty
        self.myDatabaseFields = []
# graph combobox widget
        self.mysql_ComboDatabaseFields()
# buttons for modifying FIELDS IN TABLE
# ... add
        self.buttonDatabaseFieldsAdd = Button(
            self.frameMySQL_03_10,
            text='Add',
            borderwidth=5,
            relief=RAISED,
            font=self.buttonFontSmall,
            width=8,
            command=self.handlerDatabaseFieldsAdd,
            )
        self.buttonDatabaseFieldsAdd.grid(
            row=0,
            column=0,
            columnspan=1,
            padx=2,
            pady=2,
            sticky=E,
            )
# ... delete
        self.buttonDatabaseFieldsDelete = Button(
            self.frameMySQL_03_10,
            text='Delete',
            borderwidth=5,
            relief=RAISED,
            font=self.buttonFontSmall,
            width=8,
            command=self.handlerDatabaseFieldsDelete,
            )
        self.buttonDatabaseFieldsDelete.grid(
            row=0,
            column=1,
            columnspan=1,
            padx=2,
            pady=2,
            sticky=W,
            )
# ... functions
        self.buttonDatabaseFieldsFunctions = Button(
            self.frameMySQL_03_10,
            text='Edit field name',
            borderwidth=5,
            relief=RAISED,
            font=self.buttonFontSmall,
            width=20,
            command=self.handlerDatabaseFieldsSelect
            )
        self.buttonDatabaseFieldsFunctions.grid(
            row=1,
            column=0,
            columnspan=2,
            pady=2,
            )
            
# ... backup and restore
        self.buttonBackupRestoreDatabasesFields = Button(
            self.frameMySQL_11,
            text='Backup & Restore Databases and Tables',
            borderwidth=5,
            relief=RAISED,
            font=self.buttonFontSmall,
            width=50,
            command=self.handlerBackupRestoreDatabasesTables,
            )
        self.buttonBackupRestoreDatabasesFields.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
            
        return
            

# ===== Handlers go below ===== #

    def handlerAssignUserName(self,value):
        '''
        assign Username each time a Server is picked
        
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerAssignUserName')
        
        if value == 'localhost':
#            self.varUserMySQL.set('root')
            self.varUserMySQL.set(self.usernameForLocalHostServer)
        else:
            self.varUserMySQL.set(self.usernameForRemoteServer)
            
        return
        
            
    def handlerBackupRestoreDatabasesTables(self):
        '''
        backup and restore databases and/or tables
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerBackupRestoreDatabsesTables')

# set variables
        colorbg = 'lightblue'
# FRAMES
# destroy any old toplevel frames
        self.destroyAllDatabaseTableFieldFrames()

# open toplevel frame for entering database name
        self.toplevelBackupRestore = Toplevel(
            bg=colorbg
            )
        self.toplevelBackupRestore.title(
            'BACKUP AND RESTORE DATABASES AND TABLES'
            )
        self.toplevelBackupRestore.transient(self.frameParent)
# place the toplevel window
        xWindow = self.backuprestore_xWindowLocation
        yWindow = self.backuprestore_yWindowLocation
        self.toplevelBackupRestore.geometry(
            '+%d+%d' % (
            xWindow, 
            yWindow
              )
            )
            
# title
        frame_00 = Frame(
            self.toplevelBackupRestore,
            bg=colorbg,
            )
        frame_00.grid(
            row=0,
            column=0,
            columnspan=99,
            padx=0,
            pady=10,
            sticky=N,
            )
            
# ... backups     
        frame_10 = Frame(
            self.toplevelBackupRestore,
            bg=colorbg,
            )
        frame_10.grid(
            row=1,
            column=0,
            padx=5,
            pady=0,
            sticky=E+W,
            )
# ... radiobuttons
        frame_20 = Frame(
            self.toplevelBackupRestore,
            bg=colorbg,
            )
        frame_20.grid(
            row=2,
            column=0,
            padx=5,
            pady=0,
            )
# ... backup labels           
        frame_20_00 = Frame(
            frame_20,
            bg=colorbg,
            )
        frame_20_00.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
# ... backup radiobuttons            
        frame_20_10 = Frame(
            frame_20,
            bg=colorbg,
            )
        frame_20_10.grid(
            row=1,
            column=0,
            padx=0,
            pady=0,
            ) 
# label/entry for backup password        
        frame_30 = Frame(
            self.toplevelBackupRestore,
            bg=colorbg,
            )
        frame_30.grid(
            row=3,
            column=0,
            padx=5,
            pady=0,
            )
# ... enter password for restore
        frame_40 = Frame(
            self.toplevelBackupRestore,
            bg=colorbg,
            )
        frame_40.grid(
            row=4,
            column=0,
            padx=10,
            pady=0,
            )
# ... separator
        frame_50 = Frame(
            self.toplevelBackupRestore,
            bg=colorbg,
            )
        frame_50.grid(
            row=5,
            column=0,
            padx=5,
            pady=4,
            )
# ... restore title
        frame_60 = Frame(
            self.toplevelBackupRestore,
            bg=colorbg,
            )
        frame_60.grid(
            row=6,
            column=0,
            padx=5,
            pady=2,
            )
# ... directory for restore
        frame_70 = Frame(
            self.toplevelBackupRestore,
            bg=colorbg,
            )
        frame_70.grid(
            row=7,
            column=0,
            padx=5,
            pady=2,
            )
# ... password for restore
        frame_80 = Frame(
            self.toplevelBackupRestore,
            bg=colorbg,
            )
        frame_80.grid(
            row=8,
            column=0,
            padx=5,
            pady=2,
            )
# ... restore button
        frame_90 = Frame(
            self.toplevelBackupRestore,
            bg=colorbg,
            )
        frame_90.grid(
            row=9,
            column=0,
            padx=5,
            pady=4,
            )
            
# Cancel            
        frame_99 = Frame(
            self.toplevelBackupRestore,
            bg=colorbg,
            )
        frame_99.grid(
            row=99,
            column=0,
            padx=5,
            pady=5,
            )
            
# ----------------
            
# Widgets
# ... title
        labelHeader = Label(
            frame_00,
            text=(
                'BACKUP AND RESTORE DATABASES AND TABLES'
                ),
            bg=colorbg,
            justify=CENTER,
            font=self.labelFontMediumBold,
            )
        labelHeader.grid(
            row=0,
            column=0,
            columnspan=2,
            padx=0,
            pady=1,
            )
            
# current database and table
        labelBackupRestoreSelectDatabase = Label(
            frame_00,
            text='Current database: ',
            bg=colorbg,
            justify=RIGHT,
            font=self.labelFontMedium,
            )
        labelBackupRestoreSelectDatabase.grid(
            row=1,
            column=0,
            padx=0,
            pady=1,
            sticky=E,
            )
            
        self.varBackupRestoreSelectDatabase = StringVar()
        self.varBackupRestoreSelectDatabase.set(
            self.comboboxDbSelect.get().strip()
            )
        self.entryBackupRestoreSelectDatabase = Entry(
            frame_00,
            textvariable=self.varBackupRestoreSelectDatabase,
            disabledforeground='black',
            disabledbackground='white',
            font=self.labelFontMedium,
            state='disabled',
            width=40,
            )
        self.entryBackupRestoreSelectDatabase.grid(
            row=1,
            column=1,
            padx=5,
            pady=1,
            sticky=W,
            )

#        self.entryBackupRestoreSelectDatabase.configure(state='disabled')
# ... current table            
        labelBackupRestoreSelectTable = Label(
            frame_00,
            text='Current table: ',
            bg=colorbg,
            justify=RIGHT,
            font=self.labelFontMedium,
            )
        labelBackupRestoreSelectTable.grid(
            row=2,
            column=0,
            padx=0,
            pady=1,
            sticky=E,
            )
                
# ... logic for entry box
        self.varBackupRestoreSelectTable = StringVar()
        self.varBackupRestoreSelectTable.set(
            self.comboboxDbTableSelect.get().strip()
            )
        self.entryBackupRestoreSelectTable = Entry(
            frame_00,
            textvariable=self.varBackupRestoreSelectTable,
            disabledforeground='black',
            disabledbackground='white',
            font=self.labelFontMedium,
            state='disabled',
            width=40,
            )
        self.entryBackupRestoreSelectTable.grid(
            row=2,
            column=1,
            padx=5,
            pady=1,
            sticky=W,
            )
            
# ... current server
        labelCurrentServer = Label(
            frame_00,
            text='Current database server: ',
            bg=colorbg,
            justify=RIGHT,
            font=self.labelFontMedium,
            )
        labelCurrentServer.grid(
            row=3,
            column=0,
            padx=0,
            pady=1,
            sticky=E,
            )
        self.varCurrentServer = StringVar()
        self.varCurrentServer.set(
            self.comboServerMySQL.get().strip()
            )
        entryCurrentServer = Entry(
            frame_00,
            textvariable=self.varCurrentServer,
            state='disabled',
            disabledforeground='black',
            disabledbackground='white',
            font=self.labelFontMedium,
            width=40,
            )
        entryCurrentServer.grid(
            row=3,
            column=1,
            padx=5,
            pady=1,
            sticky=W,
            ) 

# ... label for user
        labelUserForBackup = Label(
            frame_00,
            text='Username for current database server: ',
            bg=colorbg,
            font=self.labelFontMedium,
            )
        labelUserForBackup.grid(
            row=4,
            column=0,
            sticky=E,
            padx=0,
            pady=1,
            )
# ... entry for user
        self.varUserMySQL_BackupRestore = StringVar()
        self.varUserMySQL_BackupRestore.set(self.varUserMySQL.get())
        self.entryUserMySQL_Backup = Entry(
            frame_00,
            width=40,
            textvariable=self.varUserMySQL_BackupRestore,
            font=self.labelFontMedium,
            state='disabled',
            disabledforeground='black',
            disabledbackground='white',
            )
        self.entryUserMySQL_Backup.grid(
            row=4,
            column=1,
            sticky=W,
            padx=5,
            pady=1,
            )
        
# ... separator
        labelSpacer = Label(
            frame_00,
            text=(
                '-'*60,
                ),
            bg=colorbg,
            justify=CENTER,
            font=self.labelFontMedium,
            )
        labelSpacer.grid(
            row=6,
            column=0,
            columnspan=2,
            padx=0,
            pady=1,
            )
        
# ... backups
        labelHeaderTableBackup = Label(
            frame_10,
            text=(
                'BACKUP Database(s) and Table(s) to a file:'
                ),
            bg=colorbg,
            width=60,
            anchor=W,
            justify=LEFT,
            font=self.labelFontMediumBold,
            )
        labelHeaderTableBackup.grid(
            row=0,
            column=0,
            padx=2,
            pady=1,
            sticky=W,
            )
        labelHeaderTableBackupNotes = Label(
            frame_10,
            text=(
                '   - Uses "mysqldump" command-line utility to backup to a directory on the host running PylotDB.\n' +
                '   - Since a command-line utility is invoked, the remote server host will ask for a password in\n' +
                '       the local command window.\n' +
                '   - Once created, the BACKUP file can be moved to another destination server using FTP or SCP.\n' +
                '   - PYLOTDB can be used from any computer visible to the server host to restore the BACKUP file\n' +
                '       databases/tables, but the BACKUP file must be local to PylotDB.\n' +
                '   - A backup filename is automatically specified depending on following selection.'
                ),
            bg=colorbg,
            width=75,
            anchor=W,
            justify=LEFT,
            font=self.labelFontMedium,
            )
        labelHeaderTableBackupNotes.grid(
            row=1,
            column=0,
            padx=2,
            pady=2,
            sticky=W,
            )       
# radiobuttons
# ... 'backup' options
# ...   radiobutton variable
        self.varSelectBackup_TableFunctions = StringVar()
#        self.varSelectBackup_TableFunctions.set('one_database_all_tables')
# ...   all databases, all tables
        self.radiobuttonAllDatabasesAllTables_TableFunctions = Radiobutton(
            frame_20_00,
            variable=self.varSelectBackup_TableFunctions,
            value='all_databases_all_tables',
            text='All databases, all tables',
            bg=colorbg,
            font=self.labelFontMedium,
            command=self.handlerBackup_Filename,
            )
        self.radiobuttonAllDatabasesAllTables_TableFunctions.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            sticky=W,
            )
# ...   one database, all tables
        self.radiobuttonOneDatabaseAllTables_TableFunctions = Radiobutton(
            frame_20_00,
            variable=self.varSelectBackup_TableFunctions,
            value='one_database_all_tables',
            text='Current database, all tables',
            bg=colorbg,
            font=self.labelFontMedium,
            command=self.handlerBackup_Filename,
            )
        self.radiobuttonOneDatabaseAllTables_TableFunctions.grid(
            row=1,
            column=0,
            padx=0,
            pady=0,
            sticky=W,
            )
# ...   one database, one table
        self.radiobuttonOneDatabaseOneTable_TableFunctions = Radiobutton(
            frame_20_00,
            variable=self.varSelectBackup_TableFunctions,
            value='one_database_one_table',
            text='Current database, current table',
            bg=colorbg,
            font=self.labelFontMedium,
            command=self.handlerBackup_Filename,
            )
        self.radiobuttonOneDatabaseOneTable_TableFunctions.grid(
            row=2,
            column=0,
            padx=0,
            pady=0,
            sticky=W,
            )
# ... 'backup' table structure only (no data) of selected table in selected database
        self.radiobuttonStructureOnly_TableFunctions = Radiobutton(
            frame_20_00,
            variable=self.varSelectBackup_TableFunctions,
            value='structure_only',
            text=(
                'Table structure only (no data) of current\n' +
                'table in current database'
                ),
            bg=colorbg,
            font=self.labelFontMedium,
            command=self.handlerBackup_Filename,
            )
        self.radiobuttonStructureOnly_TableFunctions.grid(
            row=3,
            column=0,
            padx=0,
            pady=0,
            sticky=W,
            )
            
# ... 'backup' filename
        labelBackupFilename = Label(
            frame_20_10,
            text=(
                'Use filename\n' +
                '("date_time.sql" (mmddyy_HHMM.sql) will be appended):'
                ),
            bg=colorbg,
            justify=RIGHT,
            font=self.labelFontMedium,
            )
        labelBackupFilename.grid(
            row=0,
            column=0,
            padx=0,
            pady=2,
            sticky=E,
            )
# ... 'backup' entry field
        self.varBackupFileName = StringVar()
        self.entryBackupFileName = Entry(
            frame_20_10,
            textvariable=self.varBackupFileName,
            bg='white',
            fg='black',
            width = 35,
            font=self.labelFontMedium,
            )
        self.entryBackupFileName.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            sticky=W,
            )
        
            
# ... 'backup' directory
        labelBackupDirectory = Label(
            frame_20_10,
            text=(
                'and backup to local directory:'
                ),
            bg=colorbg,
            justify=RIGHT,
            font=self.labelFontMedium,
            )
        labelBackupDirectory.grid(
            row=1,
            column=0,
            padx=0,
            pady=1,
            sticky=E,
            )
# ... 'backup' directory entry field
        self.varBackupDirName = StringVar()
        self.entryBackupDirName = Entry(
            frame_20_10,
            textvariable=self.varBackupDirName,
            bg='white',
            fg='black',
            width=35,
            font=self.labelFontMedium,
            )
        self.entryBackupDirName.grid(
            row=1,
            column=1,
            padx=0,
            pady=1,
            sticky=W,
            )

# .. 'backup' browse button
        buttonBrowseForBackupFile = Button(
            frame_20_10,
            text='Browse for local directory',
            width=20,
            borderwidth=3,
            relief=RAISED,
            background='white',
            foreground='blue',
            font=self.labelFontMedium,
            command=self.handlerBrowseForBackupDirectory,
            )
        buttonBrowseForBackupFile.grid(
            row=2,
            column=1,
            padx=0,
            pady=0,
            sticky=N,
            )
            
# ... label for backup password
        labelPasswordForBackup = Label(
            frame_30,
            text='Password for current database server: ',
            bg=colorbg,
            font=self.labelFontMedium,
            )
        labelPasswordForBackup.grid(
            row=0,
            column=0,
            padx=0,
            pady=5,
            sticky=E,
            )  
# entry for password            
        self.varPasswordForBackup = StringVar()
        self.entryPasswordForBackup = Entry(
            frame_30,
            bg='white',
            fg='black',
            relief=FLAT,
            show='*',
            textvariable=self.varPasswordForBackup,
            width=20,
            )
        self.entryPasswordForBackup.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            sticky=W,
            )
            
# ... 'backup' button
        buttonBackupFile = Button(
            frame_40,
            text='Backup',
            width=10,
            borderwidth=3,
            relief=RAISED,
            background='white',
            foreground='blue',
            font=self.labelFontMedium,
            command=self.handlerBackupFile,
            )
        buttonBackupFile.grid(
            row=0,
            column=0,
            padx=0,
            pady=2,
            sticky=E+W,
            )
            
# Separator
        labelSpacer = Label(
            frame_50,
            text=(
                '-'*60,
                ),
            bg=colorbg,
            justify=CENTER,
            font=self.labelFontMedium,
            )
        labelSpacer.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
            
# ... backups
        labelHeaderTableRestore = Label(
            frame_60,
            text=(
                'RESTORE Database(s) and Table(s) from file:'
                ),
            bg=colorbg,
            width=60,
            anchor=W,
            justify=LEFT,
            font=self.labelFontMediumBold,
            )
        labelHeaderTableRestore.grid(
            row=0,
            column=0,
            padx=2,
            pady=0,
            sticky=W,
            )
            
        labelRestoreTable = Label(
            frame_60,
            text=(
                '   - Uses MySQL command line utility to restore a "mysqldump" BACKUP file.\n' +
                '   - BACKUP file must be local to PylotDB.\n' +
                '   - Databases and/or tables will be restored to the server to which PylotDB is connected,\n' +
                '     as shown at the top of this window.\n' +
                '   - This process never destroys an existing database name; existing tables with identical\n' +
                '      names in the backup file are overwritten; other tables are left in place.'     
                ),
            bg=colorbg,
            width=75,
            font=self.labelFontMedium,
            anchor=W,
            justify=LEFT,
            )
        labelRestoreTable.grid(
            row=1,
            column=0,
            padx=2,
            pady=0,
            sticky=W,
            )
            
# ... 'restore' filename
        labelRestoreFilename = Label(
            frame_70,
            text=(
                'Use file:'
                ),
            bg=colorbg,
            justify=RIGHT,
            font=self.labelFontMedium,
            )
        labelRestoreFilename.grid(
            row=0,
            column=0,
            padx=0,
            pady=1,
            sticky=E,
            )
# ... 'restore' entry field
        self.varRestoreFileName = StringVar()
        self.entryRestoreFileName = Entry(
            frame_70,
            textvariable=self.varRestoreFileName,
            background='white',
            foreground='black',
            width = 30,
            font=self.labelFontMedium,
            )
        self.entryRestoreFileName.grid(
            row=0,
            column=1,
            padx=0,
            pady=1,
            sticky=W,
            )
            
# ... 'restore' directory
        labelRestoreDirectory = Label(
            frame_70,
            text=(
                'from local directory:'
                ),
            bg=colorbg,
            justify=RIGHT,
            font=self.labelFontMedium,
            )
        labelRestoreDirectory.grid(
            row=1,
            column=0,
            padx=0,
            pady=1,
            sticky=E,
            )        
# ... 'restore' directory entry field
        self.varRestoreDirName = StringVar()
        self.entryRestoreDirName = Entry(
            frame_70,
            textvariable=self.varRestoreDirName,
            background='white',
            foreground='black',
            width=30,
            font=self.labelFontMedium,
            )
        self.entryRestoreDirName.grid(
            row=1,
            column=1,
            padx=0,
            pady=1,
            sticky=W,
            )

# ... browse button for restore
        buttonBrowseForRestoreFile = Button(
            frame_70,
            text='Browse for local file',
            width=15,
            borderwidth=3,
            relief=RAISED,
            background='white',
            foreground='blue',
            font=self.labelFontMedium,
            command=self.handlerBrowseForRestoreFile,
            )
        buttonBrowseForRestoreFile.grid(
            row=2,
            column=1,
            padx=0,
            pady=0,
            )
# ... label for backup password
        labelPasswordForRestore = Label(
            frame_80,
            text='Password for current database server: ',
            bg=colorbg,
            font=self.labelFontMedium,
            )
        labelPasswordForRestore.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            sticky=E,
            )  
# entry for password            
        self.varPasswordForRestore = StringVar()
        self.entryPasswordForRestore = Entry(
            frame_80,
            bg='white',
            fg='black',
            relief=FLAT,
            show='*',
            textvariable=self.varPasswordForRestore,
            width=20,
            )
        self.entryPasswordForRestore.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            sticky=W,
            ) 
            
# ... 'restore' button
        buttonRestoreFile = Button(
            frame_90,
            text='Restore',
            width=10,
            borderwidth=3,
            relief=RAISED,
            background='white',
            foreground='blue',
            font=self.labelFontMedium,
            command=self.handlerRestoreFileUsingSubprocess,
            )
        buttonRestoreFile.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            sticky=E+W,
            )  

# graph Cancel buttons            
        self.buttonBackupRestoreCancel = Button(
            frame_99,
            text='Cancel',
            borderwidth=5,
            relief=RAISED,
            justify=CENTER,
            width=25,
            command=self.handlerBackupRestoreCancel,
            font=self.labelFontMedium,
            )
        self.buttonBackupRestoreCancel.grid(
            row=0,
            column=0,
            padx=5,
            pady=0,
            ) 
            
        return 


    def enterPasswordForBackupRestore(self):
        '''
        Purpose:
        allows user to enter password to current database server
        
        NOTE: This method is not used at present
        
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'enterPasswordForBackupRestore')
            
# constants
        colorbg='tan'
            
# define main window, use parent window = self.toplevelBackupRestore
# ... destroy any toplevel frames
        self.destroyToplevelEnterPasswordForBackupRestore()

# ... open toplevel frame for entering password
        self.toplevelEnterPasswordForBackupRestore = Toplevel(
            self.toplevelBackupRestore,
            bg=colorbg,
            )
        self.toplevelEnterPasswordForBackupRestore.title(
            'ENTER PASSWORD FOR DATABASE SERVER'
            )
        self.toplevelEnterPasswordForBackupRestore.transient(
            self.toplevelBackupRestore
            )
            
        x_Windows= \
            self.toplevelBackupRestore.winfo_rootx() - self.offsetWindowX + 100
        y_Windows= \
            self.toplevelBackupRestore.winfo_rooty() - self.offsetWindowY + 100
        self.toplevelEnterPasswordForBackupRestore.geometry(
            '+%d+%d' % (x_Windows, y_Windows)
            )
            
# label and password entry widgets
        frame_00 = frame_00 = Frame(
            self.toplevelEnterPasswordForBackupRestore,
            bg=colorbg,
            )
        frame_00.grid(
            row=0,
            column=0,
            padx=0,
            pady=10,
            )
            
# ... ok and cancel widgets
        frame_10 = Frame(
            self.toplevelEnterPasswordForBackupRestore,
            bg=colorbg,
            )
        frame_10.grid(
            row=1,
            column=0,
            padx=5,
            pady=0,
            )
            
# --- widgets ---
# label
        label = Label(
            frame_00,
            text='Enter password for current database server: ',
            bg=colorbg,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )        
# entry for password            
        self.varPasswordForBackupRestore = StringVar()
        self.entryPasswordForBackupRestore = Entry(
            frame_00,
            bg='white',
            fg='black',
            relief=FLAT,
            show='*',
            textvariable=self.varPasswordForBackupRestore,
            width=20,
            )
        self.entryPasswordForBackupRestore.grid(
            row=0,
            column=1,
            padx=5,
            pady=0,
            )
# ok button
        self.buttonPasswordForBackupRestore = Button(
            frame_10,
            bg='white',
            fg='blue',
            relief=RAISED,
            text='OK',
            width=15,
            command=self.handlerEnterPasswordForBackupRestore,
            )
        self.buttonPasswordForBackupRestore.grid(
            row=0,
            column=0,
            padx=5,
            pady=10,
            )
# cancel button
        self.buttonCancelPasswordForBackupRestore = Button(
            frame_10,
            relief=RAISED,
            text='Cancel',
            width=15,
            command=self.destroyToplevelEnterPasswordForBackupRestore,
            )
        self.buttonCancelPasswordForBackupRestore.grid(
            row=0,
            column=1,
            padx=5,
            pady=10,
            )
            
        return
            
         
    def handlerEnterPasswordForBackupRestore(self):
        '''
        Purpose:
        Entery password for backup and restore
        
        NOTE: This method is not used at present
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerEnterPasswordForBackupRestore')
            
        showinfo(
            'Error: system stop',
            'This handler being called is not used at present, so the fact\n' +
            'that you have arrived here is a coding error.\n\n' +
            'Please contact code administrator so this can be corrected.'
            )
        sys.exit()
        
        
        self.varPasswordForBackupRestore.set(
            self.entryPasswordForBackupRestore.get().strip()
            )
            
        self.destroyToplevelEnterPasswordForBackupRestore()
        
        return    
            
            
    def destroyToplevelEnterPasswordForBackupRestore(self):
        '''
        Purpose:
        destroy toplevel window self.toplevelEnterPasswordForBackupRestore
        and record the last known location of this toplevel
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'destroyToplevelEnterPasswordForBackupRestore')
        
        try:
            self.toplevelEnterPasswordForBackupRestore.destroy()
        except:
            pass
        
        return
        

    def checkMySQLConnection(self):
        '''
        checks connection to MySQL server and switches STATUS lights
            depending on status
            
        Connection indicators:
            self.radiobuttonStatusDbNotConnected.configure(state='normal')
            self.radiobuttonStatusDbAttemptConnect.configure(state='disabled')
            self.radiobuttonStatusDbConnected.configure(state='disabled')
        
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'checkMySQLConnection')
        
# check if connected to a MySQL server
        self.connectionFlag = 1
#        if not self.myDbConnection:
# try any always-true command; if valid, we are still connected  
#        self.cursorHandleMySQL.execute('show databases')
#        return
        try:
            self.cursorHandleMySQL.execute('show engines')
        except:
            self.radiobuttonStatusDbNotConnected.configure(state='normal')
            self.radiobuttonStatusDbAttemptConnect.configure(state='disabled')
            self.radiobuttonStatusDbConnected.configure(state='disabled')
            self.comboboxDbSelect.clear()
            self.comboboxDbTableSelect.clear()
            self.comboboxDbFieldSelect.clear()
            stringNotConnected = (
                'You are not connected to a database server.'
                )
            self.MySQL_Output(
                1,
                stringNotConnected
                )
            showinfo(
                'Info: not connected',
                stringNotConnected
                )
            self.connectionFlag = 0
            return
        '''
        showinfo(
                'Info: connected',
                'Connected to MySQL server.\n'
                )    
        '''
        return
        
        
    def checkMySQLConnection_fromMainWindow(self):
        '''
        checks connection to MySQL server from Main Window
        
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'checkMySQLConnection_fromMainWindow')
        
# check if connected to a MySQL server
        self.connectionFlag = 1
#        if not self.myDbConnection:
# try any always-true command; if valid, we are still connected       
        try:
            self.cursorHandleMySQL.execute('show engines')
        except:
            self.connectionFlag = 0
            
        return
        

    def handlerMySQLConnect(self):
        '''
        connects to MySQL server and extracts database names
        
        Inputs:
            username:   self.varUserMySQL
            password:   self.varPasswordMySQL
            server:     self.comboServerMySQL
            port:       self.varPortMySQL
            
            Databases, Tables, and Fields lists:
                self.myDatabases
                self.myDatabaseTables
                self.myDatabaseFields

        Connection indicators:
            self.radiobuttonStatusDbNotConnected.configure(state='normal')
            self.radiobuttonStatusDbAttemptConnect.configure(state='disabled')
            self.radiobuttonStatusDbConnected.configure(state='disabled')
            
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerMySQLConnect')
            
        self.checkMySQLConnection_fromMainWindow()
            
        if self.connectionFlag:
            stringConnected = (
                'You are already connected to a MySQL server.\n\n' +
                'Disconnect first, then connect to desired server.'
                )
            showinfo(
                'Info: connected',
                stringConnected
                )
# clear password field
            self.varPasswordMySQL.set('')
            return
        
        self.radiobuttonStatusDbNotConnected.configure(state='disabled')
        self.radiobuttonStatusDbAttemptConnect.configure(state='normal')
        self.radiobuttonStatusDbConnected.configure(state='disabled')    
        
# check if all values are present
        un=self.varUserMySQL.get()
        pw=self.varPasswordMySQL.get()
        svr=self.comboServerMySQL.get()
        prt=self.varPortMySQL.get()
        
        valuePresent=1
        valueString=''
        
        if un == '':
            valuePresent=0
            self.MySQL_Output(
                0,
                ' Username is blank.'
                )
            valueString=' Username is blank\n'
        if pw == '':
            valuePresent=0
            self.MySQL_Output(
                0,
                ' Password is blank.'
                )
            valueString+=' Password is blank.\n'
        if svr == '':
            valuePresent=0
            self.MySQL_Output(
                0,
                ' Server is not specified.'
                )
            valueString+=' Server is not specified.\n'
        if prt == '':
            valuePresent=0
            self.MySQL_Output(
                0,
                ' Port is blank; try 3306'
                )
            valueString+=' Port is blank.\n'
        
        if not valuePresent:
            self.MySQL_Output(
                1,
                ' Following errors occurred:\n' + valueString
                )
            showerror(
            'ERROR in input',
            'Please correct the following errors:\n\n' +
            valueString
            )
            self.radiobuttonStatusDbNotConnected.configure(state='normal')
            self.radiobuttonStatusDbAttemptConnect.configure(state='disabled')
            
            self.radiobuttonStatusDbConnected.configure(state='disabled')   
            return
        
        self.MySQL_Output(
            0,
            '     user = ' + un + '\n' +
            '     host = ' + svr + '\n' +
            '     port = ' + prt 
            )
                   
# now connect to server
        try:
            self.myDbConnection = MySQLdb.connect(
                user=un,
                passwd=pw,
                host=svr,
                port=eval(prt)
                )            
        except:
            stringErrorServerNotAvailable = (
                'Could not connect to database.\n\n' + 
                'Possible reasons:\n' +
                '  - Invalid username, password, or server name\n' +
                '  - Check if "Caps Lock" has been pressed\n' +
                '  - Server timeout (log back in)\n' +
                '  - Server not available at this time\n\n' +
                'Check input fields and try again.'
                )
            self.MySQL_Output(
                1,
                stringErrorServerNotAvailable
                )
            showerror(
                'ERROR',
                stringErrorServerNotAvailable
                )
            self.radiobuttonStatusDbNotConnected.configure(state='normal')
            self.radiobuttonStatusDbAttemptConnect.configure(state='disabled')
            self.radiobuttonStatusDbConnected.configure(state='disabled') 
            self.varPasswordMySQL.set('')
            return    

# At this point, connection is successful
        self.MySQL_Output(
            1,
            '\nConnected to MySQL database.\n'
            )
# ... show status indicators
        self.radiobuttonStatusDbNotConnected.configure(state='disabled')
        self.radiobuttonStatusDbAttemptConnect.configure(state='disabled')
        self.radiobuttonStatusDbConnected.configure(state='normal')
        
# store values  for use in inserting data into database
        self._userMySQL_Save = un
#        self._passwdMySQL_Save = pw
        self._hostMySQL_Save = svr
        self._portMySQL_Save = prt
        
# reset password field for security purposes
        self.varPasswordMySQL.set('')

# get a cursor handle for executing SQL commands
        self.cursorHandleMySQL = self.myDbConnection.cursor()
        
# turn on autocommit; else, database will not update when you want
        self.cursorHandleMySQL.execute("set autocommit = 1")  
        
# stats
        self.infoSystem_MySQL_Access()
        
# get database list
        self.mysql_GetDatabases()
        
# graph combobox for Databases
        self.mysql_ComboDatabases()
        
        return

        
    def mysql_GetDatabases(self):
        '''
        gets list of databases from MySQL server
        
        inputs:
            
        outputs:
            self.myDatabases
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'mysql_GetDatabases') 

# clear database list
        self.myDatabases = []
# get databases
        self.MySQL_Commands(
            1,
            'self.cursorHandleMySQL.execute("SHOW DATABASES")'
            )
        start=time.time()
        self.cursorHandleMySQL.execute("SHOW DATABASES")
        databases = self.cursorHandleMySQL.fetchall()
        finish=time.time()
        delta_t = finish - start
        self.MySQL_Commands(
            0,
            '  (Time: %-7.4f secs)' % delta_t
            )
            
        self.MySQL_Output(
            1,
            'Databases:'
            )
        i=0
        printString=''
        self.myDatabases = []
        for database in databases:
            i+=1
            printString+=('%2s. ' % i  + database[0] + '\n')
# assemble string for combobox
            self.myDatabases.append(database[0]) 
            
        self.myDatabases.sort()
            
        self.MySQL_Output(
            0,
            printString
            )
            
        return

            
    def mysql_GetDatabaseTables(self):
        '''
        gets list of database tables from MySQL server
        
        inputs:
            
        outputs:
            self.myDatabaseTables
            
        Called by:
        
        Calls:
            self.refreshTables()
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'mysql_GetDatabaseTables')
        
# get current database
        databaseCurrent = self.comboboxDbSelect.get().strip()
        if databaseCurrent == '' or databaseCurrent == None:
            '''
            self.MySQL_Output(
                1,
                'No database has been specified.'
                )
            showerror(
                'Error: no database',
                'No database has been chosen for this\n' +
                'operation.\n\n' +
                'Please choose a database.'
                )
            '''
            return
        for database in self.myDatabases:
            if database == databaseCurrent:
                self.refreshTables()
                return
                
# if we get this far, no database match
        self.MySQL_Output(
            1,
            'Database is not in current list.'
            )
        showerror(
            'Error: database does not exist.',
            'The database for which you are trying to generate\n' +
            'a table does not exist in the current list of\n' +
            'databases.\n\n' +
            'Please create the database before trying to add\n' +
            'a table to it.'
            )
            
        return
        

    def handlerMySQLDisconnect(self):
        '''
        disconnects from MySQL database
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerMySQLDisconnect')
        
# check if connected to a MySQL server
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return
        
        ans=askokcancel(
            'Disconnect...',
            'You are about to disconnect\n' +
            'from the MySQL database.\n\n' + 
            'Click OK to continue, or CANCEL to\n' +
            'quit this process.'
            )
        if ans:
            try:
                self.myDbConnection.close()  
                
            except:
                showinfo(
                    'Info...',
                    'No database is opened.'
                    )
                return
                
            self.MySQL_Output(
                1,
                'Disconnected from MySQL database.'
                )
        else:
            self.MySQL_Output(
                1, 
                'Disconnect process canceled.'
                )
            return
            
# clear 'Select a Database' combobox
        self.MySQL_Output(
            1,
            'Clearing all combo boxes...'
            )
        self.comboboxDbSelect.clear()
        self.comboboxDbTableSelect.clear()
        self.comboboxDbFieldSelect.clear()
        
# reset password
        self.MySQL_Output(
            1,
            'Reset password field.'
            )
        self.varPasswordMySQL.set('')
        
# reset totals
        self.MySQL_Output(
            1,
            'Reset totals.'
            )
        self.varDbTotal.set(0)
        self.varDbTablesTotal.set(0)
        self.varDbFieldsTotal.set(0)

# set indicators
        self.MySQL_Output(
            1,
            'Reset Status indicators.'
            )
        self.radiobuttonStatusDbNotConnected.configure(state='normal')
        self.radiobuttonStatusDbAttemptConnect.configure(state='disabled')
        self.radiobuttonStatusDbConnected.configure(state='disabled')
        
# set server connection to false   
        self.MySQL_Output(
            1,
            'Set server connection to false.'
            )
        self.myDbConnection = 0
        
        return
       
            
    def handlerResetValuesMySQL(self):
        '''
        reset MySQL server values
        
        Inputs:
            
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerResetValuesMySQL')

# clear password            
        self.varPasswordMySQL.set('')
        
# arbitrarily select server to display
        self.comboServerMySQL.selectitem(self.servers[0])
        
# pick port
        if self.pylotdbDotConf_Exists:
            self.varPortMySQL.set(
                self.portForServer
#                self.yamlDotLoad[main_database_servers_port][0]
                )
        else:
            self.varPortMySQL.set('3306')
            
# pick username based on selected server
        if self.comboServerMySQL.get().strip() == 'localhost':
#            self.varUserMySQL.set('root')
            self.varUserMySQL.set(self.usernameForLocalHostServer)
        else:
            self.varUserMySQL.set(self.usernameForRemoteServer)
            
        
        return
        
        
    def handlerDbSelect(self):
        '''
        sets the database chosen in the combobox as the one to be used.
        also shows the tables associated with the selected database.
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerDbSelect')

# get the database name
        db = self.comboboxDbSelect.get()
        stringDbSelect = 'USE' + ' ' + db
        self.MySQL_Commands(
            1,
            'self.cursorHandleMySQL.execute("' + stringDbSelect + '")'
            )
        self.cursorHandleMySQL.execute(stringDbSelect)
            
# now double check that the database we have is the one we chose
        self.MySQL_Commands(
            1,
            'self.cursorHandleMySQL.execute("SELECT DATABASE()")'
            )
        start=time.time()
        self.cursorHandleMySQL.execute("SELECT DATABASE()")
        dbCurrentFetchall = self.cursorHandleMySQL.fetchall()
        finish=time.time()
        delta_t = finish - start
        self.MySQL_Commands(
            0,
            '  (Time: %-7.4f secs)' % delta_t
            )
            
        self.MySQL_Output(
            1,
            'Current database:'
            )
        for item in dbCurrentFetchall:
            self.MySQL_Output(
                1,
                ' %s' % item[0]
                )
            dbCurrent=item[0]
            
        if db <> dbCurrent:
            self.MySQL_Output(
                1,
                (('ERROR: database chosen is not the one being used!' + '\n' +
                ' You selected: %s \n' +
                ' Current database: %s \n' +
                '\n>> Cannot continue. <<\n') % (db, dbCurrent))
                )
            sys.exit()

# now show the tables
        self.MySQL_Commands(
            1,
            'self.cursorHandleMySQL.execute("SHOW TABLES")'
            )
        self.cursorHandleMySQL.execute("SHOW TABLES")
        self.MySQL_Output(
            1,
            'List all tables:'
            )
        dbCurrentTablesFetchall = self.cursorHandleMySQL.fetchall()
        self.myDatabaseTables = []
        for table in dbCurrentTablesFetchall:
            self.myDatabaseTables.append(table[0]) 
        self.myDatabaseTables.sort()
        
        i=0
        for item in self.myDatabaseTables:
            i+=1
            self.MySQL_Output(
                0,
                (' %3s. %s' % (i,item))
                )
  
        return
        
        
    def mysql_ComboDatabases(self):
        '''
        graph combobox for DATABASES
        
        Inputs: 
            self.myDatabases
            
        Outputs:
            self.comboboxDbSelect(.set()/.get())  
            self.varDbTotal(.set()/.get())
            
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'mysql_ComboDatabases')

# top label
        labelDbSelect = Label(
            self.frameMySQL_01_00,
            text='DATABASES\n(select to show Tables)',
            bg=self.colorbg,
            )
        labelDbSelect.grid(
            row=0,
            column=0,
            columnspan=2,
            padx=0,
            pady=2,
            )
            
# combobox            
        self.comboboxDbSelect = Pmw.ComboBox(
            self.frameMySQL_01_00,
            scrolledlist_items=self.myDatabases,
            dropdown=0,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            selectioncommand=self.handler_ComboDatabases,
            scrolledlist_hscrollmode='static',
            scrolledlist_vscrollmode='static',
            scrolledlist_hull_width=500,
            )
        self.comboboxDbSelect.grid(
            row=1,
            column=0,
            columnspan=2,
            pady=2,
            )
#        self.comboboxDbSelect.component('scrolledlist').configure(
#            hscrollmode='static'
#            )
#        self.comboboxDbSelect.component('scrolledlist').configure(
#            vscrollmode='static'
#            )
# could also have used...
#        self.comboboxDbSelect.configure(scrolledlist_hscrollmode = 'static')
#        self.comboboxDbSelect.configure(scrolledlist_vscrollmode = 'static')
        
# 'total' label               
        labelDbTotal = Label(
            self.frameMySQL_01_00,
            text='Databases: ',
            bg=self.colorbg,
            )
        labelDbTotal.grid(
            row=2,
            column=0,
            pady=2,
            sticky=E,
            )
            
# 'entry' for total # of databases            
        self.varDbTotal=StringVar()
        self.varDbTotal.set(len(self.myDatabases))
        self.entryDbTotal = Entry(
            self.frameMySQL_01_00,
            bg=self.colorbg,
            relief=FLAT,
            textvariable=self.varDbTotal,
            width=5,
            state='disabled',
            disabledforeground='black',
            disabledbackground=self.colorbg,
            )
        self.entryDbTotal.grid(
            row=2,
            column=1,
            pady=2,
            sticky=W,
            )
            
        return 
        
            
    def handler_ComboDatabases(self, myDatabase):
        '''
        handles selection from DATABASE combobox
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handler_ComboDatabases')
        
# get the current selection for Database
        self.use_Database = myDatabase
        
#        self.MySQL_Output(
#            1,
#            '  ... use database:' + self.use_Database
#            )
        
# clear Tables and total
        self.clearDbTables()
# clear Fields and total
        self.clearDbFields()
# refresh table list
        self.refreshTables() 
            
# show tables in Tables combobox
        self.mysql_ComboDatabaseTables()
        
# if 'Delete Database' window exists, refresh the 'Select database:' field
        try:
            mapped0 = self.toplevelDatabaseDelete.winfo_exists()
        except:
            mapped0 = False
            
        if mapped0:
            '''
            self.comboboxEnterDatabaseNameDelete.setentry(
                self.comboboxDbSelect.get().strip()
                )
            '''
            self.varEntryEnterDatabaseNameDelete.set(
                self.comboboxDbSelect.get().strip()
                )
                
# if ADD FIELD window exists, update it
        try:
            mappedFieldAdd = self.toplevelFieldAdd.winfo_exists()
        except:
            mappedFieldAdd = False
            
        if mappedFieldAdd:
            '''
# close it and return
            self.toplevelFieldAdd.destroy()
            return
            '''
# update Database entry field
            currentDatabase = self.comboboxDbSelect.get().strip()
            self.varEnterDatabaseFieldAddDatabases.set(currentDatabase)
# clear Table entry field
            self.varEnterDatabaseFieldAddTables.set('')      
# regrid combobox for "After column ..." to have no menu
# ... combobox for column
            self.comboboxFieldAddPosition_AfterColumn = Pmw.ComboBox(
                self.frame_10_Add_Field,
#                scrolledlist_items=tempMyDatabaseFields,
                listheight=150,
                entry_state='disabled',
                entry_disabledbackground='white',
                entry_disabledforeground='black',
                selectioncommand=self.handlerSetRadiobuttonAfter,
                entry_width=30,
                scrolledlist_hull_width=500,
                )
            self.comboboxFieldAddPosition_AfterColumn.grid(
                row=6,
                column=1,
                pady=0,
                sticky=N+E,
                )            
            
# if DELETE FIELD window exists, update it
        try:
            mappedFieldDelete = self.toplevelFieldDelete.winfo_exists()
        except:
            mappedFieldDelete = False
            
        if mappedFieldDelete:
            '''
# close it and return
            self.toplevelFieldDelete.destroy()
            return
            '''
# update Database entry field
            currentDatabase = self.comboboxDbSelect.get().strip()
            self.varEnterDatabaseFieldDeleteDatabases.set(currentDatabase)
# clear Table entry field
            self.varEnterDatabaseFieldDeleteTables.set('')
# clear Field entry field
            self.varEntryEnterDatabaseFieldDelete.set('')
            
            
# if EDIT FIELD NAME window exists, close it
        try:
            mappedFieldEdit = self.toplevelFieldNameEdit.winfo_exists()
        except:
            mappedFieldEdit = False
            
        if mappedFieldEdit:
            '''
# close and return
            self.toplevelFieldNameEdit.destroy()
            return
            '''
# update Database entry field
            currentDatabase = self.comboboxDbSelect.get().strip()
            self.varDatabaseEditField.set(currentDatabase)
# clear Table entry field
            self.varTableEditField.set('')
# clear Field entry
            self.varEntryEnterSelectFieldEditFieldName.set('')
# clear Field structure entry fields
            self.varField1.set('')
            self.varField2.set('')
            self.varField3.set('')
            self.varField4.set('')
            self.varField5.set('')
            self.varField6.set('')
# leave new Field name as is     
            
                
# if 'Create Table -- 2 Methods' window exists, refresh the fields
#   'Create table in current database'
        try:
            mapped1 = self.toplevelTableCreate.winfo_exists()
        except:
            mapped1 = False
            
        if mapped1:
            self.varDatabaseForNewTable.set(
                self.comboboxDbSelect.get().strip()
                )
        
# if 'Table Functions' window exists, refresh the 'Table:' field
        try:
            mapped2 = self.toplevelTableFunctions.winfo_exists()
        except:
            mapped2 = False
            
        if mapped2:            
            self.varTableFunctionsSelectDatabase.set(
                self.comboboxDbSelect.get().strip()
                )
            self.varEntryTableFunctionsSelectTable.set('')
# clear 'rename' current table
            self.varTableFunctionsRename.set('')
# set 'copy' database name same as current database
            self.comboboxDatabaseNameCopy.setentry(
                self.comboboxDbSelect.get().strip()
                )
# clear 'copy' table name
            self.varTableFunctionsCopy.set('')
            
            
# if 'Rename Database' window exists, refresh the current database field
        try:
            mapped3 = self.toplevelDatabaseRename.winfo_exists()
        except:
            mapped3 = False           
        if mapped3:
            self.varDatabaseNameCurrent.set(
#            self.comboboxDatabaseNameCurrent.setentry(
                self.comboboxDbSelect.get().strip()
                )
                
# if 'Backup and Restore' window exists, refresh current database field,
#    and blank the field "and use filename"
        try:
            mapped4 = self.toplevelBackupRestore.winfo_exists()
        except:
            mapped4 = False
        if mapped4:
            self.varBackupRestoreSelectDatabase.set(
                self.comboboxDbSelect.get().strip()
                )
            self.varBackupRestoreSelectTable.set('')
            self.varBackupFileName.set('')
            if self.varSelectBackup_TableFunctions.get() == 'all_databases_all_tables':
                self.radiobuttonAllDatabasesAllTables_TableFunctions.invoke()
            elif self.varSelectBackup_TableFunctions.get() == 'one_database_all_tables':
                self.radiobuttonOneDatabaseAllTables_TableFunctions.invoke()
            elif self.varSelectBackup_TableFunctions.get() == 'one_database_one_table':
                self.radiobuttonOneDatabaseOneTable_TableFunctions.invoke()
            elif self.varSelectBackup_TableFunctions.get() == 'structure_only':
                self.radiobuttonStructureOnly_TableFunctions.invoke()            
            else:
                pass
                
# if 'Add Field' window exists, refresh current database field
        '''
        try:
            mapped5 = self.toplevelFieldAdd.winfo_exists()
        except:
            mapped5 = False
        if mapped5:
            self.varEnterDatabaseFieldAddDatabases.set(
                self.comboboxDbSelect.get().strip()
                )
            self.varEnterDatabaseFieldAddTables.set(
                ''
                )
        '''
                
# if 'Delete Table' window exists, refresh current database, blank table field
        try:
            mapped6 = self.toplevelTableDelete.winfo_exists()
        except:
            mapped6 = False
        if mapped6:
            self.varDatabaseForDeleteTable.set(
                self.comboboxDbSelect.get()
                )
            self.varEntryEnterDatabaseTablesNameDelete.set('')
                
# if 'Delete Field' window exists, refresh table field, blank 'field' entry
        '''
        try:
            mapped7 = self.toplevelFieldDelete.winfo_exists()
        except:
            mapped7 = False
            
        if mapped7:
            self.varEnterDatabaseFieldDeleteDatabases.set(
                self.comboboxDbSelect.get().strip()
                )
            self.varEnterDatabaseFieldDeleteTables.set('')
            self.varEntryEnterDatabaseFieldDelete.set('')
        '''
            
# if 'Edit Field Name' window exists, close it
        '''
        try:
            mapped8 = self.toplevelFieldNameEdit.winfo_exists()
        except:
            mapped8 = False
            
        if mapped8:
            self.varDatabaseEditField.set(
                self.comboboxDbSelect.get()
                )
            self.varTableEditField.set('')
            self.varEntryEnterSelectFieldEditFieldName.set('')
            self.varField1.set('')
            self.varField2.set('')
            self.varField3.set('')
            self.varField4.set('')
            self.varField5.set('')
            self.varField6.set('')
        '''
        
        return
        
        
    def handlerDatabaseAdd(self):
        '''
        Add a database to current list of databases
        
        inputs:
            self.cursorHandleMySQL
            self.comboboxDbSelect.get()
            self.myDatabases()
            
        outputs:
            self.myDatabases()    # revised
       
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerDatabaseAdd')

# check if connected to a MySQL server
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return
        
# initialize
        self.myTablesFromExistingDatabases = []
            
# destroy any old toplevel frames
        self.destroyAllDatabaseTableFieldFrames()
                    
# open Toplevel frame for entering database name
        self.toplevelDatabaseCreate = Toplevel(
            self.frameParent,
            bg='tan'
            )
        self.toplevelDatabaseCreate.title(
            'DATABASES'
            )
            
        self.toplevelDatabaseCreate.transient(self.frameParent)
# place the top window
#        x_Windows = self.createDatabase_xWindowLocation
#        y_Windows = self.createDatabase_yWindowLocation
        x_Windows = self.frameParent.winfo_rootx() + 5
        y_Windows = self.frameParent.winfo_rooty() + 200
        
        self.toplevelDatabaseCreate.geometry(
            '+%d+%d' % (x_Windows, y_Windows)
            )
            
        rowCount = 0
        
# add frames to toplevel            
        frame_00 = Frame(
            self.toplevelDatabaseCreate,
            bg='tan',
            )
        frame_00.grid(
            row=rowCount,
            column=0,
            padx=5,
            pady=5,
            )
        
        rowCount += 1
        frame_05 = Frame(
            self.toplevelDatabaseCreate,
            bg='tan',
            )
        frame_05.grid(
            row=rowCount,
            column=0,
            padx=5,
            pady=5,
            )
#       
        rowCount += 1
        frame_10 = Frame(
            self.toplevelDatabaseCreate,
            bg='tan',
            )
        frame_10.grid(
            row=rowCount,
            column=0,
            padx=5,
            pady=5,
            )
#            
        rowCount += 1
        frame_20 = Frame(
            self.toplevelDatabaseCreate,
            bg='tan',
            )
        frame_20.grid(
            row=rowCount,
            column=0,
            padx=5,
            pady=5,
            )
            
# WIDGETS
        labelTitleDatabaseNameAdd = Label(
            frame_00,
            text='CREATE DATABASE',
            bg='tan',
            justify=CENTER,
            font=self.labelFontMediumBold,
            )
        labelTitleDatabaseNameAdd.grid(
            row=0,
            column=0,
            padx=5,
            pady=5,
            )
            
        self.varCheckbuttonAutoCreateSandboxTable = IntVar()
        self.checkbuttonAutoCreateSandboxTable = Checkbutton(
            frame_05,
            text=(
                '  AUTO-CREATE "SANDBOX" TABLE IN DATABASE\n' +
                '    Can be used as sample table or to receive\n' +
                '    data from companion code Co-PylotDB'
                ),
            bg='tan',
            variable=self.varCheckbuttonAutoCreateSandboxTable,
            justify=LEFT,
            )
        self.checkbuttonAutoCreateSandboxTable.grid(
            row=0,
            column=0,
            padx=0,
            pady=5,
            )
            
        Row = 0
        labelEnterDatabaseNameAdd = Label(
            frame_10,
            text=(
            'DATABASE NAME\n' +
            'No spaces, no dashes;\n' +
            'underscores OK'
            ),
            bg='tan',
            justify=RIGHT,
            )
        labelEnterDatabaseNameAdd.grid(
            row=Row,
            column=0,
            rowspan=2,
            padx=0,
            pady=5,
            sticky=E,
            )

        self.varEnterDatabaseNameAdd=StringVar()
        self.varEnterDatabaseNameAdd.set('')
        self.entryEnterDatabaseNameAdd = Entry(
            frame_10,
            width=30,
            textvariable=self.varEnterDatabaseNameAdd,
            )
        self.entryEnterDatabaseNameAdd.grid(
            row=Row,
            column=1,
            padx=5,
            pady=2,
            sticky=W,
            )
        self.entryEnterDatabaseNameAdd.bind(
            "<KeyPress-Return>",
            self.handlerBindDatabaseNameAdd,
            )
            
# graph Add and Cancel buttons
        Row += 1
        self.buttonOkEnterDatabaseNameAdd = Button(
            frame_10,
            text='Add',
            borderwidth=3,
            relief=RAISED,
            justify=CENTER,
            background='white',
            foreground='blue',
            font=self.buttonFontSmall,
            width=10,
            command=self.handlerDatabaseNameAdd,
            )
        self.buttonOkEnterDatabaseNameAdd.grid(
            row=Row,
            column=1,
            padx=5,
            pady=0,
            sticky=N,
            )
            
        self.buttonCancelEnterDatabaseNameAdd = Button(
            frame_20,
            text='Cancel',
            borderwidth=5,
            relief=RAISED,
            justify=CENTER,
            width=20,
            command=self.handlerToplevelDatabaseCreateDestroy
            )
        self.buttonCancelEnterDatabaseNameAdd.grid(
            row=0,
            column=0,
            padx=5,
            pady=15,
            ) 

        return
        
        
    def handlerToplevelDatabaseCreateDestroy(self):
        '''
        Purpose:
            save location for 'Create Database' window; close toplevel
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerToplevelDatabaseCreateDestroy')

# save location for next time window is opened
        self.createDatabase_xWindowLocation = \
            self.toplevelDatabaseCreate.winfo_rootx() - self.offsetWindowX
        self.createDatabase_yWindowLocation = \
            self.toplevelDatabaseCreate.winfo_rooty() - self.offsetWindowY

# destroy current toplevel            
        self.toplevelDatabaseCreate.destroy()
        
        return
        

    def handlerDatabaseNameAdd(self):
        '''
        handler for:
            handler_DatabaseAdd
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerDatabaeNameAdd')
            
# make sure field is not empty
# ... first, strip any leading whitespace (careless user!)        
        self.varEnterDatabaseNameAdd.set(self.varEnterDatabaseNameAdd.get().strip())
        databaseAdd = self.varEnterDatabaseNameAdd.get()
        if databaseAdd == '' or databaseAdd == None:
            self.MySQL_Output(
                1,
                'Entry for database name is blank.' + '\n' +
                ' Try again.'
                )
            showerror(
                'Error: no database name',
                'No name in database entry field.\n\n' +
                'Enter a database name into field.'
                )
            return

# check if database is already exists
        if databaseAdd in self.myDatabases:
            self.MySQL_Output(
                1,
                'The following database already exists!\n\n' +
                '%s'
                ) % databaseAdd
            showerror(
                'Error: database exists',
                'The following database already exists!\n\n' +
                '%s\n\n' +
                'A new database CANNOT be created.\n\n' +
                'To create a new database, enter a unique\n' + 
                'name in the entry field, then click "Add".\n\n' 
                ) % databaseAdd
            return
                
# if all checks pass, add database to list 
# get final ok to add  
        stringAddDatabase = (
            'You are about to create database\n\n' + 
            '"' + databaseAdd + '"'
            )
        if self.varCheckbuttonAutoCreateSandboxTable.get():
            stringAddDatabase += (
                '\n\nTable "sandbox" will be automatically\n' +
                'created in the database.' 
                )
        stringAddDatabase += (
            '\n\nClick OK to continue, or CANCEL to\n' +
            'quit this process.'
            )
        ans=askokcancel(
            'Create database',
            stringAddDatabase
            )
            
        if ans:
            self.MySQL_Output(
                1,
                ' Add database: ' + databaseAdd
                )
                
# add to databases
            self.MySQL_Commands(
                1,
                'self.cursorHandleMySQL.execute("CREATE DATABASE' + ' ' + databaseAdd + '")'
                )
            try:
                self.cursorHandleMySQL.execute('CREATE DATABASE' + ' ' + databaseAdd)
            except:
                stringCannotCreateDatabase = (
                    'Unable to create database.\n\n' +
                    'One reason may be that the database name you have chosen\n' +
                    'is already in use by the server as a reserved name.\n\n' +
                    'Another may be that you are using a dash instead of an\n' +
                    'underscore in the name. Dashes are treated as special characters\n' +
                    'by the server and will not allow a database to be created with them.\n\n' +
                    'Enter a different name and try again.'
                    )
                print(stringCannotCreateDatabase)
                self.MySQL_Output(
                    0,
                    stringCannotCreateDatabase
                    )
                showerror(
                    'Error: cannot create database',
                    stringCannotCreateDatabase
                    )
                return

# clear the old name from the CREATE DATABASE window
            self.varEnterDatabaseNameAdd.set('')
# get new database list
# ... first save what's selected in combobox, if anything
            saveCurrentDatabase = self.comboboxDbSelect.get()
# ... clear all databases
            self.comboboxDbSelect.clear()
# ... get new list
            self.mysql_GetDatabases()
# ... regrid DATABASES combobox
            self.mysql_ComboDatabases()
# ... restore picked selection, if any
            if saveCurrentDatabase <> '':
                self.comboboxDbSelect.selectitem(saveCurrentDatabase)
# flush privileges; otherwise, will get error like
#   "can't run this command yet"
            stringFlushPrivileges = (
                'FLUSH PRIVILEGES'
                )
            self.cursorHandleMySQL.execute(stringFlushPrivileges)
            
            
# Create SANDBOX table if user so desired
            
# if box is checked, create 'sandbox' table by one of two methods:
# method 1: copying table 'template_sandbox' from database 'template_co_pylotdb' 
#           to newly created database; may be useful if user does not have
#           'create' privileges but can copy a table to another database
# method 2: creating table from scratch; useful if method 1 fails

# ... here we go
            flagCreate = 0
            if self.varCheckbuttonAutoCreateSandboxTable.get():
# TRY METHOD 1 FIRST: COPY (success if flagCreate = 1)
                flagCreate = self.create_sandbox_from_copy(databaseAdd,'sandbox')
# TRY METHOD 2 IF METHOD 1 DOES NOT WORK (success if flagCreate = 2)
                if not flagCreate:
                    flagCreate = self.create_sandbox_from_scratch(databaseAdd,'sandbox')
# if both Method 1 and Method 2 fail, then we cannot create table 'sandbox';
#    either method will pop-up success widget, but show failure widget here                    
                if flagCreate == 0:
                    stringCreateFailed = (
                    'Failed to create table "sandbox" either\n' + 
                    'by copying or creation from scratch.\n\n'
                    )
                    print('\n' + stringCreateFailed)
                    self.MySQL_Output(
                        0,
                        stringCreateFailed,
                        parent=self.toplevelDatabaseCreate
                        )
                    try:
                        showinfo(
                            'Info: cannot create sandbox table',
                            stringCreateFailed,
                            parent=self.toplevelDatabaseCreate
                            )
                    except:
                        showinfo(
                            'Info: cannot create sandbox table',
                            stringCreateFailed
                            )
                    return
                    
        else:
# cancel operation
            self.MySQL_Output(
                1,
                'CANCELED: add database'
                )
                
        return
        
        
    def create_sandbox_from_copy(self,databaseAdd,tableNameSandbox):
        '''
        Purpose:
            create the table 'sandbox' by copying table 'template_sandbox' from 
            database 'template_co_pylotdb'; 
            if this method does not work due to lack of permissions to create
            a table, then try calling 'create_sandbox_from_scratch'
            
        Returns:
            1 if successful, 0 if not
            
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'create_sandbox_from_copy')
            
        stringCreateAttempt = (
            'Attempting to create "sandbox" table by copying ...'
            )
        
        if DEBUG_SANDBOX:
            print('\n' + stringCreateAttempt)
            
        self.MySQL_Output(
            0,
            '\n' + stringCreateAttempt
            )
            
# check if database/table containing 'template_sandbox' exist
        listOfDatabases = []
        listOfTables = []
        sourceDatabase = 'template_co_pylotdb'
        sourceTable = 'template_sandbox'
        finalTableName = tableNameSandbox
# get list of databases
        self.cursorHandleMySQL.execute("SHOW DATABASES")
        temp_listOfDatabases = self.cursorHandleMySQL.fetchall()
        for database in temp_listOfDatabases:
            listOfDatabases.append(database[0])
        listOfDatabases.sort()
        
        if DEBUG_SANDBOX:
            stringListOfDatabases = (
                '\nList of databases for finding table "sandbox":'
                )
            print(stringListOfDatabases)
            print(listOfDatabases)
            
        if sourceDatabase in listOfDatabases:
# get list of tables
            self.cursorHandleMySQL.execute("SHOW TABLES FROM " + sourceDatabase)
            temp_listOfTables = self.cursorHandleMySQL.fetchall()
            for table in temp_listOfTables:
                listOfTables.append(table[0])
            listOfTables.sort()
            if DEBUG_SANDBOX:
                stringListOfTables = (
                    '\nList of tables in database %s:'
                    ) % (
                    sourceDatabase
                    )
                print(stringListOfTables)
                print(listOfTables)
                
            if sourceTable in listOfTables:                        
# database and table exist, so copy table 'template_sandbox' to new database.
# ... takes 2 commands to do this
                try:
                    self.cursorHandleMySQL.execute(
                        "CREATE TABLE " + databaseAdd + "." + finalTableName +
                        " LIKE " + sourceDatabase + "." + sourceTable
                        )
                    self.cursorHandleMySQL.execute(
                        "INSERT INTO " + databaseAdd + "." + finalTableName + " SELECT * FROM " +
                        sourceDatabase + "." + sourceTable
                        )
                except:
                    stringFailToCreateSandbox = (
                        'Unable to copy table from\n\n' +
                        '%s\n' + 
                        'in database\n' +
                        '%s\n\n' +
                        'to table\n\n' +
                        '%s\n' +
                        'in database\n' +
                        '%s\n\n'
                        'Reason is unknown but may be due to lack\n' +
                        'of permissions to create a table.'
                        ) % (
                        sourceTable,
                        sourceDatabase,
                        finalTableName,
                        databaseAdd
                        )
                    if DEBUG_SANDBOX:
                        print('\n' + stringFailToCreateSandbox)
                    self.MySQL_Output(
                        0,
                        stringFailToCreateSandbox
                        )
                    return 0
                    
# if we get here, creation of 'sandbox' table was success
                stringSuccessCreateSandbox = (
                    'Success!\n\n' +
                    'table: %s\n' + 
                    'has been created in\n' +
                    'database: %s\n\n' +
                    'by copying from\n\n' +
                    'table: %s\n' +
                    'in\n' +
                    'database: %s'
                    ) % (
                    finalTableName,
                    databaseAdd,
                    sourceTable,
                    sourceDatabase
                    )
                self.MySQL_Output(
                    0,
                    stringSuccessCreateSandbox
                    )
                try:
                    showinfo(
                        'Info: success',
                        stringSuccessCreateSandbox,
                        parent=self.toplevelDatabaseCreate
                        ) 
                except:
                    showinfo(
                        'Info: success',
                        stringSuccessCreateSandbox
                        )
                return 1
                   
# no targetTable found                        
            else:
                stringNoTemplateTable = (
                    'The table\n\n' +
                    '"%s"\n\n' + 
                    'does not exist in database\n\n' +
                    '"%s"\n\n' +
                    'The table cannot be created by copying from another database.'
                    ) % (
                    sourceTable,
                    sourceDatabase
                    )
                if DEBUG_SANDBOX:
                    print('\n' + stringNoTemplateTable)
                self.MySQL_Output(
                    0,
                    stringNoTemplateTable
                    )
                return 0

# no targetDatabase found
        else:
            stringNoTemplateDatabase = (
                'The database\n\n' +
                '"%s"\n\n' +
                'that is supposed to contain a "sandbox" table template\n' +
                'does not exist on the server.\n\n' +
                'The table\n\n' +
                '"%s"\n\n' +
                'cannot be created by copying from this database.'
                ) % (
                sourceDatabase,
                sourceTable
                )
            if DEBUG_SANDBOX:
                print('\n' + stringNoTemplateDatabase)
            self.MySQL_Output(
                0,
                stringNoTemplateDatabase
                )
            return 0
                    
                    
    def create_sandbox_from_scratch(self,databaseAdd,tableNameSandbox):
        '''
        Purpose:
            create the table 'sandbox' from scratch. 
            can also create 'sandbox' table by calling 'create_sandbox_from_copy'
            
        Returns:
            1 if successful, 0 if not
            
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'create_sandbox_from_scratch')
            
        targetTable = tableNameSandbox
        
        stringCreateAttempt = (
            'Attempting to create "%s" table from scratch...'
            ) % tableNameSandbox
            
        if DEBUG_SANDBOX:
            print('\n' + stringCreateAttempt)
        
        self.MySQL_Output(
            0,
            '\n' + stringCreateAttempt
            )

# command to create table in database
        commandCreateTable = 'CREATE TABLE' + ' ' + databaseAdd + '.' + targetTable + ' ' 

# create commands to generate fields
        subCommand = ''
        subCommand += (
            '(' +
            'user char(20) DEFAULT NULL,' +                         # field 1
            'tester_name_first char(255) DEFAULT NULL,' +           # field 2
            'tester_name_last char(255) DEFAULT NULL,' +            # field 3
            'current_dir char(255) DEFAULT NULL,' +                 # field 4
            'host_name char(255) DEFAULT NULL,' +                   # field 5
            'target_machine char(255) DEFAULT NULL,' +              # field 6
            'day_number_since_01jan2011 int(5) DEFAULT NULL,' +     # field 7
            'day_of_week char(3) DEFAULT NULL,' +                   # field 8
            'month char(3) DEFAULT NULL,' +                         # field 9
            'day_of_month int(2) DEFAULT NULL,' +                   # field 10
            'year int(6) DEFAULT NULL,' +                           # field 11
            'date_of_last_send char(15) DEFAULT NULL,' +            # field 12
            'time_of_last_send char(15) DEFAULT NULL,' +            # field 13
            'input_file_name char(255) DEFAULT NULL,' +             # field 14
            'input_file_dir char(255) DEFAULT NULL,' +              # field 15
            'input_file_contents text DEFAULT NULL,' +              # field 16
            'output_file_name char(255) DEFAULT NULL,' +            # field 17
            'output_file_dir char(255) DEFAULT NULL,' +             # field 18
            'output_file_contents text DEFAULT NULL,' +             # field 19
            'makefile_name char(255) DEFAULT NULL,' +               # field 20
            'makefile_dir char(255) DEFAULT NULL,' +                # field 21
            'makefile_contents text DEFAULT NULL,' +                # field 22
            'source_file_name char(255) DEFAULT NULL,' +            # field 23
            'source_file_dir char(255) DEFAULT NULL,' +             # field 24
            'source_file_contents text DEFAULT NULL,' +             # field 25
            'executable_file_name char(255) DEFAULT NULL,' +        # field 26
            'executable_file_dir char(255) DEFAULT NULL,' +         # field 27
            'qsub_file_name char(255) DEFAULT NULL,' +              # field 28
            'qsub_file_dir char(255) DEFAULT NULL,' +               # field 29
            'qsub_file_contents text DEFAULT NULL,' +               # field 30
            'compile_line char(255) DEFAULT NULL,' +                # field 31
            'execute_line char(255) DEFAULT NULL,' +                # field 32
            'user_comments text DEFAULT NULL,'                       # field 33
            )
            
# field 34: add auto_index field
        subCommand += (
            'auto_index INT(12) NOT NULL AUTO_INCREMENT PRIMARY KEY )' # field 34
            )
            
# put it all together
        commandCreateTable += subCommand
        
# print commandCreateTable for the record
        self.MySQL_Commands(
            1,
            'self.cursorHandleMySQL.execute(' + commandCreateTable + ')'
            )
            
        if DEBUG_SANDBOX:
            print('\nCommand to create "sandbox" table from scratch:')
            print('self.cursorHandleMySQL.execute(' + commandCreateTable + ')' )
        
# command to create the table    
        try:
            self.cursorHandleMySQL.execute( commandCreateTable )
        except:
            stringFailToCreateSandboxFromScratch = (
                'Unable to create from scratch table\n\n' +
                '"%s"\n\n' + 
                'in database\n\n' +
                '"%s"\n\n' +
                'Reason is unknown but may be due to lack\n' +
                'of permissions to create a table.'
                ) % (
                targetTable,
                databaseAdd
                )
            if DEBUG_SANDBOX:
                print('\n' + stringFailToCreateSandboxFromScratch)
            self.MySQL_Output(
                0,
                stringFailToCreateSandboxFromScratch
                )
            return 0
            
# if we get here, table creation from scratch was a success
        stringSuccessCreateSandbox = (
            'Success!\n\n' +
            'table: %s\n' + 
            'has been created from scratch in\n' +
            'database: %s\n\n' 
            ) % (
            targetTable,
            databaseAdd
            )
        if DEBUG_SANDBOX:
            print('\n' + stringSuccessCreateSandbox)
        self.MySQL_Output(
            0,
            stringSuccessCreateSandbox
            )
            
        try:
            showinfo(
                'Info: success',
                stringSuccessCreateSandbox,
                parent=self.toplevelDatabaseCreate
                )
        except:
            showinfo(
                'Info: success',
                stringSuccessCreateSandbox
                )
        return 1
            
            
    def handlerDatabaseDelete(self):
        '''
        Delete a database from current list of databases
        
        inputs:
            self.cursorHandleMySQL
            self.comboboxDbSelect.get()
            self.myDatabases()
            
        outputs:
            self.myDatabases() # revised
       
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerDatabaseDelete')
            
        self.use_Database = self.comboboxDbSelect.get().strip()

# check if connected to a MySQL server
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return
            
# destroy any old toplevel frames
        self.destroyAllDatabaseTableFieldFrames()
                    
# open Toplevel frame for entering database name
        self.toplevelDatabaseDelete = Toplevel(
            self.frameParent,
            bg='tan'
            )
        self.toplevelDatabaseDelete.title(
            'DATABASES'
            )
# keep it on top of the parent window
        self.toplevelDatabaseDelete.transient(self.frameParent)
# place the top window
#        x_Windows=self.deleteDatabase_xWindowLocation
#        y_Windows=self.deleteDatabase_yWindowLocation
        x_Windows = self.frameParent.winfo_rootx() + 5
        y_Windows = self.frameParent.winfo_rooty() + 200
        
        self.toplevelDatabaseDelete.geometry(
            '+%d+%d' % (x_Windows, y_Windows)
            )
            
        frame_00 = Frame(
            self.toplevelDatabaseDelete,
            bg='tan',
            )
        frame_00.grid(
            row=0,
            column=0,
            padx=5,
            pady=5,
            )
            
        self.frame_10_delete_databases = Frame(
            self.toplevelDatabaseDelete,
            bg='tan',
            )
        self.frame_10_delete_databases.grid(
            row=1,
            column=0,
            padx=5,
            pady=5,
            )
            
        frame_20 = Frame(
            self.toplevelDatabaseDelete,
            bg='tan',
            )
        frame_20.grid(
            row=2,
            column=0,
            padx=5,
            pady=5,
            )
            
# WIDGETS
        labelTitleDatabaseNameAdd = Label(
            frame_00,
            text='DELETE DATABASE',
            bg='tan',
            justify=CENTER,
            font=self.labelFontMediumBold,
            )
        labelTitleDatabaseNameAdd.grid(
            row=0,
            column=0,
            padx=5,
            pady=5,
            )     
            
        labelEnterDatabaseNameDelete = Label(
            self.frame_10_delete_databases,
            text='Selected database: ',
            bg='tan',
            justify=RIGHT,
            )
        labelEnterDatabaseNameDelete.grid(
            row=0,
            column=0,
            padx=0,
            pady=5,
            sticky=E,
            )
        '''
# combobox
        self.comboboxEnterDatabaseNameDelete = Pmw.ComboBox(
            self.frame_10_delete_databases,
            scrolledlist_items=self.myDatabases,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            entry_width=30,
            scrolledlist_hull_width=500,
            )
        self.comboboxEnterDatabaseNameDelete.grid(
            row=0,
            column=1,
            padx=5,
            pady=5,
            sticky=W,
            )
        if self.use_Database:
            self.comboboxEnterDatabaseNameDelete.selectitem(self.use_Database)
        else:
            self.comboboxEnterDatabaseNameDelete.setentry('')
        '''
            
        self.varEntryEnterDatabaseNameDelete = StringVar()
        if self.use_Database:
            self.varEntryEnterDatabaseNameDelete.set(self.use_Database)
        else:
            self.varEntryEnterDatabaseNameDelete.set('')
        self.entryEnterDatabaseNameDelete = Entry(
            self.frame_10_delete_databases,
            state='disable',
            textvariable=self.varEntryEnterDatabaseNameDelete,
            disabledforeground='black',
            disabledbackground='white',
            width=30,
            )
        self.entryEnterDatabaseNameDelete.grid(
            row=0,
            column=1,
            padx=5,
            pady=5,
            sticky=W,
            )
        
# graph Delete and Cancel buttons
        self.buttonOkEnterDatabaseNameDelete = Button(
            self.frame_10_delete_databases,
            text='Delete',
            borderwidth=3,
            relief=RAISED,
            justify=CENTER,
            background='white',
            foreground='blue',
            font=self.buttonFontSmall,
            width=10,
            command=self.handlerDatabaseNameDelete,
            )
        self.buttonOkEnterDatabaseNameDelete.grid(
            row=1,
            column=1,
            padx=5,
            pady=0,
            sticky=N,
            )
            
        self.buttonCancelEnterDatabaseNameDelete = Button(
            frame_20,
            text='Cancel',
            borderwidth=5,
            relief=RAISED,
            justify=CENTER,
            width=20,
            command=self.handlerToplevelDatabaseDeleteDestroy,
            )
        self.buttonCancelEnterDatabaseNameDelete.grid(
            row=0,
            column=0,
            padx=5,
            pady=15,
            )

        return
        
        
    def handlerToplevelDatabaseDeleteDestroy(self):
        '''
        Purpose:
            destroy 'Delete Database' window
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerToplevelDatabaseDelete')

# save location for next time window is opened
        self.deleteDatabase_xWindowLocation = \
            self.toplevelDatabaseDelete.winfo_rootx() - self.offsetWindowX
        self.deleteDatabase_yWindowLocation = \
            self.toplevelDatabaseDelete.winfo_rooty() - self.offsetWindowY

# destroy current toplevel            
        self.toplevelDatabaseDelete.destroy()
        
        return
        

    def handlerDatabaseNameDelete(self):
        '''
        handler for:
            handlerDatabaseDelete
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerDatabaseNameDelete')

            # make sure field is not empty
#        databaseDelete = self.comboboxEnterDatabaseNameDelete.get().strip()
        databaseDelete = self.varEntryEnterDatabaseNameDelete.get().strip()
# ... first, strip any leading whitespace (careless user!)        
   #     databaseDelete = databaseDelete.strip()
# ... check for blank name
        if databaseDelete == '' or databaseDelete == None:
            stringErrorDatabaseNameBlank = (
                'Entry for database name is blank.\n\n' +
                'Select a database and try again.'
                )
            self.MySQL_Output(
                1,
                stringErrorDatabaseNameBlank
                )
            showerror(
                'Error: no database name',
                stringErrorDatabaseNameBlank
                )
            return

# check if database is in list
        for myDatabase in self.myDatabases:
            if databaseDelete == myDatabase:
# get final ok to delete           
                ans=askokcancel(
                    'Delete database',
                    'You are about to delete database\n' + 
                    '"' + databaseDelete + '"' + '.\n\n' +
                    'Click OK to continue, or CANCEL to\n' +
                    'quit this process.\n'
                    )
            
                if ans:
                    self.MySQL_Output(
                        1,
                        ' Delete database: ' + databaseDelete
                        )
                    try:
# delete from databases
                        self.MySQL_Commands(
                            1,
                            'self.cursorHandleMySQL.execute("DROP DATABASE' + ' ' + databaseDelete + '")'
                            )
                        self.cursorHandleMySQL.execute("DROP DATABASE" + " " + databaseDelete)

                    except:
# user has no delete permissions
                        self.MySQL_Output(
                            1,
                            'Error: user probably does not have "delete" permissions.'
                            )
                        showerror(
                            'Error: no "delete" permissions',
                            'Unable to delete database.\n\n' +
                            'You probably do not have "delete" permissions for\n' + 
                            'this database.\n\n' + 
                            'Check with a system administrator for obtaining\n' +
                            'appropriate permissions to delete a database.\n'
                            )
                        return
                    
                    else:
# get rid of Toplevel frame
#                        self.toplevelDatabaseDelete.destroy()
# get new database list
# ... first save what's selected in combobox
                        saveCurrentDatabase = self.comboboxDbSelect.get()
# ... clear all databases
                        self.comboboxDbSelect.clear()
# ... get new list
                        self.mysql_GetDatabases()
# ... regrid DATABASES combobox
                        self.mysql_ComboDatabases()
# ... restore selection if possible
                        if saveCurrentDatabase in self.myDatabases:
                            self.comboboxDbSelect.selectitem(saveCurrentDatabase)
                        else:
# ... current selection was the one deleted, so clear tables and fields
# ...   clear out TABLES combobox
                            self.clearDbTables()
# ...   clear out FIELDS combobox
                            self.clearDbFields()
# ...   blank entry field
#                            self.comboboxEnterDatabaseNameDelete.setentry('')
                            self.varEntryEnterDatabaseNameDelete.set('')
# flush privileges; otherwise, will get error like
#   "can't run this command yet"
                            stringFlushPrivileges = (
                                'FLUSH PRIVILEGES'
                                )
                            self.cursorHandleMySQL.execute(stringFlushPrivileges)
                            
# re-list widget with new database list
                        '''
                        self.comboboxEnterDatabaseNameDelete = Pmw.ComboBox(
                            self.frame_10_delete_databases,
                            scrolledlist_items=self.myDatabases,
                            dropdown=1,
                            entry_state='disabled',
                            entry_disabledbackground='white',
                            entry_disabledforeground='black',
                            entry_width=30,
                            scrolledlist_hull_width=500,
                            )
                        self.comboboxEnterDatabaseNameDelete.grid(
                            row=0,
                            column=1,
                            padx=5,
                            pady=5,
                            sticky=W,
                            )
                        try:
                            self.comboboxEnterDatabaseNameDelete.selectitem(self.use_Database)
                        except:
                            self.comboboxEnterDatabaseNameDelete.setentry('')
                        '''
# re-graph widget with empty field; selecting database will set the new value
                        self.varEntryEnterDatabaseNameDelete.set('')
                        
                        return
                else:
                    self.MySQL_Output(
                        1,
                        'CANCELED: delete database'
                        )
                    return
                
# if we get this far, database does not exist in list
        print 'This database does not exist!\n'
        showerror(
            'Error: database does not exist',
            'You entered a database that does not\n' +
            'currently exist! No database will be deleted.\n\n' +
            'To delete a database, enter an existing\n' + 
            'name into the entry field, then\n' +
            'click "Delete".\n\n'
            )
            
        return
        
        
    def handlerDatabaseTablesAdd(self):
        '''
        Add a table to current list of tables
        
        inputs:
            self.cursorHandleMySQL
            self.comboboxDbSelect.get()
            self.myDatabases()
            
        outputs:
            self.myDatabases()    # revised
       
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerDatabaseTablesAdd')

# check if connected to a MySQL server
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return
        
# FRAMES
# destroy any old toplevel frames
        self.destroyAllDatabaseTableFieldFrames()
                   
# open Toplevel frame for entering database name
        self.toplevelTableCreate = Toplevel(
            self.frameParent,
            bg='tan'
            )
        self.toplevelTableCreate.title(
#            'Create table'
            'CREATE TABLE'
            )
        self.toplevelTableCreate.transient(self.frameParent)
# place the top window
        x_Windows = self.createTableTwoMethods_xWindowLocation
        y_Windows = self.createTableTwoMethods_yWindowLocation
        self.toplevelTableCreate.geometry(
            '+%d+%d' % (x_Windows, y_Windows)
            )
# title             
        frame_00 = Frame(
            self.toplevelTableCreate,
            bg='tan',
            )
        frame_00.grid(
            row=0,
            column=0,
            )
# from scratch            
        frame_10 = Frame(
            self.toplevelTableCreate,
            bg='tan',
            )
        frame_10.grid(
            row=1,
            column=0,
            padx=5,
            pady=5,
            sticky=E+W,
            )
            
        frame_10_00 = Frame(
            frame_10,
            bg='tan'
            )
        frame_10_00.grid(
            row=0,
            column=0,
            padx=5,
            pady=0,
            sticky=E+W,
            )
# ... fields
        frame_20 = Frame(
            self.toplevelTableCreate,
            bg='tan',
            )
        frame_20.grid(
            row=2,
            column=0,
            padx=5,
            pady=0,
            )        
# from an existing table
        frame_30 = Frame(
            self.toplevelTableCreate,
            bg='tan',
            )
        frame_30.grid(
            row=3,
            column=0,
            padx=5,
            pady=5,
            sticky=E+W,
            )
# ... fields
        self.frame_40_FromExistingDatabases = Frame(
            self.toplevelTableCreate,
            bg='tan',
            )
        self.frame_40_FromExistingDatabases.grid(
            row=4,
            column=0,
            padx=5,
            pady=0,
            )  
# create sandbox table
        frame_50 = Frame(
            self.toplevelTableCreate,
            bg='tan',
            )
        frame_50.grid(
            row=5,
            column=0,
            padx=5,
            pady=0,
            sticky=E+W,
            )
# ... button for creating sandbox table
        self.frame_60_CreateSandboxTable = Frame(
            self.toplevelTableCreate,
            bg='tan',
            )
        self.frame_60_CreateSandboxTable.grid(
            row=6,
            column=0,
            padx=5,
            pady=0,
            )
# cancel 
        frame_99 = Frame(
            self.toplevelTableCreate,
            bg='tan',
            )
        frame_99.grid(
            row=7,
            column=0,
            padx=5,
            pady=5,
            )
            
# WIDGETS
# ... title
        Row = 0
        labelTitleCreateTable = Label(
            frame_00,
            text=(
                'CREATE TABLE -- 3 METHODS\n' + 
                '(all methods create tables with empty fields)'
                ),
            bg='tan',
            justify=CENTER,
            font=self.labelFontMediumBold,
            )
        labelTitleCreateTable.grid(
            row=Row,
            column=0,
            columnspan=99,
            padx=5,
            pady=10,
            )
        Row += 1
        labelEnterDatabase = Label(
            frame_00,
            text='Create table in current database: ',
            bg='tan',
            justify=RIGHT,
            )
        labelEnterDatabase.grid(
            row=Row,
            column=0,
            padx=5,
            pady=5,
            sticky=E,
            )
            
        self.varDatabaseForNewTable = StringVar()
        self.varDatabaseForNewTable.set(self.comboboxDbSelect.get())
        self.entryDatabaseForNewTable = Entry(
            frame_00,
            textvariable=self.varDatabaseForNewTable,
            disabledforeground='black',
            disabledbackground='white',
            state='disabled',
            width=30,
            )
        self.entryDatabaseForNewTable.grid(
            row=Row,
            column=1,
            padx=5,
            pady=5,
            sticky=W,
            )

# ... separator            
        Row += 1
        labelSeparator = Label(
            frame_00,
            text = (
                '-'*60 
                ),
            bg='tan',
            )
        labelSeparator.grid(
            row=Row,
            column=0,
            columnspan=99,
            padx=0,
            pady=0,
            )
        
# ... FROM SCRATCH
        Row = 0
        labelFromScratch = Label(
            frame_10_00,
            text=(
                'METHOD 1. CREATE TABLE FROM SCRATCH\n' +
                '  Creates new table from user-defined field names, and datatypes'
                ),
            bg='tan',
#            anchor=W,
            justify=LEFT,
            font=self.labelFontMediumBold,
            )
        labelFromScratch.grid(
            row=Row,
            column=0,
            padx=0,
            pady=5,
            )
            
# ... fields        
        Row = 0
        labelEnterDatabaseTablesNameAdd = Label(
            frame_20,
            text=(
                'ENTER NAME FOR NEW TABLE\n' +
                'To be created in current database designated at top of this window;\n' +
                'no special characters or dashes are allowed, but can use underscores'
                ),
            bg='tan',
            justify=RIGHT,
            )
        labelEnterDatabaseTablesNameAdd.grid(
            row=Row,
            column=0,
            rowspan=2,
            padx=5,
            pady=5,
            sticky=E,
            )

        self.varEnterDatabaseTablesNameAdd = StringVar()
        self.varEnterDatabaseTablesNameAdd.set('new_table')
        self.entryEnterDatabaseTablesNameAdd = Entry(
            frame_20,
            width=30,
            textvariable=self.varEnterDatabaseTablesNameAdd,
            )
        self.entryEnterDatabaseTablesNameAdd.grid(
            row=Row,
            column=1,
            padx=5,
            pady=0,
#            sticky=S,
            )
         
        Row += 1
        buttonClearNewTableNameMethod1 = Button(
            frame_20,
            text='Clear',
            font=self.buttonFontSmallest,
            borderwidth=2,
            relief=RAISED,
            width=8,
            background='white',
            foreground='blue',
            command=self.handlerClearNewTableNameMethod1,
            )
        buttonClearNewTableNameMethod1.grid(
            row=Row,
            column=1,
            padx=5,
            pady=0,
            sticky=N,
            )
                
# define initial number of fields in table
        Row += 1
        labelFieldsForNewTable = Label(
            frame_20,
            text=(
                'NUMBER OF FIELDS FOR NEW TABLE\n' +
                'At least 1 required; do NOT include the AUTO_INDEX field\n' +
                'in this count; it will be added automatically'
                ),
            bg='tan',
            justify=RIGHT,
            )
        labelFieldsForNewTable.grid(
            row=Row,
            column=0,
            padx=5,
            pady=5,
            sticky=E,
            )
            
# Pmw.entry field; integer validation; use .getvalue() method to retrieve values
        self.entryfieldFieldsForNewTable = Pmw.EntryField(
            frame_20,
            validate = {
                'validator' : 'integer',
                'min' : 0,
                'max' : 255
                },
            entry_width=10,
            )
        self.entryfieldFieldsForNewTable.grid(
            row=Row,
            column=1,
            padx=5,
            pady=5,
            sticky=W,
            )
        self.entryfieldFieldsForNewTable.setvalue(1)
#        self.entryfieldFieldsForNewTable.configure(entry_width=10)
        self.entryfieldFieldsForNewTable.bind(
            "<KeyPress-Return>",
            self.handlerBindFieldsForNewTable,
            )

        Row += 1
        self.buttonDefineFieldsForNewTable = Button(
            frame_20,
            text='Method 1. Define fields ...',
            borderwidth=5,
            relief=RAISED,
            width=30,
            background='white',
            foreground='blue',
            command=self.handlerDefineFieldsForNewTable,
            )
        self.buttonDefineFieldsForNewTable.grid(
            row=Row,
            column=0,
            columnspan=99,
            padx=5,
            pady=5,
            )
            
# ... separator            
        Row += 1
        labelSeparator = Label(
            frame_20,
            text = (
                '-'*60 
                ),
            bg='tan',
            )
        labelSeparator.grid(
            row=Row,
            column=0,
            columnspan=99,
            padx=0,
            pady=0,
            )
            
# ... FROM EXISTING TABLE

        Row = 0
        labelFromExistingTable = Label(
            frame_30,
            text=(
                'METHOD 2. CREATE TABLE FROM AN EXISTING DATABASE AND TABLE\n' +
                '  Uses table structure from any table in any database to create a new\n' +
                '  empty table in current database'
                ),
            bg='tan',
            justify=LEFT,
            font=self.labelFontMediumBold,
            )
        labelFromExistingTable.grid(
            row=Row,
            column=0,
            padx=0,
            pady=5,
            )
        
        Row = 0
        labelChooseDatabase = Label(
            self.frame_40_FromExistingDatabases,
            text='SELECT ANY EXISTING DATABASE',
            bg='tan',
            justify=RIGHT,
            )
        labelChooseDatabase.grid(
            row=Row,
            column=0,
            padx=5,
            pady=5,
            sticky=E,
            )
            
        self.comboboxDatabaseFromExistingDatabases = Pmw.ComboBox(
            self.frame_40_FromExistingDatabases,
            scrolledlist_items=self.myDatabases,
            scrolledlist_hscrollmode='static',
            scrolledlist_vscrollmode='static',
            selectioncommand=self.handlerGetDatabaseTables,
            entry_width=30,
            scrolledlist_hull_width=500,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            )
        self.comboboxDatabaseFromExistingDatabases.grid(
            row=Row,
            column=1,
            padx=5,
            pady=5,
            sticky=W,
            )
        self.comboboxDatabaseFromExistingDatabases.setentry(
            self.varDatabaseForNewTable.get()
            )
        
        Row += 1
        self.myRowFromExistingDatabases = Row
        labelChooseDatabaseTable = Label(
            self.frame_40_FromExistingDatabases,
            text=(
                'SELECT AN EXISTING TABLE\n' +
                'Choose from tables in database selected immediately above'
                ),
            bg='tan',
            justify=RIGHT,
            )
        labelChooseDatabaseTable.grid(
            row=Row,
            column=0,
            padx=5,
            pady=5,
            sticky=E,
            )
            
#        self.myTablesFromExistingDatabases = []
        self.comboboxTablesFromExistingDatabases = Pmw.ComboBox(
            self.frame_40_FromExistingDatabases,
            scrolledlist_items=self.myDatabaseTables,
            scrolledlist_hscrollmode='static',
            scrolledlist_vscrollmode='static',
            entry_width=30,
            scrolledlist_hull_width=500,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            )
        self.comboboxTablesFromExistingDatabases.grid(
            row=Row,
            column=1,
            padx=5,
            pady=5,
            sticky=W,
            )
        if self.comboboxDbTableSelect.get().strip() <> '':
            self.comboboxTablesFromExistingDatabases.setentry(
                self.comboboxDbTableSelect.get()
                )
        
        Row += 1
        labelEnterNewTableName = Label(
            self.frame_40_FromExistingDatabases,
            text=(
                'ENTER NAME FOR NEW TABLE\n' +
                'To be created in current database designated at top of this window;\n' +
                'to use different database, select desired database from main window'
                ),
            bg='tan',
            justify=RIGHT,
            )
        labelEnterNewTableName.grid(
            row=Row,
            column=0,
            rowspan=2,
            padx=5,
            pady=5,
            sticky=E,
            )

        self.varEnterNewTableName = StringVar()
        self.varEnterNewTableName.set('new_table')
        self.entryEnterNewTableName = Entry(
            self.frame_40_FromExistingDatabases,
            width=30,
            textvariable=self.varEnterNewTableName,
            )
        self.entryEnterNewTableName.grid(
            row=Row,
            column=1,
            padx=5,
            pady=0,
            sticky=W,
            )
        self.entryEnterNewTableName.bind(
            "<KeyPress-Return>",
            self.handlerBindEnterNewTableName,
            )
            
        Row += 1
        buttonClearNewTableNameMethod2 = Button(
            self.frame_40_FromExistingDatabases,
            text='Clear',
            font=self.buttonFontSmallest,
            borderwidth=2,
            relief=RAISED,
            width=8,
            background='white',
            foreground='blue',
            command=self.handlerClearNewTableNameMethod2,
            )
        buttonClearNewTableNameMethod2.grid(
            row=Row,
            column=1,
            padx=5,
            pady=0,
            sticky=N,
            )
            
        Row += 1
        self.buttonCreateNewTable = Button(
            self.frame_40_FromExistingDatabases,
            text='Method 2. Create new table',
            borderwidth=5,
            relief=RAISED,
            width=30,
            background='white',
            foreground='blue',
            command=self.handlerCreateNewTableFromExistingTable,
            )
        self.buttonCreateNewTable.grid(
            row=Row,
            column=0,
            columnspan=99,
            padx=5,
            pady=5,
            )
            
# ... separator            
        Row += 1
        labelSeparator = Label(
            self.frame_40_FromExistingDatabases,
            text = (
                '-'*60 
                ),
            bg='tan',
            )
        labelSeparator.grid(
            row=Row,
            column=0,
            columnspan=99,
            padx=0,
            pady=0,
            )
            
# FRAME 50

        Row = 0
        labelCreateSandboxTable = Label(
            frame_50,
            text=(
                'METHOD 3. CREATE "SANDBOX" TABLE\n' +
                '  Creates a table formatted for Co-Pylot data transfer' 
                ),
            bg='tan',
            justify=LEFT,
            font=self.labelFontMediumBold,
            )
        labelCreateSandboxTable.grid(
            row=Row,
            column=0,
            padx=0,
            pady=5,
            )

# FRAME 60       
     
        Row = 0
        labelEnterSandboxTableName = Label(
            self.frame_60_CreateSandboxTable,
            text=(
                'ENTER NAME FOR "SANDBOX" TABLE\n' +
                'To be created in current database designated at top of this window;\n' +
                'to use different database, select desired database from main window' 
                ),
            bg='tan',
            justify=RIGHT,
            )
        labelEnterSandboxTableName.grid(
            row=Row,
            column=0,
            rowspan=2,
            padx=5,
            pady=5,
            sticky=E,
            )

        self.varEnterSandboxTableName = StringVar()
        self.varEnterSandboxTableName.set('sandbox')
        self.entryEnterSandboxTableName = Entry(
            self.frame_60_CreateSandboxTable,
            width=30,
            textvariable=self.varEnterSandboxTableName,
            )
        self.entryEnterSandboxTableName.grid(
            row=Row,
            column=1,
            padx=5,
            pady=0,
            sticky=W,
            )
        self.entryEnterSandboxTableName.bind(
            "<KeyPress-Return>",
            self.handlerBindEnterSandboxTableName,
            )
        
        Row += 1
        buttonClearSandboxTableName = Button(
            self.frame_60_CreateSandboxTable,
            text='Clear',
            font=self.buttonFontSmallest,
            borderwidth=2,
            relief=RAISED,
            width=8,
            background='white',
            foreground='blue',
            command=self.handlerClearSandboxTableName,
            )
        buttonClearSandboxTableName.grid(
            row=Row,
            column=1,
            padx=5,
            pady=0,
            sticky=N,
            )
            
        Row += 1
        self.buttonCreateSandboxTable = Button(
            self.frame_60_CreateSandboxTable,
            text='Method 3. Create "sandbox" table',
            borderwidth=5,
            relief=RAISED,
            width=30,
            background='white',
            foreground='blue',
            command=self.handlerCreateSandboxTable,
            )
        self.buttonCreateSandboxTable.grid(
            row=Row,
            column=0,
            columnspan=99,
            padx=5,
            pady=5,
            sticky=N,
            )
            
# ... separator            
        Row += 1
        labelSeparator = Label(
            self.frame_60_CreateSandboxTable,
            text = (
                '-'*60 
                ),
            bg='tan',
            )
        labelSeparator.grid(
            row=Row,
            column=0,
            columnspan=99,
            padx=0,
            pady=0,
            )

# ... cancel            
        self.buttonCancelDefineFieldsForNewTable = Button(
            frame_99,
            text='Cancel',
            borderwidth=5,
            relief=RAISED,
            width=12,
            command=self.handlerToplevelTableCreateDestroy,
            )
        self.buttonCancelDefineFieldsForNewTable.grid(
            row=0,
            column=0,
            padx=5,
            pady=5,
            )
            
        return
        
        
    def handlerToplevelTableCreateDestroy(self):
        '''
        Purpose:
            remember location of window for later use; then close
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerToplevelTableCreateDestroy')

# save location for next time window is opened         
        self.createTableTwoMethods_xWindowLocation = \
            self.toplevelTableCreate.winfo_rootx() - self.offsetWindowX
        self.createTableTwoMethods_yWindowLocation = \
            self.toplevelTableCreate.winfo_rooty() - self.offsetWindowY

# destroy current toplevel           
        self.toplevelTableCreate.destroy()
        
        return
        
        
    def handlerFieldNameEditDestroy(self):
        '''
        Purpose:
            destroy 'Edit Field Name' window
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerFieldNameEditDestroy')

# save location for next time window is opened
        self.editFieldName_xWindowLocation = \
            self.toplevelFieldNameEdit.winfo_rootx() - self.offsetWindowX
        self.editFieldName_yWindowLocation = \
            self.toplevelFieldNameEdit.winfo_rooty() - self.offsetWindowY

# destroy current toplevel            
        self.toplevelFieldNameEdit.destroy()
        
        return
        
        
    def handlerClearChangeFieldName(self):
        '''
        Purpose:
            clear the 'Ener new Field name' field in Edit Field Name window
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerClearChangeFieldName')
            
        self.varChangeFieldName.set('')
        
        return
        
        
    def handlerClearDatabaseFieldAdd(self):
        '''
        Purpose:
            clear the 'new field name' field in Add Field window
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerClearDatabaseFieldAdd')
            
        self.varEnterDatabaseFieldAdd.set('')
        
        return
        
        
    def handlerClearTableFunctionsCopy(self):
        '''
        Purpose:
            clear the 'Rename current table' field in Table Functions
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerClearTableFunctionsCopy')
            
        self.varTableFunctionsCopy.set('')
        
        return
        
        
    def handlerClearTableFunctionsRename(self):
        '''
        Purpose:
            clear the 'Rename current table' field in Table Functions
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerClearTableFunctionsRename')
            
        self.varTableFunctionsRename.set('')
        
        return
        
        
    def handlerClearNewTableNameMethod1(self):
        '''
        Purpose:
            clear the 'new table name' widget in "Create Table"
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerClearNewTableNameMethod1')
            
        self.varEnterDatabaseTablesNameAdd.set('')
        
        return
            
            
    def handlerClearNewTableNameMethod2(self):
        '''
        Purpose:
            clear the 'new table name' widget in "Create Table"
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerClearNewTableNameMethod2')
            
        self.varEnterNewTableName.set('')
        
        return
        
        
    def handlerClearSandboxTableName(self):
        '''
        Purpose:
            clear the 'new table name' widget in "Create Table"
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerClearSandboxTableName')
            
        self.varEnterSandboxTableName.set('')
        
        return
        
            
    def handlerGetDatabaseTables(self,selectedDatabase):
        '''
        Purpose:
            Determine tables for an arbitrarily selected database
            
        Called by:
            handlerDatabaseTablesAdd
            
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerGetDatabaseTables')
            
# clear field for tables
#        self.comboboxTablesFromExistingDatabases.setentry('')
        self.comboboxTablesFromExistingDatabases.clear()
# get tables for selected database
#   and generate scrolled list for choosing a table in the next combobox
#   scrolledlist_items=self.myTablesFromExistingDatabases
#        selectedDatabase = self.comboboxDatabaseFromExistingDatabases.get().strip()
        if selectedDatabase == '':
            stringErrorDatabase = (
                'No database has been selected from which to choose\n' +
                'a list of tables.\n\n' +
                'Select a database and try again.'
                )
            print stringErrorDatabase
            self.MySQL_Output(
                0,
                stringErrorDatabase
                )
            showerror(
                'Error: no database',
                stringErrorDatabase
                )
            return
# clear table list
        self.myTablesFromExistingDatabases = []
# get database tables
        self.MySQL_Commands(
            1,
            'self.cursorHandleMySQL.execute("SHOW TABLES FROM ' + selectedDatabase + '")'
            )
        start = time.time()
        self.cursorHandleMySQL.execute("SHOW TABLES FROM " + selectedDatabase)
        tempListOfTables = self.cursorHandleMySQL.fetchall()
        for table in tempListOfTables:
            self.myTablesFromExistingDatabases.append(table[0])  
        self.myTablesFromExistingDatabases.sort()
        
        finish = time.time()
        delta_t = finish - start
        self.MySQL_Commands(
            0,
            '  (Time: %-7.4f secs)' % delta_t
            )

        self.MySQL_Output(
            1,
            '\nTables in database ' + selectedDatabase + ':'
            )

# replot widget for listing tables
        self.comboboxTablesFromExistingDatabases = Pmw.ComboBox(
            self.frame_40_FromExistingDatabases,
            scrolledlist_items=self.myTablesFromExistingDatabases,
            scrolledlist_hscrollmode='static',
            scrolledlist_vscrollmode='static',
            entry_width=30,
            scrolledlist_hull_width=500,
            )
        self.comboboxTablesFromExistingDatabases.grid(
            row=self.myRowFromExistingDatabases,
            column=1,
            padx=5,
            pady=5,
            sticky=W,
            )
        
        return
        
        
    def handlerCreateSandboxTable(self):
        '''
        Purpose:
            create a sandbox table for use with co-pylot
        '''
        
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerCreateSandboxTable')
            
# check if connected to a MySQL server
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return

# define database and table with local names
        myDatabase = self.varDatabaseForNewTable.get().strip()
        myDatabaseTable = self.varEnterSandboxTableName.get().strip()
        
        if DEBUG_SANDBOX:
            print('\nmyDatabase = %s' % myDatabase)
            print('myDatabaseTable = %s' % myDatabaseTable)
        
# check if database name is present
        if myDatabase == '':
            stringNoDatabase = (
                'No database has been selected.\n\n' +
                'Select a database and try again.'
                )
            print(stringNoDatabase)
            self.MySQL_Output(
                0,
                stringNoDatabase
                )
            showerror(
                'Error: no database',
                stringNoDatabase
                )
            return
            
# check if new table name is present
        if myDatabaseTable == '':
            stringNoTable = (
                'No table name has been entered.\n\n' +
                'Enter a table name in the entry field and try again.'
                )
            self.MySQL_Output(
                0,
                stringNoTable
                )
            showerror(
                'Error: no table name',
                stringNoTable
                )
            return

# check if table already exists in database for CREATE SANDBOX TABLE;
#  ... if so, output message and return
        if myDatabaseTable in self.myDatabaseTables:
            self.MySQL_Output(
                1,
                ('Table %s already exists!\n') % myDatabaseTable
                )
            stringTableExists = (
                'The following table already exists!\n\n' +
                '  %s\n\n' +
                'A new table CANNOT be created.\n\n' +
                'To create a new table, enter a unique table\n' + 
                'name in the ENTER NAME FOR "SANDBOX" TABLE entry\n' +
                'field, then click \'Create "sandbox" table\', or delete the\n' +
                'duplicate table from the database and try again.'
                ) % myDatabaseTable
            self.MySQL_Output(
                1,
                stringTableExists
                )
            showerror(
                'Error: table exists',
                stringTableExists
                )
            return
                
# generate the "sandbox" table
# ... here we go
        flagCreate = 0
# TRY METHOD 1 FIRST: COPY (success if flagCreate = 1)
        flagCreate = self.create_sandbox_from_copy(myDatabase,myDatabaseTable)
# TRY METHOD 2 IF METHOD 1 DOES NOT WORK (success if flagCreate = 2)
        if not flagCreate:
            flagCreate = self.create_sandbox_from_scratch(myDatabase,myDatabaseTable)
# if both Method 1 and Method 2 fail, then we cannot create table 'sandbox';
#    either method will pop-up success widget, but show failure widget here 
        print('flagCreate = %s' % flagCreate)
            
        if flagCreate == 0:
            stringCreateFailed = (
                'Failed to create table "%s" either\n' + 
                'by copying or creation from scratch.\n\n'
                ) % myDatabaseTable
            print('\n' + stringCreateFailed)
            self.MySQL_Output(
                0,
                stringCreateFailed
                )
            try:
                showinfo(
                    'Info: cannot create sandbox table',
                    stringCreateFailed,
                    parent=self.toplevelTableCreate
                    )
            except:
                showinfo(
                    'Info: cannot create sandbox table',
                    stringCreateFailed
                    )
            return


# renew list of tables in combobox in main window
# ... get selected table name
        currentTableName = self.comboboxDbTableSelect.get().strip()
# ... get new tables list (calls refreshTables)
        self.mysql_GetDatabaseTables()
# ... regrid Tables combobox
        self.mysql_ComboDatabaseTables()
        
# clear list of fields in combobox in main windows
# ... regrid Fields combobox 
# ... (needs both database and table specified in comboboxes)
        if currentTableName:
# ...   re-list the fields
#            self.refreshFields()
            self.comboboxDbTableSelect.setentry(
                currentTableName
                )      
        
        return
        
        
    def handlerCreateNewTableFromExistingTable(self):
        '''
        Purpose:
            create a new table using an existing table's data structure
        '''
        
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerCreateNewTableFromExistingTable')
            
        currentDatabase = self.varDatabaseForNewTable.get().strip()
        existingDatabase = self.comboboxDatabaseFromExistingDatabases.get().strip()
        existingTable = self.comboboxTablesFromExistingDatabases.get().strip()
        newTable = self.varEnterNewTableName.get().strip()
# error checks        
        if (
        currentDatabase == ''
        or
        existingDatabase == ''
        or
        existingTable == ''
        or
        newTable == ''
        ):
            stringError = (
                'The following values are missing:\n\n'
                )
            if currentDatabase == '':
                stringError += ' - current database name\n\n'
            if existingDatabase == '':
                stringError += ' - existing database name\n\n'
            if existingTable == '':
                stringError += ' - table chosen from existing database\n\n'
            if newTable == '':
                stringError += ' - name for NEW table\n\n'
            stringError += (
                'Enter proper values and try again.'
                )
            print stringError
            self.MySQL_Output(
                0,
                stringError
                )
            showerror(   
                'Error: invalid values',
                stringError
                )
            return
            
# make sure new table name does not conflict with other tables in this database
#   for CREATE TABLE FROM EXISTING TABLE
        if newTable in self.myDatabaseTables:
            self.MySQL_Output(
                1,
                ('Table %s already exists!\n') % newTable
                )
            stringTableExists = (
                'The following table already exists!\n\n' +
                '  %s\n\n' +
                'A new table CANNOT be created.\n\n' +
                'To create a new table, enter a unique table\n' + 
                'name in the ENTER NAME FOR NEW TABLE entry field,\n' +
                'then click \'Create new table\', or delete the\n' +
                'duplicate table from the database and try again.'
                ) % newTable
            showerror(
                'Error: table exists',
                stringTableExists
                )
            return

# if we get this far, input ok

# form MySQL command; time it
        self.MySQL_Commands(
            1,
            'self.cursorHandleMySQL.execute("CREATE TABLE ' +
                currentDatabase + '.' + newTable + ' LIKE ' + existingDatabase + '.' + 
                existingTable + '")'
            )
        try:
            start = time.time()
            self.cursorHandleMySQL.execute(
                "CREATE TABLE " + currentDatabase + "." + newTable +
                " LIKE " + existingDatabase + "." + existingTable
                )
            finish = time.time()
            delta_t = finish - start
            self.MySQL_Commands(
                0,
                '  (Time: %-7.4f secs)' % delta_t
                )
        except:
            stringNoCreate = (
                'Unable to create table using name\n\n' +
                '   %s\n\n' +
                'It is possible the name contains special characters\n' +
                'that are not allowed (e.g., underscores are ok, dashes are not),\n' +
                'or that the name is reserved for system tables.\n\n' +
                'Enter a different name and try again.'
                )
            print(stringNoCreate)
            self.MySQL_Output(
                0,
                stringNoCreate
                )
            showerror(
                'Error: unable to create table',
                stringNoCreate
                )
            return
            
# clear fields
        self.clearDbFields()            
# refresh 'Databases' and 'Tables in Database' in main MySQL ACCESS window; clear 'Fields in Table'
# get new tables list
        self.refreshTables()
#        self.mysql_GetDatabaseTables()
# regrid Tables combobox
        self.mysql_ComboDatabaseTables()
        self.comboboxDbTableSelect.selectitem(newTable)
        self.refreshFields()
        self.varEnterNewTableName.set('')
        
        return
           
           
    def handlerTableFunctionsCopy(self):
        '''
        Purpose:
            copy a table in the current database to either
                1. the same database with a new table name for the table (otherwise, a conflict is noted)
                2. a new database with either the same table name or a new table name
        '''
        
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerTableFunctionsCopy')
            
# get current database and table
        currentDatabase = self.varTableFunctionsSelectDatabase.get().strip()
        currentTable = self.varEntryTableFunctionsSelectTable.get().strip()
# get new database name in which to store the table
        newDatabase = self.comboboxDatabaseNameCopy.get().strip()    
# get new name for table
        newTable = self.varTableFunctionsCopy.get().strip()
# define table list
        myTablesFromNewDatabase = []

# get list of new database's tables, to make sure new table does not conflict with any existing tables
        try:
            self.cursorHandleMySQL.execute("SHOW TABLES FROM " + newDatabase)
            tempTables = self.cursorHandleMySQL.fetchall()
            for table in tempTables:
                myTablesFromNewDatabase.append(table[0]) 
            myTablesFromNewDatabase.sort()
        except:
            stringErrorShowTables = (
                'Unable to retrieve tables from database\n\n' + 
                '%s\n\n' +
                'Check output windows for error messages.'
                ) % newDatabase
            self.MySQL_Output(  
                1,
                stringErrorShowTables
                )
            showerror(
                'Error: cannot retrieve table',
                stringErrorShowTables
                )
            return

        print '\nmyTablesFromNewDatabase (list) ='
        print myTablesFromNewDatabase    
        print 'newDatabase ='
        print newDatabase
        print 'newTable ='
        print newTable
                    
            
#        print('\nmyTablesFromNewDatabase = ')
#        print myTablesFromNewDatabase

# error checks        
        if (
        currentDatabase == ''
        or
        currentTable == ''
        or
        newDatabase == ''
        or
        newTable == ''
        ):
            stringError = (
                'The following values are missing:\n\n'
                )
            if currentDatabase == '':
                stringError += ' - current database name\n\n'
            if currentTable == '':
                stringError += ' - current table name\n\n'
            if newDatabase == '':
                stringError += ' - new database name\n\n'
            if newTable == '':
                stringError += ' - new table name\n\n'
            stringError += (
                'Enter proper values and try again.'
                )
            print stringError
            self.MySQL_Output(
                0,
                stringError
                )
            showerror(   
                'Error: invalid values',
                stringError
                )
            return
# check for duplicate names for both databases and tables
        if currentDatabase == newDatabase and currentTable == newTable:
            stringDuplicates = (
                'The names for the database and table are\n' +
                'identical to the current database and\n' +
                'current table.\n\n' +
                'At least the table names must be different.\n\n' +
                'Enter different names and try again.'
                )
            print stringDuplicates
            self.MySQL_Output(
                0,
                stringDuplicates
                )
            showerror(
                'Error: Duplicate names',
                stringDuplicates
                )
            return
# make sure new table name does not conflict with other tables in this database
#        for table in self.myDatabaseTables:
        for table in myTablesFromNewDatabase:
            print 'newTable, table =',newTable,table
            if table == newTable:
                stringErrorTableName = (
                    'Name for the new table\n\n' +
                    '%s\n\n' +
                    'conflicts with an existing table name\n\n' +
                    'in the target database\n\n' +
                    '%s\n\n' +
                    'Choose another name for the table or another\n\n' +
                    'database name and try again.'
                    ) % (newTable, newDatabase)
                print stringErrorTableName
                self.MySQL_Output(
                    0,
                    stringErrorTableName
                    )
                showerror(
                    'Error: table name conflict',
                    stringErrorTableName
                    )
                return
# check if new table name has more than one word
        if len(newTable.split()) > 1:
            stringErrorBadTableName = (
                'The new table name has spaces and therefore\n' +
                'is in the wrong format.\n\n' +
                'Enter new table name with no spaces and\n' +
                'no special characters (use underscore instead\n'+
                'of spaces, for example) and try again.'
                )
            self.MySQL_Output(
                1,
                stringErrorBadTableName
                )
            showerror(
                'Error: bad table name',
                stringErrorBadTableName
                )
            return

# if we get this far, input ok

# form MySQL command; time it
        self.MySQL_Commands(
            1,
            'Two commands:\n' +
            ' 1. self.cursorHandleMySQL.execute("CREATE TABLE ' +
                newDatabase + '.' + newTable + ' LIKE ' + 
                currentDatabase + '.' + currentTable + '")' + '\n' +
#                currentDatabase + '.' + newTable + ' LIKE ' + currentDatabase + '.' + 
#                currentTable + '")' + '\n' +
            ' 2. self.cursorHandleMySQL.execute("INSERT INTO ' +
                newDatabase + '.' + newTable + ' SELECT * FROM ' +
                currentDatabase + '.' + currentTable
            )
        start = time.time()
        self.cursorHandleMySQL.execute(
            "CREATE TABLE " + newDatabase + "." + newTable +
            " LIKE " + currentDatabase + "." + currentTable
            )
        self.cursorHandleMySQL.execute(
            "INSERT INTO " + newDatabase + "." + newTable + " SELECT * FROM " +
            currentDatabase + "." + currentTable
            )
        finish = time.time()
        delta_t = finish - start
        self.MySQL_Commands(
            0,
            '  (Time: %-7.4f secs)' % delta_t
            )
           
        myTableName = self.varEntryTableFunctionsSelectTable.get().strip()
# clear fields
        self.clearDbFields()            
# refresh 'Databases' and 'Tables in Database' in main MySQL ACCESS window; clear 'Fields in Table'
# get new tables list
        self.refreshTables()
#        self.mysql_GetDatabaseTables()
# regrid Tables combobox
        self.mysql_ComboDatabaseTables()
        self.comboboxDbTableSelect.selectitem(myTableName)
        self.refreshFields()
        self.varEntryTableFunctionsSelectTable.set(myTableName)
        self.handlerDatabaseTableFunctions()
        self.varTableFunctionsCopy.set('')
# keep the target database the same
        try:
            self.comboboxDatabaseNameCopy.selectitem(newDatabase)
        except:
            pass
# flush privileges; otherwise, will get error like
#   "can't run this command yet"
        stringFlushPrivileges = (
            'FLUSH PRIVILEGES'
            )
        self.cursorHandleMySQL.execute(stringFlushPrivileges)
        
# destroy 'TABLE FUNCTIONS' window
#        self.toplevelTableCreate.destroy()

        return       
        
            
    def handlerDatabaseFunctions(self):
        '''
        Rename database
        
        inputs:
            self.cursorHandleMySQL
            self.comboboxDbSelect.get()
            self.myDatabases()
            
        outputs:
           
       
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerDatabaseFunctions')

# check if connected to a MySQL server
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return
        
# make sure a database has been selected
        myDatabase = self.comboboxDbSelect.get()
        '''
        if not myDatabase:
            stringNoDatabase = 'Please select a database.'
            print '\n' + stringNoDatabase
            self.MySQL_Output(
                0,
                stringNoDatabase
                )
            showerror(
                'Error: no database selected',
                '\n' + stringNoDatabase + '\n\n'
                )
            return
        '''
# TOPLEVELS            
# ... destroy any old toplevel frames
        self.destroyAllDatabaseTableFieldFrames()
                    
# ... open Toplevel frame for entering database name
        self.toplevelDatabaseRename = Toplevel(
            self.frameParent,
            bg='tan'
            )
        self.toplevelDatabaseRename.title(
            'DATABASES'
            )
# ... keep it on top of the parent window
        self.toplevelDatabaseRename.transient(self.frameParent)
# ... place the top window
#        x_Windows = self.renameDatabase_xWindowLocation
#        y_Windows = self.renameDatabase_yWindowLocation
        x_Windows = self.frameParent.winfo_rootx() + 5
        y_Windows = self.frameParent.winfo_rooty() + 200
        
        self.toplevelDatabaseRename.geometry(
            '+%d+%d' % (x_Windows, y_Windows)
            )
            
# FRAMES
# ... Title            
        frame_00 = Frame(
            self.toplevelDatabaseRename,
            bg='tan',
            )
        frame_00.grid(
            row=0,
            column=0,
            padx=0,
            pady=5,
            )
# ... Name that database            
        frame_10 = Frame(
            self.toplevelDatabaseRename,
            bg='tan',
            )
        frame_10.grid(
            row=1,
            column=0,
            padx=0,
            pady=5,
            )
        '''
        frame_10_00 = Frame(
            frame_10,
            bg='tan',
            )
        frame_10_00.grid(
            row=0,
            column=0,
            padx=0,
            pady=5,
            )
        frame_10_10 = Frame(
            frame_10,
            bg='tan',
            )
        frame_10_10.grid(
            row=0,
            column=0,
            padx=0,
            pady=5,
            )
        '''
# ... Cancel    
        frame_99 = Frame(
            self.toplevelDatabaseRename,
            bg='tan',
            )
        frame_99.grid(
            row=99,
            column=0,
            padx=0,
            pady=5,
            )

# WIDGETS            
        labelDatabaseRename = Label(
            frame_00,
            text='RENAME DATABASE',
            bg='tan',
            justify=CENTER,
            font=self.labelFontMediumBold,
            )
        labelDatabaseRename.grid(
            row=0,
            column=0,
            padx=5,
            pady=10,
            )
            
        
# ... label for database name            
        labelDatabaseName = Label(
            frame_10,
            text='Selected database: ',
            bg='tan',
            justify=RIGHT,
            )
        labelDatabaseName.grid(
            row=0,
            column=0,
            padx=5,
            pady=5,
            sticky=E,
            )
            
        '''
# combobox for database name             
        self.comboboxDatabaseNameCurrent = Pmw.ComboBox(
            frame_10,
            scrolledlist_items=self.myDatabases,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            entry_width=30,
            scrolledlist_hull_width=500,
            )
        self.comboboxDatabaseNameCurrent.grid(
            row=0,
            column=1,
            sticky=W,
            padx=5,
            pady=5,
            )
# ... affix scrollbars
        self.comboboxDbTableSelect.configure(scrolledlist_hscrollmode = 'static')
        self.comboboxDbTableSelect.configure(scrolledlist_vscrollmode = 'static')
        if myDatabase:
            self.comboboxDatabaseNameCurrent.selectitem(myDatabase)
        else:
            self.comboboxDatabaseNameCurrent.setentry('')
        '''
# disable entry so user can't change field value
#        self.entryDatabaseRenameFrom.configure(state='disabled')
# set value to be same as selected database
        '''
        if self.comboboxDbSelect.get():
            self.varDatabaseNameCurrent.set(
                self.comboboxDbSelect.get().strip()
                )
        else:
            self.varDatabseRenameFrom.set('')
        '''
        
# entry field for database name
        self.varDatabaseNameCurrent = StringVar()
        self.varDatabaseNameCurrent.set(myDatabase)
        self.entryDatabaseNameCurrent = Entry(
            frame_10,
            textvariable=self.varDatabaseNameCurrent,
            width=30,
            disabledforeground='black',
            disabledbackground='white',
            state='disabled'
            )
        self.entryDatabaseNameCurrent.grid(
            row=0,
            column=1,
            padx=5,
            pady=5,
            sticky=W,
            )
            
        labelDatabaseRenameTo = Label(
            frame_10,
            text='Rename database to: ',
            bg='tan',
            justify=RIGHT,
            )
        labelDatabaseRenameTo.grid(
            row=1,
            column=0,
            padx=5,
            pady=5,
            sticky=E,
            )
            
# ... entry field for new database name
        self.varDatabaseRenameTo = StringVar()
        self.varDatabaseRenameTo.set('')
        self.entryDatabaseRenameTo = Entry(
            frame_10,
            textvariable=self.varDatabaseRenameTo,
            width=30,
            )
        self.entryDatabaseRenameTo.grid(
            row=1,
            column=1,
            padx=5,
            pady=5,
            sticky=W,
            )
        self.entryDatabaseRenameTo.bind(
            "<KeyPress-Return>",
            self.handlerBindDatabaseRenameTo,
            )
            
# database Rename button
        self.buttonDatabaseRenameTo = Button(
            frame_10,
            text='Rename',
            borderwidth=3,
            background='white',
            foreground='blue',
            font=self.buttonFontSmall,
            relief=RAISED,
            justify=CENTER,
            width=10,
            command=self.handlerDatabaseRename,
            )
        self.buttonDatabaseRenameTo.grid(
            row=2,
            column=1,
            padx=0,
            pady=0,
#            sticky=N,
            )
        '''   
# database delete
        labelDatabaseDelete = Label(
            frame_30,
            text='Delete database: ',
            bg='tan',
            justify=RIGHT,
            )
        labelDatabaseDelete.grid(
            row=0,
            column=0,
            padx=5,
            pady=5,
            sticky=E,
            )
            
# ... entry field for database delete
        self.varDatabaseDelete = StringVar()
        self.varDatabaseDelete.set('')
        self.entryDatabaseDelete = Entry(
            frame_30,
            textvariable=self.varDatabaseDelete,
            width=20,
            )
        self.entryDatabaseDelete.grid(
            row=0,
            column=1,
            sticky=W,
            padx=0,
            pady=5,
            )
            
# ... button for database delete
        self.buttonDatabaseDelete = Button(
            frame_30,
            text='Delete database',
            borderwidth=5,
            font=self.buttonFontSmall,
            relief=RAISED,
            justify=CENTER,
            width=20,
            command=self.handlerDatabaseDelete,
            )
        self.buttonDatabaseDelete.grid(
            row=0,
            column=0,
            padx=0,
            pady=5
            ) 
        '''            
            
# database Cancel button
        self.buttonCancelDatabaseFunctions = Button(
            frame_99,
            text='Cancel',
            font=self.buttonFontSmall,
            borderwidth=5,
            relief=RAISED,
            justify=CENTER,
            width=20,
            command=self.handlerToplevelDatabaseRenameDestroy,
            )
        self.buttonCancelDatabaseFunctions.grid(
            row=0,
            column=0,
            padx=5,
            pady=10,
            ) 
        
        return
        
        
    def handlerToplevelDatabaseRenameDestroy(self):
        '''
        Purpose:
            destroy 'Edit Field Name' window
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerToplevelDatabaseRenameDestroy')

# save location for next time window is opened
        self.renameDatabase_xWindowLocation = \
            self.toplevelDatabaseRename.winfo_rootx() - self.offsetWindowX
        self.renameDatabase_yWindowLocation = \
            self.toplevelDatabaseRename.winfo_rooty() - self.offsetWindowY

# destroy current toplevel            
        self.toplevelDatabaseRename.destroy()
        
        return
        

    def handlerDatabaseRename(self):
        '''
        Purpose:
            rename a database
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerDatabaseRename')

# check if connected to a MySQL server
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return

# get the new name from the entry field
#        myDatabaseRenameFrom = self.comboboxDatabaseNameCurrent.get().strip()
        myDatabaseRenameFrom = self.varDatabaseNameCurrent.get().strip()
        myDatabaseRenameTo = self.varDatabaseRenameTo.get().strip()
# check for a blank name
        if(
            myDatabaseRenameFrom == '' or
            myDatabaseRenameTo == ''
            ):
            if myDatabaseRenameFrom == '':
                self.MySQL_Output(
                    1,
                    'Rename Database "from" field is blank\n' +
                    'Please select a current database name.'
                    )
                showerror(
                    'Error: invalid field name',
                    '\nRename Database "from" field is blank.\n\n' +
                    'Please select a current database name.\n\n'
                    )
            if myDatabaseRenameTo == '':
                self.MySQL_Output(
                    1,
                    'Rename Database "to" field is blank.\n\n' +
                    'Please enter a new database name.'
                    )
                showerror(
                    'Error: invalid field name',
                    '\nRename Database "to" field is blank.\n\n' +
                    'Please enter a new database name.\n'
                    )
                return
# check for duplicate name
        if myDatabaseRenameFrom == myDatabaseRenameTo:
            stringErrorDuplicateDatabaseNames = (
                'The name you entered is identical to the\n' +
                'current database.\n\n' +
                'Please enter a unique name in the "to:" field\n' +
                'and try again.'
                )
            self.MySQL_Output(
                1,
                stringErrorDuplicateDatabaseNames
                )
            showerror(
                'Error: duplicate name',
                stringErrorDuplicateDatabaseNames
                )
            return
# check if new name already exists in list of databases
        for database in self.myDatabases:
            if myDatabaseRenameTo == database:
                stringErrorUsedDatabaseName = (
                    'The name you entered is in use by an\n' +
                    'existing database.\n\n' +
                    'Enter a unique name in the "to:" field\n' +
                    'and try again.'
                    )
                self.MySQL_Output(
                    1,
                    stringErrorUsedDatabaseName
                    )
                showerror(
                    'Error: name in use',
                    stringErrorUsedDatabaseName
                    )
                return
                                
# check if database name is still valid
       
        for database in self.myDatabases:
            if database == myDatabaseRenameFrom:
# database name is valid
                self.MySQL_Output(
                    1,
                    'Database ' + myDatabaseRenameFrom + ' is listed in databases.'
                    )
                self.MySQL_Output(
                    1,
                    'Renaming database\n' + 
                    myDatabaseRenameFrom + '\n\n' +
                    'to' + '\n\n' +
                    myDatabaseRenameTo + '\n'
                    )
                
                ans = askokcancel(
                    'Rename database...',
                    '\nYou are about to rename database\n\n' +
                    myDatabaseRenameFrom + '\n\n' +
                    'to' + '\n\n' +
                    myDatabaseRenameTo + '\n\n' + 
                    'Click on OK to continue, or CANCEL to stop this process\n\n'
                    )
                
                if ans:
# assemble string to rename database
# newer MySQL 5.1 command
                    stringRenameDatabase = (
                        'RENAME DATABASE ' + myDatabaseRenameFrom + ' to ' +
                        myDatabaseRenameTo
                        )
                        
                    self.MySQL_Output(
                        0,
                        'String to rename database:\n' + stringRenameDatabase
                        )
                        
                    self.MySQL_Commands(
                        1,
                        'self.cursorHandleMySQL.execute("' + stringRenameDatabase + '")'
                        )
# execute
                    try:
                        self.cursorHandleMySQL.execute(stringRenameDatabase)
                    except:
                        stringErrorCannotRename = (
                            'Sorry, database cannot be renamed since the current MySQL\n' +
                            'version does not allow the option "RENAME".\n\n' +
                            'However, PylotDB allows a workaround, as follows.\n\n' +
                            'From the "Backup & Restore Databases and Tables" window,\n' +
                            'select "Current database, all tables", then click on \n' +
                            '"Browse for local directory" to choose an existing directory\n' +
                            'in which to store the file.\n\n' +
                            'Next, enter a filename and then the password for the current\n' +
                            'database server and click on "Backup" to create the backup file.\n\n' +
                            'The backup file just created is an editable text file. Edit this file to\n' +
                            'change the name of the database in three lines, all near the top of\n' +
                            'the file. The database name is typically found in the comment line\n' +
                            'beginning with "-- Current Database:", in the line beginning with\n' +
                            '"CREATE", and in another beginning with "USE".\n\n' +
                            'The next step is to use the "Restore" function in the same\n' + 
                            '"Backup & Restore Databases and Tables" window to restore the\n' +
                            'backup file. First, "Browse" for the backup file. Next, enter the\n' +
                            'database server password. Finally, click on "Restore", and the\n' +
                            'backup file will now restore with the new database name.\n\n' +
                            'BE SURE TO READ ANY WARNINGS TO MAKE SURE YOU ARE NOT\n' +
                            'OVERWRITING ANY DATABASES AND/OR TABLES ACCIDENTALLY!\n\n' +
                            'The old database can then be deleted or allowed to remain in place.'
                            )
                        self.MySQL_Output(
                            1,
                            stringErrorCannotRename
                            )
                        showerror(
                            'Error: cannot rename database',
                            stringErrorCannotRename
                            )
                    break
                    
                else:
# cancel rename 
                    self.MySQL_Output(
                        1,
                        'CANCELED: database rename.\n'
                        )
                    break
                    
# get the selected database, if any
                if self.comboboxDbSelect.get():
                    tempSaveDatabase = self.comboboxDbSelect.get()
        
# get new database list
                self.mysql_GetDatabases()  
# regrid the database window, to show the change
                self.mysql_ComboDatabases()
# redisplay the old database if it was displayed initially
                if tempSaveDatabase == myDatabaseRenameFrom:
                    self.comboboxDbSelect.selectitem(myDatabaseRenameTo)
# or else just display what was in the database 'select' box initially
                else:
                    self.comboboxDbSelect.selectitem(tempSaveDatabase)
# if 'Backup and Restore' window exists, refresh current                   
                try:
                    mapped = self.toplevelBackupRestore.winfo_exists()
                except:
                    mapped = False
                if mapped:
#                    self.buttonBackupRestoreDatabasesFields.invoke()
                    self.handlerBackupRestoreDatabasesTables()    # Backup/Restore handler
                    '''
                    self.varBackupRestoreSelectTable.set(
                        self.comboboxDbTableSelect.get().strip()
                        )
                    '''
                break
                
        return

            
    def handlerDefineFieldsForNewTable(self):
        '''
        Purpose:
        widgets for defining fields for a new table
        
        Called by:
        handlerDatabaseTablesAdd
        
        Inputs:
            self.entryfieldFieldsForNewTable # number of fields to enter
        
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerDefineFieldsForNewTable')

# check if database name is present
        if self.varDatabaseForNewTable.get().strip() == '':
            stringNoDatabase = (
                'No database has been selected.\n\n' +
                'Select a database and try again.'
                )
            print(stringNoDatabase)
            self.MySQL_Output(
                0,
                stringNoDatabase
                )
            showerror(
                'Error: no database',
                stringNoDatabase
                )
            return
            
# check if new table name is present
        if self.varEnterDatabaseTablesNameAdd.get().strip() == '':
            stringNoTable = (
                'No table has been selected.\n\n' +
                'Select a table and try again.'
                )
            self.MySQL_Output(
                0,
                stringNoTable
                )
            showerror(
                'Error: no table name',
                stringNoTable
                )
            return
            
# set background color
        colorbg = 'lightblue'
        
# get current database and table
        try:
            myDatabaseTable = self.varEnterDatabaseTablesNameAdd.get().strip() # from Create Table -- 3 Methods
            myDatabase = self.varDatabaseForNewTable.get().strip()
        except:
            try:
                myDatabaseTable = self.varTableNameForCreateTable.get().strip()    # from window created here ...
                myDatabase = self.comboboxDatabaseNameForCreateTable.get().strip()  # assumes window already exists
            except:
                stringNoTableOrDatabase = (
                    'A table name and/or database has not been specified.\n\n' +
                    'Specify both a database and a table name and try again.'
                    )
                print(stringNoTableOrDatabase)
                self.MySQL_Output(
                    0,
                    stringNoTableOrDatabase
                    )
                try:
                    showerror(
                        'Error: missing entries',
                        stringNoTableOrDatabase,
                        parent=self.toplevelDefineFieldsForNewTable,
                        )
                except:
                    try:
                        showerror(
                            'Error: missing entries',
                            stringNoTableOrDatabase,
                            parent=self.toplevelTableCreate,
                            )
                    except:
                        showerror(
                            'Error: missing entries',
                            stringNoTableOrDatabase
                            )
            return
         
# check if table already exists for CREATE TABLE FROM SCRATCH
        if myDatabaseTable in self.myDatabaseTables:
            self.MySQL_Output(
                1,
                ('Table %s already exists!\n') % myDatabaseTable
                )
            stringTableExists = (
                'The following table already exists!\n\n' +
                '  %s\n\n' +
                'A new table CANNOT be created.\n\n' +
                'To create a new table, enter a unique table\n' + 
                'name in the ENTER NAME FOR NEW TABLE entry\n' +
                'field, then click \'Define fields ...\', or delete the\n' +
                'duplicate table from the database and try again.'
                ) % myDatabaseTable
            showerror(
                'Error: table exists',
                stringTableExists
                )
            return
        
# CONSTANTS
# number of fields required
        self.numFields = int(self.entryfieldFieldsForNewTable.getvalue())
        self.MySQL_Output(
            1,
            'Number of fields to enter: ' + str(self.numFields)
            )
        
# FRAMES
# destroy any old toplevel frames
        try:
            mapped = self.toplevelDefineFieldsForNewTable.winfo_exists()
        except:
            mapped = False
            
        if mapped:
            stringAskToDestroy = (
                'A window for creating a table is already displayed.\n\n' +
                'If you wish to close this window (all entries will be lost)\n' +
                'and start a new one, click "OK".\n\n' +
                'To keep the existing window, click "Cancel".'
                )
            yes = askokcancel(
                    'Window open: Define Fields',
                    stringAskToDestroy
                    )
            if yes:
                self.toplevelDefineFieldsForNewTable.destroy()
                self.MySQL_Output(
                    1,
                    'Previous toplevel widget removed from screen.'
                    )
            else:
                return
        else: 
            pass
            '''
            self.MySQL_Output(
                1,
                'No previous toplevel widget to remove from screen.'
                )
            '''
            
# open Toplevel frame for entering database name
        self.toplevelDefineFieldsForNewTable = Toplevel(
#            self.frameParent,
            bg=colorbg
            )
        self.toplevelDefineFieldsForNewTable.title(
#            'Add table & fields...'
            'Server: ' + self.comboServerMySQL.get() + '     ' +
            'Database: ' + self.varDatabaseForNewTable.get() + '     ' +
            'Table: ' + self.varEnterDatabaseTablesNameAdd.get().strip()
            )
        self.toplevelDefineFieldsForNewTable.transient(self.frameParent)
# place the top window
        x_Windows = self.createTableFromScratch_xWindowLocation
        y_Windows = self.createTableFromScratch_yWindowLocation
        
        self.toplevelDefineFieldsForNewTable.geometry(
            '+%d+%d' % (x_Windows, y_Windows)
            )

        frameTitle = Frame(
            self.toplevelDefineFieldsForNewTable,
            bg=colorbg,
            )
        frameTitle.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            sticky=N,
            )
# ... title
        label = Label(
            frameTitle,
            text='CREATE TABLE FROM SCRATCH',
            font=self.titleFont,
            bg=colorbg,
            )
        label.grid(
            row=0,
            column=0,
            columnspan=5,
            padx=5,
            pady=10,
            )
# ... table
        label = Label(
            frameTitle,
            text='Creating table ',
            bg=colorbg,
            )
        label.grid(
            row=1,
            column=0,
            padx=0,
            pady=2,
            sticky=E,
            )
        self.varTableNameForCreateTable = StringVar()
        self.varTableNameForCreateTable.set(myDatabaseTable)
        self.entryTableNameForCreateTable = Entry(
            frameTitle,
            textvariable=self.varTableNameForCreateTable,
            bg='white',
            fg='black',
            state='normal',
            width=25,
            disabledforeground='black',
            disabledbackground='white',
            )
        self.entryTableNameForCreateTable.grid(
            row=1,
            column=1,
            padx=0,
            pady=2,
            sticky=W,
            )       
# ... database 
        label = Label(
            frameTitle,
            text='  in database ',
            bg=colorbg,
            )
        label.grid(
            row=1,
            column=2,
            padx=0,
            pady=2,
            sticky=E,
            )
        '''    
        self.varDatabaseNameForCreateTable = StringVar()
        self.varDatabaseNameForCreateTable.set(myDatabase)
        self.entryDatabaseNameForCreateTable = Entry(
            frameTitle,
            textvariable=self.varDatabaseNameForCreateTable,
            bg='white',
            fg='black',
            state='disable',
            disabledforeground='black',
            disabledbackground='white',
            )
        self.entryDatabaseNameForCreateTable.grid(
            row=1,
            column=3,
            padx=0,
            pady=2,
            sticky=W,
            )  
        '''
        self.comboboxDatabaseNameForCreateTable = Pmw.ComboBox(
            frameTitle,
            entry_width=25,
            scrolledlist_items=self.myDatabases,
            scrolledlist_hull_width=500,
            scrolledlist_hscrollmode='static',
            scrolledlist_vscrollmode='static',
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            )
        self.comboboxDatabaseNameForCreateTable.grid(
            row=1,
            column=3,
            padx=0,
            pady=2,
            sticky=W,
            )
#        self.comboboxDatabaseNameForCreateTable.configure(scrolledlist_hscrollmode = 'static')
#        self.comboboxDatabaseNameForCreateTable.configure(scrolledlist_vscrollmode = 'static')
        self.comboboxDatabaseNameForCreateTable.selectitem(myDatabase)   

# ... numFields
        label = Label(
            frameTitle,
            text='  number of fields ',
            bg=colorbg,
            )
        label.grid(
            row=1,
            column=4,
            padx=0,
            pady=2,
            sticky=W,
            )
        self.varNumFieldsForCreateTable = IntVar()
        self.varNumFieldsForCreateTable.set(
            self.entryfieldFieldsForNewTable.get()
            )
        self.entryNumFieldsForCreateTable = Entry(
            frameTitle,
            textvariable=self.varNumFieldsForCreateTable,
            bg='white',
            fg='black',
            state='disable',
            width=5,
            disabledforeground='black',
            disabledbackground='white',
            )
        self.entryNumFieldsForCreateTable.grid(
            row=1,
            column=5,
            padx=0,
            pady=2,
            sticky=W,
            )   
# header            
        frameTitles = Pmw.ScrolledFrame(
            self.toplevelDefineFieldsForNewTable,
            usehullsize=1,
            hull_width=900,
            hull_height=110,
            hscrollmode='none',
            vscrollmode='static',
            horizflex='expand',
            vertflex='expand',
            )
        frameTitles.grid(
            row=1,
            column=0,
            padx=5,
            pady=0,
            )
          
# Use scrolled frame for list of fields
        frameListOfFieldsScrolled = Pmw.ScrolledFrame(
            self.toplevelDefineFieldsForNewTable,
            usehullsize=1,
            hull_width=900,
            hull_height=300,
            hscrollmode='none',
            vscrollmode='static',
            horizflex='expand',
            vertflex='expand',
            )
        frameListOfFieldsScrolled.grid(
            row=2,
            column=0,
            padx=5,
            pady=5,
            )
        Pmw.Color.changecolor(
            self.toplevelDefineFieldsForNewTable, 
            background=colorbg
            ) 
       
# inside scrolled frame  

        frame_00_Scrolled = Frame(
            frameListOfFieldsScrolled.interior(),
            bg=colorbg,
#            borderwidth=5,
#            relief=GROOVE,
            )
        frame_00_Scrolled.grid(
            row=0,
            column=0,
            pady=5,
            sticky=N+E+W+S
            )
# put contents at top
        frameListOfFieldsScrolled.interior().grid_rowconfigure(1,weight=1)
#        frameListOfFieldsScrolled.interior().grid_columnconfigure(1,weight=0)
            
# for toplevel subframes
        frame_10 = Frame(
            self.toplevelDefineFieldsForNewTable,
            bg=colorbg,
            )
        frame_10.grid(
            row=3,
            column=0,
            )
            
# WIDGETS
            
# header
#        fieldHeader = []
        dict_FieldHeader = {
            'No.' : ['']*self.numFields,
            'Name' : ['']*self.numFields,
            'Datatype' : ['']*self.numFields,
            'Length' : ['']*self.numFields,
            'Options' : ['']*self.numFields,
            'Default Value' : ['']*self.numFields,
            'Keys' : ['']*self.numFields
            }
            
        self.MySQL_Output(
            1,
            'dict_FieldHeader names:'
            )
        self.MySQL_Output(
            0,
            dict_FieldHeader
            )
            
# iterate to show header labels; no need to save label names
#  check for key in dictionary since key:values are not stored as entered
        padxTitle = 3
        padxField = 5
        for key in dict_FieldHeader:
            if key == 'No.':
                column=0
                columnWidth=3
            elif key == 'Name':
                column=1
                columnWidth=15
            elif key == 'Datatype':
                column=2
                columnWidth=20 #*
            elif key == 'Length':
                column=3
                columnWidth=15
            elif key == 'Options':
                column=4
                columnWidth=15
            elif key == 'Default Value':
                column=5
                columnWidth=25 #*
            elif key == 'Keys':
                column=6
                columnWidth=15
            else:
                self.MySQL_Output(
                    1,
                    'ERROR: column heading is incorrectly handled.'
                    )
                self.MySQL_Output(
                    1,
                    '   Header key = ' + key
                    )
                showerror(
                    'Error: header key',
                    '\nHeader key ' + key + 'is not correctly handled in\n' +
                    MODULE + '/' + 'handlerDefineFieldsForNewTable\n\n' +
                    'Unable to complete table construction.\n'
                    )
                toplevelDefineFieldsForNewTable.destroy()
                return
# designate required variables
            if key == 'No.':
                keyTitle = '\n\n' + key
            elif key == 'Name':
                keyTitle = key + '\n(Required,\nno spaces)'
            elif key == 'Datatype':
                keyTitle = '\n' + key + '\n' + '(Required)'
            elif key == 'Length':
                keyTitle = key + '\n' + '(No parens;\n' + 'grayed if not\n' + 'applicable)'
            elif key == 'Options':
                keyTitle = '\n' + key + '\n(usually left blank)'
            elif key == 'Default Value':
                keyTitle = 'Default\nValue\n(usually left blank)'
            elif key == 'Keys':
                keyTitle = 'Non-Primary\nSearch Key(s)\n(usually left blank)\n(optional)'
            else:
                print('\nError: no match for keyTitle in ' + MODULE)
                showerror(
                    'Error: no match for keyTitle',
                    '\n "keyTitle" has no match in' + '\n\n' +
                    MODULE + '\n\n' + 
                    'Current value: ' + key + '\n\n' + 
                    'Check module.' + '\n\n'
                    )
                return
                    
               
# define column label        
            label = Label(
                frameTitles.interior(),
                text=keyTitle,
#                font=self.titleFont,
                bg=colorbg,
#                justify=LEFT,
                width=columnWidth,
                )
            label.grid(
                row=0,
                column=column,
                padx=padxTitle,
                pady=2
                )

        self.varButtonSetOrClearDefaultLength = IntVar()
        checkbuttonSetOrClearDefaultLength = Checkbutton(
            frameTitles.interior(),
            indicator=0,
            text='Default/Clear all',
            variable=self.varButtonSetOrClearDefaultLength,
            font=self.buttonFontSmallest,
            bg='white',
            fg='blue',
            borderwidth=3,
            relief=RAISED,
            justify=CENTER,
            command=self.handlerSetOrClearLengthDefaults
            )
        checkbuttonSetOrClearDefaultLength.grid(
            row=1,
            column=3,
            padx=5,
            pady=2,
            sticky=N,
            )
            
        self.varButtonClearOptions = IntVar()
        self.checkbuttonClearOptions = Checkbutton(
            frameTitles.interior(),
            indicator=0,
            text='Clear',
            variable=self.varButtonClearOptions,
            font=self.buttonFontSmallest,
            bg='white',
            fg='blue',
            borderwidth=3,
            relief=RAISED,
            justify=CENTER,
            command=self.handlerClearOptions,
            )
        self.checkbuttonClearOptions.grid(
            row=1,
            column=4,
            padx=5,
            pady=2,
            sticky=N,
            )
                
        self.buttonKeyDeselect = Button(
            frameTitles.interior(),
            text='Deselect',
            font=self.buttonFontSmall,
            borderwidth=2,
            relief=RAISED,
            command=self.handlerKeyDeselect,
            )
        self.buttonKeyDeselect.grid(
            row=1,
            column=6,
            padx=5,
            pady=2,
            sticky=N,
            )
                
# define lists for table
        self.varFieldName_Name = []
        self.varFieldName_Datatype = []
        self.varFieldName_Length = []
        self.varFieldName_Options = []
        self.varFieldName_DefaultValue = []
#        self.checkbuttonFieldName_Keys = []
# define value for 'key'
        self.varFieldName_Keys = []  # ranges from 1 to numFields

# iterate to list all fields
        irow=0
        numrow=1
        for numField in range(self.numFields):
# save numField for bindings
            self.save_numField = numField
# column 'No.'
            icol=0
# column No.
            self.labelFieldName_No = Label(
                frame_00_Scrolled,
#                frameListOfFieldsScrolled.interior(),
                text=(
                    str(numrow) + '.'
                    ),
                relief=FLAT,
                bg=colorbg,
                width=3,
                justify=RIGHT,
                )
            self.labelFieldName_No.grid(
                row=irow,
                column=icol,
                padx=padxField,
                sticky=N,
                )
            
# column 'Name'
            icol+=1
            self.varFieldName_Name.append('')
            self.varFieldName_Name[numField] = Pmw.EntryField(
                frame_00_Scrolled,
#                frameListOfFieldsScrolled.interior(),
                value=''
                )
            self.varFieldName_Name[numField].grid(
                row=irow,
                column=icol,
                padx=padxField,
                sticky=N,
                )
            self.varFieldName_Name[numField].configure(entry_width=15)

# column 'Datatype'
            icol+=1
            self.varFieldName_Datatype.append('')
            self.varFieldName_Datatype[numField] = Pmw.ComboBox(
                frame_00_Scrolled,
#                frameListOfFieldsScrolled.interior(),
                scrolledlist_items=self.fieldDataTypes,
                listheight=320,
                entry_width=15,
                entry_state='disabled',
                entry_disabledbackground='white',
                entry_disabledforeground='black',
                selectioncommand=self.handlerFieldName_Datatype,
                scrolledlist_hull_width=500,
                )
            self.varFieldName_Datatype[numField].grid(
                row=irow,
                column=icol,
                padx=padxField,
                sticky=N,
                )
#            self.varFieldName_Datatype[numField].configure(entry_width=15)

# define handler to determine which row we are on in the Create Table window

            def handlerGetRowNumber(event, self=self, i=(numField)):
                return self.handlerBinding_VarFieldName_Datatype(event,i)
            self.varFieldName_Datatype[numField].bind(
                "<Enter>",
                handlerGetRowNumber
                )
#                self.handlerBinding_VarFieldName_Datatype
#                )
               
# column 'Length'
            icol+=1
         
            self.varFieldName_Length.append('')               
            self.varFieldName_Length[numField] = Pmw.EntryField(
                frame_00_Scrolled,
#                frameListOfFieldsScrolled.interior(),
                value='',
                entry_width=15,
                entry_state='normal',
                entry_disabledbackground='gray',
                entry_disabledforeground='black',
                )
            self.varFieldName_Length[numField].grid(
                row=irow,
                column=icol,
                padx=padxField,
                sticky=N,
                )
#            self.varFieldName_Length[numField].configure(entry_width=15)

# column 'Options'
            icol+=1
            self.varFieldName_Options.append('')
            self.varFieldName_Options[numField] = Pmw.ComboBox(
                frame_00_Scrolled,
#                frameListOfFieldsScrolled.interior(),
                scrolledlist_items=self.fieldOptions,
                listheight=50,
                entry_width=15,
                entry_state='disabled',
                entry_disabledbackground='white',
                entry_disabledforeground='black',
                scrolledlist_hull_width=500,
                )
            self.varFieldName_Options[numField].grid(
                row=irow,
                column=icol,
                padx=padxField,
                sticky=N,
                )
#            self.varFieldName_Options[numField].configure(entry_width=15)
            
# column 'Default Value'
            icol+=1
            self.varFieldName_DefaultValue.append('') 
            self.varFieldName_DefaultValue[numField] = Pmw.EntryField(
                frame_00_Scrolled,
#                frameListOfFieldsScrolled.interior(),
                value='',
                entry_width=20,
                )
            self.varFieldName_DefaultValue[numField].grid(
                row=irow,
                column=icol,
                padx=padxField,
                sticky=N,
                )
#            self.varFieldName_DefaultValue[numField].configure(entry_width=20)

# column 'Key'
            icol+=1
            varFNK = IntVar()
            checkbuttonFieldName_Keys = Checkbutton(
                frame_00_Scrolled,
#                frameListOfFieldsScrolled.interior(),
                selectcolor='white',
                variable=varFNK,
#                value=numField+1,
                bg='lightblue',
                relief=FLAT,
                width=10,
#                command=self.handlerFieldName_Keys,
                )
            checkbuttonFieldName_Keys.grid(
                row=irow,
                column=icol,
                padx=10,
                pady=0,
                sticky=N,
                )
            self.varFieldName_Keys.append(varFNK)
                
# increment row            
            irow+=1
            numrow+=1

          
# DO NOT DELETE            
# data attributes needed for adding table and fields 
# ---- original database to save and then restore, since new table may be in another database
# original database:            self.comboboxDbSelect.get()
# ---- for database ----
# new table name:               self.varEnterDatabaseTablesNameAdd()
# selected database:            self.comboboxDatabaseForNewTable()
# number of fields:             self.entryfieldFieldsForNewTable.get()
# ---- for fields ----
# field name (list):                       self.varFieldName_Name[].get()
# field datatype (list):                  self.varFieldName_Datatype[].get()
# field length (list):                      self.varFieldName_Length[].get()
# field options(list):                      self.varFieldName_Options[].get()
# field default value(list):            self.varFieldName_DefaultValue[].get().strip() 
# field radiobutton for key(list):  self.varFieldName_Key[].get().strip()  (True if set) 
# 
            
# graph Add and Cancel buttons
# ... NOTE to user
        irow = 0
        labelExplainDefaults = Label(
            frame_10,
            text=(
                'NOTE 1: "Length" field is populated with typical values. These ' + 
                'are minimally error-checked in this window, so it is possible\n' +
                'to enter invalid values. If table creation is not successful, ' +
                'check "Length" variables for faulty values. Auto-enter default\n' +
                'values, if desired, by clicking on "Default/Clear all" button ' +
                'once or twice until default values appear.'
                ),
            justify=LEFT,
            bg=colorbg,
            )
        labelExplainDefaults.grid(
            row=irow,
            column=0,
            columnspan=2,
            padx=2,
            pady=0,
            )
# ... checkbutton for including INDEX field
        irow += 1
        labelIndexFieldForNewTable = Label(
            frame_10,
            text=(
                'NOTE 2: When table is created, one additional field is added ' +
                'at table end to allow automatically-incremented INDEX values.\n' + 
                'This field is designated as the PRIMARY KEY and allows table ' +
                'rows to be uniquely identified.\n' +
                'As required by MySQL, this is the only PRIMARY KEY field, ' +
                'though multiple non-primary search keys are allowed.'
                ),
            bg=colorbg,
            justify=LEFT,
            )
        labelIndexFieldForNewTable.grid(
            row=irow,
            column=0,
            columnspan=2,
            padx=2,
            pady=5,
            )
        '''    
        self.varIndexFieldForNewTable = IntVar()
        self.checkbuttonIndexFieldForNewTable = Checkbutton(
            frame_10,
            text=(
                'When table is created, add additional field at end\n' +
                'to include sequential, automatically incremented\n' + 
                'INDEX value to uniquely identify table rows\n' +
                '(STRONGLY RECOMMENDED!!)'
                ),
            bg='lightblue',
            variable=self.varIndexFieldForNewTable,
            justify=LEFT,
            )
        self.checkbuttonIndexFieldForNewTable.grid(
            row=irow,
            column=0,
            columnspan=2,
            padx=2,
            pady=5,
            )
        '''
# ... button: create table & fields            
        irow += 1
        self.buttonOkDefineFieldsForNewTable = Button(
            frame_10,
            text='Create table & fields',
            borderwidth=5,
            relief=RAISED,
            justify=CENTER,
            width=20,
            command=self.handlerDatabaseTablesNameAdd,
            )
        self.buttonOkDefineFieldsForNewTable.grid(
            row=irow,
            column=0,
            padx=10,
            pady=10,
            sticky=E,
            )

# ... button: cancel            
        self.buttonCancelDefineFieldsForNewTable = Button(
            frame_10,
            text='Cancel',
            borderwidth=5,
            relief=RAISED,
            justify=CENTER,
            width=15,
            command=self.handlerToplevelDefineFieldsForNewTableDestroy,
            )
        self.buttonCancelDefineFieldsForNewTable.grid(
            row=irow,
            column=1,
            padx=10,
            pady=10,
            sticky=W,
            )  
            
# put contents at top
#        frameListOfFieldsScrolled.reposition()
#        frameListOfFieldsScrolled.interior().grid_rowconfigure(1,weight=1)
#        frameListOfFieldsScrolled.grid_columnconfigure(1,weight=0)
        
        return
        
        
    def handlerToplevelDefineFieldsForNewTableDestroy(self):
        '''
        Purpose:
            destroy 'Create Table from Scratch' window
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerToplevelDefineFieldsForNewTableDestroy')

# save location for next time window is opened
        self.createTableFromScratch_xWindowLocation = \
            self.toplevelDefineFieldsForNewTable.winfo_rootx() - self.offsetWindowX
        self.createTableFromScratch_yWindowLocation = \
            self.toplevelDefineFieldsForNewTable.winfo_rooty() - self.offsetWindowY

# destroy current toplevel            
        self.toplevelDefineFieldsForNewTable.destroy()
        
        return
        
     
    def handlerDestroy(self):
        '''
        Purpose:
            close the following window but save the last location
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerDestroy')
            
        self.createTableFromScratch_xWindowLocation = self.toplevelDefineFieldsForNewTable.winfo_rootx() - self.offsetWindowX
        self.createTableFromScratch_yWindowLocation = self.toplevelDefineFieldsForNewTable.winfo_rooty() - self.offsetWindowY
        self.toplevelDefineFieldsForNewTable.destroy()
        
        return
        
        
    def handlerClearOptions(self):
        '''
        Purpose:
            clear all options set for new table fields when creating
            a table from scratch
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerClearOptions')
            
# cycle thru all rows, clearing the options
        for numField in range(self.numFields):
            self.varFieldName_Options[numField].setentry('')
# reset button
        self.checkbuttonClearOptions.deselect()
            
        return
                


    def handlerBinding_VarFieldName_Datatype(self,event,rowNumber):
        '''
        Purpose:
        to define which row is being examined in the Create Table window
        
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerBinding_VarFieldName_Datatype')

#        print('\n\n----\nevent.widget = %s' % event.widget)
        self.numField_Save = rowNumber
#        print('\nself.numField_Save = %s\n' % (self.numField_Save))
        
        return
    

    def handlerDatabaseTablesNameAdd(self):
        '''
        handler for:
            handlerDatabaseTablesAdd
            
         data attributes needed for adding table and fields 
         ---- original database to save and then restore, 
         since new table may be in another database
        # original database:                self.comboboxDbSelect.get()
        # ---- for database ----
        # new table name:                   self.varEnterDatabaseTablesNameAdd.get()
        # selected database:                self.comboboxDatabaseForNewTable.get()
        # number of fields:                 self.entryfieldFieldsForNewTable.get()
        # ---- for fields ----
        # field name (list):                self.varFieldName_Name[].get()
        # field datatype (list):            self.varFieldName_Datatype[].get()
        # field length (list):              self.varFieldName_Length[].get()
        # field options(list):              self.varFieldName_Options[].get()
        # field default value(list):        self.varFieldName_DefaultValue[].get().strip() 
        # field radiobutton for key:        self.varFieldName_Key.get().strip()  (True if set) 
        #                                      (value corresponds to "New Fields for Table" line number)
        # 
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerDatabaseTablesNameAdd')
        
# ... first, strip any leading whitespace (careless user!)        
        self.varEnterDatabaseTablesNameAdd.set(
            self.varEnterDatabaseTablesNameAdd.get().strip()
            )
        
# get table and database name from "Create Table -- 2 Methods"
#        databaseAdd = self.entryDatabaseForNewTable.get().strip()     
#        tableAdd = self.varEnterDatabaseTablesNameAdd.get().strip()
# get table from "Create Table From Scratch"
        myDatabaseTable = self.varTableNameForCreateTable.get().strip()
        myDatabase = self.comboboxDatabaseNameForCreateTable.get().strip()
# get number of fields
#        numFields = int(self.entryfieldFieldsForNewTable.get().strip())
        numFields = self.varNumFieldsForCreateTable.get()
        
# check if table name is blank
        if myDatabaseTable == '' or myDatabaseTable == None:
            self.MySQL_Output(
                1,
                'Entry for table name is blank.' + '\n' +
                ' Try again.'
                )
            showerror(
                'Error: no table name',
                'No name in table entry field.\n\n' +
                'Enter a table name into field.'
                )
            return

# check if database table already exists; this is necessary since in this window
#   the user is allowed to change the database and/or the table names at the
#   last minute to avoid having to close the window and lose all the entries

# ... get tables in user-specified database
        self.MySQL_Commands(
            1,
            'self.cursorHandleMySQL.execute("SHOW TABLES FROM ' + myDatabase + '")'
            )
        start = time.time()
        try:
            self.cursorHandleMySQL.execute("SHOW TABLES FROM " + myDatabase)
        except:
            stringShowTablesError = (
                'Unable to display tables for database\n\n' + 
                '%s\n\n' +
                'It is likely the database name contains special characters\n' +
                'not allowed by the server. In particular, dashes are NOT\n' +
                'allowed, but underscores are.\n\n' +
                'Also, the name may be a reserved word.\n\n' +
                'Try creating a database with a different name.'
                ) % myDatabase
            print stringShowTablesError
            self.MySQL_Output(
                0,
                stringShowTablesError
                )
            showerror(
                'Error: invalid database name',
                stringShowTablesError
                )
            return
        tempTables = self.cursorHandleMySQL.fetchall()
        myTables = []
        for table in tempTables:
            myTables.append(table[0]) 
        myTables.sort()
        
        finish = time.time()
        delta_t = finish - start
        self.MySQL_Commands(
            0,
            '  (Time: %-7.4f secs)' % delta_t
            )

        if myDatabaseTable in myTables:
            self.MySQL_Output(
                1,
                ('Table "%s" already exists\n in database "%s"') % 
                (myDatabaseTable, myDatabase)
                )
            stringTableExists = (
                'The following table already exists!\n\n' +
                '  table: %s\n' +
                '  database: %s\n\n' +
                'A new table CANNOT be created.\n\n' +
                'To create a new table, make sure a unique table\n' + 
                'name is entered for the designated database and\n' + 
                'try again.'
                ) % (
                myDatabaseTable,
                myDatabase
                )
            showerror(
                'Error: table exists',
                stringTableExists
                )
            return
                
# print table as it will appear
        self.MySQL_Output(
            1,
            'Affected database: ' + myDatabase + '\n' +
            'Affected table: ' + myDatabaseTable + '\n' +
            'Number of fields to insert: ' + str(numFields)
            )
        
        self.MySQL_Output(
            0,
            'Fields to insert into table:' + '\n' +
            'No.  Name  Datatype  Length  Options  Default_Value  Key'
            )
# check name
        listErrorCountName = []
        
        for numField in range(numFields):
            if self.varFieldName_Name[numField].get().strip() == '':
                listErrorCountName.append(numField)
        if len(listErrorCountName) is not 0:
            print(
              '\nThere are Name fields that have yet to be assigned.' + '\n' +
              'Please correct and try again.'
              )
            showerror(
                'Error: invalid Name fields',
                '\nThere are ' + str(len(listErrorCountName)) + 
                ' Name fields that have yet to be assigned.' + '\n' +
                'Please correct and try again.'
                )
            return
            
# check datatype
        listErrorCountDatatype = []
        
        for numField in range(numFields):
            if self.varFieldName_Datatype[numField].get().strip() == '':
                listErrorCountDatatype.append(numField)
        if len(listErrorCountDatatype) is not 0:
            print(
              '\nThere are ' + str(len(listErrorCountDatatype)) + 
              ' Datatype fields that have yet to be assigned.' + '\n' +
              'Please correct and try again.'
              )
            showerror(
                'Error: invalid Datatype fields',
                '\nThere are ' + str(len(listErrorCountDatatype)) + 
                ' Datatype fields that have yet to be assigned.' + '\n' +
                'Please correct and try again.'
                )
            return
            
# check length           
        listErrorCountLength = []
        numEmptyCountLength = 0
        varFieldName_Length = []
        
        for numField in range(numFields):
# filter out any error detected in Length field
            tempLength = self.varFieldName_Length[numField].get()
            varFieldName_Length.append('')
            if tempLength == '' and  (
            self.varFieldName_Datatype[numField].get().strip() <> 'DATE' and
            self.varFieldName_Datatype[numField].get().strip() <> 'DOUBLE' and
            self.varFieldName_Datatype[numField].get().strip() <> 'FLOAT' and
            self.varFieldName_Datatype[numField].get().strip() <> 'LONGTEXT' and
            self.varFieldName_Datatype[numField].get().strip() <> 'MEDIUMTEXT' and
            self.varFieldName_Datatype[numField].get().strip() <> 'TEXT' and
            self.varFieldName_Datatype[numField].get().strip() <> 'TIME' and
            self.varFieldName_Datatype[numField].get().strip() <> 'TIMESTAMP' and
            self.varFieldName_Datatype[numField].get().strip() <> 'TINYTEXT'
            ):
                numEmptyCountLength+=1
            else:
                varFieldName_Length[numField] = tempLength
                
# check emptycountLength
        if numEmptyCountLength is not 0:
            if numEmptyCountLength == 1:
                print (
                    '\nThere is %s Length field blank that should not be.\n\n' +
                    'Please correct and try again.\n\n' +
                    'numField, self.varFieldName_Datatype[numField].get().strip() = %s, %s'
                    ) % (
                    str(numEmptyCountLength), 
                    str(numField + 1), 
                    self.varFieldName_Datatype[numField].get().strip()
                    )
                showerror(
                    'Error: empty Length field',
                    '\nThere is ' + str(numEmptyCountLength) + ' Length field blank ' +
                    'that should not be.' +
                    '\n\nPlease correct and try again.'
                    )
            else:
                print (
                    '\nThere are %s Length fields blank that should not be.\n\n' +
                    'Please correct and try again.\n\n' +
                    'numField, self.varFieldName_Datatype[numField].get().strip() = %s, %s'
                    ) % (
                    str(numEmptyCountLength), 
                    str(numField + 1), 
                    self.varFieldName_Datatype[numField].get().strip()
                    )
                showerror(
                    'Error: empty Length fields',
                    '\nThere are ' + str(numEmptyCountLength) + ' Length fields blank ' +
                    'that should not be.' +
                    '\n\nPlease correct and try again.'
                    )
            
            return
                
# check errorcountLength
        if len(listErrorCountLength) is not 0:
            print (
                '\nFollowing %s Length fields have errors:' % len(listErrorCountLength)
                )
            print ( 
                '%5s %20s %25s' % (' No. ','      Datatype      ',
                '          Length         ')
                )
            print ('-'*5 + ' ' + '-'*20 + ' ' + '-'*25)
            for numField in listErrorCountLength:
                print (
                    '%5s %-20s %-25s' % (
                    numField+1,
                    self.varFieldName_Datatype[numField].get(),
                    varFieldName_Length[numField]
                    )
                    )
            print ('\nPlease correct the field(s) and try again.')
# prepare 'showinfo' string
            showinfoString = (
                'Following ' + str(len(listErrorCountLength)) + ' fields have errors:\n\n'
                )
            showinfoString += (
              'Field' + '   ' + 'Length field contains:' + '\n'
              )
            for numField in listErrorCountLength:
#                tempDataType = self.varFieldName_Datatype[numField].get()
#                if tempDataType == '' or tempDataType == None:
#                    tempDataType = '-----               '
                showinfoString += ('%-5s    %-25s' % (
                    numField+1,
#                    tempDataType,
                    varFieldName_Length[numField]
                    )) + '\n'
            showerror(
                'Error: invalid field entries',
                showinfoString
                )
            return
            
# perform bounds check on Length based on which Datatype is used -- keep it simple
        boundcheckNumField = []
        boundcheckErrorString = []
        
        for numField in range(numFields):
# define empty string; used for DECIMAL, FLOAT, DOUBLE
            stringBoundCheck = ''
# use shorter name
            name = self.varFieldName_Name[numField].get()
            var = varFieldName_Length[numField]
# NAME check
# ... cannot be just a number
            try:
                intName = int(name)
            except:
                pass
            else:
                boundcheckNumField.append(numField)
                boundcheckErrorString.append(
                    'name error: name cannot be just an integer'
                    )
# ... name length must be <= 64 characters 
            if len(name) > 64:
                boundcheckNumField.append(numField)
                boundcheckErrorString.append(
                    'name error: name length must be <= 64 characters'
                    )
                
# 0. BIGINT - range: -9223372036854775808 < BIGINT < 9223372036854775807
            if self.varFieldName_Datatype[numField].get().strip() == 'BIGINT':             
# ... check type      
                try: 
                    int_var = int(var)
                except:
                    boundcheckNumField.append(numField)
                    boundcheckErrorString.append(
                        'incorrect type: BIGINT Length field must be type \'int\''
                        )
                    continue
                else:                   
# ... check bounds
                    if int_var < 1 or int_var > 255:
                        boundcheckNumField.append(numField)
                        boundcheckErrorString.append(
                            'out of range: 0 < BIGINT Length < 255'
                            )
                    continue
                
# 1. CHAR - range: 0 < CHAR < 255
            if self.varFieldName_Datatype[numField].get().strip() == 'CHAR':
# ... check type      
                try: 
                    int_var = int(var)
                except:
                    boundcheckNumField.append(numField)
                    boundcheckErrorString.append(
                        'incorrect type: CHAR Length field must be type \'int\''
                        )
                    continue
                else:                   
# ... check bounds
                    if int_var < 1 or int_var > 255:
                        boundcheckNumField.append(numField)
                        boundcheckErrorString.append(
                            'out of range: 0 < CHAR Length < 255'
                            )
                    continue

# 2. DATE - <\'YYYY-MM-DD\'>
            if self.varFieldName_Datatype[numField].get().strip() == 'DATE':
# ... note that var should have been changed to '' above if the correct default value is in the DATE field
                if var <> '' and self.varFieldName_Length[numField].get().strip() <> "<'YYYY-MM-DD'>":
                    boundcheckNumField.append(numField)
                    boundcheckErrorString.append(
                        'incorrect value: DATE Length field must be set to <\'YYYY-MM-DD\'> ' +
                        '(including the < and > signs)'
                        )
                continue
                
# 3. DECIMAL - max width = 255
            if self.varFieldName_Datatype[numField].get().strip() == 'DECIMAL':
# check Length field input; can be either one or two ints; if two, separate by commas;
# ... anything else is an error
                stringBoundCheck = self.checkNewTableLengthFieldInput(var,'DECIMAL')
                if stringBoundCheck <> '':
                    boundcheckNumField.append(numField)
                    boundCheckErrorString.append(stringBoundCheck)
                    continue
                    
# 4. DOUBLE
            if self.varFieldName_Datatype[numField].get().strip() == 'DOUBLE':
# check Length field input; can be either one or two ints; if two, separate by commas;
# ... anything else is an error
                stringBoundCheck = self.checkNewTableLengthFieldInput(var,'DOUBLE')
                if stringBoundCheck <> '':
#                    boundcheckNumField.append(numField)
#                    boundCheckErrorString.append(stringBoundCheck)
                    continue
                   
# 5. FLOAT  
            if self.varFieldName_Datatype[numField].get().strip() == 'FLOAT':
# check Length field input; can be either one or two ints; if two, separate by commas;
# ... anything else is an error
                stringBoundCheck = self.checkNewTableLengthFieldInput(var,'FLOAT')
                if stringBoundCheck <> '':
#                    boundcheckNumField.append(numField)
#                    boundCheckErrorString.append(stringBoundCheck)
                    continue
               
# 6. INTEGER - range: -2147483648 < INTEGER < 2147483647
            if self.varFieldName_Datatype[numField].get().strip() == 'INTEGER':             
# ... check type      
                try: 
                    int_var = int(var)
                except:
                    boundcheckNumField.append(numField)
                    boundcheckErrorString.append(
                        'incorrect type: INTEGER Length field must be type \'int\''
                        )
                    continue
                else:                   
# ... check bounds
                    if int_var < 1 or int_var > 255:
                        boundcheckNumField.append(numField)
                        boundcheckErrorString.append('For INTEGER: 0 < Length < 255')
                    continue

# 7. INTEGER UNSIGNED - range: 0 < INTEGER UNSIGNED < 4294967295
            if self.varFieldName_Datatype[numField].get().strip() == 'INTEGER UNSIGNED':                
# ... check type      
                try: 
                    int_var = int(var)
                except:
                    boundcheckNumField.append(numField)
                    boundcheckErrorString.append('incorrect type: INTEGER UNSIGNED Length field must be type \'int\'')
                    continue
                else:                   
# ... check bounds
                    if int_var < 1 or int_var > 255:
                        boundcheckNumField.append(numField)
                        boundcheckErrorString.append('out of range: 0 < INTEGER UNSIGNED Length < 255')
                    continue
                
# 8. LONGTEXT - range: up to a max of 4000MB (4GB); no Length required
            if self.varFieldName_Datatype[numField].get().strip() == 'LONGTEXT':
                continue
                
# 9. MEDIUMTEXT - range: up to a max of 16MB; no Length required
            if self.varFieldName_Datatype[numField].get().strip() == 'MEDIUMTEXT':
                continue

# 10. SMALLINT - range: -32768 < SMALLINT < 32767
            if self.varFieldName_Datatype[numField].get().strip() == 'SMALLINT':             
# ... check type      
                try: 
                    int_var = int(var)
                except:
                    boundcheckNumField.append(numField)
                    boundcheckErrorString.append('incorrect type: SMALLINT Length field must be type \'int\'')
                    continue
                else:                   
# ... check bounds
                    if int_var < 1 or int_var > 255:
                        boundcheckNumField.append(numField)
                        boundcheckErrorString.append('out of range: 0 < SMALLINT Length < 255')
                    continue

# 11. SMALLINT UNSIGNED - range: 0 < SMALLINT < 65500
            if self.varFieldName_Datatype[numField].get().strip() == 'SMALLINT UNSIGNED':
# ... check type      
                try: 
                    int_var = int(var)
                except:
                    boundcheckNumField.append(numField)
                    boundcheckErrorString.append('incorrect type: SMALLINT UNSIGNED Length field must be of type \'int\'')
                    continue
                else:                   
# ... check bounds
                    if int_var < 1 or int_var > 255:
                        boundcheckNumField.append(numField)
                        boundcheckErrorString.append('out of range: 0 < SMALLINT Length < 5')
                    continue

# 12. TEXT - range: max of 64KB; no Length required
            if self.varFieldName_Datatype[numField].get().strip() == 'TEXT':
                continue
                
# 13. TIME
            if self.varFieldName_Datatype[numField].get().strip() == 'TIME':
# ... note that var should have been changed to '' above if the correct default value is in the TIME field
                if var <> '' and self.varFieldName_Length[numField].get().strip() <> "<'DD HH:MM:SS'>":
                    boundcheckNumField.append(numField)
                    boundcheckErrorString.append('incorrect value: TIME Length field must be set to <\'DD HH:MM:SS\'> (including the < and > signs)')
                continue

# 14. TIMESTAMP                
            if self.varFieldName_Datatype[numField].get().strip() == 'TIMESTAMP':
# ... note that var should have been changed to '' above if the correct default value is in the TIMESTAMP field
                if var <> '' and self.varFieldName_Length[numField].get().strip() <> "<NULL, or 'YYYY-MM-DD HH:MM:SS:'>":
                    boundcheckNumField.append(numField)
                    boundcheckErrorString.append('incorrect value: TIMESTAMP Length field must be set to <NULL, or \'YYYY-MM-DD HH:MM:SS\'> (including the < and > signs)')
                continue

# 15. TINYTEXT                
            if self.varFieldName_Datatype[numField].get().strip() == 'TINYTEXT':
# ... note that var should have been changed to '' above if the correct default value is in the TINYTEXT field
                if var <> '' and self.varFieldName_Length[numField].get().strip() <> "<Max 255B>":
                    boundcheckNumField.append(numField)
                    boundcheckErrorString.append('incorrect value: TINYTEXT Length field must be <Max 255B> (including the < and > signs)')
                continue
                
# 16. VARCHAR - range: up to 65500 chars             
            if self.varFieldName_Datatype[numField].get().strip() == 'VARCHAR':
# ... check type      
                try: 
                    int_var = int(var)
                except:
                    boundcheckNumField.append(numField)
                    boundcheckErrorString.append('incorrect type: VARCHAR Length field must be type \'int\'')
                    continue
                else:                   
# ... check bounds
                    if int_var < 1 or int_var > 65500:
                        boundcheckNumField.append(numField)
                        boundcheckErrorString.append('out of range; VARCHAR Length field must be 0 < Length < 65500')
                    continue
                
# any other  values have been user specified -- up to user to verify

# process bounds checks
        if len(boundcheckNumField) is not 0:
            stringBoundCheck = ''
            print ('\nErrors found in defining datatype Lengths fields:')
            for count in range(len(boundcheckNumField)):
                print (' %s. %s -- %s' % (count+1, boundcheckNumField[count]+1, boundcheckErrorString[count]))
                stringBoundCheck+='\n %s.  %s       %s' % (count+1, boundcheckNumField[count]+1, boundcheckErrorString[count])
            stringBoundCheck+='\n\n'
            self.MySQL_Output(
                1,
                '\nErrors found in defining datatype Lengths fields:'
                )
            self.MySQL_Output(
                0,
                stringBoundCheck
                )
            showerror(
                'Error: datatype Length fields',
                '\n' +
                '#   Field      Error\n' +
                '---  ---      ----------------------' +
                stringBoundCheck
                )
            return

# good to go if we make it this far   

# ... process non-primary keys
        self.handlerFieldName_Keys()
# 
        print
        for numField in range(numFields):
            var = self.varFieldName_Keys[numField]
            if var.get():
#            if self.varFieldName_Keys.get().strip() == numField+1:
                keysNonPrimary = 'Yes'
                print(
                    '\n Field %s is a Non-primary Key' % numField
                    )
            else:
                keysNonPrimary = 'No'
            '''
            print ('%3d' + '  ' + '%5s' + '  ' + '%8s' + '  ' + '%6s' + 
                '  ' + '%7s' + '  ' + '%12s' + '  ' + '%4s' ) % \
                (numField+1,
                self.varFieldName_Name[numField].get(),
                self.varFieldName_Datatype[numField].get(),
                varFieldName_Length,
                self.varFieldName_Options[numField].get(),
                self.varFieldName_DefaultValue[numField].get(),
                keyPrimary
                ) 
            '''
            self.MySQL_Output(
                0,
                ('%3d' + '  ' + '%5s' + '  ' + '%8s' + '  ' + '%6s' + 
                '  ' + '%7s' + '  ' + '%12s' + '  ' + '%4s' ) % \
                (numField+1,
                self.varFieldName_Name[numField].get(),
                self.varFieldName_Datatype[numField].get(),
                varFieldName_Length[numField],
                self.varFieldName_Options[numField].get(),
                self.varFieldName_DefaultValue[numField].get(),
                keysNonPrimary
                )
                )

# if all checks pass, add database to list 
# get final ok to add            
        ans=askokcancel(
            'Add table...',
            'You are about to add table\n\n' + 
            '"' + myDatabaseTable + '"\n\n' + 
            'to database\n\n"' + 
            '"' + myDatabase + '".\n\n' +
            'Click OK to continue, CANCEL to\n' +
            'quit this process.\n'
            )
            
        if ans:
            self.MySQL_Output(
                1,
                'Add table "%s" to database "%s"' % (myDatabaseTable, myDatabase)
                )
# select database   
#            self.cursorHandleMySQL.execute('USE' + ' ' + databaseAdd) 
            self.MySQL_Output(
                1,
                ('Now using database: ',myDatabase)
                )

# create table in database
            commandCreateTable = (
                'CREATE TABLE' + ' ' + myDatabase + '.' + myDatabaseTable + ' (' 
                )
            subCommand = ''

#            myKey = self.varFieldName_Key.get()
# set keyPrimary to False until we find an actual Primary Key
            keysNonPrimary = False
            keysNonPrimary_Names = []
            
            for numField in range(numFields):
                myName = self.varFieldName_Name[numField].get()
                myDatatype = self.varFieldName_Datatype[numField].get()
                myLength = varFieldName_Length[numField]
                myOptions = self.varFieldName_Options[numField].get()
                myDefaultValue = self.varFieldName_DefaultValue[numField].get()
# determine if field is a Primary Key                
                var = self.varFieldName_Keys[numField]
                if var.get():
#                if myKey == numField+1:
                    keysNonPrimary = True
                    keysNonPrimary_Names.append(myName)
# check if name and datatype, AT LEAST, are available - no blank fields here
                if (
                    (myName == None) or 
                    (myName == '') or 
                    (myDatatype == None) or 
                    (myDatatype == '')
                    ):
# if Name is not available, say so
                    if (
                        (myName == None) or 
                        (myName == '')
                        ):
                        self.MySQL_Output(
                            1,
                            'ERROR: no Name for field ' + str(numField + 1) + '. A name\n' +
                            'must be present.\n'
                            )
                        showerror(
                            'Error: no Name for field',
                            '\nThere is no Name for field ' + str(numField + 1) + '. A name\n'
                            'must be present.\n'
                            )
# if Datatype is not available, say so
                    if (
                        (myDatatype == None) or 
                        (myDatatype == '')
                        ):
                        self.MySQL_Output(
                            1,
                            'ERROR: no Datatype for field ' + str(numField + 1) + '. A datatype\n' +
                            'must be present.\n'
                            )
                        showerror(
                            'Error: no Datatype for field',
                            '\nThere is no Datatype for field ' + str(numField + 1) + '. A datatype\n'
                            'must be present.\n'
                            )
                    return
# if ok this far, start forming command line                        
                subCommand = ( 
                    '\n' + ' '*8 + myName + ' '
                    )
                if myLength:
                    if myDatatype == 'INTEGER UNSIGNED':
                        subCommand += 'INT(' + myLength + ') UNSIGNED' + ' '
                    elif myDatatype == 'SMALLINT UNSIGNED':
                        subCommand += 'SMALLINT(' + myLength + ') UNSIGNED' + ' '
                    elif(
                        (myDatatype == 'LONGTEXT') or
                        (myDatatype == 'MEDIUMTEXT') or
                        (myDatatype == 'TEXT') or
                        (myDatatype == 'TINYTEXT')
                        ):
                        subCommand += (
                            myDatatype + ' '
                            )
                        
                    else:
                        subCommand += (
                            myDatatype + '(' + 
                            myLength + ')' + ' '
                            )
                else:
                    subCommand += myDatatype + ' '
                    
                if myOptions:
                    subCommand += myOptions + ' '
                    
                if myDefaultValue:
                    subCommand += 'DEFAULT' + ' ' + myDefaultValue
                    
                if numField < (numFields-1):
                    subCommand += ','
                    
                commandCreateTable += subCommand
                
# add auto_index field
            commandCreateTable += (
                ',\n' + ' '*8 + 
                'auto_index INT(12) NOT NULL AUTO_INCREMENT PRIMARY KEY'
                )
                
# if non-primary keys, add to command string after it is fully formed
            if keysNonPrimary:
                commandCreateTable += ',\n' + ' '*8 + 'KEY ('
#                for name in keysNonPrimary_Names:
                for numNames in range(len(keysNonPrimary_Names)):
                    name = keysNonPrimary_Names[numNames]
                    if numNames <> len(keysNonPrimary_Names) - 1:
                        commandCreateTable += name + ', '
                    else:
                        commandCreateTable += name
            '''
            commandCreateTable += ')'
            '''
# add closing parenthesis
            commandCreateTable += '\n' + ' '*8 + ')'

# print commandCreateTable for the record
            self.MySQL_Commands(
                1,
                'self.cursorHandleMySQL.execute(' + commandCreateTable + ')'
                )        

            try:
                self.cursorHandleMySQL.execute( commandCreateTable)
            except:
                print ('\nCommand to create table:\n%s' % commandCreateTable)
                self.MySQL_Output(
                    1,
                    '\nError in command to create table:\n' +
                    commandCreateTable + '\n\n'
                    )
                stringCannotCreateTable = (
                    'Cannot create table. This may be due to\n\n' +
                    '  - keyword being used to name a field\n' +
                    '  - duplicate names\n' +
                    '  - a syntax problem, or special characters\n' +
                    '     (including spaces) in field names\n' +
                    '  - erroneous length parameter\n' +
                    '  - the table already exists\n' +
                    '  - memory required for row is too large (reduce lengths)\n\n' +
                    'but the exact cause of this problem is unknown.'
                    )
                self.MySQL_Output(
                    1,
                    stringCannotCreateTable
                    )
                try:
                    showerror(
                        'ERROR: cannot create table',
                        stringCannotCreateTable,
                        parent=self.toplevelDefineFieldsForNewTable
                        )
                except:
                    showerror(
                        'ERROR: cannot create table',
                        stringCannotCreateTable
                        )
                return
                
# if a table has been specified, keep it and return to it after the new table is added
            if self.comboboxDbTableSelect.get():
                self.use_DatabaseTable = self.comboboxDbTableSelect.get().strip()
                self.MySQL_Output(
                    1,
                    'Using table ' + self.use_DatabaseTable
                    )
# get new tables list
                self.mysql_GetDatabaseTables()
# regrid TABLES combobox
                self.mysql_ComboDatabaseTables()
# specify table in selection box
                self.comboboxDbTableSelect.selectitem(
                    self.use_DatabaseTable
                    )
# regrid FIELDS combobox
                self.refreshFields()
                
            else:
# no table is listed in the 'selected' field, so list new tables and clear fields
                self.mysql_GetDatabaseTables()
# regrid TABLES combobox
                self.mysql_ComboDatabaseTables()
# clear fields  
                self.clearDbFields()
            showinfo(
                'Info: table creation',
                'Table creation was successful.',
                )
#            self.toplevelDefineFieldsForNewTable.destroy()
            return
        else:
            self.MySQL_Output(
                1,
                'CANCELED: "Add table & fields" operation canceled '
                )
        
        return
        
        
    def checkNewTableLengthFieldInput(self,var,datatype):
        '''
        Purpose:
            checks format of Length field for new tables, to ensure
            proper entry;
            
            Allowable format:
            - the entry can either be one or two ints
            - if two ints, they must be separated by a comma
            - no other special characters allowed
            
        Input variables:
            var         Length as specified in new table creation window
            datatype    For this method, can be only DECIMAL, FLOAT, DOUBLE
                            since each of these can have the 'width' specified
                            to be either a single int, or a pair of ints with the
                            second int specifying the number of decimal places
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'checkNewTableLengthFieldInput')
            
# ... initialize
        stringExclude = '[A-Za-z\!\.\_\=\:\;\@\#\$\%\^\&\*\(\)\-\+\{\}\|\]\[\"\'\?\/\<\>]'
        testForForwardSlash = 0
        testForAllOthers = 0
        errorString = ''
        commonString = (
            datatype + ' Length field format values must ' +
            'be either a single int, or at most 2 ints separated by comma.'
            )
        
# ... make sure something is in field
        if var.strip() == '':
            errorString = (
                'empty field: ' + commonString
                )
            return errorString
        
# ... if any of the following are found, input is wrong
        testForForwardSlash = var.count('/')                # takes care of escape characters; re.findall can't
        testForAllOthers = re.findall(stringExclude,var)    # takes care of everything else
        if testForForwardSlash or testForAllOthers:
            errorString = (
                'special chars not allowed: ' + commonString
                )
            return errorString
            
            
# ... count commas; should be one and only one
        varCountComma = var.count(',')
# ... if comma is found
        if varCountComma:
            varSplitCommaList = var.split(',')
            lenVarSplitCommaList = len(varSplitCommaList)
# ... check if more than 2 commas
            if lenVarSplitCommaList > 2:
                errorString = (
                    'too many values: ' + commonString
                    )
                return errorString

# if everything ok, return empty string             
        return ''
            
            
    def handlerDatabaseTablesDelete(self):
        '''
        Delete a table from current list of tables
        
        inputs:
            self.cursorHandleMySQL
            self.comboboxDbSelect.get()
            self.myDatabaseTables()
            
        outputs:
            self.myDatabaseTables() # revised
       
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerDatabaseTablesDelete')

# check if connected to a MySQL server
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return
            
# destroy any old toplevel frames
        self.destroyAllDatabaseTableFieldFrames()
                    
# open Toplevel frame for entering database name
        self.toplevelTableDelete = Toplevel(
            self.frameParent,
            bg='tan'
            )
        self.toplevelTableDelete.title(
#            'Delete table'
            'TABLES IN DATABASE'
            )
# keep it on top of the parent window
        self.toplevelTableDelete.transient(self.frameParent)
# place the top window
#        x_Windows = self.deleteTable_xWindowLocation
#        y_Windows = self.deleteTable_yWindowLocation
        x_Windows = self.frameParent.winfo_rootx() + 75
        y_Windows = self.frameParent.winfo_rooty() + 50
        
        self.toplevelTableDelete.geometry(
            '+%d+%d' % (x_Windows, y_Windows)
            )
# frame for title        
        frame_00 = Frame(
            self.toplevelTableDelete,
            bg='tan',
            )
        frame_00.grid(
            row=0,
            column=0,
            padx=5,
            pady=10,
            )
# frame for database, select table, delete select table
        frame_10 = Frame(
            self.toplevelTableDelete,
            bg='tan',
            )
        frame_10.grid(
            row=1,
            column=0,
            padx=5,
            pady=0,
            )
# frame for cancel
        frame_20 = Frame(
            self.toplevelTableDelete,
            bg='tan',
            )
        frame_20.grid(
            row=2,
            column=0,
            padx=5,
            pady=5,
            )

# WIDGETS
            
        labelTitleTablesNameDelete = Label(
            frame_00,
            text='DELETE TABLE',
            bg='tan',
            font=self.labelFontMediumBold,
            justify=CENTER
            )
        labelTitleTablesNameDelete.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
            
        labelEnterDatabase = Label(
            frame_10,
            text='Database: ',
            bg='tan',
            justify=RIGHT,
            )
        labelEnterDatabase.grid(
            row=0,
            column=0,
            padx=0,
            pady=5,
            sticky=E,
            )
            
        self.varDatabaseForDeleteTable = StringVar()
        self.entryDatabaseForDeleteTable = Entry(
            frame_10,
            textvariable=self.varDatabaseForDeleteTable,
            relief=FLAT,
            disabledforeground='black',
            disabledbackground='white',
            width=30,
            )
        self.entryDatabaseForDeleteTable.grid(
            row=0,
            column=1,
            padx=5,
            pady=5,
            sticky=W,
            )
        self.varDatabaseForDeleteTable.set(self.comboboxDbSelect.get())
        self.entryDatabaseForDeleteTable.configure(state='disable')
            
        labelEnterDatabaseTablesNameDelete = Label(
            frame_10,
            text='Table: ',
            bg='tan',
            justify=RIGHT,
            )
        labelEnterDatabaseTablesNameDelete.grid(
            row=1,
            column=0,
            padx=0,
            pady=5,
            sticky=E,
            )

# for combobox
        '''
        self.comboboxEnterDatabaseTablesNameDelete = Pmw.ComboBox(
            frame_10,
#            selectioncommand=self.handlerDatabaseTablesNameDelete,
            scrolledlist_items=self.myDatabaseTables,
            entry_width=30,
            scrolledlist_hull_width=500,
            )
        self.comboboxEnterDatabaseTablesNameDelete.grid(
            row=1,
            column=1,
            padx=5,
            pady=5,
            sticky=W,
            )
# set default value if one exists
        if self.comboboxDbTableSelect.get():
            self.comboboxEnterDatabaseTablesNameDelete.selectitem(
                self.comboboxDbTableSelect.get().strip()
                )
        '''
                
        self.varEntryEnterDatabaseTablesNameDelete = StringVar()
        if self.comboboxDbTableSelect.get():
            self.varEntryEnterDatabaseTablesNameDelete.set(
                self.comboboxDbTableSelect.get().strip()
                )
        self.entryEnterDatabaseTablesNameDelete = Entry(
            frame_10,
            textvariable=self.varEntryEnterDatabaseTablesNameDelete,
            width=30,
            relief=FLAT,
            disabledbackground='white',
            disabledforeground='black',
            state='disable',
            )
        self.entryEnterDatabaseTablesNameDelete.grid(
            row=1,
            column=1,
            padx=5,
            pady=5,
            sticky=W,
            )
   
# graph Delete and Cancel buttons
        self.buttonOkEnterDatabaseTablesNameDelete = Button(
            frame_10,
            text='Delete',
            borderwidth=3,
            relief=RAISED,
            justify=CENTER,
            width=10,
            background='white',
            foreground='blue',
            font=self.buttonFontSmall,
            command=self.handlerDatabaseTablesNameDelete,
            )
        self.buttonOkEnterDatabaseTablesNameDelete.grid(
            row=2,
            column=1,
            padx=0,
            pady=0,
            sticky=N,
            )
            
        self.buttonCancelEnterDatabaseTablesNameDelete = Button(
            frame_20,
            text='Cancel',
            borderwidth=5,
            relief=RAISED,
            justify=CENTER,
            width=12,
            command=self.handlerToplevelTableDeleteDestroy,
            )
        self.buttonCancelEnterDatabaseTablesNameDelete.grid(
            row=0,
            column=0,
            padx=0,
            pady=10,
            )
        
        return
        
        
    def handlerToplevelTableDeleteDestroy(self):
        '''
        Purpose:
            destroy 'Edit Field Name' window
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerToplevelTableDeleteDestroy')

# save location for next time window is opened
        self.deleteTable_xWindowLocation = \
            self.toplevelTableDelete.winfo_rootx() - self.offsetWindowX
        self.deleteTable_yWindowLocation = \
            self.toplevelTableDelete.winfo_rooty() - self.offsetWindowY

# destroy current toplevel            
        self.toplevelTableDelete.destroy()
        
        return
        

    def handlerDatabaseTablesNameDelete(self):
        '''
        handler for:
            handlerDatabaseTablesDelete
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerDatabaseTablesNameDelete')
            
# make sure field is not empty
# ... first, strip any leading whitespace (careless user!)        
#        tableDelete = self.comboboxEnterDatabaseTablesNameDelete.get()
        tableDelete = self.varEntryEnterDatabaseTablesNameDelete.get().strip() 
        
# ... check for blank name
        if tableDelete == '' or tableDelete == None:
            self.MySQL_Output(
                1,
                'Entry for table name is blank.' + '\n' +
                ' Try again.'
                )
            showerror(
                'Error: no table name',
                'No name in table entry field.\n\n' +
                'Enter a table name into field.'
                )
            return
            
# get current database
        currentDatabase = self.comboboxDbSelect.get()

# check if database table is in list
        for myTable in self.myDatabaseTables:
            if tableDelete == myTable:
# get final ok to delete           
                ans=askokcancel(
                    'Delete table...',
                    'You are about to delete a table\n' + 
                    '"' + tableDelete + '"' + '.\n\n' +
                    'Click OK to continue, or CANCEL to\n' +
                    'quit this process.\n'
                    )
            
                if ans:
                    self.MySQL_Output(
                        1,
                        ' Delete table: ' + tableDelete
                        )
                        
                    self.MySQL_Commands(
                        1,
                        'self.cursorHandleMySQL.execute("DROP TABLE' + ' ' + 
                            currentDatabase + '.' + tableDelete + '")'
                        )
                    try:
# delete table from databases
                        self.cursorHandleMySQL.execute(
                            'DROP TABLE' + ' ' + currentDatabase + '.' + tableDelete
                            )
                    except:
# user has no delete permissions
                        self.MySQL_Output(
                            1,
                            'Error: user probably does not have "delete" permissions.'
                            )
                        showerror(
                            'Error: unable to delete',
                            'Unable to delete table.\n\n' +
                            'You probably do not have "delete" permissions for\n' + 
                            'this table.\n\n' + 
                            'Check with a system administrator for obtaining\n' +
                            'appropriate permissions to delete a table.\n'
                            )
                        return
                    
                    else:
# get new tables list (refresh tables)
                        self.mysql_GetDatabaseTables()
# regrid Tables combobox
                        self.mysql_ComboDatabaseTables()
# clear fields
                        self.clearDbFields()
# clear selection in 'Delete database' window
#                        self.comboboxEnterDatabaseTablesNameDelete.clear()
                        self.varEntryEnterDatabaseTablesNameDelete.set('')
# regrid 'Delete database' frame
#                        self.handlerDatabaseTablesDelete()
# if 'Backup and Restore' window is open, blank the field with current table
                        try:
                            mapped = self.toplevelBackupRestore.winfo_exists()
                        except:
                            mapped = False
                        if mapped:
                            self.varBackupRestoreSelectTable.set('')
                        
                    return
                    
                else:
                    self.MySQL_Output(
                        1,
                        'CANCELED: delete table'  
                        )
                    return
                
# if we get this far, database does not exist in list
        self.MySQL_Output(
            1,
            'This table does not exist!\n'
            )
        showerror(
            'Error: table does not exist',
            'You apparently entered a table that does not\n' +
            'currently exist! No table will be deleted.\n\n' +
            'To delete a table, enter an existing\n' + 
            'name into the entry field, then\n' +
            'click "Delete".\n\n'
            )
            
        return
                     
                
    def mysql_ComboDatabaseTables(self):
        '''
        graph combobox for DATABASE TABLES
        
        Inputs: 
            self.myDatabaseTables
            
        Outputs:
            self.comboboxDbTableSelect(.set()/.get())
            self.varDbTablesTotal(.set()/.get())
            
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'mysql_ComboDatabaseTables')
            
# ... top label
        labelTables = Label(
            self.frameMySQL_02_00,
            text='TABLES IN DATABASE\n(select to show Fields)',
            bg=self.colorbg,
            )
        labelTables.grid(
            row=0,
            column=0,
            columnspan=2,
            padx=0,
            pady=2,
            )
# ... combobox for Database TABLES               
        self.comboboxDbTableSelect = Pmw.ComboBox(
            self.frameMySQL_02_00,
            scrolledlist_items=self.myDatabaseTables,
            scrolledlist_hscrollmode='static',
            scrolledlist_vscrollmode='static',
            dropdown=0,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            selectioncommand=self.handler_ComboDatabaseTables,
            )
        self.comboboxDbTableSelect.grid(
            row=1,
            column=0,
            columnspan=2,
            pady=2,
            )
# ... affix scrollbars
#        self.comboboxDbTableSelect.configure(scrolledlist_hscrollmode = 'static')
#        self.comboboxDbTableSelect.configure(scrolledlist_vscrollmode = 'static')

# ... label for total            
        labelDbTablesTotal = Label(
            self.frameMySQL_02_00,
            text='Tables: ',
            bg=self.colorbg,
            )
        labelDbTablesTotal.grid(
            row=2,
            column=0,
            pady=2,
            sticky=E,
            )
# ... total # of tables          
        self.varDbTablesTotal = StringVar()
        self.varDbTablesTotal.set(len(self.myDatabaseTables))
        self.entryDbTablesTotal = Entry(
            self.frameMySQL_02_00,
            bg=self.colorbg,
            relief=FLAT,
            textvariable=self.varDbTablesTotal,
            width=5,
            state='disabled',
            disabledforeground='black',
            disabledbackground=self.colorbg,
            )
        self.entryDbTablesTotal.grid(
            row=2,
            column=1,
            pady=2,
            sticky=W,
            ) 
        
        return
        

    def handler_ComboDatabaseTables(self, myTable):
        '''
        handles selection from TABLES combobox
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handler_ComboDatabaseTables')
        
# get the current selection for Database
#        self.use_Database = self.comboboxDbSelect.get()
#        print '  ... use database:',self.use_Database
        
# get the current selection for Database
        self.use_DatabaseTable = myTable
        self.MySQL_Output(
            1,
            '\n  ... use database table: %s' % (self.use_DatabaseTable)
            )
        
# clear Fields
        self.comboboxDbFieldSelect.clear()
        
# make MySQL use this selection
#        self.cursorHandleMySQL.execute('USE' + ' ' + self.use_Database)

# refresh fields
        self.refreshFields()
        
# if ADD FIELD window exists, update it
        try:
            mappedFieldAdd = self.toplevelFieldAdd.winfo_exists()
        except:
            mappedFieldAdd = False
            
        if mappedFieldAdd:
            '''
# close it and return
            self.toplevelFieldAdd.destroy()
            return
            '''
# set table field with new table name
            currentTable = self.comboboxDbTableSelect.get().strip()
            self.varEnterDatabaseFieldAddTables.set(currentTable)

# get new table columns for drop-down menu for "After column ..."
# do not include last 'auto_index' column in scrolled list
            tempMyDatabaseFields = []
            for number,field in enumerate(self.myDatabaseFields[0:-1]):
                tempMyDatabaseFields.append(str(number + 1) + '. ' + field)
# ... combobox for column
            self.comboboxFieldAddPosition_AfterColumn = Pmw.ComboBox(
                self.frame_10_Add_Field,
#            scrolledlist_items=self.myDatabaseFields,
                scrolledlist_items=tempMyDatabaseFields,
                listheight=150,
                entry_state='disabled',
                entry_disabledbackground='white',
                entry_disabledforeground='black',
                selectioncommand=self.handlerSetRadiobuttonAfter,
                entry_width=30,
                scrolledlist_hull_width=500,
                )
            self.comboboxFieldAddPosition_AfterColumn.grid(
                row=6,
                column=1,
                pady=0,
                sticky=N+E,
                )            

            
# if DELETE FIELD window exists, close it
        try:
            mappedFieldDelete = self.toplevelFieldDelete.winfo_exists()
        except:
            mappedFieldDelete = False
            
        if mappedFieldDelete:
            '''
# close and return
            self.toplevelFieldDelete.destroy()
            return
            '''
# update Table entry field
            currentTable = self.comboboxDbTableSelect.get().strip()
            self.varEnterDatabaseFieldDeleteTables.set(currentTable)
# clear Field entry field
            self.varEntryEnterDatabaseFieldDelete.set('')
            
            
# if EDIT FIELD NAME window exists, close it
        try:
            mappedFieldEdit = self.toplevelFieldNameEdit.winfo_exists()
        except:
            mappedFieldEdit = False
            
        if mappedFieldEdit:
            '''
# close and return
            self.toplevelFieldNameEdit.destroy()
            return
            '''
# update Table entry field
            currentTable = self.comboboxDbTableSelect.get().strip()
            self.varTableEditField.set(currentTable)
# clear Field entry
            self.varEntryEnterSelectFieldEditFieldName.set('')
# clear Field structure entry fields
            self.varField1.set('')
            self.varField2.set('')
            self.varField3.set('')
            self.varField4.set('')
            self.varField5.set('')
            self.varField6.set('')
# leave new Field name as is   
            
        
# if 'Table Functions' window exists, refresh the 'Table:' field
        try:
            mapped0 = self.toplevelTableFunctions.winfo_exists()
        except:
            mapped0 = False 

        if mapped0:            
            self.varEntryTableFunctionsSelectTable.set(
                self.comboboxDbTableSelect.get().strip()
                )  
            self.varTableFunctionsRename.set(
                'rename__' + self.varEntryTableFunctionsSelectTable.get()
                )
            self.varTableFunctionsCopy.set(
                'copy__' + self.varEntryTableFunctionsSelectTable.get()
                )

# if 'Backup and Restore' window exists, refresh current table field                
        try:
            mapped1 = self.toplevelBackupRestore.winfo_exists()
        except:
            mapped1 = False
            
        if mapped1:
            self.varBackupFileName.set(
                'backup__' + self.comboboxDbTableSelect.get().strip()
                )
            self.varBackupRestoreSelectTable.set(
                self.comboboxDbTableSelect.get().strip()
                )            
                
# if 'Add Field' window exists, refresh current table field
        '''
        try:
            mapped2 = self.toplevelFieldAdd.winfo_exists()
        except:
            mapped2 = False
            
        if mapped2:
            self.varEnterDatabaseFieldAddTables.set(
                self.comboboxDbTableSelect.get().strip()
                )
        '''
                
# if 'Delete Table' window exists, refresh table field
        try:
            mapped3 = self.toplevelTableDelete.winfo_exists()
        except:
            mapped3 = False
        if mapped3:
            self.varEntryEnterDatabaseTablesNameDelete.set(
                self.comboboxDbTableSelect.get().strip()
                )
                
# if 'Delete Field' window exists, refresh table field, blank 'field' entry
        '''
        try:
            mapped4 = self.toplevelFieldDelete.winfo_exists()
        except:
            mapped4 = False
            
        if mapped4:
            self.varEnterDatabaseFieldDeleteTables.set(
                self.comboboxDbTableSelect.get().strip()
                )
            self.varEntryEnterDatabaseFieldDelete.set('')
        '''
            
# if 'Edit Field Name' window exists, close it
        '''
        try:
            mapped5 = self.toplevelFieldNameEdit.winfo_exists()
        except:
            mapped5 = False
            
        if mapped5:
            self.varTableEditField.set(
                self.comboboxDbTableSelect.get()
                )
            self.varEntryEnterSelectFieldEditFieldName.set('')
            self.varField1.set('')
            self.varField2.set('')
            self.varField3.set('')
            self.varField4.set('')
            self.varField5.set('')
            self.varField6.set('')
        '''
        
        return
        
        
    def refreshFields(self):
        '''
        refresh the fields table
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'refreshFields')
            
# get current database
        myDatabase = self.comboboxDbSelect.get().strip()
        
        if not myDatabase:
            self.MySQL_Output(
                1,
                'Error: No database has been specified.'
                )
            showerror(
                'Error: no database',
                'No database has been chosen for this\n' +
                'operation.\n\n' +
                'Please choose a database.'
                )
            return
            
# get current table
        myTable = self.comboboxDbTableSelect.get().strip()
        
        if not myTable:
            self.MySQL_Output(
                1,
                'Error: No table has been specified.'
                )
            showerror(
                'Error: no table',
                'No table has been selected for this\n' +
                'operation.\n\n' +
                'Please select a table.'
                )
            return
        
# get tables that go with database selection; error check
        try:
            stringDescribe = (
                'DESCRIBE' + ' ' + myDatabase + '.' + myTable
                )
            self.MySQL_Commands(
                1,
                'self.cursorHandleMySQL.execute("' + stringDescribe + '")'
                )
# execute command
            start = time.time()
            self.cursorHandleMySQL.execute(
                stringDescribe
                )
            finish = time.time()
            delta_t = finish - start
# print elapsed time
            self.MySQL_Commands(
                0,
                '  (Time: %-7.4f secs)' % delta_t
                )

        except:
            stringCannotShowContents = (
                'Cannot show contents of table\n' +
                '   %s\n\n' +
                'in database\n\n' +
                '   %s\n\n' +
                'This may be due to\n\n' + 
                '   1. lost server connection\n' +
                '   2. a MySQL-command syntax problem\n' + 
                '   3. lack of proper permissions to show this table,\n' +
                '   4. an empty table\n\n' +
                'It is not exactly known what caused this problem.\n' +
                'Contact the database sys-admin for further guidance,\n' +
                'if necessary.'
                ) % (
                self.myTable, 
                self.myDatabase
                )
            self.MySQL_Output(
                1,
                stringCannotShowContents
                )
            showerror(
                'ERROR: cannot show table contents',
                stringCannotShowContents
                )
                
            return

                
        fields = self.cursorHandleMySQL.fetchall()
        
# define database fields
        self.myDatabaseFields = []
# assemble string for combobox widget
        for field in fields:
            self.myDatabaseFields.append(field[0])

        if DEBUG_REFRESHFIELDS:
            self.MySQL_Output(
                1,
                'MySQL Fields for selected Database and Table:'
                )
            i=0
            for field in fields:
                i+=1
                self.MySQL_Output(
                    0,
                    '%3s. %s ' % (i,field[0])
                    )

# sort using 'sorted' so that original stays as is
#        self.myDatabaseFields_Select = sorted(self.myDatabaseFields)

# show fields in Fields combobox
        self.mysql_ComboDatabaseFields()  
        
        return
        

    def refreshTables(self):
        '''
        Purpose:
            refresh tables list            
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'refreshTables\n')

# check if connected to a MySQL server
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return           
        
# define current database
        myDatabase = self.comboboxDbSelect.get()
        
#        self.MySQL_Output(
#            1,
#            'Using database: ' + myDatabase
#            )

        if not myDatabase:
            self.MySQL_Output(
                1,
                (
                'Error: no database specified.\n' +
                'No database has been specified. Please\n' +
                'select a database and try again.\n'
                )
                )
            showerror(
                'Error: no database specified',
                '\nNo database has been specified. Please\n' +
                'select a database and try again.\n\n'
                )
            return
        
#        self.cursorHandleMySQL.execute('USE' + ' ' + myDatabase)

# clear table list
        self.myDatabaseTables = []
# get database tables
        self.MySQL_Commands(
            1,
            'self.cursorHandleMySQL.execute("SHOW TABLES FROM ' + myDatabase + '")'
            )
        start = time.time()
        try:
            self.cursorHandleMySQL.execute("SHOW TABLES FROM " + myDatabase)
        except:
            stringShowTablesError = (
                'Unable to display tables for database\n\n' + 
                '%s\n\n' +
                'It is likely the database name contains special characters\n' +
                'not allowed by the server. In particular, dashes are NOT\n' +
                'allowed, but underscores are.\n\n' +
                'Also, the name may be a reserved word.\n\n' +
                'Try creating a database with a different name.'
                ) % myDatabase
            print stringShowTablesError
            self.MySQL_Output(
                0,
                stringShowTablesError
                )
            showerror(
                'Error: invalid database name',
                stringShowTablesError
                )
            return
        tempTables = self.cursorHandleMySQL.fetchall()
        tables = []

# tempTables is a tuple; must reference element [0] of each item        
        for table in tempTables:
            tables.append(table[0]) 
        tables.sort()
        
        if DEBUG_TABLES_REFRESH:
            print('\ntempTables = \n')
            print(tempTables)
            print('\ntables.sort() = \n')
            print(tables)
        
        finish = time.time()
        delta_t = finish - start
        self.MySQL_Commands(
            0,
            '  (Time: %-7.4f secs)' % delta_t
            )

        self.MySQL_Output(
            1,
            'Tables in database ' + myDatabase + ':'
            )

        self.myDatabaseTables = []
        
        for (number,table) in enumerate(tables):
            self.MySQL_Output(
                0,
                '%3s. ' % (number + 1)  + table
                )
            self.myDatabaseTables.append(table) 
            
        self.myDatabaseTables.sort()
        
        if DEBUG_TABLES_REFRESH:
            print('\nself.myDatabaseTables = \n')
            print(self.myDatabaseTables)
              
        return  
        
        
    def mysql_ComboDatabaseFields(self):
        '''
        graph combobox for DATABASE FIELDS
        
        Inputs: 
            self.myDatabaseFields
            
        Outputs:
            self.comboboxDbSelect(.set()/.get())  
            self.varDbFieldsTotal(.set()/.get())
            
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'mysql_ComboDatabaseFields')
        
# ... top label
        labelFields = Label(
            self.frameMySQL_03_00,
#            text='FIELDS IN TABLE\n(select to edit field name)',
            text='FIELDS IN TABLE\n(listed in column order) ',
            bg=self.colorbg,
            )
        labelFields.grid(
            row=0,
            column=0,
            columnspan=2,
            padx=0,
            pady=2,
            )
            
# use numbered list for scrolledlist_items
        myDatabaseFields_Numbered = []
        for num,field in enumerate(self.myDatabaseFields):
            myDatabaseFields_Numbered.append(str(num+1) + '. ' + field) 
# ... combobox for database Fields            
        self.comboboxDbFieldSelect = Pmw.ComboBox(
            self.frameMySQL_03_00,
#            scrolledlist_items=enumerate(self.myDatabaseFields),
            scrolledlist_items=myDatabaseFields_Numbered,
            scrolledlist_hscrollmode='static',
            scrolledlist_vscrollmode='static',
            dropdown=0,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            selectioncommand=self.handlerDbFieldSelect,
            )
        self.comboboxDbFieldSelect.grid(
            row=1,
            column=0,
            columnspan=2,
            pady=2,
            )
# ... affix scrollbars
#        self.comboboxDbFieldSelect.configure(scrolledlist_hscrollmode = 'static')
#        self.comboboxDbFieldSelect.configure(scrolledlist_vscrollmode = 'static')
        
# ... label for total            
        labelDbFieldsTotal = Label(
            self.frameMySQL_03_00,
            text='Fields: ',
            bg=self.colorbg,
            )
        labelDbFieldsTotal.grid(
            row=2,
            column=0,
            pady=2,
            sticky=E,
            )
# ... entry for total           
        self.varDbFieldsTotal = StringVar()
        self.varDbFieldsTotal.set(len(self.myDatabaseFields))
        self.entryDbFieldsTotal = Entry(
            self.frameMySQL_03_00,
            bg=self.colorbg,
            relief=FLAT,
            textvariable=self.varDbFieldsTotal,
            state='disabled',
            disabledforeground='black',
            disabledbackground=self.colorbg,
            width=5,
            )
        self.entryDbFieldsTotal.grid(
            row=2,
            column=1,
            pady=2,
            sticky=W,
            )
        
        return
            
           
    def handlerDbFieldSelect(self,value):
        '''
        Purpose:
            when field is selected, logic here prevents auto_index
            from being modified by user
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerDbFieldSelect')

# strip out the leading field number            
        try:
            myField = value.split('.')[1].strip()
        except:
            stringCannotReadEntry = (
                'Cannot read field entry, or the entry\n' +
                'does not have the proper format of\n' +
                ' #. fieldname\n\n' +
                'Inform code administrator of this error.'
                )
            print('\n' + stringCannotReadEntry)
            self.MySQL_Output(
                0,
                stringCannotReadEntry
                )
            try:
                showerror(
                    'Error: invalid entry',
                    stringCannotReadEntry,
                    parent=self.frameParent
                    )
            except:
                showerror(
                    'Error: invalid entry',
                    stringCannotReadEntry
                    )
            return
            
# check if blank entry           
        if(
        myField == None
        or
        myField == ''
        ):
            stringNoFieldEntry = (
                'Field value has no entry.\n\n' +
                'Select a valid entry and try again.'
                )
            print('\n' + stringNoFieldEntry)
            self.MySQL_Output(
                0,
                stringNoFieldEntry
                )
            try:
                showerror(
                    'Error: no entry',
                    stringNoFieldEntry,
                    parent=self.frameParent
                    )
            except:
                showerror(
                    'Error: no entry',
                    stringNoFieldEntry
                    )
            return

# leave 'auto_index' alone            
        if myField == 'auto_index':
            self.comboboxDbFieldSelect.setentry('')
            stringAutoIndexNotSelectable = ''
            stringAutoIndexNotSelectable = (
                'The field\n\n' +
                '  > auto_index\n\n' +
                'is a permanent field and is NOT selectable.\n\n' +
                'Select a different field.'
                )
            print(stringAutoIndexNotSelectable)
            self.MySQL_Output(
                0,
                stringAutoIndexNotSelectable
                )
            showerror(
            'Error: not selectable',
            stringAutoIndexNotSelectable
            )
            return
            
# if 'DELETE FIELD' window exists, update 'Select field:'
        try:
            mapped = self.toplevelFieldDelete.winfo_exists()
        except:
            mapped = False
            
        if mapped:
            self.varEntryEnterDatabaseFieldDelete.set(value)
            
# if 'EDIT FIELD NAME' window exists, update 'Select field:'
        try:
            mapped = self.toplevelFieldNameEdit.winfo_exists()
        except:
            mapped = False
            
        if mapped:
            self.varEntryEnterSelectFieldEditFieldName.set(value)
            self.handlerEditFieldSelect(
                self.comboboxDbFieldSelect.get()
                )
            
        return
              
            
    def handlerDatabaseFieldsSelect(self):
        '''
        pops up a toplevel frame for editing a field structure and value
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerDatabaseFieldsSelect')
        
# check if connected to the database server - MySQL
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return
        
# destroy any old frames
        self.destroyAllDatabaseTableFieldFrames()

# check if database and table have been specified        
# ... get current database and table 
        currentDatabaseForField = self.comboboxDbSelect.get().strip()      
        currentTableForField = self.comboboxDbTableSelect.get().strip()      
# ... check if a database and table have been selected
        if (
            currentDatabaseForField == '' or currentTableForField == ''
            ):
            stringNoDatabaseOrTableSelected = ''
            stringNoDatabaseOrTableSelected = (
                'The following needs correcting:\n\n'
                )
            if currentDatabaseForField == '':
                stringNoDatabaseOrTableSelected += '  > No database has been selected.\n\n'
            if currentTableForField == '':
                stringNoDatabaseOrTableSelected += '  > No table has been selected.\n\n'
            stringNoDatabaseOrTableSelected += (
                'Please select the database and/or table and try again.'
                )
            self.MySQL_Output(
                0,
                stringNoDatabaseOrTableSelected
                )
            showerror(
                'Edit field name ...',
                stringNoDatabaseOrTableSelected
                )  
            return

# set my current field 
        if (
        self.comboboxDbFieldSelect.get().strip() <> ''
        and
        self.comboboxDbFieldSelect.get().split('.')[1].strip() <> "auto_index"
        ):
            myCurrentField = self.comboboxDbFieldSelect.get()
        else:
            myCurrentField = ''
            '''
            stringNoSelection = (
                'No field has been selected to edit.\n\n' +
                'Select a field to edit first, then\n\n' +
                'try again.'
                )
            print('\n' + stringNoSelection)
            self.MySQL_Output(
                0,
                stringNoSelection
                )
            showerror(
            'Error: no selection',
            stringNoSelection
            )
            return
            '''
            
# FRAMES
            
# open Toplevel frame for entering database name
        self.toplevelFieldNameEdit = Toplevel(
#            self.frameParent,
            bg='tan'
            )
        self.toplevelFieldNameEdit.title(
            'EDIT FIELD NAMES'
#            'FIELDS IN TABLE'
            )
        self.toplevelFieldNameEdit.transient(self.frameParent)
# place the top window
#        x_Windows = self.editFieldName_xWindowLocation
#        y_Windows = self.editFieldName_yWindowLocation
        x_Windows = self.frameParent.winfo_rootx() + 10
        y_Windows = self.frameParent.winfo_rooty() + 100
        
        self.toplevelFieldNameEdit.geometry(
            '+%d+%d' % (x_Windows, y_Windows)
            )

# FRAMES within toplevel
        frame_00 = Frame(
            self.toplevelFieldNameEdit,
            bg='tan',
            )
        frame_00.grid(
            row=0,
            column=0,
            padx=5,
            pady=5,
            )
            
        self.frame_10_EditField = Frame(
            self.toplevelFieldNameEdit,
            bg='tan',
            )
        self.frame_10_EditField.grid(
            row=1,
            column=0,
            padx=5,
            pady=5,
            )
            
        self.frame_20_EditField = Frame(
            self.toplevelFieldNameEdit,
            bg='tan',
            )
        self.frame_20_EditField.grid(
            row=2,
            column=0,
            padx=5,
            pady=5,
            )
            
        frame_30 = Frame(
            self.toplevelFieldNameEdit,
            bg='tan',
            )
        frame_30.grid(
            row=3,
            column=0,
            padx=5,
            pady=5,
            )
            
        frame_99 = Frame(
            self.toplevelFieldNameEdit,
            bg='tan',
            )
        frame_99.grid(
            row=99,
            column=0,
            padx=5,
            pady=5,
            )
            
# WIDGETS

# label for frame
        label_00 = Label(
            frame_00,
            text=(
                'EDIT FIELD NAME\n' +
                'Cannot rename PRIMARY KEY "auto-index" field;\n' +
                'pick any Database, Table, or Field'
                ),
            bg='tan',
            font=self.labelFontMediumBold,
            justify=CENTER,
            )
        label_00.grid(
            row=0,
            column=0,
            columnspan=99,
            ) 
            
        label_myDatabase = Label(
            self.frame_10_EditField,
            text='Database: ',
            justify=RIGHT,
            bg='tan',
            )
        label_myDatabase.grid(
            row=0,
            column=0,
            padx=2,
            pady=2,
            sticky=E,
            )
        self.varDatabaseEditField = StringVar()
        self.myDatabaseEditField = Entry(
            self.frame_10_EditField,
            textvariable=self.varDatabaseEditField,
            disabledforeground='black',
            disabledbackground='white',
            state='disable',
            width=30,
            )
        self.myDatabaseEditField.grid(
            row=0,
            column=1,
            padx=5,
            pady=2,
            sticky=W,
            )
        if self.comboboxDbSelect.get():
            myDatabase = self.comboboxDbSelect.get().strip()
            self.varDatabaseEditField.set(
                myDatabase
                )
        else:
            self.MySQL_Output(
                1,
                'Error: no database has been selected for this operation'
                )
            showerror(
                'Error: no database selected',
                '\nNo database has been selected.\n\n' +
                'Please select a valid database\n' +
                'before continuing.\n\n'
                )
            return
                
        label_myTable = Label(
            self.frame_10_EditField,
            text='Table: ',
            justify=RIGHT,
            bg='tan',
            )
        label_myTable.grid(
            row=1,
            column=0,
            padx=2,
            pady=2,
            sticky=E,
            ) 
            
        self.varTableEditField = StringVar()
        self.myTableEditField = Entry(
            self.frame_10_EditField,
            textvariable=self.varTableEditField,
            disabledforeground='black',
            disabledbackground='white',
            state='disable',
            width=30,
            )
        self.myTableEditField.grid(
            row=1,
            column=1,
            padx=5,
            pady=2,
            sticky=W,
            )
        if self.comboboxDbTableSelect.get():
            myTable = self.comboboxDbTableSelect.get().strip()
            self.varTableEditField.set(
                myTable
                )
        else:
            self.MySQL_Output(
                1,
                'Error: no table has been selected for this operation'
                )
            showerror(
                'Error: no table selected',
                '\nNo table has been selected.\n\n' +
                'Please select a valid table\n' +
                'before continuing.\n\n'
                )
            return
            
# define the following now, since used in both 
#       self.mySelectFieldEditField
# and
#     self.entryChangeFieldName
        self.varChangeFieldName = StringVar()  
            
        label_myField = Label(
            self.frame_10_EditField,
            text='Field: ',
            justify=RIGHT,
            bg='tan',
            )
        label_myField.grid(
            row=2,
            column=0,
            padx=2,
            pady=2,
            sticky=E,
            ) 

# for combobox
        '''
        tempMyDatabaseFields = []
        for num,field in enumerate(self.myDatabaseFields[:-1]):
            tempMyDatabaseFields.append(str(num + 1) + '. ' + field)
            
        self.mySelectFieldEditField = Pmw.ComboBox(
            self.frame_10_EditField,
#            scrolledlist_items=self.myDatabaseFields,
            scrolledlist_items=tempMyDatabaseFields,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            selectioncommand=self.handlerEditFieldSelect,
            entry_width=30,
            scrolledlist_hull_width=500,
            )
        self.mySelectFieldEditField.grid(
            row=2,
            column=1,
            padx=5,
            pady=2,
            sticky=W,
            )
        try:
            self.mySelectFieldEditField.selectitem(myCurrentField)
        except:
            self.mySelectFieldEditField.setentry('')
        '''
        
        self.varEntryEnterSelectFieldEditFieldName = StringVar()
        self.varEntryEnterSelectFieldEditFieldName.set(
            myCurrentField
            )
        self.entryEnterSelectFieldEditFieldName = Entry(
            self.frame_10_EditField,
            textvariable=self.varEntryEnterSelectFieldEditFieldName,
            disabledforeground='black',
            disabledbackground='white',
            state='disable',
            width=30,
            )
        self.entryEnterSelectFieldEditFieldName.grid(
            row=2,
            column=1,
            padx=5,
            pady=2,
            sticky=W,
            )

# show field structure        
        self.handlerEditFieldSelect(myCurrentField)
        
# widget for name change
        labelChangeFieldName = Label(
            frame_30,
            text=(
                'Enter new Field name: \n' +
                '(no special characters; all lowercase; \n' +
                'underscores ok) '
                ),
            justify=RIGHT,
            bg='tan',
            )
        labelChangeFieldName.grid(
            row=0,
            column=0,
            rowspan=2,
            padx=2,
            pady=2,
            sticky=E,
            )
             
        self.entryChangeFieldName = Entry(
            frame_30,
            textvariable=self.varChangeFieldName,
            width=30
            )
        self.entryChangeFieldName.grid(
            row=0,
            column=1,
            padx=2,
            pady=2,
            sticky=W,
            )
                      
        buttonClearChangeFieldName = Button(
            frame_30,
            text='Clear',
            font=self.buttonFontSmallest,
            borderwidth=2,
            relief=RAISED,
            width=8,
            background='white',
            foreground='blue',
            command=self.handlerClearChangeFieldName,
            )
        buttonClearChangeFieldName.grid(
            row=1,
            column=1,
            padx=5,
            pady=0,
            sticky=N,
            )
                       
# CHANGE field name button
        buttonEditFieldSave = Button(
            frame_99,
            text='Change name',
            borderwidth=5,
            relief=RAISED,
            justify=CENTER,
            background='white',
            foreground='blue',
            font=self.buttonFontSmall,
            width=15,
            command=self.handlerChangeFieldName,
            )
        buttonEditFieldSave.grid(
            row=0,
            column=0,
            padx=5,
            pady=5,
            )

# CANCEL button        
        buttonEditFieldCancel = Button(
            frame_99,
            text='Cancel',
            font=self.buttonFontSmall,
            borderwidth=5,
            relief=RAISED,
            justify=CENTER,
            width=15,
            command=self.handlerFieldNameEditDestroy,
            )
        buttonEditFieldCancel.grid(
            row=0,
            column=1,
            padx=5,
            pady=15,
            ) 
        
        return
        
            
    def handlerChangeFieldName(self):
        '''
        Purpose:
            change field name
            
        Called by:
            handlerDatabaseFieldsSelect
        
        Calls:       
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerChangeFieldName')

# check if new field name is present
        if(
        not self.varTableEditField.get().strip()
        or
        not self.varChangeFieldName.get().strip() 
        or 
#        not self.mySelectFieldEditField.get()
        not self.varEntryEnterSelectFieldEditFieldName.get().strip()
        ):
            stringError = ''
            if not self.varTableEditField.get().strip():
                stringError += ' - Table\n'
            if not self.varEntryEnterSelectFieldEditFieldName.get().strip():
                stringError += ' - Field\n' 
#                self.myStuctureFieldsEditField_Clear()
                self.varField1.set('')
                self.varField2.set('')
                self.varField3.set('')
                self.varField4.set('')
                self.varField5.set('')
                self.varField6.set('')
            if self.varChangeFieldName.get().strip() == '':
                stringError += ' - New field name.\n'                
            self.MySQL_Output(
                1, 
                'Error: invalid fields' + '\n' +
                'The following fields need attention:\n' +
                stringError
                )
            showerror(
                'Error: invalid fields',
                'The following fields need valid input:\n\n' +
                stringError + '\n' +
                'Input appropriate values and try again.'
                )
            return
            
        myDatabase = self.varDatabaseEditField.get()
        myTable = self.varTableEditField.get()
#        columnNumber = self.mySelectFieldEditField.get().split('.')[0].strip()
        columnNumber = self.varEntryEnterSelectFieldEditFieldName.get().split('.')[0].strip()
#        myOldField = self.mySelectFieldEditField.get().split('.')[1].strip()
        myOldField = self.varEntryEnterSelectFieldEditFieldName.get().split('.')[1].strip()
        myNewField = self.varChangeFieldName.get()
#        myNewFieldWithColumnNumber = (str(columnNumber) + '. ' + myNewField)
        myNewFieldWithColumnNumber = (str(columnNumber) + '. ' + myNewField)
        myDatatype = self.myDatatypeChangeFieldName
        myNull = self.myNullChangeFieldName
        myKey = self.myKeyChangeFieldName
        myDefault = self.myDefaultChangeFieldName
        myExtra = self.myExtraChangeFieldName
        
# check for duplicate names in 'Select field" and "Enter new field name"
        if myNewField == myOldField:
            stringErrorDuplicates = (
                'New field name is identical to current field name.\n\n' +
                'Please enter a unique new field name.'
                )
            self.MySQL_Output(
                0,
                '\n' + stringErrorDuplicates
                )
            showerror(
                'Error: field name duplicates',
                stringErrorDuplicates
                )
            return
        
# change field name in table
        if (myKey == 'PRI' or myKey == 'pri') and \
            (myExtra == 'auto_increment' or myExtra == 'AUTO_INCREMENT'):
# this requires a two step process: drop field, then add it with same structure
# ... drop old auto_increment line
            stringDropFieldName = (
                'ALTER TABLE' + ' ' + myDatabase + '.' + myTable + ' ' +
                'drop' + ' ' + myOldField 
               )
            self.MySQL_Commands(
                1,
                'Primary Key field with auto_increment:\n' +
                '  Step 1/2: drop field\n' +
                '    self.cursorHandleMySQL.execute("' + stringDropFieldName + '")'
                )        
            try:
                self.cursorHandleMySQL.execute(
                    stringDropFieldName
                    )
            except:
                self.MySQL_Output(
                    1,
                    'Error: Cannot drop field name.\n' +
                    'An unknown error has occurred.\n\n' +
                    'Check input syntax and try again.\n'
                    )
                showerror(
                    'Error: Cannot drop field name',
                    'Cannot drop field name.\n' + 
                    'An unknown error has occurred.\n\n' + 
                    'Check and correct input syntax and try again.'
                    )
                return
# ... add new auto_increment line
            stringAddFieldName = (
                'ALTER TABLE' + ' ' + myDatabase + '.' + myTable + ' ' +
                'ADD' + ' ' + myNewField + ' ' + myDatatype + ' ' + 
                'NOT NULL PRIMARY KEY AUTO_INCREMENT'
                )
            self.MySQL_Commands(
                1,
                '  Step 2/2: add field\n' +
                '    self.cursorHandleMySQL.execute("' + stringAddFieldName + '")'
                )
            
            try:
                self.cursorHandleMySQL.execute(
                    stringAddFieldName
                    )
            except:
                self.MySQL_Output(
                    1,
                    'Error: Cannot add field name.\n' +
                    'An unknown error has occurred.\n\n' +
                    'Check input syntax and try again.\n'
                    )
                showerror(
                    'Error: cannot add field name',
                    'Cannot add field name.\n' + 
                    'An unknown error has occurred.\n\n' + 
                    'Check and correct input syntax and try again.'
                    )  

        else:

            stringChangeFieldName = (
                'ALTER TABLE' + ' ' + myDatabase + '.' + myTable + ' ' +
                'CHANGE' + ' ' + myOldField + ' ' + myNewField + ' ' + 
                myDatatype + ' ' 
                )

            if myNull:
                if myNull == 'NO':
                    stringChangeFieldName += 'NOT NULL' +  ' ' #' "' + myNull + '" '
                elif myNull == 'YES':
                    stringChangeFieldName += 'NULL' + ' '
            '''        
            if myKey:
                stringChangeFieldName += 'KEY' + ' (' + myNewField + ') '
            if myDefault:
                stringChangeFieldName += 'DEFAULT' + ' ' + myDefault + ' '
            else:
                stringChangeFieldName += 'DEFAULT' + ' '
            if myExtra:
                stringChangeFieldName += 'EXTRA' + ' "' + myExtra + '" '
            '''
            
            self.MySQL_Output(
                1,
                'Rename the selected field:' + '\n' +
                stringChangeFieldName 
                )
            
# check for trying to rename a field with a name that already exists
            for field in self.myDatabaseFields:
                if field == myNewField:
                    stringErrorNameChange = (
                        'Cannot perform the field name change due\n' +
                        'to a duplicate column named "' + myNewField + '".\n\n' +
                        'Enter another field name and try again.'
                        )
                    self.MySQL_Output(
                        1,
                        stringErrorNameChange
                        )
                    showerror(
                        'Error: field name change',
                        stringErrorNameChange
                        )
                    return
                
            self.MySQL_Commands(
                1,
                'self.cursorHandleMySQL.execute("' + stringChangeFieldName + '")'
                )
            
            try:
                self.cursorHandleMySQL.execute(
                    stringChangeFieldName
                    )
            except:
                stringErrorNameChange = (
                    'An unknown error has occurred but is probably due ' +
                    'to invalid MySQL syntax.\n\n' +
                    'Please report error.\n'
                    )
                self.MySQL_Output(
                    1,
                    'Error: Cannot perform the field name change.\n' +
                    stringErrorNameChange
                    )
                showerror(
                    'Error: field name change',
                    stringErrorNameChange
                    )
                return
# fetch table            
        self.cursorHandleMySQL.fetchall() 
        
# reset field listing in main window as well as in toplevel 'edit field name'
        self.refreshFields()
        
# reset the  'Select field:' widget in 'Edit Field Name' 
        '''
        tempMyDatabaseFields = []
        for num,field in enumerate(self.myDatabaseFields[:-1]):
            tempMyDatabaseFields.append(str(num + 1) + '. ' + field)
            
        self.mySelectFieldEditField = Pmw.ComboBox(
            self.frame_10_EditField,
            scrolledlist_items=tempMyDatabaseFields,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            selectioncommand=self.handlerEditFieldSelect,
            entry_width=30,
            scrolledlist_hull_width=500,
            )
        self.mySelectFieldEditField.grid(
            row=2,
            column=1,
            padx=5,
            pady=2,
            sticky=W,
            )
        '''
        self.varEntryEnterSelectFieldEditFieldName.set('')
        
# make sure myNewField is part of the new 'self.myDatabaseFields' list
        fieldExists = False
        for field in self.myDatabaseFields:
            if field == myNewField:
#            if field == myNewField.split('.')[1].strip():
                fieldExists = True
                break
        if not fieldExists:
            stringErrorMyNewField = (
                'The new field "' + myNewField + '" was not found in the current\n' +
                'list of fields. Hence, the field structure did not get\n' +
                'updated for some reason.\n\n' +
                'This should not happen.\n\n' +
                'Please report this error to code administrator.'
                )
            self.MySQL_Output(
                0,
                '\n' + stringErrorMyNewField
                )
            showerror(
                'Error: field not found',
                stringErrorMyNewField
                )
            return  
            
# if get this far, field exists and is listed in 'self.myDatabaseFields'       
#        self.mySelectFieldEditField.selectitem(myNewFieldWithColumnNumber)
        self.varEntryEnterSelectFieldEditFieldName.set(myNewFieldWithColumnNumber)
        
# relist the field structure in 'Edit Field Name' toplevel
        self.handlerEditFieldSelect(myNewFieldWithColumnNumber)
        
# clear 'Enter new field name'
        self.varChangeFieldName.set('')

# update table values only if current EDIT FIELD NAME database and table correspond to  
#   the displayed database and table   
        try:
            mapped = self.toplevelTableValues.winfo_exists()
        except:
            mapped = False
                                
        if mapped:
# make sure databases and tables are same for ADD FIELD and for the displayed table values; 
#   otherwise, don't need to update
            if (
            self.databaseDisplayedTableValues == self.varDatabaseEditField.get().strip()
            and
            self.tableDisplayedTableValues == self.varTableEditField.get().strip()
            ):
                self.handlerDisplayLimitedRows()    # PEEK handle
# update filter window
                try:
                    mapped = self.toplevelSelectDisplayOrderedFields.winfo_exists()
                except:
                    mapped = False
            
                if mapped:
                    self.handlerSelectDisplayOrderedFields_Update()
                    
# kill the Quik-Select window
                self.handlerQuikSelectCancelWindow()   
        
        return

            
    def handlerEditFieldSelect(self,tempField):
        '''
        Purpose:
            display a different field in 'Edit Field Value'
            when selected
            
        Called by:
            handlerDatabaseFieldsSelect
        
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerEditFieldSelect')
            
# clear 'Enter new field name'
        self.varChangeFieldName.set('')
# re-grid self.frame_20_EditField
# get myDatabase
        if self.comboboxDbSelect.get():
            myDatabase = self.comboboxDbSelect.get()
            self.varDatabaseEditField.set(
                myDatabase.strip()
                )
            self.myDatabaseEditField.configure(state='disable')
        else:
            self.MySQL_Output(
                1,
                'Error: no database has been selected for this operation'
                )
            showerror(
                'Error: no database selected',
                '\nNo database has been selected.\n\n' +
                'Please select a valid database\n' +
                'before continuing.\n\n'
                )
            return

# get myTable
        if self.comboboxDbTableSelect.get():
            myTable = self.comboboxDbTableSelect.get()
            self.varTableEditField.set(
                myTable.strip()
                )
            self.myTableEditField.configure(state='disable')
        else:
            self.MySQL_Output(
                1,
                'Error: no table has been selected for this operation'
                )
            showerror(
                'Error: no table selected',
                '\nNo table has been selected.\n\n' +
                'Please select a valid table\n' +
                'before continuing.\n\n'
                )
            return

# define field widths
        width_i = 5
        width_Field = 25
        width_Datatype = 15
        width_Null = 6
        width_Key = 6
        width_Default = 15
        width_Extra = 15

        rowCount=1
      
# HEADER labels

# ... header1
        varHeader1 = StringVar()
        entryFieldLabel1 = Entry(
            self.frame_20_EditField,
            textvariable=varHeader1,
            width=width_Field,
            bg='tan',
            justify=CENTER,
            relief=FLAT,
            disabledbackground='tan',
            disabledforeground='black',
            )
        entryFieldLabel1.grid(
            row=rowCount,
            column=0,
            padx=2,
            pady=2,
            )
#        entryFieldLabel1.configure(state='normal')
        varHeader1.set('Field')
        entryFieldLabel1.configure(state='disable')
# ... header2
        varHeader2 = StringVar()
        entryFieldLabel2 = Entry(
            self.frame_20_EditField,
            textvariable=varHeader2,
            width=width_Datatype,
            bg='tan',
            justify=CENTER,
            relief=FLAT,
            disabledbackground='tan',
            disabledforeground='black',
            )
        entryFieldLabel2.grid(
            row=rowCount,
            column=1,
            padx=2,
            pady=2,
            )
#        entryFieldLabel2.configure(state='normal')
        varHeader2.set('Datatype')
        entryFieldLabel2.configure(state='disable')
# ... header3
        varHeader3 = StringVar()
        entryFieldLabel3 = Entry(
            self.frame_20_EditField,
            textvariable=varHeader3,
            width=width_Null,
            bg='tan',
            justify=CENTER,
            relief=FLAT,
            disabledbackground='tan',
            disabledforeground='black',
            )
        entryFieldLabel3.grid(
            row=rowCount,
            column=2,
            padx=2,
            pady=2,
            )
#        entryFieldLabel3.configure(state='normal')
        varHeader3.set('Null')
        entryFieldLabel3.configure(state='disable')
# ... header4
        varHeader4 = StringVar()
        entryFieldLabel4 = Entry(
            self.frame_20_EditField,
            textvariable=varHeader4,
            width=width_Key,
            bg='tan',
            justify=CENTER,
            relief=FLAT,
            disabledbackground='tan',
            disabledforeground='black',
            )
        entryFieldLabel4.grid(
            row=rowCount,
            column=3,
            padx=2,
            pady=2,
            )
#        entryFieldLabel4.configure(state='normal')
        varHeader4.set('Key')
        entryFieldLabel4.configure(state='disable')
# ... header5
        varHeader5 = StringVar()
        entryFieldLabel5 = Entry(
            self.frame_20_EditField,
            textvariable=varHeader5,
            width=width_Default,
            bg='tan',
            justify=CENTER,
            relief=FLAT,
            disabledbackground='tan',
            disabledforeground='black',
            )
        entryFieldLabel5.grid(
            row=rowCount,
            column=4,
            padx=2,
            pady=2,
            )
#        entryFieldLabel5.configure(state='normal')
        varHeader5.set('Default')
        entryFieldLabel5.configure(state='disable')
# ... header6
        varHeader6 = StringVar()
        entryFieldLabel6 = Entry(
            self.frame_20_EditField,
            textvariable=varHeader6,
            width=width_Extra,
            bg='tan',
            justify=CENTER,
            relief=FLAT,
            disabledbackground='tan',
            disabledforeground='black',
            )
        entryFieldLabel6.grid(
            row=rowCount,
            column=5,
            padx=2,
            pady=2,
            )
#        entryFieldLabel6.configure(state='normal')
        varHeader6.set('Extra')
        entryFieldLabel6.configure(state='disable') 

# show value in editable field
        if tempField <> '':
            stringTableStructure = (
                'SHOW COLUMNS FROM ' + myDatabase + '.' + myTable
                )
            self.MySQL_Commands(
                1,
                'self.cursorHandleMySQL.execute("' + stringTableStructure + '")'
                )
            start=time.time()
            try:
                self.cursorHandleMySQL.execute(
                    stringTableStructure
                    )
            except:
# check if connected to a MySQL server
                self.checkMySQLConnection()
                if self.connectionFlag == 0: return
# if not a connection problem, the command has wrong syntax
                stringErrorShowColumns = (
                    'Unable to show field structure for editing.\n\n' +
                    'Reason for this is unknown, but may be due to:\n\n' +
                    ' - the MySQL command has the wrong syntax\n\n' +
                    'Please report this error.'
                    )
                print(
                   stringErrorShowColumns
                   )
                self.MySQL_Output(
                    0,
                    stringErrorShowColumns
                    )
                showerror(
                    'Error: MySQL command/access problem',
                    stringErrorShowColumns
                    )
                return
            self.tableStructure = self.cursorHandleMySQL.fetchall()
            finish=time.time()
            delta_t = finish - start
            self.MySQL_Commands(
                0,
                '  (Time: %-7.4f secs)' % delta_t
                )
            
# define field widths
        '''
        width_i = 5
        width_Field = 25
        width_Datatype = 15
        width_Null = 6
        width_Key = 6
        width_Default = 15
        width_Extra = 15
        '''
        
# get current field value
#        tempField = self.mySelectFieldEditField.get()
#        if self.mySelectFieldEditField.get():
        if self.varEntryEnterSelectFieldEditFieldName.get():
            tempField = self.varEntryEnterSelectFieldEditFieldName.get().split('.')[1].strip()
        else:
            tempField = ''
# search tableStructure for tempField
        success=0
        if tempField == '':
            itersToSearch = 1
        else:
            itersToSearch = len(self.tableStructure)
# look for tempField match, then print structure;
# ... if tempField is blank, print blanks for field structure
        for i in range(itersToSearch):
            if tempField <> '':
                myField, myDatatype, myNull, myKey, myDefault, myExtra = \
                    self.tableStructure[i]
            elif tempField == '':
                myField = ''
                myDatatype = ''
                myNull = '' 
                myKey = ''
                myDefault = ''
                myExtra = ''
                
            self.MySQL_Output(
                1,
                'Trying to match myField and tempField:' + '\n' +
                'myField = %s, tempField = %s' % (myField,tempField)
                )
                
            if (
            (myField == tempField)
            or
            myField == ''
            ):
                success=1
                self.myFieldChangeFieldName = myField
                self.myDatatypeChangeFieldName = myDatatype
                self.myNullChangeFieldName = myNull
                self.myKeyChangeFieldName = myKey
                self.myDefaultChangeFieldName = myDefault
                self.myExtraChangeFieldName = myExtra

# HEADER values
                rowCount=2

# ... field 1
                columnCount=0
                self.varField1 = StringVar()
                entryField1 = Entry(
                    self.frame_20_EditField,
                    textvariable = self.varField1,
                    width=width_Field,
                    relief=SUNKEN,
                    disabledbackground='white',
                    disabledforeground='black',
                    state='disable'
                    )
                entryField1.grid(
                    row=rowCount,
                    column=columnCount,
                    padx=2,
                    pady=2,
                    sticky='n',
                    ) 
#                entryField1.configure(state='normal')
                self.varField1.set(myField)
#                entryField1.configure(state='disable')
# ... field 2
                columnCount+=1
                self.varField2 = StringVar()
                entryField2 = Entry(
                    self.frame_20_EditField,
                    textvariable = self.varField2,
                    width=width_Datatype,
                    relief=SUNKEN,
                    disabledbackground='white',
                    disabledforeground='black',
                    state='disable'
                    )
                entryField2.grid(
                    row=rowCount,
                    column=columnCount,
                    padx=2,
                    pady=2,
                    sticky='n',
                    )
#                entryField2.configure(state='normal')
                self.varField2.set(myDatatype)
#                entryField2.configure(state='disable')
# ... field 3
                columnCount+=1
                self.varField3 = StringVar()
                entryField3 = Entry(
                    self.frame_20_EditField,
                    textvariable = self.varField3,
                    width=width_Null,
                    relief=SUNKEN,
                    disabledbackground='white',
                    disabledforeground='black',
                    state='disable',
                    )
                entryField3.grid(
                    row=rowCount,
                    column=columnCount,
                    padx=2,
                    pady=2,
                    sticky='n',
                    )
#                entryField3.configure(state='normal')
                self.varField3.set(myNull)
#                entryField3.configure(state='disable')
# ... field 4
                columnCount+=1
                self.varField4 = StringVar()
                entryField4 = Entry(
                    self.frame_20_EditField,
                    textvariable = self.varField4,
                    width=width_Key,
                    relief=SUNKEN,
                    disabledbackground='white',
                    disabledforeground='black',
                    state='disable',
                    )
                entryField4.grid(
                    row=rowCount,
                    column=columnCount,
                    padx=2,
                    pady=2,
                    sticky='n',
                    )
#                entryField4.configure(state='normal')
                self.varField4.set(myKey)
#                entryField4.configure(state='disable')
# ... field 5
                columnCount+=1
                self.varField5 = StringVar()
                entryField5 = Entry(
                    self.frame_20_EditField,
                    textvariable=self.varField5,
                    width=width_Default,
                    relief=SUNKEN,
                    disabledbackground='white',
                    disabledforeground='black',
                    state='disable',
                    )
                entryField5.grid(
                    row=rowCount,
                    column=columnCount,
                    padx=2,
                    pady=2,
                    sticky='n',
                    ) 
#                entryField5.configure(state='normal')
                self.varField5.set(myDefault)
#                entryField5.configure(state='disable')
# ... field 6
                columnCount+=1
                self.varField6 = StringVar()
                entryField6 = Entry(
                    self.frame_20_EditField,
                    textvariable = self.varField6,
                    width=width_Extra,
                    relief=SUNKEN,
                    disabledbackground='white',
                    disabledforeground='black',
                    state='disable',
                    )
                entryField6.grid(
                    row=rowCount,
                    column=columnCount,
                    padx=2,
                    pady=2,
                    sticky='n',
                    )
#                entryField6.configure(state='normal')
                self.varField6.set(myExtra)
#                entryField6.configure(state='disable')       

# check if success
        if not success:
# just keep going; leave field blank in 'Edit Field Name' window
            pass
            '''
            stringInvalidField = (
                'Error: an invalid field has been entered, or\n' +
                'the field is blank.\n\n' +
                'Please enter a valid field and try again.'
                )
            self.MySQL_Output(
                1,
                stringInvalidField
                )
            showerror(
                'Error: invalid field',
                stringInvalidField
                )
#            self.toplevelFieldNameEdit.destroy()
            '''
        
        return   
        

    def handlerEditFieldClearField(self,dummyVar):
        '''
        Purpose:
            clear 'select field' in frame toplevelFieldNameEdit

        Called by:
            handlerDatabaseFieldsSelect

        Calls:
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerEditFieldClearField')
            
# clear 'select field'
#        self.mySelectFieldEditField.clear()
        self.varEntryEnterSelectFieldEditFieldName.set('')
        
        return
        

    def handlerFieldName_Keys(self):
        '''
        prints values for selected checkbuttons for MySQL 
          'Primary Key' variables; also sets certain fields to 
          appropriate values

        Called by:
            handlerDefineFieldsForNewTable

        Inputs:
            self.varFieldName_Key

        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerFieldName_Keys')
            
        print(  
            '\n self.varFieldName_Keys.get():'
            )
        valueKey = 0   
        for var in self.varFieldName_Keys:
            print(
                'valueKey = %s, var.get() = %s' % (valueKey,var.get())
                )

# show info to explain above settings
        '''
        showinfo(
            'Info: altered fields',
            '\nNote that the "Options" and "Default Value" fields\n' +
            'for "Key(s)" selections have been auto-filled with\n' +
            '"NOT NULL" and "0".\n\n' +
            'This is required since "Key(s)" values must have\n' +
            'a value to be valid.\n'
            )
        '''
        
        return
        

    def handlerKeyDeselect(self):
        '''
        deselects all Primary Key radiobuttons
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerKeyDeselect')

        for var in self.varFieldName_Keys:
            var.set(0)
        
        return


    def handlerDatabaseTableFunctions(self):
        '''
        Defines functions acting on Tables
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerDatabaseTableFunctions')

# check if connected to a MySQL server
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return   

# check if database has been set
# make sure a database has been selected
        myTable = self.comboboxDbTableSelect.get()
        if not myTable:
            stringNoTable = (
                'Please select both a database and table.\n'
                )
            print '\n' + stringNoTable
            self.MySQL_Output(
                0,
                stringNoTable
                )
            showerror(
                'Error: no table selected',
                '\n' + stringNoTable + '\n'
                )
            return

# FRAMES
# destroy any old toplevel frames
        self.destroyAllDatabaseTableFieldFrames()

# open Toplevel frame for entering database name
        self.toplevelTableFunctions = Toplevel(
#            self.frameParent,
            bg='tan'
            )
        self.toplevelTableFunctions.title(
            'TABLE FUNCTIONS'
            )
        self.toplevelTableFunctions.transient(self.frameParent)
# place the top window
        x_Windows = self.tableFunctions_xWindowLocation
        y_Windows = self.tableFunctions_yWindowLocation
        self.toplevelTableFunctions.geometry(
            '+%d+%d' % (x_Windows, y_Windows)
            )

        self.frame_00_comboboxTableFunctions = Frame(
            self.toplevelTableFunctions,
            bg='tan',
            )
        self.frame_00_comboboxTableFunctions.grid(
            row=0,
            column=0,
            pady=5,
            )
            
        frame_10 = Frame(
            self.toplevelTableFunctions,
            bg='tan',
            )
        frame_10.grid(
            row=1,
            column=0,
            pady=0,
            )
            
        frame_20 = Frame(
            self.toplevelTableFunctions,
            bg='tan',
            )
        frame_20.grid(
            row=2,
            column=0,
            padx=5,
            pady=0,
            )
            
        frame_25 = Frame(
            self.toplevelTableFunctions,
            bg='tan',
            )
        frame_25.grid(
            row=3,
            column=0,
            padx=5,
            pady=0,
            )
            
        frame_30 = Frame(
            self.toplevelTableFunctions,
            bg='tan',
            )
        frame_30.grid(
            row=4,
            column=0,
            padx=5,
            pady=0,
            )

# Cancel            
        frame_99 = Frame(
            self.toplevelTableFunctions,
            bg='tan',
            )
        frame_99.grid(
            row=99,
            column=0,
            padx=5,
            pady=5,
            )
            
# WIDGETS
            
        labelTableFunctionsMain = Label(
            self.frame_00_comboboxTableFunctions,
            text='TABLE FUNCTIONS',
            bg='tan',
            justify=CENTER,
            font=self.labelFontMediumBold,
            )
        labelTableFunctionsMain.grid(
            row=0,
            column=0,
            columnspan=2,
            padx=0,
            pady=10,
            )
            
        labelTableFunctionsSelectDatabase = Label(
            self.frame_00_comboboxTableFunctions,
            text='Current database: ',
            bg='tan',
            justify=RIGHT,
            font=self.labelFontMedium,
            )
        labelTableFunctionsSelectDatabase.grid(
            row=1,
            column=0,
            pady=5,
            sticky=E,
            )
            
# 'current database' entry widget           
        self.varTableFunctionsSelectDatabase = StringVar()
        self.entryTableFunctionsSelectDatabase = Entry(
            self.frame_00_comboboxTableFunctions,
            textvariable=self.varTableFunctionsSelectDatabase,
            borderwidth=2,
            disabledforeground='black',
            disabledbackground='white',
            font=self.labelFontMedium,
            state=DISABLED,
            width=30,
            )
        self.entryTableFunctionsSelectDatabase.grid(
            row=1,
            column=1,
            padx=0,
            pady=1,
            sticky=W,
            )
        self.varTableFunctionsSelectDatabase.set(
            self.comboboxDbSelect.get().strip()
            )
# scrollbar command
# set up horizontal scroll bar; will set up 'command' after widget definition        
        self.entryTableFunctionsSelectDatabase_ScrollX = Scrollbar(
            self.frame_00_comboboxTableFunctions,
            orient=HORIZONTAL,
            width=15,
            command=self.handlerEntryTableFunctionsSelectDatabase,
            )
        self.entryTableFunctionsSelectDatabase_ScrollX.grid(
            row=2,
            column=1,
            padx=0,
            pady=2,
            sticky=E+W,
            )
        self.entryTableFunctionsSelectDatabase.configure(
            xscrollcommand=self.entryTableFunctionsSelectDatabase_ScrollX.set
            )
            
        labelTableFunctionsSelectTable = Label(
            self.frame_00_comboboxTableFunctions,
            text='Current table: ',
            bg='tan',
            justify=RIGHT,
            font=self.labelFontMedium,
            )
        labelTableFunctionsSelectTable.grid(
            row=3,
            column=0,
            pady=5,
            sticky=E,
            )     
           
# ... 'current table' entry widget
        self.varEntryTableFunctionsSelectTable = StringVar()
        self.entryTableFunctionsSelectTable = Entry(
            self.frame_00_comboboxTableFunctions,
            textvariable=self.varEntryTableFunctionsSelectTable,
            borderwidth=2,
            disabledforeground='black',
            disabledbackground='white',
            font=self.labelFontMedium,
            state=DISABLED,
            width=30,
            )
        self.entryTableFunctionsSelectTable.grid(
            row=3,
            column=1,
            padx=0,
            pady=5,
            sticky=W,
            )  
        self.varEntryTableFunctionsSelectTable.set(
            self.comboboxDbTableSelect.get().strip()
            )
            
# set up horizontal scroll bar
        self.entryTableFunctionsSelectTable_ScrollX = Scrollbar(
            self.frame_00_comboboxTableFunctions,
            orient=HORIZONTAL,
            width=15,
            command=self.handlerEntryTableFunctionsSelectTable,
            )
        self.entryTableFunctionsSelectTable_ScrollX.grid(
            row=4,
            column=1,
            padx=0,
            pady=2,
            sticky=E+W,
            )
        self.entryTableFunctionsSelectTable.configure(
            xscrollcommand=self.entryTableFunctionsSelectTable_ScrollX.set
            )  
            
# show values
        self.labelButtonTableFunctionsShowValues = 'Show table'
        self.buttonTableFunctionsShowValues = Button(
            frame_10,
            text=self.labelButtonTableFunctionsShowValues,
            borderwidth=5,
            relief=RAISED,
            justify=CENTER,
            background='white',
            foreground='blue',
            width=20,
            font=self.labelFontMedium,
# if want to download entire table:
#            command=self.handlerTableFunctionsShowValues_Command,
# if want to download only a small portion of a table (useful for large tables especially):
            command=self.handlerTableFunctionsShowValues_Command_Peek,
            )
        self.buttonTableFunctionsShowValues.grid(
            row=0,
            column=0,
            padx=5,
            pady=2,
            )
            
# show structure
        self.buttonTableFunctionsShowStructure = Button(
            frame_10,
            text='Show table structure',
            borderwidth=5,
            relief=RAISED,
            justify=CENTER,
            background='white',
            foreground='blue',
            width=20,
            font=self.labelFontMedium,
            command=self.handlerTableFunctionsShowStructure
            )
        self.buttonTableFunctionsShowStructure.grid(
            row=0,
            column=1,
            padx=5,
            pady=2,
            )
            
# Rename table
        labelTableRenameDashes = Label(
            frame_20,
            text=(
                '\n' +
                '-'*30 +
                '\n'
                ),
            bg='tan',
            justify=RIGHT,
            font=self.labelFontMedium,
            )
        labelTableRenameDashes.grid(
            row=0,
            column=0,
            columnspan=99,
            padx=5,
            pady=0,
            )
            
        labelTableRename = Label(
            frame_20,
            text=(
            'RENAME current table to: '
            ),
            bg='tan',
            justify=RIGHT,
            font=self.labelFontMedium,
            )
        labelTableRename.grid(
            row=1,
            column=0,
            padx=5,
            pady=2,
            sticky=E,
            )

        self.varTableFunctionsRename = StringVar()
        self.varTableFunctionsRename.set('rename__' + self.varEntryTableFunctionsSelectTable.get())
        self.entryTableFunctionsRename = Entry(
            frame_20,
            borderwidth=2,
            relief=SUNKEN,
            textvariable=self.varTableFunctionsRename,
            font=self.labelFontMedium,
            width=30,
            )
        self.entryTableFunctionsRename.grid(
            row=1,
            column=1,
            padx=0,
            pady=5,
            sticky=W,
            )
        self.entryTableFunctionsRename.bind(
            "<KeyPress-Return>",
            self.handlerBindTableFunctionsRename,
            )
# set up horizontal scroll bar
        self.entryTableFunctionsRename_ScrollX = Scrollbar(
            frame_20,
            orient=HORIZONTAL,
            width=15,
            command=self.handlerEntryTableFunctionsRenameCurrentTable,
            )
        self.entryTableFunctionsRename_ScrollX.grid(
            row=2,
            column=1,
            padx=0,
            pady=2,
            sticky=E+W,
            )
        self.entryTableFunctionsRename.configure(
            xscrollcommand=self.entryTableFunctionsRename_ScrollX.set
            )
            
        buttonClearTableFunctionsRename = Button(
            frame_20,
            text='Clear',
            font=self.buttonFontSmallest,
            borderwidth=2,
            relief=RAISED,
            width=8,
            background='white',
            foreground='blue',
            command=self.handlerClearTableFunctionsRename,
            )
        buttonClearTableFunctionsRename.grid(
            row=3,
            column=1,
            padx=5,
            pady=2,
            sticky=N,
            )
         
        self.buttonTableFunctionsRename = Button(
            frame_20,
            text='Rename table',
            borderwidth=5,
            relief=RAISED,
            background='white',
            foreground='blue',
#            font=self.buttonFontSmall,
            font=self.labelFontMedium,
            command=self.handlerTableFunctionsRename,
            width=15,
            )
        self.buttonTableFunctionsRename.grid(
            row=4,
            column=0,
            columnspan=99,
            padx=0,
            pady=5,
            sticky=N,
            )
            
# copy table & contents
        labelSpacer = Label(
            frame_25,
            text=(
                '\n' +
                '-'*30 +
                '\n'
                ),
            bg='tan',
            justify=CENTER,
            font=self.labelFontMedium,
            )
        labelSpacer.grid(
            row=0,
            column=0,
            padx=0,
            pady=2,
            columnspan=99,
            )
            
        labelTableRename1 = Label(
            frame_25,
            text=(
                'COPY current table contents to database: '
                ),
            bg='tan',
            justify=RIGHT,
            font=self.labelFontMedium,
            )
        labelTableRename1.grid(
            row=1,
            column=0,
            padx=2,
            pady=2,
            sticky=E,
            )
            
# ... list all current fields except last one; the auto_index field can NEVER be deleted       
        self.comboboxDatabaseNameCopy = Pmw.ComboBox(
            frame_25,
            scrolledlist_items=self.myDatabases,
            dropdown=1,
            listheight=150,
            entry_borderwidth=2,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            entry_font=self.labelFontMedium,
            entry_width=30,
            scrolledlist_hull_width=500,
            )
        self.comboboxDatabaseNameCopy.grid(
            row=1,
            column=1,
            padx=0,
            pady=2,
            sticky=W,
            )
        self.comboboxDatabaseNameCopy.setentry(
            self.varTableFunctionsSelectDatabase.get().strip()
            )
            
        labelTableRename2 = Label(
            frame_25,
            text=(
                'and use new table name:'
                ),
            bg='tan',
            justify=RIGHT,
            font=self.labelFontMedium,
            )
        labelTableRename2.grid(
            row=2,
            column=0,
            padx=5,
            pady=2,
            sticky=E,
            )

        self.varTableFunctionsCopy = StringVar()
        self.varTableFunctionsCopy.set('copy__' + self.varEntryTableFunctionsSelectTable.get())
        self.entryTableFunctionsCopy = Entry(
            frame_25,
            borderwidth=2,
            relief=SUNKEN,
            textvariable=self.varTableFunctionsCopy,
            font=self.labelFontMedium,
            width=33,
            )
        self.entryTableFunctionsCopy.grid(
            row=2,
            column=1,
            padx=0,
            pady=5,
            sticky=W,
            )
        self.entryTableFunctionsCopy.bind(
            "<KeyPress-Return>",
            self.handlerBindTableFunctionsCopy,
            )
            
# set up horizontal scroll bar
        self.entryTableFunctionsCopy_ScrollX = Scrollbar(
            frame_25,
            orient=HORIZONTAL,
            width=20,
            command=self.handlerEntryTableFunctionsCopy,
            )
        self.entryTableFunctionsCopy_ScrollX.grid(
            row=3,
            column=1,
            padx=0,
            pady=0,
            sticky=E+W,
            )
        self.entryTableFunctionsCopy.configure(
            xscrollcommand=self.entryTableFunctionsCopy_ScrollX.set
            )
            
        buttonClearTableFunctionsCopy = Button(
            frame_25,
            text='Clear',
            font=self.buttonFontSmallest,
            borderwidth=2,
            relief=RAISED,
            width=8,
            background='white',
            foreground='blue',
            command=self.handlerClearTableFunctionsCopy,
            )
        buttonClearTableFunctionsCopy.grid(
            row=4,
            column=1,
            padx=5,
            pady=2,
            sticky=N,
            )
         
        self.buttonTableFunctionsCopy = Button(
            frame_25,
            text='Copy table',
            borderwidth=5,
            relief=RAISED,
            background='white',
            foreground='blue',
#            font=self.buttonFontSmall,
            font=self.labelFontMedium,
            command=self.handlerTableFunctionsCopy,
            width=15,
            )
        self.buttonTableFunctionsCopy.grid(
            row=5,
            column=0,
            columnspan=99,
            padx=0,
            pady=5,
            sticky=N,
            )
                       
# search table
        labelTableFunctionsSearch = Label(
            frame_30,
            text='Search table for: ',
            bg='tan',
            justify=RIGHT,
            font=self.labelFontMedium,
            )
        '''
        labelTableFunctionsSearch.grid(
            row=0,
            column=0,
            padx=5,
            pady=5,
            sticky=E,
            )
        '''
            
        self.varTableFunctionsSearch = StringVar()
        self.varTableFunctionsSearch.set('')
        self.entryTableFunctionsSearch = Entry(
            frame_30,
            borderwidth=2,
            relief=SUNKEN,
            textvariable=self.varTableFunctionsSearch,
            font=self.labelFontMedium,
            )
        '''
        self.entryTableFunctionsSearch.grid(
            row=0,
            column=1,
            padx=5,
            pady=5,
            sticky=W,
            )
        '''
         
        self.buttonTableFunctionsSearch = Button(
            frame_30,
            text='Search*',
            fg='darkgray',
            borderwidth=5,
            relief=RAISED,
#            command=self.handlerTableFunctionsSearch,
            width=10,
            font=self.buttonFontSmall,
            )
        '''
        self.buttonTableFunctionsSearch.grid(
            row=1,
            column=1,
            padx=0,
            pady=0,
            sticky=N,
            )
        '''

# graph Cancel buttons            
        self.buttonTableFunctionsCancel = Button(
            frame_99,
            text='Cancel',
            borderwidth=5,
            relief=RAISED,
            justify=CENTER,
            width=25,
            command=self.handlerTableFunctionsCancelDestroy,
            font=self.labelFontMedium,
            )
        self.buttonTableFunctionsCancel.grid(
            row=0,
            column=0,
            padx=5,
            pady=5,
            ) 
            
        return
        
        
    def handlerEntryTableFunctionsSelectDatabase(self,*args):
        '''
        allows x scrolling of widget
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerEntryTableFunctionsSelectDatabase')
            
#       print '\n ??? for Database widget, args =', args
        op, howMany = args[0], args[1]
        if op == 'scroll':
            units = args[2]
            self.entryTableFunctionsSelectDatabase.xview_scroll(howMany, units)
        elif op == "moveto":
            self.entryTableFunctionsSelectDatabase.xview_moveto(howMany)
        
        return
        
        
    def handlerEntryTableFunctionsSelectTable(self,*args):
        '''
        allows x scrolling of widget
        '''  
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerEntryTableFunctionsSelectTable')
            
#        print '\n ??? for Table widget, args =', args
        op, howMany = args[0], args[1]
        if op == 'scroll':
            units = args[2]
            self.entryTableFunctionsSelectTable.xview_scroll(howMany, units)
        elif op == "moveto":
            self.entryTableFunctionsSelectTable.xview_moveto(howMany)
        
        return
        
        
    def handlerEntryTableFunctionsRenameCurrentTable(self,*args):
        '''
        allows x scrolling of widget
        '''  
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerEntryTableFunctionsRenameCurrentTable')
            
#        print '\n ??? for Table widget, args =', args
        op, howMany = args[0], args[1]
        if op == 'scroll':
            units = args[2]
            self.entryTableFunctionsRename.xview_scroll(howMany, units)
        elif op == "moveto":
            self.entryTableFunctionsRename.xview_moveto(howMany)
        
        return
        
        
    def handlerEntryTableFunctionsUseTableName(self,*args):
        '''
        allows x scrolling of widget
        '''  
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerEntryTableFunctionsUseTableName')
#        print '\n ??? for Table widget, args =', args
        op, howMany = args[0], args[1]
        if op == 'scroll':
            units = args[2]
            self.entryTableFunctionsCopy.xview_scroll(howMany, units)
        elif op == "moveto":
            self.entryTableFunctionsCopy.xview_moveto(howMany)
        
        return
        
        
    def handlerEntryTableFunctionsCopy(self,*args):
        '''
        allows x scrolling of widget
        '''  
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerEntryTableFunctionsCopy')
            
#        print '\n ??? for Table widget, args =', args
        op, howMany = args[0], args[1]
        if op == 'scroll':
            units = args[2]
            self.entryTableFunctionsCopy.xview_scroll(howMany, units)
        elif op == "moveto":
            self.entryTableFunctionsCopy.xview_moveto(howMany)
        
        return
        
        
    def handlerBindTableFunctionsRename(self,event):
        '''
        Purpose:
            invokes the 'Rename' button if 'enter' is pressed during entry
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerBindTableFunctionsRename')
           
        self.buttonTableFunctionsRename.invoke()
        
        return
        
        
    def handlerBindTableFunctionsCopy(self,event):
        '''
        Purpose:
            invokes the button widget to copy a table to new location
            if enter is pressed during entry
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerBindTableFunctionsCopy')
           
        self.buttonTableFunctionsCopy.invoke()
        
        return
        
        
    def handlerBindFieldsForNewTable(self,event):
        '''
        Purpose:
            invokes the button widget to create fields for new table
            if enter is pressed during entry
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerBindFieldsForNewTable')
            
        self.buttonDefineFieldsForNewTable.invoke()
        
        return
        
        
    def handlerBindEnterNewTableName(self,event):
        '''
        Purpose:
            invokes the button widget to create new table
            if enter is pressed during entry
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerBindEnterNewTableName')
           
        self.buttonCreateNewTable.invoke()
        
        return
        
        
    def handlerBindEnterSandboxTableName(self,event):
        '''
        Purpose:
            invokes the button widget to create sandbox table
            if enter is pressed during entry
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerBindEnterSandboxTableName')
           
        self.buttonCreateSandboxTable.invoke()
        
        return
        
    
    def handlerBindDatabaseNameAdd(self,event):
        '''
        Purpose:
            invokes the button widget to create a database
            if enter is pressed during entry
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerBindDatabaseNameAdd')
           
        self.buttonOkEnterDatabaseNameAdd.invoke()
        
        return
        
     
    def handlerBindDatabaseRenameTo(self,event):
        '''
        Purpose:
            invokes the button widget to rename databases
            if enter is pressed during entry
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerBindDatabaseRenameTo')
           
        self.buttonDatabaseRenameTo.invoke()
        
        return
        
        
    def handlerBrowseForBackupDirectory(self):
        '''
        Purpose:
            select filename for backup of database table(s)
        Variables:
            backup dir:         self.varBackupDirName.set(<dirname>)
            backup filename:    self.varBackupFileName.set(<filename>)
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerBrowseForBackupDirectory')
# check connection        
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return
        
        # define dictionary of options for askopenfilename()
        options = {}
        options = {
#            'defaultextension' : '.',
#            'filetypes' : [('mysqldump files','.sql'),('All files','*')],
            'initialdir' : '.',
#            'initialfile' : '',
            'parent' : self.toplevelBackupRestore,
#            'title' : 'Pick backup filename'
            'title' : 'Pick backup directory'
            }      
        
# clear current selection
        self.varBackupDirName.set('')
#        self.varBackupFileName.set('')
# get filename using askopenfilename
#        self.fullpath_FileNameForBackup = tkFileDialog.asksaveasfilename(**options)
#        dirname, filename = os.path.split(self.fullpath_FileNameForBackup)
        dirname = tkFileDialog.askdirectory(**options)
        filename = self.varBackupFileName.get()
        fullpath = dirname + '/' + filename
#        self.dirForBackup = tkFileDialog.askdirectory(**options)
#        dirname, filename = os.path.split(self.fullpath_FileNameForBackup)
#        dirname, filename = os.path.split(asksaveasfilename(**options))
# dwb - NOTE
#   os.path.split(askopenfilename()) gives forward slashes in the filename
#   os.getcwd() gives backward slashes in the filename
#       Hence, one cannot compare the results of these two methods to ensure the user stays in the same directory.
#       Too bad :(
#        if filename == '' and currentFileName == '':
        if dirname == '':
            print '   No directory name chosen for backup!'
            showinfo(
                '\nNo directory name chosen for backup...',
                'You must choose a directory name to continue.\n\n'
                )
            return            
        else:
            print
            print ' dirname =',dirname
            print ' filename =',filename
            print ' full pathname = ',fullpath
            print
            self.varBackupDirName.set(dirname)
#            self.varBackupFileName.set(filename)
        
        return
        
        
    def handlerBackup_Filename(self):
        '''
        Purpose:
            auto-inserts a pre-determined filename for backups into
            self.varBackupFileName
            
        Variables of interest:  
            currentDatabase:    self.varBackupRestoreSelectDatabase.get()
            currentTable:       self.varBackupRestoreSelectTable.get()
            
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerBackup_Filename')
        
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return
        '''
            stringNotConnected = (
                'There is no connection to the MySQL server.\n\n' +
                'Login to a MySQL server and try again.'
                )
            print stringNotConnected
            self.MySQL_Output(
                0,
                stringNotConnected
                )
            showerror(
                'Error: not connected',
                stringNotConnected
                )
            return
        '''
            
        option = self.varSelectBackup_TableFunctions.get()
        currentDatabase = self.varBackupRestoreSelectDatabase.get().strip()
        currentTable = self.varBackupRestoreSelectTable.get().strip()
        currentServer = self.varCurrentServer.get().strip()
        currentServerUsingDot = currentServer.replace('.','Dot')
        
        
        if option == 'all_databases_all_tables':
            self.varBackupFileName.set('')
            self.varBackupFileName.set(
                'backup__' + option + '_from_' + currentServerUsingDot
                )
        
        elif option == 'one_database_all_tables':
            self.varBackupFileName.set('')
# check if database is known
            if currentDatabase == '':
                stringNoDatabase = (
                    'No database has been selected.\n\n' +
                    'Select a database to continue with this backup.'
                    )
                print stringNoDatabase
                self.MySQL_Output(
                    0,
                    stringNoDatabase
                    )
                showerror(
                    'Error: no database selected',
                    stringNoDatabase
                    )
                return
            self.varBackupFileName.set(
                'backup__' + currentDatabase + '_all_tables' + '_from_' + 
                currentServerUsingDot
                )
            
        elif option == 'one_database_one_table':
            self.varBackupFileName.set('')
            if currentDatabase == '' or currentTable == '':
                stringNoData = 'Missing the following:\n\n'
                if currentDatabase == '':
                    stringNoData += (
                        ' - No database has been selected\n\n' 
                        )
                if currentTable == '':
                    stringNoData += (
                        ' - No table has been selected\n\n' 
                        )
                stringNoData += (
                    'Select database and/or table from the main window\n' +
                    'to continue with this backup.'
                    )
                print stringNoData
                self.MySQL_Output(
                    0,
                    stringNoData
                    )
                showerror(
                    'Error: missing data',
                    stringNoData
                    )
                return
            self.varBackupFileName.set(
                'backup__' + currentDatabase + '_' + currentTable + '_from_' + 
                currentServerUsingDot
                )
            
        elif option == 'structure_only':
            self.varBackupFileName.set('')
            if currentDatabase == '' or currentTable == '':
                stringNoData = 'Missing the following:\n\n'
                if currentDatabase == '':
                    stringNoData += (
                        ' - No database has been selected\n\n' 
                        )
                if currentTable == '':
                    stringNoData += (
                        ' - No table has been selected\n\n' 
                        )
                stringNoData += (
                    'Select from the main window to continue with this backup.'
                    )
                print stringNoData
                self.MySQL_Output(
                    0,
                    stringNoData
                    )
                showerror(
                    'Error: missing input',
                    stringNoData
                    )
                return
            self.varBackupFileName.set(
                'backup__' + currentTable + '_structure_only' + '_from_' + 
                currentServerUsingDot
                )
        
        else:
            stringErrorInput = (
                'None of the options for selecting a backup are valid.\n\n' +
                'Contact code administrator with this error.\n\n' +
                'Halting this process...'
                )
            print stringErrorInput
            self.MySQL_Output(
                1,
                stringErrorInput
                )
            showerror(
                'Error: invalid option',
                stringErrorInput
                )
        
        return

 
    def handlerBrowseForRestoreFile(self):
        '''
        Purpose:
            select filename for restore of database table(s)
        Variables:
            restore dir:        self.varRestoreDirName.get()
            restore filename:   self.varRestoreFileName.get()
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerBrowseForRestoreFile')

# check connection
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return
# define dictionary of options for askopenfilename()
        options = {}
        options = {
            'defaultextension' : '.',
            'filetypes' : [('mysqldump files','.sql'),('All files','*')],
            'initialdir' : '.',
            'initialfile' : '',
            'parent' : self.toplevelBackupRestore,
            'title' : 'Pick restore filename'
            }      
# get current filename in entry field
#        currentFileName = self.varEntryPlotFileData_AllCurvesOnePlot.get()
#        print '     Current filename:',currentFileName
        
# clear current selection
        self.varRestoreDirName.set('')
        self.varRestoreFileName.set('')
# get filename using askopenfilename
#        dirname, filename = os.path.split(tkFileDialog.askopenfilename(**options))
        self.fullpath_FileNameForRestore = tkFileDialog.askopenfilename(**options)
        dirname, filename = os.path.split(self.fullpath_FileNameForRestore)
#        dirname, filename = os.path.split(asksaveasfilename(**options))
# dwb - NOTE
#   os.path.split(askopenfilename()) gives forward slashes in the filename
#   os.getcwd() gives backward slashes in the filename
#       Hence, one cannot compare the results of these two methods to ensure the user stays in the same directory.
#       Too bad :(
#        if filename == '' and currentFileName == '':
        if filename == '':
            print '   No filename chosen for restore!'
            showinfo(
                '\nNo filename chosen for restore...',
                'You must enter a filename to continue.\n\n'
                )
            return            
        else:
            print
            print ' dirname =',dirname
            print ' filename =',filename
            print ' full pathname = ',self.fullpath_FileNameForRestore
            print
            self.varRestoreDirName.set(dirname)
            self.varRestoreFileName.set(filename)
        
        return
        
        
    def handlerBackupFile(self):
        '''
        Purpose:
            backup database table(s) using mysqldump utility command
        Variables:
            current database:   self.varTableFunctionsSelectDatabase.get()
            current table:      self.varEntryTableFunctionsSelectTable.get()
            backup dir:         self.varBackupDirName.get()
            backup filename:    self.varBackupFileName.get()
            command selection:  self.varSelectBackup_TableFunctions
                                    'all_databases_all_tables'
                                    'one_database_all_tables'
                                    'one_database_one_table'
                                    'table_structure_only'
                                
            password:           self.varPasswordMySQL_BackupRestore.get()
                                (blank this after using)
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerBackupFile')
            
# check connection
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return
# local variables
#        current_database = self.varTableFunctionsSelectDatabase.get()
        current_database = self.varBackupRestoreSelectDatabase.get().strip()
#        current_table = self.varEntryTableFunctionsSelectTable.get()
        current_table = self.varBackupRestoreSelectTable.get().strip()
        current_server = self._hostMySQL_Save
        dirname = self.varBackupDirName.get().strip()
        filename = self.varBackupFileName.get().strip()
        
# check input params; additional checks done below
        stringInputError = ''
        if (
        (current_database == '' and
          self.varSelectBackup_TableFunctions.get().strip() <> 'all_databases_all_tables')
        or
        dirname == ''
        or
        filename == ''
        or
        current_server == ''
        ):
            if(
            (current_database == '')
            and 
            (self.varSelectBackup_TableFunctions.get().strip() <> 'all_databases_all_tables')
            ):
                stringInputError += (
                    '- Current database'
                    )
            if dirname == '':
                stringInputError += (
                    '- Backup to local directory'
                    )
            if filename == '':
                stringInputError += (
                    '- Backup filename'
                    )
            if current_server == '':
                stringInputError += (
                    '- database server'
                    )
            stringTotal = (
                'The following inputs are missing:\n\n' +
                stringInputError + 
                '\n\n'
                )
            print stringTotal
            showerror(
                'Error: missing input',
                stringTotal
                )
            return
                
# --- end of check ---


# add  "daymonthyear' + '.sql' extension for backup files; the restore process will look for '.sql' files by default
        now = time.localtime(time.time())
        date = time.strftime("%m%d%y_%H%M",now)
        filename += '_' + date + '.sql'
#        fullpath = '.'.join([dirname,filename])
        fullpath = str(dirname + '/' + filename )  # use str() to coerce from unicode back to standard string
        user = self.varUserMySQL_BackupRestore.get().strip()

        passwd = self.varPasswordForBackup.get().strip()       
# reset passwd field, regardless if mysqldump is successful or not
        self.varPasswordForBackup.set('')

        choice = self.varSelectBackup_TableFunctions.get().strip()
        
        if DEBUG_BACKUP:
            print('Backup full path = %s' % fullpath)

# if backup file already exists, give user option to bail
        if os.path.exists(fullpath):
            stringFileExists = (
                'File\n\n' +
                '%s\n\n' +
                'already exists.\n\n' + 
                'If you continue, file will be overwritten.\n\n' +
                'Press OK to continue, Cancel to halt backup.'
                ) % filename
            ans = askokcancel(
                'Question...',
                stringFileExists
                )
            if not ans:
                return
                
# error checks          
        if choice == '' or dirname == '' or filename == '' or user == '' or passwd == '':
            stringInputDataMissing = ''
            stringInputDataMissing = 'The following inputs are missing:\n\n'
            if choice == '':
                stringInputDataMissing += (
                    '   - choice for backup type\n\n'
                    )
            if dirname == '':
                stringInputDataMissing += (
                    '   - local directory name\n'
                    )
            if filename == '':
                stringInputDataMissing += (
                    '   - file name\n'
                    )
            if user == '':
                stringInputDataMissing += (
                    '   - username for current database server\n'
                    )
            if passwd == '':
                stringInputDataMissing += (
                    '   - password for current database server\n'
                    )                   
            stringInputDataMissing += (
                '\nCorrect entries and try again.'
                )

# print results of error check
            print stringInputDataMissing
            showerror(
                'Error: missing entries',
                stringInputDataMissing
                )
            return
# end of checks   
        
# since these commands use the mysqldump utility program, 
#   and since no passwords are stored in PylotDB,
#   passwd must be re-entered
        success = 0
        
# define failure string
        stringFailure = (
            '\nBACKUP could not execute the "mysqldump" command\n' +
            'properly for backing up "%s".\n\n' +
            'The reason is unknown, but could be that\n\n' +
            ' - SSH is not installed\n' +
            ' - The database server is not accepting external connections\n' +
            ' - Server not available at this time\n' +
            ' - Directory or file name for backup is invalid\n' 
            ' - Password is invalid\n\n' 
            )
        
# define initial part of command to run on server
        if current_server == 'localhost' or current_server == '127.0.0.1':
# don't need to ssh
            listCommand = []
        else:
# will need ssh to get to remote machine
            listCommand = ['ssh ' + user + '@' + current_server + ' ']
            stringEnterPasswordForHost = (
                'REQUEST FOR SERVER HOST PASSWORD IN COMMAND WINDOW\n\n' +
                'Unless it cannot be completed due to missing or faulty\n' +
                'parameters, the command used to generate a backup file on a\n' +
                'remote server requires a connection to the server\'s HOST\n' +
                'machine to execute (this is NOT the server password!). This\n' +
                'is for security reasons.\n\n' +
                'The request to enter a Password to the HOST will show\n' +
                'up in the command window.\n\n' +
                'Click OK below, then check the command window and enter your\n' +
                'password to the HOST machine.\n\n' +
                'To cancel this request, click Cancel\n'
                )
                
# +++++++++++++++++++++++++++++++++        
# all databases, all tables
# +++++++++++++++++++++++++++++++++
        if choice == 'all_databases_all_tables':
# send params as list of strings so don't have to worry about special characters
#   REF: http://www.doughellmann.com/PyMOTW/subprocess/
            listCommand.append('mysqldump ')
            listCommand.append('--user=' + user + ' ')
            listCommand.append('--password=' + passwd + ' ')
            listCommand.append('--all-databases' + ' ')
                
            listCommand.append('> ')
            listCommand.append('"' + fullpath + '"')
            
            if DEBUG_BACKUP:
                print(
                    ('\nBackup command "all_databases_all_tables":\n%s\n') 
                    % listCommand
                    )
            

# new way
            '''
                stringCommand = (
                    'mysqldump -u ' + user + ' -p ' + passwd +
                    ' --all-databases' + 
                    ' > ' + fullpath
                    )
            '''

# if remote host, enter password            
            if current_server <> 'localhost' and current_server <> '127.0.0.1':
                print(stringEnterPasswordForHost)
                self.MySQL_Output(
                    0,
                    stringEnterPasswordForHost
                    )
                yes = askokcancel(
                    'INFO: enter password',
                    stringEnterPasswordForHost
                    )
                if not yes:
                    return
            
            
            
# working example of using subprocess.call
# >>> exitStatus = subprocess.call(['ssh dwbarne@oso.sandia.gov','mysqldump', '--u
# ser=dwbarne','--password=d','--databases Demo','>','d:\Temp\myBackupFileDWBfromT
# exas'],shell=True)

            stringListCommand = ''
            for itemNum in range(len(listCommand)):
                stringListCommand += listCommand[itemNum]
            if DEBUG_BACKUP:
                print('\nstringListCommand = \n%s\n' % stringListCommand)
            
            start = time.time()
# if exitStatus = 0, all ok; if exitStatus > 0, error occurred
#            exitStatus = os.system(stringCommand)   
            exitStatus = subprocess.call(stringListCommand, shell=True)
            finish = time.time()
            delta_t = finish - start
            if exitStatus == 0:
                success = 1
            else:
                string1 = stringFailure % ('all databases, all tables')
                print string1
                showerror(
                    'Error: backup',
                    string1
                    )   

# +++++++++++++++++++++++++++++++++ 
# one database, all tables
# +++++++++++++++++++++++++++++++++                  
        elif choice == 'one_database_all_tables':
            listCommand.append('mysqldump ')
            listCommand.append('--user=' + user + ' ')
            listCommand.append('--password=' + passwd + ' ')
            listCommand.append('--databases ')
            listCommand.append(current_database + ' ')
            
            listCommand.append('> ')
            listCommand.append('"' + fullpath + '"')
            
            if DEBUG_BACKUP:
                print(
                    ('\nBackup command "one_database_all_tables":\n%s\n') 
                    % listCommand
                    )
            
                
# new way
            '''
                stringCommand = (
                    'mysqldump -u ' + user + ' -p ' + passwd +
                    ' --databases ' + current_database +
                    ' > ' + fullpath
                    )
            '''
            
# if remote host, enter password            
            if current_server <> 'localhost' and current_server <> '127.0.0.1':
                print(stringEnterPasswordForHost)
                self.MySQL_Output(
                    0,
                    stringEnterPasswordForHost
                    )
                yes = askokcancel(
                    'INFO: enter password',
                    stringEnterPasswordForHost
                    )
                if not yes:
                    return
            
            stringListCommand = ''
            for itemNum in range(len(listCommand)):
                stringListCommand += listCommand[itemNum] + ' '
            print('\nstringListCommand = \n%s\n' % stringListCommand)

            start = time.time()
# if exitStatus = 0, all ok; if exitStatus > 0, error occurred
#            exitStatus = os.system(stringCommand) 
            exitStatus = subprocess.call(stringListCommand, shell=True)
            finish = time.time()
            delta_t = finish - start
            if exitStatus == 0:
                success = 1
            else:
                string2 = stringFailure % ('one database, all tables')
                print string2
                showerror(
                    'Error: backup',
                    string2
                    )

# +++++++++++++++++++++++++++++++++ 
# one database, one table
# +++++++++++++++++++++++++++++++++          
        elif choice == 'one_database_one_table':
            listCommand.append('mysqldump ')
            listCommand.append('--user=' + user + ' ')
            listCommand.append('--password=' + passwd + ' ')
            listCommand.append(current_database + ' ')
            listCommand.append(current_table + ' ')

            listCommand.append('> ')
            listCommand.append('"' + fullpath + '"')
            
            if DEBUG_BACKUP:
                print(
                    ('\nBackup command "one_database_one_table":\n%s\n') 
                    % listCommand
                    )
                    
# new way
            '''
                stringCommand = (
                    'mysqldump -u ' + user + ' -p ' + passwd +
                    ' ' + current_database + ' ' + current_table +
                    ' > ' + fullpath
                    )
            '''
            
# if remote host, enter password            
            if current_server <> 'localhost' and current_server <> '127.0.0.1':
                print(stringEnterPasswordForHost)
                self.MySQL_Output(
                    0,
                    stringEnterPasswordForHost
                    )
                yes = askokcancel(
                    'INFO: enter password',
                    stringEnterPasswordForHost
                    )
                if not yes:
                    return
                    
            stringListCommand = ''
            for itemNum in range(len(listCommand)):
                stringListCommand += listCommand[itemNum] + ' '
            if DEBUG_BACKUP:
                print('\nstringListCommand = \n%s\n' % stringListCommand)

            start = time.time()
# if exitStatus = 0, all ok; if exitStatus > 0, error occurred
#            exitStatus = os.system(stringCommand)
            exitStatus = subprocess.call(stringListCommand, shell=True)
            finish = time.time()
            delta_t = finish - start
            if exitStatus == 0:
                success = 1
# since MySQL does not save the database name with this file, it must
#   be inserted as follows
                inFile = open(fullpath,'rU')
                myFile = inFile.readlines()
                inFile.close()
# ... find "table structure"
                rowCount = 0
                for row in myFile:
                    if '-- Table structure' in row:
                        break
                    if 'Dump completed' in row:
                        stringTableError = (
                            'The following database table appears to be corrupt or faulty:\n\n' +
                            'Database: %s\n' +
                            'Table: %s\n\n' +
                            'The words "DROP TABLE" were not found in the\n' +
                            'table. These are needed for indexing the file\n' +
                            'as to the location in which to insert the command\n' +
                            'to create the database when the table is restored.\n\n' +
                            'Examine the backup file for proper format for a MySQL backup file,\n' +
                            'and try to backup the table again.'
                            )
                        print('\n' + stringTableError)
                        self.MySQL_Output(
                            0,
                            stringTableError
                            )
                        showerror(
                            'Error: improper file format',
                            stringTableError
                            )
                        return
                    rowCount += 1
                    
                if DEBUG_BACKUP:
                    print('\nmyFile, BEFORE added lines:\n')
                    for i,row in enumerate(myFile):
                        print('%s. %s' % (i,row))
                    print('\nrowCount = %s' % rowCount)
                    print('')
# append more elements to myFile to make room for rows added below
                for i in range(9):
                    myFile.append('')
                    
# move all rows (except last 2) down 2 elements to free up location where to 
#   place database creation statement
                rowCountBackwards = len(myFile) - 1
                
                if DEBUG_BACKUP:
                    print('\nrowCountBackwards = %s' % rowCountBackwards)
                    print('rowCount = %s' % rowCount)
                 
                offset = 9
                for i,row in enumerate(myFile[(len(myFile)-1)-offset:rowCount-2:-1]):
                    myFile[rowCountBackwards] = row
                    myFile[rowCountBackwards-offset] = ''
# clear the old value  
                    myFile[rowCountBackwards] 
                    if DEBUG_BACKUP:
                        print('\n%s. %s, %s' % (i,row,rowCountBackwards)) 
                    rowCountBackwards -= 1

                myFile[rowCountBackwards-9] = ' \n'
                myFile[rowCountBackwards-8] = '--\n'
                myFile[rowCountBackwards-7] = '-- Current Database: `' + current_database + '`\n'
                myFile[rowCountBackwards-6] = '--\n'
                myFile[rowCountBackwards-5] = '\n'
                myFile[rowCountBackwards-4] = (
                    'CREATE DATABASE /*!32312 IF NOT EXISTS*/ ' +
                    '`' + current_database + '` ' + '/*!40100 DEFAULT CHARACTER SET latin1 */;\n'
                    )
                myFile[rowCountBackwards-3] = ' \n'
                myFile[rowCountBackwards-2] = 'USE `' + current_database + '`;\n'
                myFile[rowCountBackwards-1] = ' \n'
                
# now write file to disk; overwrite previous file
                outFile = open(fullpath,'w')
                outFile.writelines(myFile)
                outFile.close()
                if DEBUG_BACKUP:
                    outFile1 = open(str(dirname + '/' + 'myFile_copy' ),'w')
                    outFile1.writelines(myFile)
                    outFile.close()
                
                if DEBUG_BACKUP:
                    print('\nmyFile, AFTER added lines:\n')
                    for i,row in enumerate(myFile):
                        print('%s. %s' % (i,row))
                    print('')
                
            else:
                string3 = stringFailure % ('one database, one table')
                print string3
                showerror(
                    'Error: backup',
                    string3
                    ) 

# +++++++++++++++++++++++++++++++++                     
# table structure only
# +++++++++++++++++++++++++++++++++ 
        elif choice == 'structure_only':
            listCommand.append('mysqldump ')
            listCommand.append('--user=' + user + ' ')
            listCommand.append('--password=' + passwd + ' ')
            listCommand.append('--no-data ')
            listCommand.append(current_database + ' ')
            listCommand.append(current_table + ' ')
            
            listCommand.append('> ')
            listCommand.append('"' + fullpath + '"')

            
            if DEBUG_BACKUP:
                print(
                    ('\nBackup command "structure_only":\n%s\n') 
                    % listCommand
                    )
                    
# new way
            '''
                stringCommand = (
                    'mysqldump -u ' + user + ' -p ' + passwd +
                    ' --no-data ' + current_database + ' ' + current_table + 
                    ' > ' + fullpath
                    )
            '''
            
# if remote host, enter password
            if current_server <> 'localhost' and current_server <> '127.0.0.1':
                print(stringEnterPasswordForHost)
                self.MySQL_Output(
                    0,
                    stringEnterPasswordForHost
                    )
                yes = askokcancel(
                    'INFO: enter password',
                    stringEnterPasswordForHost
                    )
                if not yes:
                    return
                    
            stringListCommand = ''
            for itemNum in range(len(listCommand)):
                stringListCommand += listCommand[itemNum] + ' '
            if DEBUG_BACKUP:
                print('\nstringListCommand = \n%s\n' % stringListCommand)
                
            start = time.time()
# if exitStatus = 0, all ok; if exitStatus > 0, error occurred
#            exitStatus = os.system(stringCommand)
            exitStatus = subprocess.call(stringListCommand, shell=True)
            finish = time.time()
            delta_t = finish - start
            if exitStatus == 0:
                success = 1
# since MySQL does not save the database name with this file, it must
#   be inserted as follows
                inFile = open(fullpath,'rU')
                myFile = inFile.readlines()
                inFile.close()
# ... find "DROP TABLE"
                rowCount = 0
                for row in myFile:
                    if '-- Table structure' in row:
                        break
                    if 'Dump completed' in row:
                        stringTableError = (
                            'The following database table appears to be corrupt or faulty:\n\n' +
                            'Database: %s\n' +
                            'Table: %s\n\n' +
                            'The words "DROP TABLE" were not found in the\n' +
                            'table. These are needed for indexing the file\n' +
                            'as to the location in which to insert the command\n' +
                            'to create the database when the table is restored.\n\n' +
                            'Examine the backup file for proper format for a MySQL backup file,\n' +
                            'and try to backup the table again.'
                            )
                        print('\n' + stringTableError)
                        self.MySQL_Output(
                            0,
                            stringTableError
                            )
                        showerror(
                            'Error: improper file format',
                            stringTableError
                            )
                        return
                    rowCount += 1
                    
                if DEBUG_BACKUP:
                    print('\nmyFile, BEFORE added lines:\n')
                    for i,row in enumerate(myFile):
                        print('%s. %s' % (i,row))
                    print('\nrowCount = %s' % rowCount)
                    print('')
# append more elements to myFile to make room for rows added below
                for i in range(9):
                    myFile.append('')                
                    
# move all rows (except last 2) down 2 elements to free up location where to 
#   place database creation statement
                rowCountBackwards = len(myFile) - 1
                
                if DEBUG_BACKUP:
                    print('\nrowCountBackwards = %s' % rowCountBackwards)
                    print('rowCount = %s' % rowCount)
                 
                offset = 9
                for i,row in enumerate(myFile[(len(myFile)-1)-offset:rowCount-2:-1]):
                    myFile[rowCountBackwards] = row
                    myFile[rowCountBackwards-offset] = ''
# clear the old value  
                    myFile[rowCountBackwards] 
                    if DEBUG_BACKUP:
                        print('\n%s. %s, %s' % (i,row,rowCountBackwards)) 
                    rowCountBackwards -= 1

# since this mysql command does not insert a CREATE DATABASE statement, we will do so now,
#   using the database name in which the table currently resides
                myFile[rowCountBackwards-9] = ' \n'
                myFile[rowCountBackwards-8] = '--\n'
                myFile[rowCountBackwards-7] = (
                    '-- Current Database: `' + current_database + '`\n'
                    )
                myFile[rowCountBackwards-6] = '--\n'
                myFile[rowCountBackwards-5] = '\n'
                myFile[rowCountBackwards-4] = (
                    'CREATE DATABASE /*!32312 IF NOT EXISTS*/ ' +
                    '`' + current_database + '` ' + 
                    '/*!40100 DEFAULT CHARACTER SET latin1 */;\n'
                    )
                myFile[rowCountBackwards-3] = ' \n'
                myFile[rowCountBackwards-2] = 'USE `' + current_database + '`;\n'
                myFile[rowCountBackwards-1] = ' \n'
                
# append 'structure_only' to end of filename at each occurrence so that when file is 
#   restored, this file containing only the structure of a table does NOT overwrite 
#   a table with data!!! 
# ... find "Table structure", "DROP TABLE IF EXISTS", and "CREATE TABLE" 
                rowCount = 0
                replaceCount = 0
                ts = '-- Table structure'
                dt = 'DROP TABLE IF EXISTS'
                ct = 'CREATE TABLE'
                for row in myFile:
                    if (ts in row) or (dt in row) or (ct in row):
                        myFile[rowCount] = row.replace(
                            current_table,
                            current_table + '_structure_only'
                            )
                        replaceCount += 1
                    rowCount += 1
                
                if replaceCount == 0:
                    stringErrorReplaceCountZero = (
                        'Structure-only backup filename\n\n' +
                        '   %s\n\n' +
                        'did not contain the table name\n\n' +
                        '   %s\n\n' +
                        'Check the file for proper data and format.'
                        ) % (filename,current_table)
                    print('\n' + stringErrorReplaceCountZero)
                    self.MySQL_Output(
                        0,
                        stringErrorReplaceCountZero
                        )
                    showerror(
                        'Error: improper data or format',
                        stringErrorReplaceCountZero
                        )
                    return
                
# now write file to disk; overwrite previous file
                outFile = open(fullpath,'w')
                outFile.writelines(myFile)
                outFile.close()
                if DEBUG_BACKUP:
                    outFile1 = open(str(dirname + '/' + 'myFile_from_backup_structure_only_copy' ),'w')
                    outFile1.writelines(myFile)
                    outFile.close()
                
                if DEBUG_BACKUP:
                    print('\nmyFile, AFTER added lines:\n')
                    for i,row in enumerate(myFile):
                        print('%s. %s' % (i,row))
                    print('')                
                
            else:
                string4 = stringFailure % ('table structure only')
                print string4
                showerror(
                    'Error: backup',
                    string4
                    ) 
 
 
# error if get here
        else:
            stringErrorUnknown = (
                'Unknown "choice" error in module/method\n\n' +
                MODULE + '/' + 'handlerBackupFile\n\n' +
                'This error should not have happened.\n\n' +
                'Pls send email to code author or contact code administrator.'
                )
            print stringErrorUnknown
            self.MySQL_Output(
                0,
                stringErrorUnknown
                )
            showerror(
                'Error: unknown',
                stringErrorUnknown
                )
            return
            
            
        if success:
# one more check to see if backup file really exists
            if os.path.exists(fullpath):
                stringSuccess = (
                    'Backup was successful!\n\n' +
                    ' - directory:\n' +
                    '     ' + dirname + '\n\n' +
                    ' - filename:\n' +
                    '     ' + filename
                    )
                print stringSuccess
# display in IO window
                self.MySQL_Commands(
                    1,
                    stringSuccess
                    )
                self.MySQL_Commands(
                    0,
                    '  (Time: %-7.4f secs)' % delta_t
                    )
                showinfo(
                    'Info: Success',
                    stringSuccess
                    )
        
        return
        
    
    def handlerRestoreFile(self):
        '''
        Purpose:
            restore database table(s) using "source" command to 
            read a "mysqldump" file
        Variables:
            current database:   self.varTableFunctionsSelectDatabase.get()
            current table:      self.varEntryTableFunctionsSelectTable.get()
            restore dir:        self.varRestoreDirName.get()
            restore filename:   self.varRestoreFileName.get()
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerRestoreFile')
            
# check connection
        self.checkMySQLConnection()
        if self.connectionFlag == 0: 
            print('\n Disconnecting -- self.connectionFlag = %s',self.connectionFlag)
            return
        
        dirname = self.varRestoreDirName.get()
        filename = self.varRestoreFileName.get()
        fullpath = dirname + '/' + filename
        
# checks
        if dirname == '' or filename == '':
            stringInputDataMissing = ''
            stringInputDataMissing = 'The following inputs are missing:\n'
            if dirname == '':
                stringInputDataMissing += (
                    '\n   - directory name\n'
                    )
            if filename == '':
                stringInputDataMissing += (
                    '\n   - file name\n'
                    )
            stringInputDataMissing += (
                '\nCorrect entries and try again.'
                )
# print results of error check
            print stringInputDataMissing
            showerror(
                'Error: missing entries',
                stringInputDataMissing
                )
            return        
# end of checks

# assemble command string
# ... make sure "fullpath" exists
        if os.path.exists(fullpath):
            stringFileExists = (
                'File exists:\n%s\n' 
                ) % fullpath
            print stringFileExists
            self.MySQL_Output(
                0,
                stringFileExists
                )
        else:
            stringFileDoesNotExist = (
                'File\n\n%s\n\ndoes not exist.\n\n' +
                'Reason for not finding this file is unknown.\n\n' +
                'Contact code administrator for help.'
                ) % (fullpath)
            print stringFileDoesNotExist
            self.MySQL_Output(
                1,
                stringFileDoesNotExist
                )
            showerror(
                'Error: file not found',
                stringFileDoesNotExist
                )
            return
            
# read BACKUP file 
#        backupFileName = open(fullpath).read()
#        self.toplevelBackupRestore.update_idletasks()
# update idletasks 
        if DEBUG_RESTORE:
            print('\n fullpath = %s' % fullpath)
            
# use list of strings so don't have to worry about special characters in filename
        listCommand = []
        listCommand.append('SOURCE')
        listCommand.append('"' + str(fullpath) + '"')
        
        stringListCommand = ''
        for itemNum in range(len(listCommand)):
            stringListCommand += listCommand[itemNum] + ' '
        if DEBUG_RESTORE:
            print('\nstringListCommand = \n%s\n' % stringListCommand)
                
        start = time.time() 
# execute commands in file 
        try:
#            self.cursorHandleMySQL.execute(backupFileName)
# execute MySQL command
            self.cursorHandleMySQL.execute(stringListCommand)
        except:
            stringFailed = (
                'Unable to restore database(s) and/or\n' +
                'table(s).\n\n' +
                'Possible reasons:\n' +
                '  - input file name\n' + 
                '      %s\n' +
                '    may have not geen generated using the "mysqldump" command.\n\n' +
                '  - input file is not in text format (uncompress if needed)\n\n' +
                'Otherwise, the reason for the inability to restore is unknown.\n\n'
                ) % filename
            print stringFailed
            self.MySQL_Output(
                0,
                stringFailed
                )
            showerror(
                'Error: restore failed',
                stringFailed
                )
            return
        finish = time.time()
        delta_t = finish - start
        self.MySQL_Commands(
            0,
            '  (Time: %-7.4f secs)' % delta_t
            )  
        myCurrentTable = self.varBackupRestoreSelectTable.get()
        myCurrentDatabase = self.varBackupRestoreSelectDatabase.get()
        
# close file
#        backupFileName.close()

# redo databases and tables list in main window

# ... clear fields
        print('\n>>> Calling self.clearDbFields')
        self.clearDbFields()
        print('   exiting self.clearDbFields')
        
# ... clear tables
        print('\n>>> clear tables')
        self.clearDbTables()
#        print('\n>>> refresh table list')
#        self.refreshTables()

# ... get new tables list
#        print('\n>>> mysql_GetDatabaseTables')
#        self.mysql_GetDatabaseTables()
        print('\n>>> mysql_GetDatabases')
        self.mysql_GetDatabases()
# ... show tables
        print('\n>>> mysql_ComboDatabaseTables')
        self.mysql_ComboDatabaseTables()
#        self.varEnterNewTableName.set('')
#        print('\n>>> comboboxDbTableSelect')
#        self.comboboxDbTableSelect.setentry('')
# get database list
#        print('\n>>> mysql_GetDatabases')
#        self.mysql_GetDatabases()
# list databases
        print('\n>>> mysql_ComboDatabases')
        self.mysql_ComboDatabases()

        
# display in IO window
        stringSuccess = (
            'Restore completed successfully!'
            )
        self.MySQL_Commands(
            1,
            stringSuccess
            )
        self.MySQL_Commands(
            0,
            '  (Elapsed time: %-7.4f secs)' % delta_t
            )
        showinfo(
            'Success',
            stringSuccess
            )
        
        return
        
        
    def handlerRestoreFileUsingSubprocess(self):
        '''
        Purpose:
            restore database table(s) using mysql command line and subprocess.call to 
            read a "mysqldump" file
        Variables:
            current database:   self.varTableFunctionsSelectDatabase.get()
            current table:      self.varEntryTableFunctionsSelectTable.get()
            restore dir:        self.varRestoreDirName.get()
            restore filename:   self.varRestoreFileName.get()
            user:               self.varPasswordMySQL_BackupRestore.get()
            password:           self.varSelectBackup_TableFunctions.get()
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerRestoreFileUsingSubprocess')
        
# check connection
        self.checkMySQLConnection()
        if self.connectionFlag == 0: 
            print('\n Disconnecting -- self.connectionFlag = %s',self.connectionFlag)
            return
        
        dirname = self.varRestoreDirName.get().strip()
        filename = self.varRestoreFileName.get().strip()
        fullpath = dirname + '/' + filename
            
        user = self.varUserMySQL_BackupRestore.get().strip()
        passwd = self.varPasswordForRestore.get().strip()
        self.varPasswordForRestore.set('')
        current_database = self.varBackupRestoreSelectDatabase.get().strip()
        current_server = self._hostMySQL_Save
        selected_database = self.comboboxDbSelect.get().strip()
        
        if DEBUG_RESTORE:
            print('\ndirname = %s' % dirname)
            print('filename = %s' % filename)
            print('fullpath = %s' % fullpath)
            print('user = %s' % user)
            print('passwd = %s' % passwd)
            print('current_database = %s' % current_database)
            print('current_server = %s' % current_server)
            print('selected_database = %s' % selected_database)
        
# checks
        if dirname == '' or filename == '' or passwd == '':
            stringInputDataMissing = ''
            stringInputDataMissing = 'The following inputs are missing:\n'
            if dirname == '':
                stringInputDataMissing += (
                    '\n   - directory name\n'
                    )
            if filename == '':
                stringInputDataMissing += (
                    '\n   - file name\n'
                    )
            if passwd == '':
                stringInputDataMissing += (
                    '\n   - password for current database server\n' +
                    '       (necessary since passwords are never stored)\n'
                    )
            stringInputDataMissing += (
                '\nCorrect entries and try again.'
                )
# print results of error check
            print stringInputDataMissing
            showerror(
                'Error: missing entries',
                stringInputDataMissing
                )
            return        
# end of checks

# parse file for database and table info
# ... determine character of file:
# ...   1. All databases, all tables ==> will have 
# ...       'count_CurrentDatabase = ', multiple values
# ...       'count_TableStructure = ', multiple values 
# ...       'count_DumpingData = ', multiple values
# ...   2. One database, all tables ==> will have 
# ...       'count_CurrentDatabase = ', one value
# ...       'count_TableStructure = ', multiple values
# ...       'count_DumpingData = ', multiple values
# ...   3. One database, one table ==> will have
# ...       'count_CurrentDatabase = ', one value
# ...       'count_TableStructure = ', one value
# ...       'count_DumpingData = ', one value
# ...   4. Table structure only ==> will have
# ...       'count_CurrentDatabase = ', one value
# ...       'count_TableStructure = ', one value
# ...       'count_DumpingData = ', no value
#
# first, open as one string to simplify searches 
        count_CurrentDatabase = 0
        count_TableStructure = 0
        count_DumpingData = 0   
        fileOpen = open(fullpath,'rU')
        fileRestore = fileOpen.read()
        stringFind_CurrentDatabase = 'Current Database:'
        stringFind_TableStructure = 'Table structure for table'
        stringFind_DumpingData = 'Dumping data for table'
        count_CurrentDatabase = fileRestore.count(stringFind_CurrentDatabase)
        count_TableStructure = fileRestore.count(stringFind_TableStructure)
        count_DumpingData = fileRestore.count(stringFind_DumpingData)
        fileOpen.close()
        
        if DEBUG_RESTORE:
            print('\ncount_CurrentDatabase = %s' % count_CurrentDatabase)
            print('count_TableStructure = %s' % count_TableStructure)
            print('count_DumpingData = %s' % count_DumpingData)
            
# define initial part of command to run on server
        if current_server == 'localhost' or current_server == '127.0.0.1':
# don't need to ssh
            listCommand = []
        else:
# will need ssh to get to remote machine
            listCommand = ['ssh ' + user + '@' + current_server + ' ']
            stringEnterPasswordForHost = (
                'REQUEST FOR SERVER HOST PASSWORD IN COMMAND WINDOW\n\n' +
                'Unless it cannot be completed due to missing or faulty\n' +
                'parameters, the command used to generate a backup file on a\n' +
                'remote server requires a connection to the server\'s HOST\n' +
                'machine to execute (this is NOT the server password!). This\n' +
                'is for security reasons.\n\n' +
                'The request to enter a Password to the HOST will show\n' +
                'up in the command window.\n\n' +
                'Click OK below, then check the command window and enter your\n' +
                'password to the HOST machine.\n\n' +
                'To cancel this request, click Cancel\n'
                )
            
            
# +++++++++++++++++++++++++++++++++++++++++++
# logic for 'All databases, all tables'  
# +++++++++++++++++++++++++++++++++++++++++++     
        if(
        (count_CurrentDatabase > 1) 
        and
        (count_TableStructure > 1)
        and
        (count_DumpingData > 1)
        ):
# ... search thru file line by line and extract names using regular expressions
# ... dictDatabasesTablesInFile will have key:[value1,value2,...] for database:[table1,table2,...]
            typeTable = 'All databases, all tables'
            if DEBUG_RESTORE:
                print('\ntypeTable = %s' % typeTable)
            dictDatabasesTablesInFile = {}
# read entire file contents as one string
            fileOpen = open(fullpath,'rU')
            fileRestore = fileOpen.read()
            keyItems = []
# ... find all references to databases
            keyItems = re.findall(stringFind_CurrentDatabase + "\s+\`(\w+)\`", fileRestore)
            fileOpen.close()
            if DEBUG_RESTORE:
                print('\n  keyItems = %s' % keyItems)
#                print('\n  fileRestore:\n%s\n' % fileRestore)

            if len(keyItems) > 1:
                for keyItem in keyItems:
# define a dictionary with multiple keys (database names) with value = empty list 
                    dictDatabasesTablesInFile[keyItem]=[]
# error if no key items (no database names in file)
            elif len(keyItems) == 0:
                stringError_CurrentDatabaseAllTables = (
                    'No database names were found in the table type and restore file:\n\n' +
                    '  typeTable: ' + typeTable + '\n\n' +
                    '   filename: ' + fullpath + '\n\n' +
                    'The file should have multiple database names.\n\n' +
                    'Check file for appropriate values.'
                    )
                print stringError_CurrentDatabaseAllTables
                self.MySQL_Output(
                    0,
                    stringError_CurrentDatabaseAllTables
                    )
                showerror(
                'Error: only one database name',
                stringError_CurrentDatabaseAllTables
                )
                return
# error if only one database name was found; there should be more than one
            else:
                stringError_CurrentDatabaseAllTables = (
                    'Only one database was found in the table type and restore file:\n\n' +
                    '  typeTable: ' + typeTable + '\n\n' +
                    '   filename: ' + fullpath + '\n\n' +
                    'The file should have multiple database names.\n\n' +
                    'Check file for appropriate values.'
                    )
                print stringError_CurrentDatabaseAllTables
                self.MySQL_Output(
                    0,
                    stringError_CurrentDatabaseAllTables
                    )
                showerror(
                'Error: only one database name',
                stringError_CurrentDatabaseAllTables
                )
                return

# read contents of restore file; each line is a string so we can search on each line                
            fileOpen = open(fullpath,'rU')   
            fileRestore = fileOpen.readlines()
            numCountTablesInFile = 0
# ... find database name in a line, if it exists
            for line in fileRestore:
                if line.count(stringFind_CurrentDatabase) <> 0 and len(keyItems) <> 0:
                    keyDbName = re.findall(stringFind_CurrentDatabase + "\s+\`(\w+)\`", line)
                    continue
                if line.count(stringFind_TableStructure) <> 0 and len(keyItems) <> 0:
# ... find table name in a line, if it exists
                    value = re.findall(stringFind_TableStructure + "\s+\`(\w+)\`", line)
                    if DEBUG_RESTORE:
                        print('\nline = %s' % line)
                        print('   keyDbName = %s' % keyDbName)
                        print('   value = %s' % value)
                    dictDatabasesTablesInFile[keyDbName[0]].append(value[0])
                    numCountTablesInFile += 1
            fileOpen.close() 
                    
            print('\nOn the server, current databases are:\n%s' % self.myDatabases)
            
            if DEBUG_RESTORE:
                print('\ndictDatabasesTablesInFile:')
                print(dictDatabasesTablesInFile)
                
# check if any of the databases in file exist on server
            existsDatabaseOnServer = False
            for databaseInFile in dictDatabasesTablesInFile.keys():
                for databaseOnServer in self.myDatabases:
                    if databaseOnServer == databaseInFile:
                        existsDatabaseOnServer = True
            
            currentdbToReturnTo = current_database 
            
            if DEBUG_RESTORE:
                print('\ncurrentdbToReturnTo = %s' % currentdbToReturnTo)
            dictAllDatabasesTables = {}
# iterate over databases to get all table names in each; store in dictionary with
#   format of database:[list of table names]
            numCountTablesInDb = 0
            dbCurrentTables = []
            
# if database exists on server, get info about that database
            if existsDatabaseOnServer:
                for database in self.myDatabases:
# ignore this system database: information_schema
                    if database == 'information_schema':
                        continue
                    stringDbSelect = 'USE' + ' ' + database
                    self.cursorHandleMySQL.execute(stringDbSelect)
                    self.cursorHandleMySQL.execute("SHOW TABLES")
                    tempTables = self.cursorHandleMySQL.fetchall()
                    for table in tempTables:
                        dbCurrentTables.append(table[0]) 
                    dbCurrentTables.sort()
                    numCountTablesInDb += len(dbCurrentTables)
                    if DEBUG_RESTORE:
                        print('\ndbCurrentTables:\n')
                        print(dbCurrentTables)
                    dictAllDatabasesTables[database] = []
                    for list in dbCurrentTables:
                        dictAllDatabasesTables[database].append(list)
                
# go back to original database; if can't execute, clear database selection from main window
            if str(currentdbToReturnTo) <> '':
                stringDbSelect = 'USE' + ' ' + str(currentdbToReturnTo)
                try:
                    self.cursorHandleMySQL.execute(stringDbSelect)
                    if DEBUG_RESTORE:
                        print('\n Command: %s' % stringDbSelect)
                except:
                    if DEBUG_RESTORE:
                        print('\n Could not execute USE <database>; set entry to blank')
                    self.comboboxDbSelect.setentry('')
                    self.clearDbTables()
                    self.clearDbFields()                
            
# compare tables to restore with current tables to inform user of possible conflicts
# ... iterate over database:tables in file
            stringConflicts_0 = ''
            tableCount_Conflicts_Total = 0
            numCounts = 0
            if DEBUG_RESTORE:
                print('\ndictDatabasesTablesInFile:\n%s' % dictDatabasesTablesInFile)
                print('\ndictAllDatabasesTables:\n%s\n' % dictAllDatabasesTables)
            if existsDatabaseOnServer:
                for keyInFile,valuesInFile in dictDatabasesTablesInFile.iteritems():
                    tableCount_Conflicts = 0
                    for keyInDb,valuesInDb in dictAllDatabasesTables.iteritems():
# check if same database
                        if keyInFile == keyInDb:
# if so, check number of tables that match
                            for value in valuesInFile:
                                if value in valuesInDb:
                                    tableCount_Conflicts += 1
                            if tableCount_Conflicts:
                                if numCounts <= 10: # only list the first 10 stats
                                    stringConflicts_0 += (
                                        '\nDatabase "' + keyInDb + '": ' +
                                        str(tableCount_Conflicts) + ' table(s) out of ' + str(len(valuesInDb)) + 
                                        ' total'
                                        )
                                tableCount_Conflicts_Total += tableCount_Conflicts
                                numCounts += 1
                            break
                
# ... print values in readable form
            stringOutput = (
                '\nDatabase and tables from table type and restore file:\n' +
                '  typeTable: ' + typeTable + '\n' +
                '   filename: ' + fullpath + '\n' +
                '---------------------------------------------'
                )
            listKeys = dictDatabasesTablesInFile.keys()
            listKeys.sort()
            for key in listKeys:
                stringOutput += ('\nDatabase: %s' % key)
                values = dictDatabasesTablesInFile[key]
                for num,value in enumerate(values):
                    stringOutput += ('\n  %s. %s' % (num+1, value))
            print('\n' + stringOutput + '\n')
            self.MySQL_Output(
                1,
                stringOutput
                )
                
            stringConflicts = (
                '\nWARNING!\n\n' +
                'You are about to overwrite %s of a total of %s existing non-system table(s).\n\n' +
                'Also, a total of %s new table(s) will be inserted into databases from\n' +
                'the restore file.\n\n' +
                'A list of the database tables that will overwrite existing\n' +
                'tables, if any, is shown in the command and PylotDB I/O windows.\n\n' +
                'A summary of up to the first 10 databases affected is shown below.\n\n' +
                'Click OK to continue, or Cancel to quit this operation.\n\n' +
                '----------------------\n%s'
                ) % (
                tableCount_Conflicts_Total, 
                numCountTablesInDb, 
                numCountTablesInFile - tableCount_Conflicts_Total,
                stringConflicts_0
                )
            print(stringConflicts)
            self.MySQL_Output(
                0,
                stringConflicts
                )
            ans = askokcancel(
                'Warning: overwriting current tables',
                stringConflicts
                )
            if not ans:
                '''
                showinfo(
                'Info: operation canceled',
                'This operation has been canceled.'
                )
                '''
                return

# define listCommand
# ... if local server, won't need ssh
#            if current_server == 'localhost' or current_server == '127.0.0.1':
#                listCommand = []
#            else:
# if remote server, will need ssh to get to remote machine
#                listCommand = ['ssh ' + user + '@' + current_server + ' ']

# append rest of command
            listCommand.append('mysql ')
            listCommand.append('--user=' + user + ' ')
            listCommand.append('--password=' + passwd + ' ')
            listCommand.append('< ')
            listCommand.append('"' + str(fullpath) + '"')
       
# +++++++++++++++++++++++++++++++++++++++++++
# logic for 'Current database, all tables'   
# +++++++++++++++++++++++++++++++++++++++++++           
        elif(
        (count_CurrentDatabase == 1) 
        and
        (count_TableStructure > 0)
        and
        (count_DumpingData > 0)
        ):
            typeTable = 'Current database, all tables'
            if DEBUG_RESTORE:
                print('\ntypeTable = %s' % typeTable)
            dictDatabasesTablesInFile = {}
            fileOpen = open(fullpath,'rU')
            fileRestore = fileOpen.read()
            keyItems = []
            keyItems = re.findall(stringFind_CurrentDatabase + "\s+\`(\w+)\`", fileRestore)
            database = keyItems[0] # it's the only one!
            fileOpen.close()
            if DEBUG_RESTORE:
                print('\n  keyItems = %s' % keyItems)
                print('\n  fileRestore:\n%s\n' % fileRestore)
            if len(keyItems) == 1:
# define a dictionary with a key and empty list (only one key here == database name); 
# ... list values will be tables in the database
                dictDatabasesTablesInFile[keyItems[0]]=[]
            elif len(keyItems) == 0:
                stringError_CurrentDatabaseAllTables = (
                    'No database names were found in the table type and restore file:\n\n' +
                    '  typeTable: ' + typeTable + '\n\n' +
                    '   filename: ' + fullpath + '\n\n' +
                    'The file should have only one database name and at least one table name.\n\n' +
                    'Check file for appropriate values.'
                    )
                print stringError_CurrentDatabaseAllTables
                self.MySQL_Output(
                    0,
                    stringError_CurrentDatabaseAllTables
                    )
                showerror(
                'Error: no database name',
                stringError_CurrentDatabaseAllTables
                )
                return
            else:
                stringError_CurrentDatabaseAllTables = (
                    'More than one database was found in the table type and restore file:\n\n' +
                    '  typeTable: ' + typeTable + '\n\n' +
                    '   filename: ' + fullpath + '\n\n' +
                    'The file should have only one database name and at least one table name.\n\n' +
                    'Check file for appropriate values.'
                    )
                print stringError_CurrentDatabaseAllTables
                self.MySQL_Output(
                    0,
                    stringError_CurrentDatabaseAllTables
                    )
                showerror(
                'Error: too many database names',
                stringError_CurrentDatabaseAllTables
                )
                return
             
            fileOpen = open(fullpath,'rU')   
            fileRestore = fileOpen.readlines()
            numCountTablesInFile = 0
            for line in fileRestore:
                if line.count(stringFind_TableStructure) <> 0 and len(keyItems) <> 0:
# ... find table name
                    value = re.findall(stringFind_TableStructure + "\s+\`(\w+)\`", line)
                    dictDatabasesTablesInFile[keyItems[0]].append(value[0])
                    numCountTablesInFile += 1
            fileOpen.close() 
                    
            print('\nOn the server, current databases are:\n%s' % self.myDatabases)

            if DEBUG_RESTORE:
                print('\ndictDatabasesTablesInFile:')
                print(dictDatabasesTablesInFile)
            
# check if database in file exists on server
            existsDatabaseOnServer = False
            for databaseOnServer in self.myDatabases:
                if database == databaseOnServer:
                    existsDatabaseOnServer = True
            
# save current database to return to after these operations
            currentdbToReturnTo = current_database
            
#            self.cursorHandleMySQL.execute("SELECT DATABASE()")
# if no database is currently selected, the following returns a (None,) one-tuple
#            currentdbToReturnTo = self.cursorHandleMySQL.fetchall() 
            if DEBUG_RESTORE:
                print('\ncurrentdbToReturnTo = %s' % currentdbToReturnTo)
#                print('\ncurrentdbToReturnTo[0] = %s' % currentdbToReturnTo[0])
            dictAllDatabasesTables = {}
            numCountTablesInDb = 0

# if database exists on server, get info about that database            
            if existsDatabaseOnServer:
                stringDbSelect = 'USE' + ' ' + database
                self.cursorHandleMySQL.execute(stringDbSelect)
                self.cursorHandleMySQL.execute("SHOW TABLES")
                tempTables = self.cursorHandleMySQL.fetchall()
                dbCurrentTables = []
                for table in tempTables:
                    dbCurrentTables.append(table[0]) 
                dbCurrentTables.sort()
                
                numCountTablesInDb += len(dbCurrentTables)
                if DEBUG_RESTORE:
                    print('\ndbCurrentTables:\n')
                    print(dbCurrentTables)
                dictAllDatabasesTables[database] = []
                for list in dbCurrentTables:
                    dictAllDatabasesTables[database].append(list)
                    
                if DEBUG_RESTORE:
                    print('\n\ndictAllDatabasesTables:\n')
                    print(dictAllDatabasesTables)
                
# go back to original database; if can't execute, clear database selection from main window     
            if str(currentdbToReturnTo) <> '':
                stringDbSelect = 'USE' + ' ' + str(currentdbToReturnTo)
                try:
                    self.cursorHandleMySQL.execute(stringDbSelect)
                    if DEBUG_RESTORE:
                        print('\n Command: %s' % stringDbSelect)
                except:
                    if DEBUG_RESTORE:
                        print('\n Could not execute USE <database>; set entry to blank')
                        print('    stringDbSelect = %s' % stringDbSelect)
                    self.comboboxDbSelect.setentry('')
                    self.clearDbTables()
                    self.clearDbFields()
            
# compare tables to restore with current tables to inform user of possible conflicts
# ... iterate over database:tables in file
            stringConflicts_0 = ''
            tableCount_Conflicts_Total = 0
            numCounts = 0
            if DEBUG_RESTORE:
                print('\ndictDatabasesTablesInFile:\n%s' % dictDatabasesTablesInFile)
                print('\ndictAllDatabasesTables:\n%s\n' % dictAllDatabasesTables)
            if existsDatabaseOnServer:
                for keyInFile,valuesInFile in dictDatabasesTablesInFile.iteritems():
                    tableCount_Conflicts = 0
                    for keyInDb,valuesInDb in dictAllDatabasesTables.iteritems():
# check if same database
                        if keyInFile == keyInDb:
# if so, check number of tables that match
                            for value in valuesInFile:
                                if value in valuesInDb:
                                    tableCount_Conflicts += 1
                            if tableCount_Conflicts:
                                if numCounts <= 10: # only list the first 10 stats
                                    stringConflicts_0 += (
                                        '\nDatabase "' + keyInDb + '": ' +
                                        str(tableCount_Conflicts) + ' table(s) out of ' + str(len(valuesInDb)) + 
                                        ' total'
                                        )
                                tableCount_Conflicts_Total += tableCount_Conflicts
                                numCounts += 1
                            break
                
# ... print values in readable form
            stringOutput = (
                '\nDatabase and tables from table type and restore file:\n' +
                '  typeTable: ' + typeTable + '\n' +
                '   filename: ' + fullpath + '\n' +
                '---------------------------------------------'
                )
            listKeys = dictDatabasesTablesInFile.keys()
            listKeys.sort()
            for key in listKeys:
                stringOutput += ('\nDatabase: %s' % key)
                values = dictDatabasesTablesInFile[key]
                for num,value in enumerate(values):
                    stringOutput += ('\n  %s. %s' % (num+1, value))
            print('\n' + stringOutput + '\n')
            self.MySQL_Output(
                1,
                stringOutput
                )
                
            stringConflicts = (
                '\nWARNING!\n\n' +
                'You are about to overwrite %s of a total of %s existing non-system table(s) ' +
                'in database "%s".\n\n' +
                'Also, a total of %s new table(s) will be inserted into database.\n\n' +
                'A list of the database tables that will overwrite existing\n' +
                'tables, if any, is shown in the command and PylotDB I/O windows.\n\n' +
                'A summary of up to the first 10 databases affected is shown below.\n\n' +
                'Click OK to continue, or Cancel to quit this operation.\n\n' +
                '----------------------\n%s'
                ) % (
                tableCount_Conflicts_Total, 
                numCountTablesInDb,
                database,
                numCountTablesInFile - tableCount_Conflicts_Total,
                stringConflicts_0
                )
            print(stringConflicts)
            self.MySQL_Output(
                0,
                stringConflicts
                )
            ans = askokcancel(
                'Warning: overwriting current tables',
                stringConflicts
                )
            if not ans:
                '''
                showinfo(
                'Info: operation canceled',
                'This operation has been canceled.'
                )
                '''
                return

# define listCommand
# ... if local server, won't need ssh
#            if current_server == 'localhost' or current_server == '127.0.0.1':
#                listCommand = []
#            else:
# if remote server, will need ssh to get to remote machine
#                listCommand = ['ssh ' + user + '@' + current_server + ' ']

# append rest of command
            listCommand.append('mysql ')
            listCommand.append('--user=' + user + ' ')
            listCommand.append('--password=' + passwd + ' ')
            listCommand.append('< ')
            listCommand.append('"' + fullpath + '"')
            
# +++++++++++++++++++++++++++++++++++++++++++
# logic for 'Current database, current table'  
# +++++++++++++++++++++++++++++++++++++++++++
        elif(
        (count_CurrentDatabase == 1) 
        and
        (count_TableStructure == 1)
        and
        (count_DumpingData == 1)
        ):
            typeTable = 'Current database, current table'
            if DEBUG_RESTORE:
                print('\ntypeTable = %s' % typeTable)
            nameTableInFile = ''
            fileOpen = open(fullpath,'rU')
            fileRestore = fileOpen.read()
            keyItems = []
            keyItems = re.findall(stringFind_CurrentDatabase + "\s+\`(\w+)\`", fileRestore)
            database = keyItems[0] # it's the only one!
            fileOpen.close()
            if DEBUG_RESTORE:
                print('\n  keyItems = %s' % keyItems)
                print('\n  fileRestore:\n%s\n' % fileRestore)
                
            if len(keyItems) == 1:
# all is ok
                pass
            elif len(keyItems) == 0:
# no database name found
                stringError_CurrentDatabaseCurrentTable = (
                    'No database name was found in the table type and restore file:\n\n' +
                    '  typeTable: ' + typeTable + '\n\n' +
                    '   filename: ' + fullpath + '\n\n' +
                    'The file should have only one database name and one table name.\n\n' +
                    'Check file for appropriate values.'
                    )
                print stringError_CurrentDatabaseCurrentTable
                self.MySQL_Output(
                    0,
                    stringError_CurrentDatabaseCurrentTable
                    )
                showerror(
                'Error: no database name',
                stringError_CurrentDatabaseCurrentTable
                )
                return
            else:
                stringError_CurrentDatabaseCurrentTable = (
                    'More than one database was found in the table type and restore file:\n\n' +
                    '  typeTable: ' + typeTable + '\n\n' +
                    '   filename: ' + fullpath + '\n\n' +
                    'The file should have only one database name and one table name.\n\n' +
                    'Check file for appropriate values.'
                    )
                print stringError_CurrentDatabaseCurrentTable
                self.MySQL_Output(
                    0,
                    stringError_CurrentDatabaseCurrentTable
                    )
                showerror(
                'Error: too many database names',
                stringError_CurrentDatabaseCurrentTable
                )
                return
             
            fileOpen = open(fullpath,'rU')   
            fileRestore = fileOpen.readlines()
            numCountTablesInFile = 0
            for line in fileRestore:
                if line.count(stringFind_TableStructure) <> 0 and len(keyItems) <> 0:
# ... find table name
                    value = re.findall(stringFind_TableStructure + "\s+\`(\w+)\`", line)
                    nameTableInFile = value
                    numCountTablesInFile += 1
            fileOpen.close() 
                    
            print('\nOn the server, current databases are:\n%s' % self.myDatabases)

            if DEBUG_RESTORE:
                print('\nnameTableInFile: %s' % nameTableInFile)
            
# check if database in file exists on server
            existsDatabaseOnServer = False
            for databaseOnServer in self.myDatabases:
                if database == databaseOnServer:
                    existsDatabaseOnServer = True
            
# save current database to return to after these operations
            currentdbToReturnTo = current_database
            
#            self.cursorHandleMySQL.execute("SELECT DATABASE()")
# if no database is currently selected, the following returns a (None,) one-tuple
#            currentdbToReturnTo = self.cursorHandleMySQL.fetchall() 
            if DEBUG_RESTORE:
                print('\ncurrentdbToReturnTo = %s' % currentdbToReturnTo)
#                print('\ncurrentdbToReturnTo[0] = %s' % currentdbToReturnTo[0])
            dictAllDatabasesTables = {}
            numCountTablesInDb = 0

# if database exists on server, get info about that database            
            if existsDatabaseOnServer:
                stringDbSelect = 'USE' + ' ' + database
                self.cursorHandleMySQL.execute(stringDbSelect)
                self.cursorHandleMySQL.execute("SHOW TABLES")
                tempTables = self.cursorHandleMySQL.fetchall()
# change 'tempTables' from tuple to list 'dbCurrentTables'
                dbCurrentTables = []
                for table in tempTables:
                    dbCurrentTables.append(table[0]) 
                dbCurrentTables.sort()
                
                numCountTablesInDb += len(dbCurrentTables)
                if DEBUG_RESTORE:
                    print('\ndbCurrentTables:\n')
                    print(dbCurrentTables)
                dictAllDatabasesTables[database] = []
                for list in dbCurrentTables:
                    dictAllDatabasesTables[database].append(list)
                    
                if DEBUG_RESTORE:
                    print('\n\ndictAllDatabasesTables:\n')
                    print(dictAllDatabasesTables)
                
# go back to original database; if can't execute, clear database selection from main window
            if str(currentdbToReturnTo) <> '':
                stringDbSelect = 'USE' + ' ' + str(currentdbToReturnTo)
                try:
                    self.cursorHandleMySQL.execute(stringDbSelect)
                    if DEBUG_RESTORE:
                        print('\n Command: %s' % stringDbSelect)
                except:
                    if DEBUG_RESTORE:
                        print('\n Could not execute USE <database>; set entry to blank')
                        print('    stringDbSelect = %s' % stringDbSelect)
                    self.comboboxDbSelect.setentry('')
                    self.clearDbTables()
                    self.clearDbFields()
            
# compare tables to restore with current tables to inform user of possible conflicts
# ... iterate over database:tables in file
            stringConflicts_0 = ''
            tableCount_Conflicts_Total = 0
            numCounts = 0
            if DEBUG_RESTORE:
                print('\nnameTableInFile:\n%s' % nameTableInFile)
                print('\ndictAllDatabasesTables:\n%s\n' % dictAllDatabasesTables)
            if existsDatabaseOnServer:
                keyInFile = database
                valueInFile  = nameTableInFile
                tableCount_Conflicts = 0
                for keyInDb,valuesInDb in dictAllDatabasesTables.iteritems():
# check if same database
                    if keyInFile == keyInDb:
# if so, check number of tables that match

                        if valueInFile in valuesInDb:
                            tableCount_Conflicts += 1
                    if tableCount_Conflicts:
                        if numCounts <= 10: # only list the first 10 stats
                            stringConflicts_0 += (
                                '\nDatabase "' + keyInDb + '": ' +
                                str(tableCount_Conflicts) + ' table(s) out of ' + str(len(valuesInDb)) + 
                                ' total'
                                )
                        tableCount_Conflicts_Total += tableCount_Conflicts
                        numCounts += 1
                    break
                
# ... print values in readable form
            stringOutput = (
                '\nDatabase and tables from table type and restore file:\n' +
                '  typeTable: ' + typeTable + '\n' +
                '   filename: ' + fullpath + '\n' +
                '---------------------------------------------'
                )
            stringOutput += ('\nDatabase: %s' % database)
            stringOutput += ('\n  %s. %s' % (1, nameTableInFile))
            print('\n' + stringOutput + '\n')
            self.MySQL_Output(
                1,
                stringOutput
                )
                
            stringConflicts = (
                '\nWARNING!\n\n' +
                'You are about to overwrite %s of a total of %s existing non-system table(s) ' +
                'in database "%s".\n\n' +
                'Also, a total of %s new table(s) will be inserted into database.\n\n' +
                'A list of the database tables that will overwrite existing\n' +
                'tables, if any, is shown in the command and PylotDB I/O windows.\n\n' +
                'A summary of up to the first 10 databases affected is shown below.\n\n' +
                'Click OK to continue, or Cancel to quit this operation.\n\n' +
                '----------------------\n%s'
                ) % (
                tableCount_Conflicts_Total, 
                numCountTablesInDb,
                database,
                numCountTablesInFile - tableCount_Conflicts_Total,
                stringConflicts_0
                )
            print(stringConflicts)
            self.MySQL_Output(
                0,
                stringConflicts
                )
            ans = askokcancel(
                'Warning: overwriting current tables',
                stringConflicts
                )
            if not ans:
                '''
                showinfo(
                'Info: operation canceled',
                'This operation has been canceled.'
                )
                '''
                return

# define listCommand
# ... if local server, won't need ssh
#            if current_server == 'localhost' or current_server == '127.0.0.1':
#                listCommand = []
#            else:
# if remote server, will need ssh to get to remote machine
#                listCommand = ['ssh ' + user + '@' + current_server + ' ']

# append rest of command
            listCommand.append('mysql ')
            listCommand.append('--user=' + user + ' ')
            listCommand.append('--password=' + passwd + ' ')
            listCommand.append('< ')
            listCommand.append('"' + fullpath + '"')
            
# +++++++++++++++++++++++++++++++++++++++++++
# logic for 'Table structure only'
# +++++++++++++++++++++++++++++++++++++++++++
        elif(
        (count_CurrentDatabase == 1) 
        and
        (count_TableStructure == 1)
        and
        (count_DumpingData == 0)
        ):
            typeTable = 'Table structure only'
            if DEBUG_RESTORE:
                print('\ntypeTable = %s' % typeTable)
            nameTableInFile = ''
            fileOpen = open(fullpath,'rU')
            fileRestore = fileOpen.read()
            keyItems = []
            keyItems = re.findall(stringFind_CurrentDatabase + "\s+\`(\w+)\`", fileRestore)
            database = keyItems[0] # it's the only one!
            fileOpen.close()
            if DEBUG_RESTORE:
                print('\n  keyItems = %s' % keyItems)
                print('\n  fileRestore:\n%s\n' % fileRestore)
                
            if len(keyItems) == 1:
# all is ok
                pass
            elif len(keyItems) == 0:
# no database name found
                stringError_CurrentDatabaseCurrentTable = (
                    'No database name was found in the table type and restore file:\n\n' +
                    '  typeTable: ' + typeTable + '\n\n' +
                    '   filename: ' + fullpath + '\n\n' +
                    'The file should have only one database name and one table name.\n\n' +
                    'Check file for appropriate values.'
                    )
                print stringError_CurrentDatabaseCurrentTable
                self.MySQL_Output(
                    0,
                    stringError_CurrentDatabaseCurrentTable
                    )
                showerror(
                'Error: no database name',
                stringError_CurrentDatabaseCurrentTable
                )
                return
            else:
                stringError_CurrentDatabaseCurrentTable = (
                    'More than one database was found in the table type and restore file:\n\n' +
                    '  typeTable: ' + typeTable + '\n\n' +
                    '   filename: ' + fullpath + '\n\n' +
                    'The file should have only one database name and one table name.\n\n' +
                    'Check file for appropriate values.'
                    )
                print stringError_CurrentDatabaseCurrentTable
                self.MySQL_Output(
                    0,
                    stringError_CurrentDatabaseCurrentTable
                    )
                showerror(
                'Error: too many database names',
                stringError_CurrentDatabaseCurrentTable
                )
                return
             
            fileOpen = open(fullpath,'rU')   
            fileRestore = fileOpen.readlines()
            numCountTablesInFile = 0
            for line in fileRestore:
                if line.count(stringFind_TableStructure) <> 0 and len(keyItems) <> 0:
# ... find table name
                    value = re.findall(stringFind_TableStructure + "\s+\`(\w+)\`", line)
                    nameTableInFile = value
                    numCountTablesInFile += 1
            fileOpen.close() 
                    
            print('\nOn the server, current databases are:\n%s' % self.myDatabases)

            if DEBUG_RESTORE:
                print('\nnameTableInFile: %s' % nameTableInFile)
            
# check if database in file exists on server
            existsDatabaseOnServer = False
            for databaseOnServer in self.myDatabases:
                if database == databaseOnServer:
                    existsDatabaseOnServer = True
            
# save current database to return to after these operations
            currentdbToReturnTo = current_database
            
#            self.cursorHandleMySQL.execute("SELECT DATABASE()")
# if no database is currently selected, the following returns a (None,) one-tuple
#            currentdbToReturnTo = self.cursorHandleMySQL.fetchall() 
            if DEBUG_RESTORE:
                print('\ncurrentdbToReturnTo = %s' % currentdbToReturnTo)
#                print('\ncurrentdbToReturnTo[0] = %s' % currentdbToReturnTo[0])
            dictAllDatabasesTables = {}
            numCountTablesInDb = 0

# if database exists on server, get info about that database            
            if existsDatabaseOnServer:
                stringDbSelect = 'USE' + ' ' + database
                self.cursorHandleMySQL.execute(stringDbSelect)
                self.cursorHandleMySQL.execute("SHOW TABLES")
                tempTables = self.cursorHandleMySQL.fetchall()
# change 'tempTables' from tuple to list 'dbCurrentTables'
                dbCurrentTables = []
                for table in tempTables:
                    dbCurrentTables.append(table[0]) 
                dbCurrentTables.sort()
                
                numCountTablesInDb += len(dbCurrentTables)
                if DEBUG_RESTORE:
                    print('\ndbCurrentTables:\n')
                    print(dbCurrentTables)
                dictAllDatabasesTables[database] = []
                for list in dbCurrentTables:
                    dictAllDatabasesTables[database].append(list)
                    
                if DEBUG_RESTORE:
                    print('\n\ndictAllDatabasesTables:\n')
                    print(dictAllDatabasesTables)
                
# go back to original database; if can't execute, clear database selection from main window   
            if str(currentdbToReturnTo) <> '':
                stringDbSelect = 'USE' + ' ' + str(currentdbToReturnTo)
                try:
                    self.cursorHandleMySQL.execute(stringDbSelect)
                    if DEBUG_RESTORE:
                        print('\n Command: %s' % stringDbSelect)
                except:
                    if DEBUG_RESTORE:
                        print('\n Could not execute USE <database>; set entry to blank')
                        print('    stringDbSelect = %s' % stringDbSelect)
                    self.comboboxDbSelect.setentry('')
                    self.clearDbTables()
                    self.clearDbFields()
            
# compare tables to restore with current tables to inform user of possible conflicts
# ... iterate over database:tables in file
            stringConflicts_0 = ''
            tableCount_Conflicts_Total = 0
            numCounts = 0
            if DEBUG_RESTORE:
                print('\nnameTableInFile:\n%s' % nameTableInFile)
                print('\ndictAllDatabasesTables:\n%s\n' % dictAllDatabasesTables)
            if existsDatabaseOnServer:
                keyInFile = database
                valueInFile  = nameTableInFile
                tableCount_Conflicts = 0
                for keyInDb,valuesInDb in dictAllDatabasesTables.iteritems():
# check if same database
                    if keyInFile == keyInDb:
# if so, check number of tables that match

                        if valueInFile in valuesInDb:
                            tableCount_Conflicts += 1
                    if tableCount_Conflicts:
                        if numCounts <= 10: # only list the first 10 stats
                            stringConflicts_0 += (
                                '\nDatabase "' + keyInDb + '": ' +
                                str(tableCount_Conflicts) + ' table(s) out of ' + str(len(valuesInDb)) + 
                                ' total'
                                )
                        tableCount_Conflicts_Total += tableCount_Conflicts
                        numCounts += 1
                    break
                
# ... print values in readable form
            stringOutput = (
                '\nDatabase and tables from table type and restore file:\n' +
                '  typeTable: ' + typeTable + '\n' +
                '   filename: ' + fullpath + '\n' +
                '---------------------------------------------'
                )
            stringOutput += ('\nDatabase: %s' % database)
            stringOutput += ('\n  %s. %s' % (1, nameTableInFile))
            print('\n' + stringOutput + '\n')
            self.MySQL_Output(
                1,
                stringOutput
                )
                
            stringConflicts = (
                '\nWARNING!\n\n' +
                'You are about to overwrite %s of a total of %s existing non-system table(s) ' +
                'in database "%s".\n\n' +
                'Also, a total of %s new table(s) will be inserted into database.\n\n' +
                'A list of the database tables that will overwrite existing\n' +
                'tables, if any, is shown in the command and PylotDB I/O windows.\n\n' +
                'A summary of up to the first 10 databases affected is shown below.\n\n' +
                'Click OK to continue, or Cancel to quit this operation.\n\n' +
                '----------------------\n%s'
                ) % (
                tableCount_Conflicts_Total, 
                numCountTablesInDb,
                database,
                numCountTablesInFile - tableCount_Conflicts_Total,
                stringConflicts_0
                )
            print(stringConflicts)
            self.MySQL_Output(
                0,
                stringConflicts
                )
            ans = askokcancel(
                'Warning: overwriting current tables',
                stringConflicts
                )
            if not ans:
                '''
                showinfo(
                'Info: operation canceled',
                'This operation has been canceled.'
                )
                '''
                return

# define listCommand
# ... if local server, won't need ssh
#            if current_server == 'localhost' or current_server == '127.0.0.1':
#                listCommand = []
#            else:
# if remote server, will need ssh to get to remote machine
#                listCommand = ['ssh ' + user + '@' + current_server + ' ']

# append rest of command
            listCommand.append('mysql ')
            listCommand.append('--user=' + user + ' ')
            listCommand.append('--password=' + passwd + ' ')
            listCommand.append('< ')
            listCommand.append('"' + fullpath + '"')
        
# no correct set of options found
        else:
            stringNoCorrectOptionsFound = (
                'The following values have no corresponding coding:\n\n' +
                '   count_CurrentDatabase = %s\n' +
                '   count_TableStructure = %s\n' +
                '   count_DumpingData = %s\n\n' +
                'Check the input file for proper data and format.'
                ) % (count_CurrentDatabase,count_TableStructure,count_DumpingData)
            print('\n' + stringNoCorrectOptionsFound)
            self.MySQL_Output(
                0,
                stringNoCorrectOptionsFound
                )
            showerror(
                'Error: no correct options found',
                stringNoCorrectOptionsFound
                )
            return
            
# ------- END of forming RESTORE command ----------

      
# submit command to server using subprocess.call
        success = 0 
        if DEBUG_RESTORE:
            print(
                ('\nRestore command:\n%s\n') 
                % listCommand
                )
                
        stringListCommand = ''
        for itemNum in range(len(listCommand)):
            stringListCommand += listCommand[itemNum] + ' '
        if DEBUG_RESTORE:
            print('\nstringListCommand = \n%s\n' % stringListCommand)
            
# inform user that password is being requested if stringListCommand has ssh in it
# if remote host, enter password            
        if current_server <> 'localhost' and current_server <> '127.0.0.1':
            print(stringEnterPasswordForHost)
            self.MySQL_Output(
                0,
                stringEnterPasswordForHost
                )
            yes = askokcancel(
                'INFO: enter password',
                stringEnterPasswordForHost
                )
            if not yes:
                return

        start = time.time()
# if exitStatus = 0, all ok; if exitStatus > 0, error occurred
#   exitStatus = os.system(stringCommand)
        exitStatus = subprocess.call(stringListCommand, shell=True)
        finish = time.time()
        delta_t = finish - start
        if exitStatus == 0:
            success = 1
        else:
# define failure string for when RESTORE cannot execute command
            stringFailure = (
                'RESTORE could not execute the "mysql" command\n' +
                'properly for restoring from file\n' +
                '"%s".\n\n' +
                'The reason is unknown, but could be that\n' +
                ' - A password may not have been entered or may be wrong\n' +
                ' - If remote access is needed, SSH may not be installed on this machine\n' +
                ' - The database server is not accepting external connections\n' +
                ' - Server not available at this time\n' +
                ' - The database requested does not exist\n' +
                ' - The "mysql" command is pointing to a wrong or non-existing path'
                )
            string1 = stringFailure % fullpath
            print string1
            showerror(
                'Error: restore',
                string1
                )
            return

        delta_t = finish - start
        self.MySQL_Commands(
            0,
            '  (Time: %-7.4f secs)' % delta_t
            )  
        myCurrentTable = self.varBackupRestoreSelectTable.get()
        myCurrentDatabase = self.varBackupRestoreSelectDatabase.get()

# redo databases and tables list in main window, since
#   a restore has taken place, and selections may have changed

# ... clear fields
        if DEBUG_RESTORE:
            print('\n>>> Clear fields, calling self.clearDbFields')
        self.clearDbFields()
        
# ... clear tables
        if DEBUG_RESTORE:
            print('\n>>> clear tables, calling self.clearDbTables')
        self.clearDbTables()
# ... refresh list
#        self.refreshTables()
# ... get new tables list
#        self.mysql_GetDatabasesTables()
# ... clear selection
#        self.varEnterNewTableName.set('')
# ... set entry
#        self.comboboxDbTableSelect.setentry(current_table)
# ... get new list of databases
        self.mysql_GetDatabases()

# list databases
        if DEBUG_RESTORE:
            print('\n>>> List databases, calling self.mysql_ComboDatabases')
        self.mysql_ComboDatabases()
# invoke the selected database
        if DEBUG_RESTORE:
            print('\n  selected_database = %s' % selected_database)
        if selected_database <> '':
            self.comboboxDbSelect.selectitem(selected_database)
# ... update tables if a database was selected
            try:
                self.cursorHandleMySQL.execute("SHOW TABLES FROM " + selected_database)
                tempTables = self.cursorHandleMySQL.fetchall()
                self.myDatabaseTables = []
                for table in tempTables:
                    self.myDatabaseTables.append(table[0]) 
                self.myDatabaseTables.sort()
                    
                if DEBUG_RESTORE:
                    print('\n>>> Show tables, calling self.mysql_ComboDatabaseTables')
                self.mysql_ComboDatabaseTables()
            except:
                pass
        else:
            self.comboboxDbSelect.setentry('')
            
# display in IO window
        stringSuccess = (
            'Restore completed successfully!'
            )
        self.MySQL_Commands(
            1,
            stringSuccess
            )
        self.MySQL_Commands(
            0,
            '  (Elapsed time: %-7.4f secs)' % delta_t
            )
        showinfo(
            'Success',
            stringSuccess
            )
        
        return
        
        
    def handlerTableFunctionsCancelDestroy(self):
        '''
        Purpose:
            save location for next time; close the Table Functions window
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerTableFunctionsCancelDestroy')

# save location for next time window is opened
        self.tableFunctions_xWindowLocation = \
            self.toplevelTableFunctions.winfo_rootx() - self.offsetWindowX
        self.tableFunctions_yWindowLocation = \
            self.toplevelTableFunctions.winfo_rooty() - self.offsetWindowY

# destroy current toplevel            
        self.toplevelTableFunctions.destroy()
        
        return  
                
                
                
                
            
        self.toplevelTableFunctions.destroy()
        
        return
        
        
    def handlerBackupRestoreCancel(self):
        '''
        Purpose:
            exit the Table Functions window
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerBackupRestoreCancel')
            
# save window location to open in last known location
        self.backuprestore_xWindowLocation = \
            self.toplevelBackupRestore.winfo_rootx() - self.offsetWindowX
        self.backuprestore_yWindowLocation = \
            self.toplevelBackupRestore.winfo_rooty() - self.offsetWindowY
# destroy window
        self.toplevelBackupRestore.destroy()
        
        return
        
            
    def handlerTableFunctionsRename(self):
        '''
        Purpose:
            rename a table
            
        Called by:
            handlerDatabaseTableFunctions
            
        Inputs:
            
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerTableFunctionsRename')
        
# check server connection
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return

# get names
#        myDatabase = self.comboboxDbSelect.get().strip()
        myDatabase = self.varTableFunctionsSelectDatabase.get().strip()
        myNewName = self.varTableFunctionsRename.get().strip()
#        myOldName = self.comboboxDbTableSelect.get().strip()
        myOldName = self.varEntryTableFunctionsSelectTable.get().strip()
        
# check if entry field is populated
        if not myNewName:
            self.MySQL_Output(
                1,
                'Error: invalid rename field\n' +
                'The rename field is blank. Please enter\n' +
                'a unique table name for renaming selected table.'
                )
            showerror(
                'Error: invalid rename field',
                '\nThe rename field is blank. Please enter\n' +
                'a unique table name for renaming selected table.\n\n'
                )
            return
        if not myOldName:
            self.MySQL_Output(
                1,
                'Error: invalid table\n' +
                'The "Select table" field is blank. Please select\n' +
                'an existing table.'
                )
            showerror(
                'Error: invalid table',
                '\nThe "Select table" field is blank. Please select\n' +
                'an existing table.\n\n'
                )
            return
            
# check for duplicate names
        if myOldName == myNewName:
            stringErrorDuplicateNames = (
                'The new table name is identical to old name.\n\n' +
                'Enter a unique name to rename table and try again.'
                )
            self.MySQL_Output(
                1,
                stringErrorDuplicateNames
                )
            showerror(
                'Error: duplicate name',
                stringErrorDuplicateNames
                )
            return
            
# check if new table name has more than one word
        if len(myNewName.split()) > 1:
            stringErrorBadTableName = (
                'The table new name either has spaces or\n' +
                'is somehow in the wrong format.\n\n' +
                'Enter new table name with no spaces and\n' +
                'no special characters (use underscore instead\n'+
                'of spaces, for example) and try again.'
                )
            self.MySQL_Output(
                1,
                stringErrorBadTableName
                )
            showerror(
                'Error: bad table name',
                stringErrorBadTableName
                )
            return
                
# check if 'rename' table already exists
        self.MySQL_Output(
            1,
            'Checking database tables to see if new table name already exists.'
            )
        self.MySQL_Output(
            1,
            '  New table name: ' + myNewName
            )
        for myTable in self.myDatabaseTables:
            self.MySQL_Output(
                1,
                '     checking table ' + myTable
                )
            if myNewName == myTable:
                self.MySQL_Output(
                    1,
                    'This table already exists!\n'
                    )
                showerror(
                    'Error: table exists',
                    'This rename table already exists!\n' +
                    'The table CANNOT be renamed.\n\n' +
                    'To rename a table, enter a unique\n' + 
                    'name in the entry field and try again.\n\n' 
                    )
                return   

# make sure select table name exists
        self.MySQL_Output(
            1,
            'Checking old database name to make sure it exists.' + '\n' +
            ' Old table name: ' + myOldName
            )
        for myTable in self.myDatabaseTables:
            self.MySQL_Output(
                1,
                '    checking table ' + myTable
                )
            if myTable == myOldName:
# change name of table
                stringRenameTable = (
                    'ALTER TABLE' + ' ' + myDatabase + '.' + myOldName +
                    ' ' + 'RENAME' + ' ' + myDatabase + '.' + myNewName
                    )
                self.MySQL_Commands(
                    1,
                    'self.cursorHandleMySQL.execute("' + stringRenameTable + '")'
                    )
                start = time.time()
                try:
                    self.cursorHandleMySQL.execute(
                        stringRenameTable
                        )
                except:
                    stringFailureRename = (
                        'Table\n\n' + 
                        '%s\n\n' + 
                        'could not be renamed to\n\n' +
                        '%s\n\n' +
                        'Possible reasons:\n' +
                        '   - special characters in the new name\n' +
                        '   - incorrect table name format\n' +
                        '   - table names must be <= 64 characters in length\n' +
                        '   - old table does not exist (deleted between commands)\n\n' +
                        'Correct is possible and try again.'
                        ) % (myOldName,myNewName)
                    print stringFailureRename
                    self.MySQL_Output(
                        0,
                        stringFailureRename
                        )
                    showerror(
                        'Error: rename failure',
                        stringFailureRename
                        )
                    return
                finish = time.time()
                delta_t = finish - start
                self.MySQL_Commands(
                    0,
                    '  (Time: %-7.4f secs)' % delta_t
                    )
# redo tables list in main window and in toplevel window
# ... clear fields
                self.clearDbFields()
# ... relist tables in main window
                self.refreshTables()
                self.mysql_ComboDatabaseTables()
                self.comboboxDbTableSelect.selectitem(myNewName)
                self.refreshFields()
# ... regrid 'Table Functions' window
#                self.comboboxTableFunctionsSelectTable.clear()
                self.varTableFunctionsRename.set('')
                self.varEntryTableFunctionsSelectTable.set(myNewName)
                self.handlerDatabaseTableFunctions()
                return
                
# if get this far, no match was found
        self.MySQL_Output(
            1,
            'Error: no table match found. Please check\n' +
            '  all table entry widgets and try again.'
            )
        showerror(
            'Error: no table match',
            '\nNo table match was found. Please check\n' + 
            '  all table entry widgets and try again.\n\n'
            )
        
        return
        

    def handlerTableFunctionsShowStructure(self):
        '''
        display structure of a selected table
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerTableFunctionsShowStructure')
        
# check if connected to a MySQL server
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return   
        
        '''
        myTable = self.comboboxTableFunctionsSelectTable.get()
        '''
        myTable = self.comboboxDbTableSelect.get().strip()
        myDatabase = self.comboboxDbSelect.get().strip()
        if (
            myTable == '' or
            myDatabase == ''
            ):
            stringError = '\nThe TABLE FUNCTION fields need values:\n\n'
            if myDatabase == '':
                stringError += ' "Select database:"\n\n'
            if myTable == '':
                stringError += ' "Select table:"\n\n'
            stringError += 'Please select values and try again.'
            self.MySQL_Output(
                1,
                stringError
                )
            showerror(
                'Error: missing fields',
                stringError
                )
            return

# check if database is valid
        for database in self.myDatabases:
            if myDatabase == database:
# check if table is valid
                for table in self.myDatabaseTables:
                    if myTable == table:
# if we get here, both database and table are valid, so assemble string
                        stringTableStructure = (
                            "SHOW COLUMNS FROM " + myDatabase + "." + myTable
                            )
                        self.MySQL_Commands(
                            1,
                            'self.cursorHandleMySQL.execute("' + stringTableStructure + '")'
                            )
                        start=time.time()
                        self.cursorHandleMySQL.execute(
                            stringTableStructure
                            )
                        self.tableStructure = self.cursorHandleMySQL.fetchall()
                        finish=time.time()
                        delta_t = finish - start
                        self.MySQL_Commands(
                            0,
                            '  (Time: %-7.4f secs)' % delta_t
                            )  
                            
                        self.MySQL_Output(
                            1,
                            'Structure of table "' + myTable + '":\n'
                            )
                        self.MySQL_Output(
                            0,
                            self.tableStructure
                            )

# display in a text box with scrollbars
# FRAMES
# destroy any old toplevel frames
                        
                        try:
                            self.handlerDestroyToplevelTableStructure()
                            self.MySQL_Output(
                                1,
                                'Previous toplevel widget removed from screen.'
                                )
                        except: 
                            self.MySQL_Output(
                                1,
                                'No previous toplevel widget to remove from screen.'
                                )
                        
            
# open Toplevel frame for entering database name
                        self.toplevelTableStructure = Toplevel(
#            self.frameParent,
                            bg='tan',
                            )
                        self.toplevelTableStructure.title(
                            'Server: ' + self.comboServerMySQL.get() + '     ' +
                            'Database: ' + self.varTableFunctionsSelectDatabase.get() + '     ' +
                            'Table: ' + self.varEntryTableFunctionsSelectTable.get().strip()
                            )
                        self.toplevelTableStructure.transient(self.frameParent)
# place the top window
                        self.toplevelTableStructure.geometry(
                            '+%d+%d' % (self.tablestructure_xWindowLocation,self.tablestructure_yWindowLocation)
                            )

                        frame_00 = Frame(
                            self.toplevelTableStructure,
                            bg='tan',
                            )
                        frame_00.grid(
                            row=0,
                            column=0,
                            pady=2,
                            )
            
                        frame_10 = Frame(
                            self.toplevelTableStructure,
                            bg='tan',
                            )
                        frame_10.grid(
                            row=1,
                            column=0,
                            pady=2,
                            sticky=W,
                            )
                            
                        frame_15 = Pmw.ScrolledFrame(
                            self.toplevelTableStructure,
                            usehullsize=1,
                            hull_width=750,
                            hull_height=30,
                            hscrollmode='none',
                            vscrollmode='none',
                            horizflex='expand',
                            vertflex='expand',
                            )
                        frame_15.grid(
                            row=2,
                            column=0,
                            padx=2,
                            pady=2,
                            )
                            
                        frame_20 = Pmw.ScrolledFrame(
                            self.toplevelTableStructure,
                            usehullsize=1,
                            hull_width=750,
                            hull_height=420,
                            hscrollmode='dynamic',
                            vscrollmode='static',
                            horizflex='expand',
                            vertflex='expand',
                            )
                        frame_20.grid(
                            row=3,
                            column=0,
                            padx=2,
                            pady=2,
                            )
                        Pmw.Color.changecolor(
                            self.toplevelTableStructure,
                            background='tan',
                            )
                            
                        frame_30 = Frame(
                            self.toplevelTableStructure,
                            bg='tan',
                            )                            
                        frame_30.grid(
                            row=4,
                            column=0,
                            pady=2,
                            )

            
# WIDGETS           
                        labelTableStructureMain = Label(
                            frame_00,
                            text=(
                                'STRUCTURE FOR TABLE "%s"\n' +
                                'Total entries: %s'
                                ) % (
                                myTable,
                                str(len(self.tableStructure))
                                ),
#                            font=self.tableFont,
                            bg='tan',
                            justify=CENTER,
                            )
                        labelTableStructureMain.grid(
                            row=0,
                            column=0,
                            columnspan=2,
                            padx=0,
                            pady=5,
                            )

# define field widths
                        width_i = 3
                        width_Field = 25
                        width_Datatype = 15
                        width_Null = 6
                        width_Key = 6
                        width_Default = 15
                        width_Extra = 15
# Header
# ... header0                                
                        varHeader0 = StringVar()
                        entryFieldLabel0 = Entry(
                            frame_15.interior(),
                            textvariable=varHeader0,
                            width=width_i,
                            bg='tan',
                            justify=RIGHT,
#                            font=self.tableFont,
                            relief=FLAT,
                            state='disable',
                            disabledbackground='tan',
                            disabledforeground='black',
                            )
                        entryFieldLabel0.grid(
                            row=1,
                            column=0,
                            padx=2,
                            pady=2,
                            )
                        varHeader0.set(' #  ')
                        
# ... header1: "Field"
                        varHeader1 = StringVar()
                        entryFieldLabel1 = Entry(
                            frame_15.interior(),
                            textvariable=varHeader1,
                            width=width_Field,
                            bg='tan',
#                            justify=CENTER,
                            relief=FLAT,
                            state='disable',
                            disabledbackground='tan',
                            disabledforeground='black',
                            )
                        entryFieldLabel1.grid(
                            row=1,
                            column=1,
                            padx=2,
                            pady=2,
                            )
                        varHeader1.set('Field')
                        
# ... header2: "Datatype"
                        varHeader2 = StringVar()
                        entryFieldLabel2 = Entry(
                            frame_15.interior(),
                            textvariable=varHeader2,
                            width=width_Datatype,
                            bg='tan',
#                            justify=CENTER,
                            relief=FLAT,
                            state='disable',
                            disabledbackground='tan',
                            disabledforeground='black',
                            )
                        entryFieldLabel2.grid(
                            row=1,
                            column=2,
                            padx=2,
                            pady=2,
                            )
                        varHeader2.set('Datatype')
                        
# ... header3: "Null"
                        varHeader3 = StringVar()
                        entryFieldLabel3 = Entry(
                            frame_15.interior(),
                            textvariable=varHeader3,
                            width=width_Null,
                            bg='tan',
#                            justify=CENTER,
                            relief=FLAT,
                            state='disable',
                            disabledbackground='tan',
                            disabledforeground='black',
                            )
                        entryFieldLabel3.grid(
                            row=1,
                            column=3,
                            padx=2,
                            pady=2,
                            )
                        varHeader3.set('Null')
                        
# ... header4: "Key"
                        varHeader4 = StringVar()
                        entryFieldLabel4 = Entry(
                            frame_15.interior(),
                            textvariable=varHeader4,
                            width=width_Key,
                            bg='tan',
#                            justify=CENTER,
                            relief=FLAT,
                            state='disable',
                            disabledbackground='tan',
                            disabledforeground='black',
                            )
                        entryFieldLabel4.grid(
                            row=1,
                            column=4,
                            padx=2,
                            pady=2,
                            )
                        varHeader4.set('Key')
                        
# ... header5: "Default"
                        varHeader5 = StringVar()
                        entryFieldLabel5 = Entry(
                            frame_15.interior(),
                            textvariable=varHeader5,
                            width=width_Default,
                            bg='tan',
#                            justify=CENTER,
                            relief=FLAT,
                            state='disable',
                            disabledbackground='tan',
                            disabledforeground='black',
                            )
                        entryFieldLabel5.grid(
                            row=1,
                            column=5,
                            padx=2,
                            pady=2,
                            )
                        varHeader5.set('Default')
                        
# ... header6: "Extra"
                        varHeader6 = StringVar()
                        entryFieldLabel6 = Entry(
                            frame_15.interior(),
                            textvariable=varHeader6,
                            width=width_Extra,
                            bg='tan',
#                            justify=CENTER,
                            relief=FLAT,
                            state='disable',
                            disabledbackground='tan',
                            disabledforeground='black',
                            )
                        entryFieldLabel6.grid(
                            row=1,
                            column=6,
                            padx=2,
                            pady=2,
                            )
                        varHeader6.set('Extra')
                        
                        
# define empty list
                        stringTableStructure=[]

# display structure for each field
                        for i in range(len(self.tableStructure)):
                            myField, myDatatype, myNull, myKey, myDefault, myExtra = \
                                self.tableStructure[i]
#                            print(
#                                '%3s. %20s %20s %3s %3s %20s %20s' % 
#                                (i+1, myField, myDatatype, myNull, myKey, myDefault, myExtra)
#                                )
                            self.MySQL_Output(
                                0,
                                '%4s. | %-12s | %-15s | %-3s | %-3s | %-15s | %-15s |' % 
                                (i+1, myField, myDatatype, myNull, myKey, myDefault, myExtra)
                                )
                                
# Field frames - 7 total
                            columnCount=0
# ... field 0
                            varField0 = StringVar()
                            entryField0 = Entry(
                                frame_20.interior(),
                                textvariable=varField0,
                                bg='tan',
                                width=width_i,
                                justify=RIGHT,
                                relief=FLAT,
                                state='disable',
                                disabledbackground='tan',
                                disabledforeground='black',
                                )
                            entryField0.grid(
                                row=i,
                                column=columnCount,
                                padx=2,
                                pady=2,
                                sticky='n',
                                )
                            varField0.set(str(i+1) + '.')
# ... field 1
                            columnCount+=1
                            varField1 = StringVar()
                            entryField1 = Entry(
                                frame_20.interior(),
                                textvariable = varField1,
                                width=width_Field,
                                relief=SUNKEN,
                                state='disable',
                                disabledbackground='white',
                                disabledforeground='black',
                                )
                            entryField1.grid(
                                row=i,
                                column=columnCount,
                                padx=2,
                                pady=2,
                                sticky='n',
                                ) 
                            varField1.set(myField)
# ... field 2
                            columnCount+=1
                            varField2 = StringVar()
                            entryField2 = Entry(
                                frame_20.interior(),
                                textvariable = varField2,
                                width=width_Datatype,
                                relief=SUNKEN,
                                state='disable',
                                disabledbackground='white',
                                disabledforeground='black',
                                )
                            entryField2.grid(
                                row=i,
                                column=columnCount,
                                padx=2,
                                pady=2,
                                sticky='n',
                                )
                            varField2.set(myDatatype)
# ... field 3
                            columnCount+=1
                            varField3 = StringVar()
                            entryField3 = Entry(
                                frame_20.interior(),
                                textvariable = varField3,
                                width=width_Null,
                                relief=SUNKEN,
                                state='disable',
                                disabledbackground='white',
                                disabledforeground='black',
                                )
                            entryField3.grid(
                                row=i,
                                column=columnCount,
                                padx=2,
                                pady=2,
                                sticky='n',
                                )
                            varField3.set(myNull)
# ... field 4
                            columnCount+=1
                            varField4 = StringVar()
                            entryField4 = Entry(
                                frame_20.interior(),
                                textvariable = varField4,
                                width=width_Key,
                                relief=SUNKEN,
                                state='disable',
                                disabledbackground='white',
                                disabledforeground='black',
                                )
                            entryField4.grid(
                                row=i,
                                column=columnCount,
                                padx=2,
                                pady=2,
                                sticky='n',
                                )
                            varField4.set(myKey)
# ... field 5
                            columnCount+=1
                            varField5 = StringVar()
                            entryField5 = Entry(
                                frame_20.interior(),
                                textvariable = varField5,
                                width=width_Default,
                                relief=SUNKEN,
                                state='disable',
                                disabledbackground='white',
                                disabledforeground='black',
                                )
                            entryField5.grid(
                                row=i,
                                column=columnCount,
                                padx=2,
                                pady=2,
                                sticky='n',
                                ) 
                            varField5.set(myDefault)
# ... field 6
                            columnCount+=1
                            varField6 = StringVar()
                            entryField6 = Entry(
                                frame_20.interior(),
                                textvariable = varField6,
                                width=width_Extra,
                                relief=SUNKEN,
                                state='disable',
                                disabledbackground='white',
                                disabledforeground='black',
                                )
                            entryField6.grid(
                                row=i,
                                column=columnCount,
                                padx=2,
                                pady=2,
                                sticky='n',
                                )
                            varField6.set(myExtra)
# reposition widgets to be gridded correctly at top of frame instead of defaulting to middle of frame
#    (weight=0 is default)
                        frame_20.interior().grid_rowconfigure(i,weight=1)
#                        frame_20.interior().grid_columnconfigure(columnCount,weight=1)
                          
# CANCEL button                           
                        buttonCancelTableStructure = Button(
                            frame_30,
                            text='Cancel',
                            borderwidth=5,
                            width=15,
                            relief=RAISED,
                            justify=CENTER,
                            command=self.handlerDestroyToplevelTableStructure,
                            )
                        buttonCancelTableStructure.grid(
                            row=0,
                            column=0,
                            padx=2,
                            pady=5,
                            )
                        
                        return
# invalid table
                self.MySQL_Output(
                    1,
                    'Error: table not found in list of current tables.' 
                    )
                self.MySQL_Output(
                    1,
                    'Table: ' + myTable
                    )
                self.MySQL_Output(
                    1,
                    'List of current tables:\n' + self.myDatabaseTables
                    )
                self.MySQL_Output(
                    0,
                    self.myDatabseTables
                    )
                self.MySQL_Output(
                    1,
                    'This operation is canceled.'
                    )
                showerror(
                    'Error: table not found',
                    '\nThe table\n\n"' + myTable + '"\n\n' + 
                    'was not found in the current\n' +
                    'list of available tables.\n\n' +
                    'Please select a current table.'
                    )
                return
# invalid database
        self.MySQL_Output(
            1,
            'Error: database not found in list of current databases.' + '\n' +
            'Database: ' + myDatabase + '\n' +
            'This operation is canceled.'
            )
        showerror(
            'Error: database not found',
            '\nDThe database\n\n"' + myDatabase + '"\n\nwas not found\n' +
            'in the current list of available databases.\n\n' +
            'Please select a current database.'
            )
            
        return
        
    
    def handlerEditSelectedRow(self):
        '''
        Purpose:
        edit existing rows manually
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerEditSelectedRow')
            
# set last button pressed
        self.lastButtonPressed(
            BUTTONLABEL_EDITSELECTROWS
            )
        
# check if connected to a MySQL server
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return
        
# check if a table has even been read in 
        emptyTableCheck = self.checkIfEmptyTable()
        if emptyTableCheck:
            return

# see if toplevel frame exists; if so, do not destroy;
#   assume user tried to instantiate a window without knowing
#   one was already open
        try:
            mapped = self.handlerCheckIfMapped_EditSelectedRows()
        except:
            mapped = False
        
        if mapped:
            stringWindowIsOpen = (
                'Window "EDIT SELECTED ROWS" is already open.'
                )
            print('\n' + stringWindowIsOpen)
            self.MySQL_Output(
                0,
                stringWindowIsOpen
                )
            try:
                showinfo(
                    'Info: window is open',
                    stringWindowIsOpen,
                    parent=self.toplevelEditSelectedRows,
                    )
            except:
                showinfo(
                    'Info: window is open',
                    stringWindowIsOpen
                    )
            return
                    
        
# define background color
        self.EditSelectedRows_color_bg = 'lightgreen'

        myTable = self.comboboxDbTableSelect.get().strip()
        myDatabase = self.comboboxDbSelect.get().strip()
        
# set flag for checking if any changes have been made to the table via this method
        self.flagEditSelectedRows_ChangesMade = False
                                    
# ------ Define some constants ------
# define field widths
        self.EditSelectedRows_width_i = 4
        self.EditSelectedRows_width_Field = 25
        self.EditSelectedRows_width_Datatype = 15
        self.EditSelectedRows_width_Values = 25
        widthIncrementDueToScrollbar = 3
        
# for updates
        self.EditSelectedRows_MyTable = myTable
        self.EditSelectedRows_MyDatabase = myDatabase
        
        if (
            myTable == '' or
            myDatabase == ''
            ):
            stringError = '\nThe following problems need attention:\n\n'
            if myDatabase == '':
                stringError += ' - Database has not been selected\n\n'
            if myTable == '':
                stringError += ' - Table has not been selected\n\n'
            stringError += 'Select missing objects and try again.'
            self.MySQL_Output(
                1,
                stringError
                )
            showerror(
                'Error: select missing objects',
                stringError
                )
            return
            
# check if any rows are checked; user must select rows from table display
#   before coming here
# determine which rows are checked
        self.EditSelectedRows_rowsChecked = []

# note that index does not always start at zero, since we can also
#  specify a range to display in the table view
        rowsCheckedIndex = self.indexEditSelectedRows_Start

        if DEBUG_EDITSELECTEDROWS:
            print('\nself.varSelectAnyRow = %s' % self.varSelectAnyRow)
            indexCount = 0
            for var in self.varSelectAnyRow:
                indexCount += 1
                print('%s. var.get() = %s' % (indexCount,var.get()))
            print('')
            for (num,var) in enumerate(self.tableValues):
                print('%s. %s ' % (num,var))
        
        for var in self.varSelectAnyRow:
            if var.get():
                self.EditSelectedRows_rowsChecked.append(rowsCheckedIndex)
            rowsCheckedIndex += 1
            
        numRowsChecked = len(self.EditSelectedRows_rowsChecked)
            
        if numRowsChecked == 0:
            stringNoRowsChecked = (
                'No rows have been selected for editing.\n\n' +
                'Select desired rows to be edited and try again.'
                )
            print(stringNoRowsChecked)
            self.MySQL_Output(
                0,
                stringNoRowsChecked
                )
            showerror(
                'Error: no rows checked',
                stringNoRowsChecked
                )
            return
            
# store original values for each row checked
        self.EditSelectedRows_OriginalValues = []
        for row in self.EditSelectedRows_rowsChecked:
            tempOriginalValuesForOneRow = []
            for value in self.tableValues[row]:
                tempOriginalValuesForOneRow.append(value)
            self.EditSelectedRows_OriginalValues.append(tempOriginalValuesForOneRow)
        if DEBUG_EDITSELECTEDROWS:
            print(
                '\nself.EditSelectedRows_OriginalValues:\n%s\n' 
                % self.EditSelectedRows_OriginalValues
                )

# check if database is valid
        for database in self.myDatabases:
            if myDatabase == database:
# check if table is valid
                for table in self.myDatabaseTables:
                    if myTable == table:
# if we get here, both database and table are valid, so assemble string
# ... save database and table for updates
                        self.EditSelectedRows_MyTable = myTable
                        self.EditSelectedRows_MyDatabase = myDatabase
                        stringTableStructure = (
                            "SHOW COLUMNS FROM " + myDatabase + "." + myTable
                            )
                        self.MySQL_Commands(
                            1,
                            'self.cursorHandleMySQL.execute("' + stringTableStructure + '")'
                            )
                        start=time.time()
                        self.cursorHandleMySQL.execute(
                            stringTableStructure
                            )
# define table structure
                        self.tableStructure = self.cursorHandleMySQL.fetchall()
                        finish=time.time()
                        delta_t = finish - start
                        self.MySQL_Commands(
                            0,
                            '  (Time: %-7.4f secs)' % delta_t
                            )  
                            
                        if DEBUG_EDITSELECTEDROWS:
                            self.MySQL_Output(
                                1,
                                'Structure of table "' + myTable + '":\n'
                                )
                            self.MySQL_Output(
                                0,
                                self.tableStructure
                                )
                                
# destroy any old toplevel frames
                        
                        try:
                            self.handlerDestroyToplevelEditSelectedRows()
                            self.MySQL_Output(
                                1,
                                '\nPrevious toplevel widget removed from screen.'
                                )
                        except: 
                            self.MySQL_Output(
                                1,
                                '\nNo previous toplevel widget to remove from screen.'
                                )                            
            
# open Toplevel frame
                        self.toplevelEditSelectedRows = Toplevel(
#            self.frameParent,
                            bg=self.EditSelectedRows_color_bg,
                            )
                        self.toplevelEditSelectedRows.title(
                            'Server: ' + self.comboServerMySQL.get() + '     ' +
                            'Database: ' + self.varTableFunctionsSelectDatabase.get() + '     ' +
                            'Table: ' + self.varEntryTableFunctionsSelectTable.get().strip()
                            )
                        self.toplevelEditSelectedRows.transient(self.toplevelTableValues)
# place the top window
                        self.toplevelEditSelectedRows.geometry(
                            '+%d+%d' % (
                            self.editselectedrows_xWindowLocation,
                            self.editselectedrows_yWindowLocation
                            )
                            )
                            
                        rowCount = 0
# title and sub-title and selected height of 'Values' boxes
                        self.EditSelectedRows_frame_00 = Frame(
                            self.toplevelEditSelectedRows,
                            bg=self.EditSelectedRows_color_bg,
                            )
                        self.EditSelectedRows_frame_00.grid(
                            row=rowCount,
                            column=0,
                            padx=0,
                            pady=2,
                            )
# checkbuttons for displaying scrollbars and to keep 'New Values' entries displayed
                        rowCount += 1
                        self.EditSelectedRows_frame_10 = Frame(
                            self.toplevelEditSelectedRows,
                            bg=self.EditSelectedRows_color_bg,
                            )
                        self.EditSelectedRows_frame_10.grid(
                            row=rowCount,
                            column=0,
                            padx=0,
                            pady=2,
                            )
# table header  
                        rowCount += 1
                        self.frame_15_Header_EditSelectedRows = Frame(
                            self.toplevelEditSelectedRows,
                            bg=self.EditSelectedRows_color_bg,
                            )
                        self.frame_15_Header_EditSelectedRows.grid(
                            row=rowCount,
                            column=0,
                            padx=2,
                            pady=2,
                            sticky=N+E+W
                            )
                        self.canvas_15_Header_EditSelectedRows = Canvas(
                            self.frame_15_Header_EditSelectedRows,
                            bg=self.EditSelectedRows_color_bg,
#                            scrollregion=self.canvas_15_Header_EditSelectedRows.bbox('all'),
                            confine=0,
                            width=985,
                            height=30,
                            )
                        self.canvas_15_Header_EditSelectedRows.grid(
                            row=0,
                            column=0,
                            padx=0,
                            pady=0,
                            sticky=N,
                            )
#                        self.canvas_15_Header_EditSelectedRows.config(
#                            scrollregion=self.canvas_15_Header_EditSelectedRows.bbox('all')
#                            )
                            
                        self.frame_15_Canvas_Header_EditSelectedRows = Frame(
                            self.canvas_15_Header_EditSelectedRows,
                            bg=self.EditSelectedRows_color_bg,
                            padx=1,
                            pady=0,
                            )
                            
                            
# scrollable canvas for fields, datatypes, current values, etc.
                        rowCount += 1
                        self.frame_20_EditSelectedRows = Frame(
                            self.toplevelEditSelectedRows,
                            bg=self.EditSelectedRows_color_bg,
                            borderwidth=2,
                            relief=RIDGE,
                            )
#                            usehullsize=1,
#                            hull_width=985,
#                            hull_height=600,
#                            hscrollmode='none',
#                            vscrollmode='static',
#                            horizflex='expand',
#                            vertflex='expand',
#                            )
                        self.frame_20_EditSelectedRows.grid(
                            row=rowCount,
                            column=0,
                            padx=2,
                            pady=2,
                            sticky=N+E+W
                            )
#                        Pmw.Color.changecolor(
#                            self.toplevelEditSelectedRows,
#                            background=self.EditSelectedRows_color_bg,
#                            )
                        yScroll_frame_20 = Scrollbar(
                            self.toplevelEditSelectedRows,
                            orient=VERTICAL,
                            command=self.handlerEditYScrollFrame20,
                            )
                        yScroll_frame_20.grid(
                            row=rowCount,
                            column=1,
                            padx=3,
                            sticky=N+S+W,
                            )
                            
                        rowCount += 1
                        xScroll_frame_20 = Scrollbar(
                            self.toplevelEditSelectedRows,
                            orient=HORIZONTAL,
                            command=self.handlerEditXScrollFrame15Frame20,
                            )
                        xScroll_frame_20.grid(
                            row=rowCount,
                            column=0,
                            sticky=N+E+W,
                            )                          
                        self.canvas_20_EditSelectedRows = Canvas(
                            self.frame_20_EditSelectedRows,
                            bg=self.EditSelectedRows_color_bg,
                            confine=0,
                            width=985, # originally 985
                            height=600, # originally 600
                            xscrollcommand=xScroll_frame_20.set,
                            yscrollcommand=yScroll_frame_20.set, 
                            )
                        self.canvas_20_EditSelectedRows.grid(
                            row=0,
                            column=0,
                            padx=2,
                            pady=2,
                            sticky=N,
                            )
#                        self.canvas_20_EditSelectedRows.config(
#                            scrollregion=self.canvas_20_EditSelectedRows.bbox('all')
#                            )                           
                        self.frame_20_Canvas_Header_EditSelectedRows = Frame(
                            self.canvas_20_EditSelectedRows,
                            bg=self.EditSelectedRows_color_bg,
                            padx=1,
                            )
# handler for scrolling two grids in X direction
#                        xScroll_frame_20.config(
#                            command=self.handlerEditXScrollFrame15Frame20
#                            )
# handler for scrolling one grid in Y direction
#                        yScroll_frame_20.config(
#                            command=self.handlerEditYScrollFrame20
#                            )
                            
                            
# buttons for insert location, etc.  
                        rowCount += 1
                        frame_30 = Frame(
                            self.toplevelEditSelectedRows,
                            bg=self.EditSelectedRows_color_bg,
                            )                            
                        frame_30.grid(
                            row=rowCount,
                            column=0,
                            pady=2,
                            )
# buttons for move to next selected row, cancel
                        rowCount += 1
                        self.EditSelectedRows_frame_40 = Frame(
                            self.toplevelEditSelectedRows,
                            bg=self.EditSelectedRows_color_bg,
                            )                            
                        self.EditSelectedRows_frame_40.grid(
                            row=rowCount,
                            column=0,
                            pady=2,
                            )
            
# ------ WIDGETS ------- 
 
# title              
                        rowCount = 0
                        labelEditSelectedRows_Title = Label(
                            self.EditSelectedRows_frame_00,
                            text='EDIT SELECTED ROWS FOR TABLE "' + myTable + '" ',
                            font=self.labelFontMediumBold,
                            bg=self.EditSelectedRows_color_bg,
                            justify=CENTER,
                            )
                        labelEditSelectedRows_Title.grid(
                            row=rowCount,
                            column=0,
                            padx=0,
                            pady=0,
                            )
# sub-title -- display which row is being edited  
                        rowCount += 1
                        self.varLabelEditSelectedRows_RowIndex = StringVar()
                        labelEditSelectedRows_RowIndex = Label(
                            self.EditSelectedRows_frame_00,
                            textvariable=self.varLabelEditSelectedRows_RowIndex,
                            font=self.labelFontMediumBold,
                            bg=self.EditSelectedRows_color_bg,
                            justify=CENTER,
                            )
                        labelEditSelectedRows_RowIndex.grid(
                            row=rowCount,
                            column=0,
                            pady=5,
                            )
# combobox for specifying height of text widgets
                        rowCount += 1
                        self.comboboxEditSelectedRows_TextHeight = Pmw.ComboBox(
                            self.EditSelectedRows_frame_00,
                            scrolledlist_items=self.heightsForEntryWidgets_NoScrollbar,
                            listheight=140,
                            entry_width=5,
                            label_text='Select height of "Values" boxes: ',
                            labelpos='w',
                            label_background=self.EditSelectedRows_color_bg,
                            selectioncommand=self.handlerEditSelectedRows_TextHeight,
                            scrolledlist_hull_width=500,
                            )
                        self.comboboxEditSelectedRows_TextHeight.grid(
                            row=rowCount,
                            column=0,
                            padx=0,
                            pady=5,
                            )
                        self.comboboxEditSelectedRows_TextHeight.setentry('1')
# checkbox for horizontal scrollbar display
                        rowCount = 0
                        self.varEditSelectedRows_HorizontalScrollbar = IntVar()
                        self.checkboxEditSelectedRows_HorizontalScrollbar = Checkbutton(
                            self.EditSelectedRows_frame_10,
                            variable=self.varEditSelectedRows_HorizontalScrollbar,
                            text='Display horizontal scrollbars',
                            bg=self.EditSelectedRows_color_bg,
                            command=self.handlerEditSelectedRows_HorizontalScrollbar,
                            )
                        self.checkboxEditSelectedRows_HorizontalScrollbar.grid(
                            row=rowCount,
                            column=0,
                            padx=5,
                            pady=0,
                            sticky='e',
                            )
                        self.statusEditSelectedRows_HorizontalScrollbar = 'none'
# checkbox for vertical scrollbar display
                        self.varEditSelectedRows_VerticalScrollbar = IntVar()
                        self.checkboxEditSelectedRows_VerticalScrollbar = Checkbutton(
                            self.EditSelectedRows_frame_10,
                            variable=self.varEditSelectedRows_VerticalScrollbar,
                            text='Display vertical scrollbars',
                            bg=self.EditSelectedRows_color_bg,
                            command=self.handlerEditSelectedRows_VerticalScrollbar,
                            )
                        self.checkboxEditSelectedRows_VerticalScrollbar.grid(
                            row=rowCount,
                            column=1,
                            padx=5,
                            pady=0,
                            sticky='w',
                            )
                        self.statusEditSelectedRows_VerticalScrollbar = 'none'
# checkbox for keeping 'New Values' entries displayed when moving from row to row
                        self.varKeepNewValuesEntries = IntVar()
                        self.checkboxKeepNewValuesEntries = Checkbutton(
                            self.EditSelectedRows_frame_10,
                            variable=self.varKeepNewValuesEntries,
                            text='Keep saved "New Values" entries displayed when changing rows',
                            bg=self.EditSelectedRows_color_bg,
                            )
                        self.checkboxKeepNewValuesEntries.grid(
                            row=rowCount,
                            column=2,
                            padx=5,
                            pady=0,
                            sticky='w',
                            )
# Header
# ... header0     
                        rowCount_Header = 0
                        varHeader0 = StringVar()
                        entryFieldLabel0 = Entry(
#                            frame_15.interior(),
                            self.frame_15_Canvas_Header_EditSelectedRows,
                            textvariable=varHeader0,
                            width=self.EditSelectedRows_width_i,
                            bg=self.EditSelectedRows_color_bg,
                            justify=RIGHT,
#                            font=self.headerFontSmall,
                            relief=FLAT,
                            state='disable',
                            disabledbackground=self.EditSelectedRows_color_bg,
                            disabledforeground='black',
                            )
                        entryFieldLabel0.grid(
                            row=rowCount_Header,
                            column=0,
                            padx=2,
                            pady=2,
                            )
                        varHeader0.set('  # ')
# ... header1
                        varHeader1 = StringVar()
                        entryFieldLabel1 = Entry(
#                            frame_15.interior(),
                            self.frame_15_Canvas_Header_EditSelectedRows,
                            textvariable=varHeader1,
                            width=self.EditSelectedRows_width_Field,
                            bg=self.EditSelectedRows_color_bg,
#                            font=self.headerFontSmall,
                            relief=FLAT,
                            state='disable',
                            disabledbackground=self.EditSelectedRows_color_bg,
                            disabledforeground='black',
                            )
                        entryFieldLabel1.grid(
                            row=rowCount_Header,
                            column=1,
                            padx=2,
                            pady=2,
                            )
                        varHeader1.set('  Fields')
# ... header2
                        varHeader2 = StringVar()
                        entryFieldLabel2 = Entry(
#                            frame_15.interior(),
                            self.frame_15_Canvas_Header_EditSelectedRows,
                            textvariable=varHeader2,
                            width=self.EditSelectedRows_width_Datatype,
                            bg=self.EditSelectedRows_color_bg,
#                            font=self.headerFontSmall,
                            relief=FLAT,
                            state='disable',
                            disabledbackground=self.EditSelectedRows_color_bg,
                            disabledforeground='black',
                            )
                        entryFieldLabel2.grid(
                            row=rowCount_Header,
                            column=2,
                            padx=2,
                            pady=2,
                            )
                        varHeader2.set('  Datatypes')
# ... header3
                        varHeader3 = StringVar()
                        entryFieldLabel3 = Entry(
#                            frame_15.interior(),
                            self.frame_15_Canvas_Header_EditSelectedRows,
                            textvariable=varHeader3,
                            width=(
                                self.EditSelectedRows_width_Values + widthIncrementDueToScrollbar
                                ),
                            bg=self.EditSelectedRows_color_bg,
#                            font=self.headerFontSmall,
                            relief=FLAT,
                            state='disable',
                            disabledbackground=self.EditSelectedRows_color_bg,
                            disabledforeground='black',
                            )
                        entryFieldLabel3.grid(
                            row=rowCount_Header,
                            column=3,
                            padx=4,
                            pady=2,
                            )
                        varHeader3.set('  Original Values')
                            
# ... header4
                        varHeader4 = StringVar()
                        entryFieldLabel4 = Entry(
#                            frame_15.interior(),
                            self.frame_15_Canvas_Header_EditSelectedRows,
                            textvariable=varHeader4,
                            width=(
                                self.EditSelectedRows_width_Values + widthIncrementDueToScrollbar
                                ),
                            bg=self.EditSelectedRows_color_bg,
#                            justify=CENTER,
#                            font=self.headerFontSmall,
#                            font=self.entryDefaultFont,
                            relief=FLAT,
                            state='disable',
                            disabledbackground=self.EditSelectedRows_color_bg,
                            disabledforeground='black',
                            )
                        entryFieldLabel4.grid(
                            row=rowCount_Header,
                            column=5,
                            padx=4,
                            pady=2,
                            )
                        varHeader4.set('  Current Values')
                        
# ... header5
                        varHeader5 = StringVar()
                        entryFieldLabel5 = Entry(
#                            frame_15.interior(),
                            self.frame_15_Canvas_Header_EditSelectedRows,
                            textvariable=varHeader5,
                            width=(
                                self.EditSelectedRows_width_Values + widthIncrementDueToScrollbar
                                ),
                            bg=self.EditSelectedRows_color_bg,
                            fg='black',
#                            font=self.headerFontSmall,
                            relief=FLAT,
                            state='disable',
                            disabledbackground=self.EditSelectedRows_color_bg,
                            disabledforeground='black',
                            )
                        entryFieldLabel5.grid(
                            row=rowCount_Header,
                            column=7,
                            padx=4,
                            pady=2,
                            )
                        varHeader5.set('New Values')
# ... header 5 - clear
                        buttonClearNewValues = Button(
#                            frame_15.interior(),
                            self.frame_15_Canvas_Header_EditSelectedRows,
                            text='Clear New Values',
                            width=15,
                            borderwidth=5,
                            relief=RAISED,
                            justify=CENTER,
                            bg='white',
                            fg='blue',
#                            font=self.buttonFontSmall,
                            font=self.entryDefaultFont,
                            command=self.handlerEditSelectedRows_ClearNewValues,
                            )
                        buttonClearNewValues.grid(
                            row=rowCount_Header,
                            column=7,
                            padx=2,
                            pady=2,
                            sticky=E,
                            )

# initialize new values to blank fields
                        self.editSelectedRows_SaveNewValues = []
                        for row in range(len(self.tableStructure) - 1):
                            self.editSelectedRows_SaveNewValues.append('')                            

# display all fields in initially-selected row; increment with Next button below;
#   rest of window stays same
                        self.EditSelectedRows_Index = 0
                        self.EditSelectedRows_DisplayFields(
                            self.EditSelectedRows_rowsChecked[0],
                            self.EditSelectedRows_OriginalValues[0],
                            self.tableValues[self.EditSelectedRows_rowsChecked[0]]
                            )

# Update-1 button   
                        buttonInsertRow_ChangedValuesOnly = Button(
                            frame_30,
                            text=(
                                'UPDATE each Current Values field\n' +
                                'with each changed New Values field;\n' +
                                'EXCLUDE blank New Values fields;\n' +
                                'Use NULL to blank/zero-fill a text/numeric field.'
                                ),
                            borderwidth=7,
                            width=45,
                            bg='white',
                            fg='blue',
                            relief=RAISED,
                            justify=CENTER,
                            command=self.handlerEditSelectedRows_UpdateChangedValuesOnly,
                            )
                        buttonInsertRow_ChangedValuesOnly.grid(
                            row=0,
                            column=0,
                            padx=5,
                            pady=5,
                            )
# Update-2 button
                        buttonInsertRow_AllValues = Button(
                            frame_30,
                            text=(
                                'UPDATE each Current Values field\n' +
                                'with each New Values field;\n' +
                                'INCLUDE blank New Values fields which will\n' +
                                'blank text fields, zero-fill numeric fields'
                                ),
                            borderwidth=7,
                            width=45,
                            bg='white',
                            fg='blue',
                            relief=RAISED,
                            justify=CENTER,
                            command=self.handlerEditSelectedRows_UpdateChangedAndBlankValues,
                            )
                        buttonInsertRow_AllValues.grid(
                            row=0,
                            column=1,
                            padx=5,
                            pady=5,
                            )
# Restore button
                        buttonInsertRow_UseOriginalValues = Button(
                            frame_30,
                            text=(
                                'RESTORE each Current Values field\n' +
                                'with each Original Values field.\n' +
                                'IMPORTANT: Original Values fields are updated\n' +
                                'when window is closed.'
                                ),
                            borderwidth=7,
                            width=45,
                            bg='white',
                            fg='blue',
                            relief=RAISED,
                            justify=CENTER,
                            command=self.handlerEditSelectedRows_RestoreUsingOriginalValues,
                            )
                        buttonInsertRow_UseOriginalValues.grid(
                            row=0,
                            column=2,
                            padx=5,
                            pady=5,
                            )
# ... move to previously selected row
                        buttonPreviousRow = Button(
                            self.EditSelectedRows_frame_40,
                            text='<-- Previous selected row',
                            borderwidth=5,
                            width=30,
                            bg='tan',
                            fg='black',
                            state='disabled',
                            relief=RAISED,
                            justify=CENTER,
                            command=self.handlerEditPreviousSelectedRow,
                            )
                        buttonPreviousRow.grid(
                            row=0,
                            column=0,
                            padx=5,
                            pady=5,
                            )
# ... move to next selected row
                        if numRowsChecked > 1:
                            buttonNextRow = Button(
                                self.EditSelectedRows_frame_40,
                                text='Next selected row -->',
                                borderwidth=5,
                                width=30,
                                bg='tan',
                                fg='black',
                                state='normal',
                                relief=RAISED,
                                justify=CENTER,
                                command=self.handlerEditNextSelectedRow,
                                )
                            buttonNextRow.grid(
                                row=0,
                                column=1,
                                padx=5,
                                pady=5,
                                )
                        else:
                            buttonNextRow = Button(
                                self.EditSelectedRows_frame_40,
                                text='Next selected row -->',
                                borderwidth=5,
                                width=30,
                                bg='tan',
                                fg='black',
                                state='disabled',
                                relief=RAISED,
                                justify=CENTER,
                                command=self.handlerEditNextSelectedRow,
                                )
                            buttonNextRow.grid(
                                row=0,
                                column=1,
                                padx=5,
                                pady=5,
                                )
# ... cancel
                        buttonCancelNewRow = Button(
                            self.EditSelectedRows_frame_40,
                            text='Close',
                            borderwidth=5,
                            width=20,
#                            bg='white',
#                            fg='black',
                            relief=RAISED,
                            justify=CENTER,
                            command=self.handlerDestroyToplevelEditSelectedRows,
                            )
                        buttonCancelNewRow.grid(
                            row=1,
                            column=0,
                            columnspan=99,
                            padx=5,
                            pady=5,
                            )
                        
                        return
# invalid table
                stringTableNotFound = (
                    'The following table was not found in list of current tables:\n\n' +
                    ' Table: %s\n' +
                    ' Database: %s\n\n' +
                    'Select another table.\n' +
                    'This operation is canceled.'
                    ) % (myTable, myDatabase)
                self.MySQL_Output(
                    1,
                    stringTableNotFound
                    )
                showerror(
                    'Error: table not found',
                    stringTableNotFound
                    )
                return
                
# invalid database
        stringDatabaseNotFound = (
            'The following database was not found:\n\n' +
                    ' Database: %s\n\n' +
                    'Select another database.\n' +
                    'This operation is canceled.'
                    ) % (myDatabase)
        self.MySQL_Output(
            1,
            stringDatabaseNotFound
            )
        showerror(
            'Error: database not found',
            stringDatabaseNotFound
            )
            
        return
        
        
    def handlerEditXScrollFrame15Frame20(self,*args):
        '''
        allows synchronized scrolling between two frames
       '''
        self.canvas_15_Header_EditSelectedRows.xview(*args)
        self.canvas_20_EditSelectedRows.xview(*args)
       
        return
       
       
    def handlerEditYScrollFrame20(self,*args):
        '''
        allows scrolling of one frame
       '''
        self.canvas_20_EditSelectedRows.yview(*args)
        
        return
        
        
    def handlerInputXScrollFrame15Frame20(self,*args):
        '''
        allows synchronized scrolling between two frames
       '''
        self.canvas_15_Header_NewRowsManually.xview(*args)
        self.canvas_20_InputNewRows.xview(*args)
       
        return
       
       
    def handlerInputYScrollFrame20(self,*args):
        '''
        allows scrolling of one frame
       '''
        self.canvas_20_InputNewRows.yview(*args)
        
        return
        
        
    def handlerEditSelectedRows_HorizontalScrollbar(self):
        '''
        Purpose:
            determine whether horizontal scrollbar is displayed
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerEditSelectedRows_HorizontalScrollbar')
        
        if self.varEditSelectedRows_HorizontalScrollbar.get():
            self.statusEditSelectedRows_HorizontalScrollbar = 'static'
        else:
            self.statusEditSelectedRows_HorizontalScrollbar = 'none'
            
        self.handlerEditSelectedRows_TextHeight(0)
        
        return
        
        
            
    def handlerEditSelectedRows_VerticalScrollbar(self):
        '''
        Purpose:
            determine whether vertical scrollbar is displayed
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerEditSelectedRows_VerticalScrollbar')
        
        if self.varEditSelectedRows_VerticalScrollbar.get():
            self.statusEditSelectedRows_VerticalScrollbar = 'static'
        else:
            self.statusEditSelectedRows_VerticalScrollbar = 'none'
            
        self.handlerEditSelectedRows_TextHeight(0)
        
        return
            
        
    def handlerEditSelectedRows_TextHeight(self,value):
        '''
        Purpose:
            update height of entry boxes
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerEditSelectedRows_TextHeight')
            
        rowIndex = self.EditSelectedRows_RowIndex   # which row is checked
        rowSequence = self.EditSelectedRows_Index   # present value in the sequence of rows
        if DEBUG_EDITSELECTEDROWS:
            print('\nrowIndex = %s' % rowIndex)
            print('\nrowSequence = %s' % rowSequence)
            print(
                'self.EditSelectedRows_rowsChecked = %s' % 
                self.EditSelectedRows_rowsChecked
                )
            print('self.tableValues[self.EditSelectedRows_rowsChecked[rowSequence]] = ')
            print(self.tableValues[self.EditSelectedRows_rowsChecked[rowSequence]])
            print('self.originalvalues = ')
            print(self.EditSelectedRows_OriginalValues[rowSequence])
            print
            
# save values in new fields
        self.editSelectedRows_SaveNewValues = []
        for row in range(len(self.tableStructure) - 1):
            self.editSelectedRows_SaveNewValues.append(
                self.scrolledtext_EditSelectedRows_NewValues[row].get().strip()
                )
       
# clear the scrolled text boxes; otherwise, if height is selected that is less
#   than previous height, the bottom of the previous text boxes will persist and
#   will still display -- not what is wanted; so destroy previous text boxes first
        for row in range(len(self.scrolledtext_EditSelectedRows_OriginalValues)):
            self.scrolledtext_EditSelectedRows_OriginalValues[row].destroy()
            self.scrolledtext_EditSelectedRows_CurrentValues[row].destroy()
            self.scrolledtext_EditSelectedRows_NewValues[row].destroy()
            

        self.EditSelectedRows_DisplayFields(
            self.EditSelectedRows_rowsChecked[rowSequence],  # which rows are checked
            self.EditSelectedRows_OriginalValues[rowSequence],
#            self.tableValues[self.EditSelectedRows_rowsChecked[rowSequence]]
            self.tableValues[self.EditSelectedRows_rowsChecked[rowSequence]]
            )
            
        return
        
        
    def handlerCheckIfMapped_EditSelectedRows(self):
        '''
        Purpose:
            Check if toplevel is already open; if so, do not
            open another
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerCheckIfMapped_EditSelectedRows')
              
        try:
            mapped = self.toplevelEditSelectedRows.winfo_exists()
        except:
            mapped = False
            
        return mapped
        
        
    def handlerCheckIfMapped_InputNewRows(self):
        '''
        Purpose:
            Check if toplevel is already open; if so, do not
            open another
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerCheckIfMapped_InputNewRows')
              
        try:
            mapped = self.toplevelInputNewRowsManually.winfo_exists()
        except:
            mapped = False
            
        return mapped
        
        
    def handlerEditSelectedRows_ClearNewValues(self):
        '''
        Purpose:
            clear new values from editing selected rows
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerEditSelectedRows_ClearNewValues')
              
        for row in range(len(self.scrolledtext_EditSelectedRows_NewValues)):
            self.scrolledtext_EditSelectedRows_NewValues[row].clear()
            
        return
        
        
    def handlerEditSelectedRows_UpdateChangedValuesOnly(self):
        '''
        Purpose:
            Update changed values only for selected rows
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerEditSelectedRows_UpdateChangedValuesOnly')
              
# current table row              
        currentTableRow = self.EditSelectedRows_RowIndex + 1
# database
        myDatabase = self.EditSelectedRows_MyDatabase
# table
        myTable = self.EditSelectedRows_MyTable
              
# define empty lists
        fieldNumbersToUpdate = []
        valuesToUpdate = []
        fieldNamesToUpdate = []
              
# get new values to update selected table row
        icount = 0
        for row in range(len(self.scrolledtext_EditSelectedRows_NewValues)):
            value = self.scrolledtext_EditSelectedRows_NewValues[row].get().strip()
            if DEBUG_REPLACE:
                print('>> row, value = %s, %s' % (row,value))
            myField = self.EditSelectedRows_MyField[row]
            if value == 'NULL':
                fieldNumbersToUpdate.append(row)
                valuesToUpdate.append(' ')
                fieldNamesToUpdate.append(myField)
                icount += 1
            elif value <> '':
                fieldNumbersToUpdate.append(row)
                valuesToUpdate.append(value)
                fieldNamesToUpdate.append(myField)
                if DEBUG_REPLACE:
                    print('>> field Number, value, field Name = %s, %s, %s' % 
                        (
                        fieldNumbersToUpdate[icount],
                        valuesToUpdate[icount],
                        fieldNamesToUpdate[icount]
                         )
                        )
                icount += 1
                
# check if fields are empty
        if valuesToUpdate == []:
            stringNoNewValues = (
                'There are no new values to insert.\n\n' +
                'Input new values in the appropriate columns\n' +
                'and try again.'
                )
            print('\n' + stringNoNewValues)
            self.MySQL_Output(
                0,
                stringNoNewValues
                )
            try:
                showerror(
                    'Error: no new values to insert',
                    stringNoNewValues,
                    parent=self.toplevelEditSelectedRows,
                    )
            except:
                showerror(
                    'Error: no new values to insert',
                    stringNoNewValues,
                    parent=self.toplevelEditSelectedRows
                    )
            return
                
        indexAutoIndex = self.EditSelectedRows_AutoIndex
        myTable = self.EditSelectedRows_MyTable
        myDatabase = self.EditSelectedRows_MyDatabase
        
# assemble string to update database
# form replace string
        stringUpdateSet = (
            "UPDATE  " + myDatabase + "." + myTable + ' SET '
            )
            
# form fields and values
        stringFields = ''
        stringValues = ''
        stringTemp = ''
        
# update one at a time; this way, in case of an error we can keep track of which fields 
#   did not update properly
        iterLength = len(fieldNumbersToUpdate)
        iUpdateCount = 0
        iNoUpdateCount = 0
        for i in range(iterLength ):
            stringTemp = str(fieldNamesToUpdate[i]) + '="' + str(valuesToUpdate[i]) + '" ' 
        
            stringUpdate = (
                stringUpdateSet + stringTemp + "WHERE auto_index=" + str(indexAutoIndex) 
                )
            if DEBUG_REPLACE:
                print('\nstringUpdate:\n%s' % stringUpdate)
        
            try:
# throw exception even for warnings;
#  NOTE: these warnings still do not prevent the execute statement from inserting an integer value of
#        '0' when mistakenly inserting text into an integer field. This is a MySQL problem, not a PylotDB problem
#                import warnings
#                warnings.simplefilter('error', Warning)
                self.cursorHandleMySQL.execute(
                    stringUpdate
                    )
                iUpdateCount += 1
            except:
                iNoUpdateCount += 1
                stringErrorDuringReplace = (
                    'Unable to update \n\n' +
                    '  Field name: %s. %s\n' +
                    '  Database: %s\n' +
                    '  Table: %s\n' +
                    '  Row: %s\n' +
                    '  auto_index: %s\n\n' +
                    'Possible reasons:\n\n' +
                    ' - text is longer than the field allows\n' + 
                    ' - double quotes in text field (use only single quotes)\n' +
                    ' - wrong datatype\n' +
                    ' - you do not have write permissions to database\n' +
                    ' - database bug\n' +
                    ' - cannot blank a numeric field\n' +
                    ' - server is down\n\n' +
                    'Use PylotDB to check the database and/or table structure format\n' +
                    'to ensure new values conform to their expected datatype.\n\n' +
                    'Click YES if you wish to continue updating fields, NO to cancel.'
                    ) % (
                    fieldNumbersToUpdate[i] + 1,
                    fieldNamesToUpdate[i],
                    myDatabase,
                    myTable,
                    currentTableRow,
                    indexAutoIndex
                    )
                print('\n' + stringErrorDuringReplace) 
                self.MySQL_Output(
                    0,
                    stringErrorDuringReplace
                    )
                ans = askyesno(
                    'Error: cannot update field',
                    stringErrorDuringReplace,
                    parent=self.toplevelEditSelectedRows
                    )
                if not ans: 
                    stringUpdateCount = (
                        'So far, for Table row %s:\n\n' +
                        '  - Number of fields updated: %s\n\n' +
                        '  - Number of fields unable to update: %s\n\n' +
                        '  - Number of fields specified to update: %s\n'
#                        '  Total number of fields in table: %s\n' +
                        ) % (
                        currentTableRow,
                        iUpdateCount,
                        iNoUpdateCount,
                        iterLength,
#                        len(self.scrolledtext_EditSelectedRows_NewValues),
                        ) 
                    print('\n' + stringUpdateCount)
                    self.MySQL_Output(
                        0,
                        stringUpdateCount
                        )
                    showinfo(
                        'Info: stats',
                        stringUpdateCount,
                        parent=self.toplevelEditSelectedRows
                        )
                    break
                        
                        
        if iUpdateCount > 0: 
            stringSuccess = (
                'Final stats for Table row %s:\n\n' +
                '  - Number of fields updated: %s\n\n' +
                '  - Number of fields unable to update: %s\n\n' +
                '  - Number of fields specified to update: %s\n'
                ) % (                
                currentTableRow,
                iUpdateCount,
                iNoUpdateCount,
                iterLength,
                )
            print('\n' + stringSuccess)
            self.MySQL_Output(
                0,
                stringSuccess
                )      
            showinfo(
                'Info: update status',
                stringSuccess,
                parent=self.toplevelEditSelectedRows
                )
                
# set change flag
            self.flagEditSelectedRows_ChangesMade = True
        
# set SaveNewValues to NewValues
            self.editSelectedRows_SaveNewValues = []
            for i in range(len(self.tableStructure) - 1):
                self.editSelectedRows_SaveNewValues.append(
                    self.scrolledtext_EditSelectedRows_NewValues[i].get()
                    )
 
 # look for auto_index field
            flagAutoIndex = False
            for eachItem in self.tableStructureOriginal:
                if 'auto_index' in eachItem:
                    flagAutoIndex = True
                    break
                    
# update current values in window
# ... get current table values
# ...   assemble string to get field values
            if flagAutoIndex:
                stringTableValues = (
                    "SELECT * FROM " + myDatabase + "." + myTable 
                    + ' order by auto_index'
                    )
            else:
                stringTableValues = (
                    "SELECT * FROM " + myDatabase + "." + myTable 
                    )
                    
# ...   execute the command
            self.cursorHandleMySQL.execute(
                stringTableValues
                )
                
            self.tableValues = self.cursorHandleMySQL.fetchall()
            
# ... update window current values
            myIndex = self.EditSelectedRows_Index
            self.EditSelectedRows_DisplayFields(
                self.EditSelectedRows_rowsChecked[myIndex],
                self.EditSelectedRows_OriginalValues[myIndex],
                self.tableValues[self.EditSelectedRows_rowsChecked[myIndex]]
                )
             
        return
        
        
    def handlerEditSelectedRows_UpdateChangedAndBlankValues(self):
        '''
        Purpose:
            Update changed and blank values for selected rows
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerEditSelectedRows_UpdateChangedAndBlankValues')
              
# current table row              
        currentTableRow = self.EditSelectedRows_RowIndex + 1
# database
        myDatabase = self.EditSelectedRows_MyDatabase
# table
        myTable = self.EditSelectedRows_MyTable
              
# define empty lists
        fieldNumbersToUpdate = []
        valuesToUpdate = []
        fieldNamesToUpdate = []
              
# get new values to update selected table row
        icount = 0
        for row in range(len(self.scrolledtext_EditSelectedRows_NewValues)):
            value = self.scrolledtext_EditSelectedRows_NewValues[row].get().strip()
            if DEBUG_REPLACE:
                print('>> row, value = %s, %s' % (row,value))
            myField = self.EditSelectedRows_MyField[row]
            if value == '' or value == None or value == 'NULL':
                valuesToUpdate.append(' ')
            else:
                valuesToUpdate.append(value)
            fieldNumbersToUpdate.append(row)    
            fieldNamesToUpdate.append(myField)
            if DEBUG_REPLACE:
                print('>> field Number, value, field Name = %s, %s, %s' % 
                    (
                    fieldNumbersToUpdate[icount],
                    valuesToUpdate[icount],
                    fieldNamesToUpdate[icount]
                     )
                    )
            icount += 1
                        
                
# check if fields are empty
        if valuesToUpdate == []:
            stringNoNewValues = (
                'All new values are blank.\n\n' +
                'All current data will be overwritten! \n\n' +
                'Are you sure you want to insert blank values\n' +
                'for all fields?'
                )
            print('\n' + stringNoNewValues)
            self.MySQL_Output(
                0,
                stringNoNewValues
                )
            try:
#                showerror(
                ans = askyesno(
#                    'Error: no new values to insert',
                    'Error: all new values are blank',
                    stringNoNewValues,
                    parent=self.toplevelEditSelectedRows,
                    )
            except:
#                showerror(
                ans = askyesno(
                    'Error: no new values to insert',
                    stringNoNewValues,
                    parent=self.toplevelEditSelectedRows
                    )
            if ans:
                return
                
        indexAutoIndex = self.EditSelectedRows_AutoIndex
        myTable = self.EditSelectedRows_MyTable
        myDatabase = self.EditSelectedRows_MyDatabase
        
# assemble string to update database
# form replace string
        stringUpdateSet = (
            "UPDATE " + myDatabase + "." + myTable + ' SET '
            )
            
# form fields and values
        stringFields = ''
        stringValues = ''
        stringTemp = ''
        
# update one at a time; this way, in case of an error we can keep track of which fields 
#   did not update properly
        iterLength = len(fieldNumbersToUpdate)
        iUpdateCount = 0
        iNoUpdateCount = 0
        for i in range(iterLength ):
            if valuesToUpdate[i] == '':
                stringTemp = str(fieldNamesToUpdate[i]) + '=NULL '
            else:    
                stringTemp = str(fieldNamesToUpdate[i]) + '=\'' + str(valuesToUpdate[i]) + '\' ' #\\\n'
        
            stringUpdate = (
                stringUpdateSet + stringTemp + "WHERE auto_index=" + str(indexAutoIndex) 
                )
            if DEBUG_REPLACE:
                print('\nstringUpdate:\n%s' % stringUpdate)
        
            try:
                self.cursorHandleMySQL.execute(
                    stringUpdate
                    )
                iUpdateCount += 1
            except:
                iNoUpdateCount += 1
                stringErrorDuringReplace = (
                    'Unable to update \n\n' +
                    '  Field name: %s. %s\n' +
                    '  Database: %s\n' +
                    '  Table: %s\n' +
                    '  Row: %s\n' +
                    '  auto_index: %s\n\n' +
                    'Possible reasons:\n\n' +
                    ' - wrong datatype\n' +
                    ' - you do not have write permissions to database\n' +
                    ' - cannot blank a numeric field\n' +
                    ' - server is down\n\n' +
                    'Use PylotDB to check the database and/or table structure format\n' +
                    'to ensure new values conform to their expected datatype.\n\n' +
                    'Click YES if you wish to continue updating fields, NO to cancel.'
                    ) % (
                    fieldNumbersToUpdate[i] + 1,
                    fieldNamesToUpdate[i],
                    myDatabase,
                    myTable,
                    currentTableRow,
                    indexAutoIndex
                    )
                print('\n' + stringErrorDuringReplace) 
                self.MySQL_Output(
                    0,
                    stringErrorDuringReplace
                    )
                ans = askyesno(
                    'Error: cannot update field',
                    stringErrorDuringReplace,
                    parent=self.toplevelEditSelectedRows
                    )
                if not ans: 
                    stringUpdateCount = (
                        'So far, for Table row %s:\n\n' +
                        '  - Number of fields updated: %s\n\n' +
                        '  - Number of fields unable to update: %s\n\n' +
                        '  - Number of fields specified to update: %s\n'
#                        '  Total number of fields in table: %s\n' +
                        ) % (
                        currentTableRow,
                        iUpdateCount,
                        iNoUpdateCount,
                        iterLength,
#                        len(self.scrolledtext_EditSelectedRows_NewValues),
                        ) 
                    print('\n' + stringUpdateCount)
                    self.MySQL_Output(
                        0,
                        stringUpdateCount
                        )
                    showinfo(
                        'Info: stats',
                        stringUpdateCount,
                        parent=self.toplevelEditSelectedRows
                        )
                    break
         
        if iUpdateCount > 0:
            stringSuccess = (
                'Final stats for Table row %s:\n\n' +
                '  - Number of fields updated: %s\n\n' +
                '  - Number of fields unable to update: %s\n\n' +
                '  - Number of fields specified to update: %s\n'
                ) % (                
                currentTableRow,
                iUpdateCount,
                iNoUpdateCount,
                iterLength,
                )
            print('\n' + stringSuccess)
            self.MySQL_Output(
                0,
                stringSuccess
                )      
            showinfo(
                'Info: update status',
                stringSuccess,
                parent=self.toplevelEditSelectedRows
                )
            
# set change flag
            self.flagEditSelectedRows_ChangesMade = True
        
# set SaveNewValues to NewValues
            self.editSelectedRows_SaveNewValues = []
            for i in range(len(self.tableStructure) - 1):
                self.editSelectedRows_SaveNewValues.append(
                    self.scrolledtext_EditSelectedRows_NewValues[i].get()
                    )
                    
# look for auto_index field
            flagAutoIndex = False
            for eachItem in self.tableStructureOriginal:
                if 'auto_index' in eachItem:
                    flagAutoIndex = True
                    break
            
# update current values in window
# ... get current table values
# ...   assemble string to get field values
            if flagAutoIndex:
                stringTableValues = (
                    "SELECT * FROM " + myDatabase + "." + myTable
                    + ' order by auto_index'
                    )
            else:
                stringTableValues = (
                    "SELECT * FROM " + myDatabase + "." + myTable
                    )
                    
# ...   execute the command
            self.cursorHandleMySQL.execute(
                stringTableValues
                )
                
            self.tableValues = self.cursorHandleMySQL.fetchall()
            
# ... update window current values
            myIndex = self.EditSelectedRows_Index
            self.EditSelectedRows_DisplayFields(
                self.EditSelectedRows_rowsChecked[myIndex],
                self.EditSelectedRows_OriginalValues[myIndex],
                self.tableValues[self.EditSelectedRows_rowsChecked[myIndex]]
                )
             
        return

        
    def handlerEditSelectedRows_RestoreUsingOriginalValues(self):
        '''
        Purpose:
            Restore using original values for selected rows
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerEditSelectedRows_RestoreUsingOriginalValues')
              
# current table row              
        currentTableRow = self.EditSelectedRows_RowIndex + 1
# database
        myDatabase = self.EditSelectedRows_MyDatabase
# table
        myTable = self.EditSelectedRows_MyTable
              
# define empty lists
        fieldNumbersToUpdate = []
        valuesToUpdate = []
        fieldNamesToUpdate = []
              
# get original values to update selected table row
        icount = 0
        for row in range(len(self.scrolledtext_EditSelectedRows_OriginalValues)):
            value = self.scrolledtext_EditSelectedRows_OriginalValues[row].get().strip()
            print('\nvalue = %s\ntype(value) = %s\n' % (value,type(value)))
            if DEBUG_REPLACE:
                print('>> row, value = %s, %s' % (row,value))
            myField = self.EditSelectedRows_MyField[row]
            if value == '' or value == None or value == 'NULL':
                valuesToUpdate.append(' ')
            else:
                valuesToUpdate.append(value)
            fieldNumbersToUpdate.append(row)    
            fieldNamesToUpdate.append(myField)
            if DEBUG_REPLACE:
                print('>> field Number, value, field Name = %s, %s, %s' % 
                    (
                    fieldNumbersToUpdate[icount],
                    valuesToUpdate[icount],
                    fieldNamesToUpdate[icount]
                     )
                    )
            icount += 1
                        
                
# check if fields are empty
        if valuesToUpdate == []:
            stringNoOriginalValues = (
                'There are no original values to insert.\n\n' 
                )
            print('\n' + stringNoOriginalValues)
            self.MySQL_Output(
                0,
                stringNoOriginalValues
                )
            try:
                showerror(
                    'Error: no original values to insert',
                    stringNoOriginalValues,
                    parent=self.toplevelEditSelectedRows,
                    )
            except:
                showerror(
                    'Error: no original values to insert',
                    stringNoOriginalValues,
                    parent=self.toplevelEditSelectedRows
                    )
            return
                
        indexAutoIndex = self.EditSelectedRows_AutoIndex
        myTable = self.EditSelectedRows_MyTable
        myDatabase = self.EditSelectedRows_MyDatabase
        
# assemble string to update database
# form replace string
        stringUpdateSet = (
            "UPDATE " + myDatabase + "." + myTable + ' SET '
            )
            
# form fields and values
        stringFields = ''
        stringValues = ''
        stringTemp = ''
        
# update one at a time; this way, in case of an error we can keep track of which fields 
#   did not update properly
        iterLength = len(fieldNumbersToUpdate)
        iUpdateCount = 0
        iNoUpdateCount = 0
        for i in range(iterLength ):
            if valuesToUpdate[i] == '':
                stringTemp = str(fieldNamesToUpdate[i]) + '=NULL '
            else:    
                stringTemp = str(fieldNamesToUpdate[i]) + '=\'' + str(valuesToUpdate[i]) + '\' ' #\\\n'
        
            stringUpdate = (
                stringUpdateSet + stringTemp + "WHERE auto_index=" + str(indexAutoIndex) 
                )
            if DEBUG_REPLACE:
                print('\nstringUpdate:\n%s' % stringUpdate)
        
            try:
                self.cursorHandleMySQL.execute(
                    stringUpdate
                    )
                iUpdateCount += 1
            except:
                iNoUpdateCount += 1
                stringErrorDuringReplace = (
                    'Unable to update \n\n' +
                    '  Field name: %s. %s\n' +
                    '  Database: %s\n' +
                    '  Table: %s\n' +
                    '  Row: %s\n' +
                    '  auto_index: %s\n\n' +
                    'Possible reasons:\n\n' +
                    ' - double quotes in text field (use only single quotes)\n' +
                    ' - wrong datatype\n' +
                    ' - you do not have write permissions to database\n' +
                    ' - database bug\n' +
                    ' - cannot blank a numeric field\n' +
                    ' - server is down\n\n' +
                    'Use PylotDB to check the database and/or table structure format\n' +
                    'to ensure new values conform to their expected datatype.\n\n' +
                    'Click YES if you wish to continue updating fields, NO to cancel.'
                    ) % (
                    fieldNumbersToUpdate[i] + 1,
                    fieldNamesToUpdate[i],
                    myDatabase,
                    myTable,
                    currentTableRow,
                    indexAutoIndex
                    )
                print('\n' + stringErrorDuringReplace) 
                self.MySQL_Output(
                    0,
                    stringErrorDuringReplace
                    )
                ans = askyesno(
                    'Error: cannot update field',
                    stringErrorDuringReplace,
                    parent=self.toplevelEditSelectedRows
                    )
                if not ans: 
                    stringUpdateCount = (
                        'So far, for Table row %s:\n\n' +
                        '  - Number of fields updated: %s\n\n' +
                        '  - Number of fields unable to update: %s\n\n' +
                        '  - Number of fields specified to update: %s\n'
#                        '  Total number of fields in table: %s\n' +
                        ) % (
                        currentTableRow,
                        iUpdateCount,
                        iNoUpdateCount,
                        iterLength,
#                        len(self.scrolledtext_EditSelectedRows_NewValues),
                        ) 
                    print('\n' + stringUpdateCount)
                    self.MySQL_Output(
                        0,
                        stringUpdateCount
                        )
                    showinfo(
                        'Info: stats',
                        stringUpdateCount,
                        parent=self.toplevelEditSelectedRows
                        )
                    break
            
        if iUpdateCount > 0: 
            stringSuccess = (
                'Final stats for Table row %s:\n\n' +
                '  - Number of fields updated: %s\n\n' +
                '  - Number of fields unable to update: %s\n\n' +
                '  - Number of fields specified to update: %s\n'
                ) % (                
                currentTableRow,
                iUpdateCount,
                iNoUpdateCount,
                iterLength,
                )
            print('\n' + stringSuccess)
            self.MySQL_Output(
                0,
                stringSuccess
                )      
            showinfo(
                'Info: update status',
                stringSuccess,
                parent=self.toplevelEditSelectedRows
                )
                
# set change flag
            self.flagEditSelectedRows_ChangesMade = True
        
# set SaveNewValues to NewValues
            self.editSelectedRows_SaveNewValues = []
            for i in range(len(self.tableStructure) - 1):
                self.editSelectedRows_SaveNewValues.append(
                    self.scrolledtext_EditSelectedRows_NewValues[i].get()
                    )
 
# look for auto_index field
            flagAutoIndex = False
            for eachItem in self.tableStructureOriginal:
                if 'auto_index' in eachItem:
                    flagAutoIndex = True
                    break
                    
# update current values in window
# ... get current table values
# ...   assemble string to get field values
            if flagAutoIndex:
                stringTableValues = (
                    "SELECT * FROM " + myDatabase + "." + myTable
                    + ' order by auto_index'
                    )
            else:
                stringTableValues = (
                    "SELECT * FROM " + myDatabase + "." + myTable
                    )
                    
# ...   execute the command
            self.cursorHandleMySQL.execute(
                stringTableValues
                )
                
            self.tableValues = self.cursorHandleMySQL.fetchall()
            
# ... update window current values
            myIndex = self.EditSelectedRows_Index
            self.EditSelectedRows_DisplayFields(
                self.EditSelectedRows_rowsChecked[myIndex],
                self.EditSelectedRows_OriginalValues[myIndex],
                self.tableValues[self.EditSelectedRows_rowsChecked[myIndex]]
                )
             
        return

        
    def handlerEditPreviousSelectedRow(self):
        '''
        Purpose:
            edit the previously selected row before current row
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerEditPreviousSelectedRow') 
            
# check if next row to edit is last selected row; if so, disable Next button
        currentRow = self.EditSelectedRows_Index

        numRowsChecked = len(self.EditSelectedRows_rowsChecked)
# don't do anything here if only one row is checked 
        if numRowsChecked == 1:
            return
        
# some checks
        if DEBUG_EDITSELECTEDROWS:
            print('\n  currentRow = %s' % currentRow)
            print('len(self.EditSelectedRows_rowsChecked) = %s\n' % 
                len(self.EditSelectedRows_rowsChecked)
                )
# define flag for signaling when minimum row for editing is reached;
#    will print msg when true
        flag_MinimumRowReached = 0
        
        if currentRow <= 1:
# enable Next button
            buttonNextRow = Button(
                self.EditSelectedRows_frame_40,
                text='Next selected row -->',
                borderwidth=5,
                width=30,
                bg='tan',
                fg='black',
                state='normal',
                relief=RAISED,
                justify=CENTER,
                command=self.handlerEditNextSelectedRow,
                )
            buttonNextRow.grid(
                row=0,
                column=1,
                padx=5,
                pady=5,
                )
# disable Previous button
            buttonPreviousRow = Button(
                self.EditSelectedRows_frame_40,
                text='<-- Previous selected row',
                borderwidth=5,
                width=30,
                bg='tan',
                fg='lightgray',
                state='disabled',
                relief=RAISED,
                justify=CENTER,
                command=self.handlerEditPreviousSelectedRow,
                )
            buttonPreviousRow.grid(
                row=0,
                column=0,
                padx=5,
                pady=5,
                ) 
            flag_MinimumRowReached = 1

        else:
# enable Previous button
            buttonPreviousRow = Button(
                self.EditSelectedRows_frame_40,
                text='<-- Previous selected row',
                borderwidth=5,
                width=30,
                bg='tan',
                fg='black',
                state='normal',
                relief=RAISED,
                justify=CENTER,
                command=self.handlerEditPreviousSelectedRow,
                )
            buttonPreviousRow.grid(
                row=0,
                column=0,
                padx=5,
                pady=5,
                )
# enable Next button
            buttonNextRow = Button(
                self.EditSelectedRows_frame_40,
                text='Next selected row -->',
                borderwidth=5,
                width=30,
                bg='tan',
                fg='black',
                state='normal',
                relief=RAISED,
                justify=CENTER,
                command=self.handlerEditNextSelectedRow,
                )
            buttonNextRow.grid(
                row=0,
                column=1,
                padx=5,
                pady=5,
                )                
# decrement the index, but only if we have selected more than one row
        if len(self.EditSelectedRows_rowsChecked) > 1:
            self.EditSelectedRows_Index -= 1
            myIndex = self.EditSelectedRows_Index
            self.EditSelectedRows_DisplayFields(
                self.EditSelectedRows_rowsChecked[myIndex],
                self.EditSelectedRows_OriginalValues[myIndex],
                self.tableValues[self.EditSelectedRows_rowsChecked[myIndex]]
                )

# print min value reached
        if flag_MinimumRowReached:
            stringMinRowReached = (
                '\nThe minimum table row selected for edit has been reached.\n'
                )
            print(stringMinRowReached)
            self.MySQL_Output(
                0,
                stringMinRowReached
                )
            try:
                showinfo(
                    'Info: at min row',
                    stringMinRowReached,
                    parent=self.toplevelEditSelectedRows
                    )
            except:
                showinfo(
                    'Info: at min row',
                    stringMinRowReached
                    )
                
        return
        
        
        
    def handlerEditNextSelectedRow(self):
        '''
        Purpose:
            edit the next selected row after current row
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerEditNextSelectedRow') 
            
# check if next row to edit is last selected row; if so, disable Next button
        currentRow = self.EditSelectedRows_Index
        if DEBUG_EDITSELECTEDROWS:
            print('\n  currentRow = %s' % currentRow)
            print('len(self.EditSelectedRows_rowsChecked) = %s\n' % 
                (len(self.EditSelectedRows_rowsChecked))
                )
        
# define flag for signaling when minimum row for editing is reached;
#    will print msg when true
        flag_MaximumRowReached = 0
        
        numRowsChecked = len(self.EditSelectedRows_rowsChecked)
# don't do anything here if only one row is checked 
        if numRowsChecked == 1:
            return
            
        if currentRow >= len(self.EditSelectedRows_rowsChecked) - 2:
# disable Next button
            buttonNextRow = Button(
                self.EditSelectedRows_frame_40,
                text='Next selected row -->',
                borderwidth=5,
                width=30,
                bg='tan',
                fg='lightgray',
                state='disabled',
                relief=RAISED,
                justify=CENTER,
                command=self.handlerEditNextSelectedRow,
                )
            buttonNextRow.grid(
                row=0,
                column=1,
                padx=5,
                pady=5,
                )
# enable Previous button
            buttonPreviousRow = Button(
                self.EditSelectedRows_frame_40,
                text='<-- Previous selected row',
                borderwidth=5,
                width=30,
                bg='tan',
                fg='black',
                state='normal',
                relief=RAISED,
                justify=CENTER,
                command=self.handlerEditPreviousSelectedRow,
                )
            buttonPreviousRow.grid(
                row=0,
                column=0,
                padx=5,
                pady=5,
                )   
# set flag for max row reached
            flag_MaximumRowReached = 1
            
        else:
# enable Previous button
            buttonPreviousRow = Button(
                self.EditSelectedRows_frame_40,
                text='<-- Previous selected row',
                borderwidth=5,
                width=30,
                bg='tan',
                fg='black',
                state='normal',
                relief=RAISED,
                justify=CENTER,
                command=self.handlerEditPreviousSelectedRow,
                )
            buttonPreviousRow.grid(
                row=0,
                column=0,
                padx=5,
                pady=5,
                )
# enable Next button
            buttonNextRow = Button(
                self.EditSelectedRows_frame_40,
                text='Next selected row -->',
                borderwidth=5,
                width=30,
                bg='tan',
                fg='black',
                state='normal',
                relief=RAISED,
                justify=CENTER,
                command=self.handlerEditNextSelectedRow,
                )
            buttonNextRow.grid(
                row=0,
                column=1,
                padx=5,
                pady=5,
                )                
# increment the index, but only if we have selected more than one row
        if len(self.EditSelectedRows_rowsChecked) > 1:
            self.EditSelectedRows_Index += 1
            myIndex = self.EditSelectedRows_Index
            self.EditSelectedRows_DisplayFields(
                self.EditSelectedRows_rowsChecked[myIndex],
                self.EditSelectedRows_OriginalValues[myIndex],
                self.tableValues[self.EditSelectedRows_rowsChecked[myIndex]]
                )
            
# print if max row reached
        if flag_MaximumRowReached:
            stringMaxRowReached = (
                '\nThe maximum table row selected for edit has been reached.\n'
                )
            print(stringMaxRowReached)
            self.MySQL_Output(
                0,
                stringMaxRowReached
                )
            try:
                showinfo(
                    'Info: at max row',
                    stringMaxRowReached,
                    parent=self.toplevelEditSelectedRows
                    )
            except:
                showinfo(
                    'Info: at max row',
                    stringMaxRowReached
                    )
            
        return
        
        
    def EditSelectedRows_DisplayFields(
        self,rowIndex,tableRowOfOriginalValues,tableRowOfCurrentValues
        ):
        '''
        Purpose:
            display all fields as rows so user can edit the field values
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'EditSelectedRows_DisplayFields')
            
        if DEBUG_EDITSELECTEDROWS:
            print('rowIndex = %s' % rowIndex)
            print('len(tableRowOfCurrentValues) = %s' % len(tableRowOfCurrentValues))

# clear canvas
        self.clear_grid(self.frame_20_Canvas_Header_EditSelectedRows)
            
# use for updates
        self.EditSelectedRows_RowIndex = rowIndex
        
# define constants
        color_bg = self.EditSelectedRows_color_bg
        width_i = self.EditSelectedRows_width_i
        width_Fields = self.EditSelectedRows_width_Field
        width_Datatypes = self.EditSelectedRows_width_Datatype
        width_Values = self.EditSelectedRows_width_Values
        self.EditSelectedRows_AutoIndex = \
            tableRowOfCurrentValues[len(tableRowOfCurrentValues) - 1]

# clear label under title first
        self.varLabelEditSelectedRows_RowIndex.set(' '*50)
        self.varLabelEditSelectedRows_RowIndex.set(
            'currently editing table row ' + str(rowIndex + 1) + ', ' +
                'auto_index ' + str(self.EditSelectedRows_AutoIndex) + '\n' +
                'sequence ' + str(self.EditSelectedRows_Index + 1) + ' of ' + 
                str(len(self.EditSelectedRows_rowsChecked)) + ' rows selected' 
                )

        if rowIndex < 0 or rowIndex > (len(self.tableValues) - 1):
            stringIndexError = (
                'The index for row selection is out of range.\n\n' +
                'Current index range is\n' +
                '  0 <= rowIndex <= %s\n\n' +
                '  current value for rowIndex = %s\n\n' +
                'This is a coding error. Contact code administrator for\n' +
                'assistance in solving this error.'
                ) % (len(self.tableValues) - 1,rowIndex)
            print(stringIndexError)
            self.MySQL_Output(
                0,
                stringIndexError
                )
            showerror( 
                'Error: row index out of range',
                stringIndexError
                )
            return
            
# define empty lists
        self.EditSelectedRows_MyField = []
        self.scrolledtext_EditSelectedRows_OriginalValues = []
        self.scrolledtext_EditSelectedRows_CurrentValues = []
        self.scrolledtext_EditSelectedRows_NewValues = []
        yScroll_NewValues = []
        yScroll_CurrentValues = []
        yScroll_OriginalValues = []
        
# use to set text box height
        heightEntries = self.comboboxEditSelectedRows_TextHeight.get()
# check whether to use horizontal and/or vertical scrollbars;
#   values are either 'static' for display, or 'none' for do not display
        hscrollmode_EditSelectedRows = self.statusEditSelectedRows_HorizontalScrollbar
        vscrollmode_EditSelectedRows = self.statusEditSelectedRows_VerticalScrollbar

# determine which scrolledlist_items to use for 
#    'Select height of "Values" boxes'
        if (
        hscrollmode_EditSelectedRows == 'static' 
        or
        vscrollmode_EditSelectedRows == 'static'
        ):
            self.comboboxEditSelectedRows_TextHeight = Pmw.ComboBox(
                self.EditSelectedRows_frame_00,
                scrolledlist_items=self.heightsForEntryWidgets_WithScrollbar,
                listheight=140,
                entry_width=5,
                label_text='Select height of "Values" boxes: ',
                labelpos='w',
                label_background=self.EditSelectedRows_color_bg,
                selectioncommand=self.handlerEditSelectedRows_TextHeight,
                scrolledlist_hull_width=500,
                )
            self.comboboxEditSelectedRows_TextHeight.grid(
                row=2,
                column=0,
                padx=0,
                pady=5,
                )
            if eval(heightEntries) >= 3:
                self.comboboxEditSelectedRows_TextHeight.setentry(heightEntries)
            else:
                self.comboboxEditSelectedRows_TextHeight.setentry('3')
        else:
            self.comboboxEditSelectedRows_TextHeight = Pmw.ComboBox(
                self.EditSelectedRows_frame_00,
                scrolledlist_items=self.heightsForEntryWidgets_NoScrollbar,
                listheight=140,
                entry_width=5,
                label_text='Select height of "Values" boxes: ',
                labelpos='w',
                label_background=self.EditSelectedRows_color_bg,
                selectioncommand=self.handlerEditSelectedRows_TextHeight,
                scrolledlist_hull_width=500,
                )
            self.comboboxEditSelectedRows_TextHeight.grid(
                row=2,
                column=0,
                padx=0,
                pady=5,
                )
            if heightEntries == '':
                self.comboboxEditSelectedRows_TextHeight.setentry('1')
            else:
                self.comboboxEditSelectedRows_TextHeight.setentry(heightEntries) 

# re-calculate heightEntries to incorporate whether scrollbars have been invoked                    
        heightEntries = self.comboboxEditSelectedRows_TextHeight.get()
        
        
# scrollable canvas for fields, datatypes, current values, etc.
        rowCount = 3
        self.frame_20_EditSelectedRows = Frame(
            self.toplevelEditSelectedRows,
            bg=self.EditSelectedRows_color_bg,
            borderwidth=2,
            relief=RIDGE,
            )
        self.frame_20_EditSelectedRows.grid(
            row=rowCount,
            column=0,
            padx=2,
            pady=2,
            sticky=N+E+W
            )

        yScroll_frame_20 = Scrollbar(
            self.toplevelEditSelectedRows,
            orient=VERTICAL,
            command=self.handlerEditYScrollFrame20,
            )
        yScroll_frame_20.grid(
            row=rowCount,
            column=1,
            padx=3,
            sticky=N+S+W,
            )
        rowCount += 1
        xScroll_frame_20 = Scrollbar(
            self.toplevelEditSelectedRows,
            orient=HORIZONTAL,
            command=self.handlerEditXScrollFrame15Frame20,
            )
        xScroll_frame_20.grid(
            row=rowCount,
            column=0,
            sticky=N+E+W,
            )
                            
        self.canvas_20_EditSelectedRows = Canvas(
            self.frame_20_EditSelectedRows,
            bg=self.EditSelectedRows_color_bg,
            confine=0,
            width=985,
            height=600,
            xscrollcommand=xScroll_frame_20.set,
            yscrollcommand=yScroll_frame_20.set, 
            )
        self.canvas_20_EditSelectedRows.grid(
            row=0,
            column=0,
            padx=2,
            pady=2,
            sticky=N,
            )
        self.frame_20_Canvas_Header_EditSelectedRows = Frame(
            self.canvas_20_EditSelectedRows,
            bg=self.EditSelectedRows_color_bg,
            padx=1,
            )
        
# display all fields except auto_index in selected row; can't change auto_index!
        for i in range(len(self.tableStructure) - 1):
            if DEBUG_EDITSELECTEDROWS:
                print('\n  rowIndex, i = %s, %s' % (rowIndex,i))
            myField, myDatatype, myNull, myKey, myDefault, myExtra = \
                self.tableStructure[i]
#                            print(
#                                '%3s. %20s %20s %3s %3s %20s %20s' % 
#                                (i+1, myField, myDatatype, myNull, myKey, myDefault, myExtra)
#                                )
            self.MySQL_Output(
                0,
                '%4s. | %-12s | %-15s | %-3s | %-3s | %-15s | %-15s |' % 
                (i+1, myField, myDatatype, myNull, myKey, myDefault, myExtra)
                )      
                
# use following in updates of row in table
            self.EditSelectedRows_MyField.append(myField) 

# Field frames - 6 total
            columnCount=0
# ... field 0 - row number
            varField0 = StringVar()
            entryField0 = Entry(
#                self.EditSelectedRows_frame_20.interior(),
                self.frame_20_Canvas_Header_EditSelectedRows,
                textvariable = varField0,
                bg=color_bg,
                width=width_i,
                justify=RIGHT,
                relief=FLAT,
                state='disable',
                disabledbackground=color_bg,
                disabledforeground='black',
                )
            entryField0.grid(
                row=i,
                column=columnCount,
                padx=2,
                pady=2,
                sticky='n',
                )
            varField0.set(str(i+1) + '.')
# ... field 1 - field
            columnCount+=1
            entryField1 = Text(
#                self.EditSelectedRows_frame_20.interior(),
                self.frame_20_Canvas_Header_EditSelectedRows,
                wrap=NONE,
                height=1,
                font=self.entryDefaultFont,
                width=width_Fields,
                relief=SUNKEN,
                )
            entryField1.grid(
                row=i,
                column=columnCount,
                padx=2,
                pady=2,
                sticky='n',
                ) 
            entryField1.configure(state='normal')
            entryField1.insert(
                1.0,
                myField
                )
            entryField1.configure(state='disabled')
#            varField1.set(myField)

# ... field 2 - datatype
            columnCount+=1
#            varField2 = StringVar()
            entryField2 = Text(
#                self.EditSelectedRows_frame_20.interior(),
                self.frame_20_Canvas_Header_EditSelectedRows,
#                textvariable = varField2,
                width=width_Datatypes,
                wrap=NONE,
                height=1,
                font=self.entryDefaultFont,
                relief=SUNKEN,
                )
            entryField2.grid(
                row=i,
                column=columnCount,
                padx=2,
                pady=2,
                sticky='n',
                )
            entryField2.configure(state='normal')
            entryField2.insert(
                1.0,
                myDatatype
                )
            entryField2.configure(state='disabled')

                      
# ... field 3 - original values
            columnCount += 1              
            self.scrolledtext_EditSelectedRows_OriginalValues.append('')
            self.scrolledtext_EditSelectedRows_OriginalValues[i] = Pmw.ScrolledText(
#                self.EditSelectedRows_frame_20.interior(),
                self.frame_20_Canvas_Header_EditSelectedRows,
                columnheader=0,
                rowheader=0,
                text_wrap='none',
                hscrollmode=hscrollmode_EditSelectedRows,
                vscrollmode=vscrollmode_EditSelectedRows,
                scrollmargin=2,
                usehullsize=0,
                text_font=self.entryDefaultFont,
                text_height=heightEntries,
                text_width=width_Values,
                text_background='white',
                text_foreground='black',
                )
            self.scrolledtext_EditSelectedRows_OriginalValues[i].grid(
                row=i,
                column=columnCount,
                padx=4,
                pady=2,
                sticky='n',
                )
            self.scrolledtext_EditSelectedRows_OriginalValues[i].configure(text_state=NORMAL)
            if tableRowOfOriginalValues[i] <> None:
                self.scrolledtext_EditSelectedRows_OriginalValues[i].setvalue(
                    tableRowOfOriginalValues[i]
                    )
            else:
                self.scrolledtext_EditSelectedRows_OriginalValues[i].setvalue(
                    ''
                    )  
            self.scrolledtext_EditSelectedRows_OriginalValues[i].configure(text_state=DISABLED)
            
# ... field 4 - current values
            columnCount += 1                
            self.scrolledtext_EditSelectedRows_CurrentValues.append('')
            self.scrolledtext_EditSelectedRows_CurrentValues[i] = Pmw.ScrolledText(
#                self.EditSelectedRows_frame_20.interior(),
                self.frame_20_Canvas_Header_EditSelectedRows,
                columnheader=0,
                rowheader=0,
                text_wrap='none',
                hscrollmode=hscrollmode_EditSelectedRows,
                vscrollmode=vscrollmode_EditSelectedRows,
                scrollmargin=2,
                usehullsize=0,
                text_font=self.entryDefaultFont,
                text_height=heightEntries,
                text_width=width_Values,
                text_background='white',
                text_foreground='black',
                )
            self.scrolledtext_EditSelectedRows_CurrentValues[i].grid(
                row=i,
                column=columnCount,
                padx=4,
                pady=2,
                sticky='n',
                )
            if DEBUG_EDITSELECTEDROWS:
                print('\ntableRowOfCurrentValues = ')
                print(tableRowOfCurrentValues)
                print               
            self.scrolledtext_EditSelectedRows_CurrentValues[i].configure(text_state=NORMAL)
            if tableRowOfCurrentValues[i] <> None:
                self.scrolledtext_EditSelectedRows_CurrentValues[i].setvalue(
                    tableRowOfCurrentValues[i]
                    )
            else:
                self.scrolledtext_EditSelectedRows_CurrentValues[i].setvalue(
                    ''
                    )  
            self.scrolledtext_EditSelectedRows_CurrentValues[i].configure(text_state=DISABLED)
            
# ... field 5 - new values
            columnCount += 1            
            self.scrolledtext_EditSelectedRows_NewValues.append('')
            self.scrolledtext_EditSelectedRows_NewValues[i] = Pmw.ScrolledText(
#                self.EditSelectedRows_frame_20.interior(),
                self.frame_20_Canvas_Header_EditSelectedRows,
                columnheader=0,
                rowheader=0,
                text_wrap='none',
                hscrollmode=hscrollmode_EditSelectedRows,
                vscrollmode=vscrollmode_EditSelectedRows,
                scrollmargin=2,
                usehullsize=0,
                text_font=self.entryDefaultFont,
                text_height=heightEntries,
                text_width=width_Values,
                text_background='white',
                text_foreground='black',
                text_state=NORMAL,
                )
            self.scrolledtext_EditSelectedRows_NewValues[i].grid(
                row=i,
                column=columnCount,
                padx=4,
                pady=2,
                sticky='n',
                )
#            self.scrolledtext_EditSelectedRows_NewValues[i].clear()
            if self.varKeepNewValuesEntries.get():
                self.scrolledtext_EditSelectedRows_NewValues[i].setvalue(
                    self.editSelectedRows_SaveNewValues[i].strip()
                    )
            else:
                self.scrolledtext_EditSelectedRows_NewValues[i].setvalue(
                    ''
                    )
            
# reposition widgets to be gridded correctly at top of frame
# ... frame_15
        self.frame_15_Canvas_Header_EditSelectedRows.grid_rowconfigure(1,weight=1)
        self.canvas_15_Header_EditSelectedRows.create_window(
            0,
            0,
            anchor=NW,
            window=self.frame_15_Canvas_Header_EditSelectedRows
                )
        self.frame_15_Canvas_Header_EditSelectedRows.update_idletasks()
        self.canvas_15_Header_EditSelectedRows.config(
            scrollregion=self.canvas_15_Header_EditSelectedRows.bbox('all')
            )
# ... frame_20
        self.frame_20_Canvas_Header_EditSelectedRows.grid_rowconfigure(1,weight=1)
        self.canvas_20_EditSelectedRows.create_window(
            0,
            0,
            anchor=NW,
            window=self.frame_20_Canvas_Header_EditSelectedRows
            )
        self.frame_20_Canvas_Header_EditSelectedRows.update_idletasks()
        self.canvas_20_EditSelectedRows.config(
            scrollregion=self.canvas_20_EditSelectedRows.bbox('all')
             )
        
        return
        
        
    def handlerInputNewRowsManually(self):
        '''
        Purpose:
            input new rows manually; can place rows in arbitrary location
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerInputNewRowsManually')
            
# set last button pressed
        self.lastButtonPressed(
            BUTTONLABEL_INSERTNEWROWS
            )
        
# check if connected to a MySQL server
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return   
        
# define background color
        self.InputNewRows_color_bg = 'lightblue'
        
# initialize self.storeValues used in conjunction with 'Keep "New Values" entries...' checkbox               
        for i in range(len(self.tableStructure) - 1):
            self.storeValues = ''
                               
# define field widths
        self.InputNewRows_width_i = 3
        self.InputNewRows_width_Fields = 35
        self.InputNewRows_width_Datatypes = 15
        self.InputNewRows_width_NewValues = 40
        widthIncrementDueToScrollbar = 3
        
# define flag for checking if any changes have been made to the database
        self.flagInputNewRows_ChangesMade = False

        myTable = self.comboboxDbTableSelect.get().strip()
        myDatabase = self.comboboxDbSelect.get().strip()
        
        if (
            myTable == '' or
            myDatabase == ''
            ):
            stringError = '\nINSERT NEW ROWS requires the following action:\n\n'
            if myDatabase == '':
                stringError += ' "Select database:"\n\n'
            if myTable == '':
                stringError += ' "Select table:"\n\n'
            stringError += 'Select appropriate values and try again.'
            self.MySQL_Output(
                1,
                stringError
                )
            showerror(
                'Error: missing fields',
                stringError
                )
            return

# check if database is valid
        for database in self.myDatabases:
            if myDatabase == database:
# check if table is valid
                for table in self.myDatabaseTables:
                    if myTable == table:
# if we get here, both database and table are valid, so assemble string
# ... get table structure for window; will use only first two items from each row:
# ...   the header and the datatype
                        stringTableStructure = (
                            "SHOW COLUMNS FROM " + myDatabase + "." + myTable
                            )
                        self.MySQL_Commands(
                            1,
                            'self.cursorHandleMySQL.execute("' + stringTableStructure + '")'
                            )
                        start=time.time()
                        self.cursorHandleMySQL.execute(
                            stringTableStructure
                            )
                        self.tableStructure = self.cursorHandleMySQL.fetchall()
                        finish=time.time()
                        delta_t = finish - start
                        self.MySQL_Commands(
                            0,
                            '  (Time: %-7.4f secs)' % delta_t
                            )  
                            
                        if DEBUG_INSERTROW:
                            self.MySQL_Output(
                                1,
                                'Structure of table "' + myTable + '":\n'
                                )
                            self.MySQL_Output(
                                0,
                                self.tableStructure
                                )

# display in a text box with scrollbars

# FRAMES

# ... to destroy previous window  
                        '''
                        try:
                            self.handlerDestroyToplevelInputNewRowsManually()
                            self.MySQL_Output(
                                1,
                                'Previous toplevel widget removed from screen.'
                                )
                        except: 
                            self.MySQL_Output(
                                1,
                                'No previous toplevel widget to remove from screen.'
                                )
                        '''
                                
# ... to leave previous window intact, print warning, and return
                        mapped = self.handlerCheckIfMapped_InputNewRows()
                            
                        if mapped:
                            stringWindowIsOpen = (
                                'Window "INSERT NEW ROWS" is already open.'
                                )
                            print('\n' + stringWindowIsOpen)
                            self.MySQL_Output(
                                0,
                                stringWindowIsOpen
                                )
                            try:
                                showinfo(
                                    'Info: window is open',
                                    stringWindowIsOpen,
                                    parent=self.toplevelInputNewRowsManually,
                                    )
                            except:
                                showinfo(
                                    'Info: window is open',
                                    stringWindowIsOpen
                                    )
                            return
            
# open Toplevel frame for entering database name
                        self.toplevelInputNewRowsManually = Toplevel(
#            self.frameParent,
                            bg=self.InputNewRows_color_bg,
                            )
                        self.toplevelInputNewRowsManually.title(
                            'Server: ' + self.comboServerMySQL.get() + '     ' +
                            'Database: ' + self.varTableFunctionsSelectDatabase.get() + '     ' +
                            'Table: ' + self.varEntryTableFunctionsSelectTable.get().strip()
                            )
                        self.toplevelInputNewRowsManually.transient(self.toplevelTableValues)
# place the top window
                        self.toplevelInputNewRowsManually.geometry(
                            '+%d+%d' % (
                            self.inputnewrowsmanually_xWindowLocation,
                            self.inputnewrowsmanually_yWindowLocation
                            )
                            )
                            
# -------- FRAMES -------------
                            
                        rowCount = 0
# title
                        self.InputNewRows_frame_00 = Frame(
                            self.toplevelInputNewRowsManually,
                            bg=self.InputNewRows_color_bg,
                            )
                        self.InputNewRows_frame_00.grid(
                            row=rowCount,
                            column=0,
                            pady=2,
                            )

                        rowCount += 1
                        self.frame_10_InputNewRows = Frame(
                            self.toplevelInputNewRowsManually,
                            bg=self.InputNewRows_color_bg,
                            )
                        self.frame_10_InputNewRows.grid(
                            row=rowCount,
                            column=0,
                            pady=2,
                            sticky=W,
                            )
# table header   
                        rowCount += 1
                        self.frame_15_Header_NewRowsManually = Frame(
                            self.toplevelInputNewRowsManually,
                            bg=self.InputNewRows_color_bg,
                            )
                        self.frame_15_Header_NewRowsManually.grid(
                            row=rowCount,
                            column=0,
                            padx=2,
                            pady=2,
                            sticky=N+E+W
                            )
                        self.canvas_15_Header_NewRowsManually = Canvas(
                            self.frame_15_Header_NewRowsManually,
                            bg=self.InputNewRows_color_bg,
                            highlightbackground=self.InputNewRows_color_bg,
                            confine=0,
                            width=750,
                            height=40,
                            )
                        self.canvas_15_Header_NewRowsManually.grid(
                            row=0,
                            column=0,
                            padx=0,
                            pady=0,
                            sticky=N,
                            )
                        self.frame_15_Canvas_Header_NewRowsManually = Frame(
                            self.canvas_15_Header_NewRowsManually,
                            bg=self.InputNewRows_color_bg,
                            padx=1,
                            pady=0,
                            )
                                
# scrollable canvas for fields, datatypes, current values, etc.                            
                        rowCount += 1
                        self.frame_20_InputNewRows = Frame(
                            self.toplevelInputNewRowsManually,
                            bg=self.InputNewRows_color_bg,
                            borderwidth=2,
                            relief=RIDGE,
                            )
                        self.frame_20_InputNewRows.grid(
                            row=rowCount,
                            column=0,
                            padx=2,
                            pady=2,
                            sticky=N+E+W
                            )
                        yScroll_frame_20 = Scrollbar(
                            self.toplevelInputNewRowsManually,
                            orient=VERTICAL,
                            command=self.handlerInputYScrollFrame20,
                            )
                        yScroll_frame_20.grid(
                            row=rowCount,
                            column=1,
                            padx=3,
                            sticky=N+S+W,
                            )
                        rowCount += 1
                        xScroll_frame_20 = Scrollbar(
                            self.toplevelInputNewRowsManually,
                            orient=HORIZONTAL,
                            command=self.handlerInputXScrollFrame15Frame20,
                            )
                        xScroll_frame_20.grid(
                            row=rowCount,
                            column=0,
                            sticky=N+E+W,
                            )
                        self.canvas_20_InputNewRows = Canvas(
                            self.frame_20_InputNewRows,
                            bg=self.InputNewRows_color_bg,
                            confine=0,
                            width=750,
                            height=620,
                            xscrollcommand=xScroll_frame_20.set,
                            yscrollcommand=yScroll_frame_20.set, 
                            )
                        self.canvas_20_InputNewRows.grid(
                            row=0,
                            column=0,
                            padx=2,
                            pady=2,
                            sticky=N,
                            )
                        self.frame_20_Canvas_Header_InputNewRows = Frame(
                            self.canvas_20_InputNewRows,
                            bg=self.InputNewRows_color_bg,
                            padx=1,
                            )
# handler for scrolling two grids in X direction
#                        xScroll_frame_20.config(
#                            command=self.handlerInputXScrollFrame15Frame20
#                            )
# handler for scrolling one grid in Y direction
#                        yScroll_frame_20.config(
#                            command=self.handlerInputYScrollFrame20
#                            )
                    
# buttons for cancel, insert location, etc. 
                        rowCount += 1
                        frame_30 = Frame(
                            self.toplevelInputNewRowsManually,
                            bg=self.InputNewRows_color_bg,
                            )                            
                        frame_30.grid(
                            row=rowCount,
                            column=0,
                            pady=2,
                            )
    
# ------- WIDGETS ---------

# title
                        labelTableInputNewRowsMain = Label(
                            self.InputNewRows_frame_00,
                            text='INSERT NEW ROWS INTO TABLE "' + myTable + '" ',
                            font=self.labelFontMediumBold,
                            bg=self.InputNewRows_color_bg,
                            justify=CENTER,
                            )
                        labelTableInputNewRowsMain.grid(
                            row=0,
                            column=0,
                            pady=5,
                            )
# sub-title -- display which row is being generated                           
                        self.labelInputNewRows_CurrentRowNumber = Label(
                            self.InputNewRows_frame_00,
                            text='This insert will generate Row %s' % 
                                str(len(self.tableValues) + 1),
                            font=self.labelFontMediumBold,
                            bg=self.InputNewRows_color_bg,
                            justify=CENTER,
                            )
                        self.labelInputNewRows_CurrentRowNumber.grid(
                            row=1,
                            column=0,
                            pady=5,
                            )
# combobox for specifying height of text widgets
                        self.comboboxInputNewRows_TextHeight = Pmw.ComboBox(
                            self.InputNewRows_frame_00,
                            scrolledlist_items=self.heightsForInputWidgets_NoScrollbar,
                            listheight=140,
                            entry_width=5,
                            label_text='Select height of "Values" box: ',
                            labelpos='w',
                            label_background=self.InputNewRows_color_bg,
                            selectioncommand=self.handlerInputNewRows_TextHeight,
                            scrolledlist_hull_width=500,
                            )
                        self.comboboxInputNewRows_TextHeight.grid(
                            row=2,
                            column=0,
                            padx=0,
                            pady=5,
                            )
                        self.comboboxInputNewRows_TextHeight.setentry('1')
                        
# checkbox for horizontal scrollbar display
                        self.varInputNewRows_HorizontalScrollbar = IntVar()
                        self.checkboxInputNewRows_HorizontalScrollbar = Checkbutton(
                            self.frame_10_InputNewRows,
                            variable=self.varInputNewRows_HorizontalScrollbar,
                            text='Display horizontal scrollbars',
                            bg=self.InputNewRows_color_bg,
                            command=self.handlerInputNewRows_HorizontalScrollbar,
                            )
                        self.checkboxInputNewRows_HorizontalScrollbar.grid(
                            row=0,
                            column=0,
                            padx=5,
                            pady=0,
                            sticky='e',
                            )
                        self.statusInputNewRows_HorizontalScrollbar = 'none'
# checkbox for vertical scrollbar display
                        self.varInputNewRows_VerticalScrollbar = IntVar()
                        self.checkboxInputNewRows_VerticalScrollbar = Checkbutton(
                            self.frame_10_InputNewRows,
                            variable=self.varInputNewRows_VerticalScrollbar,
                            text='Display vertical scrollbars',
                            bg=self.InputNewRows_color_bg,
                            command=self.handlerInputNewRows_VerticalScrollbar,
                            )
                        self.checkboxInputNewRows_VerticalScrollbar.grid(
                            row=0,
                            column=1,
                            padx=5,
                            pady=0,
                            sticky='w',
                            )
                        self.statusInputNewRows_VerticalScrollbar = 'none'
# checkbox for keeping 'New Values' entries displayed for next row entry
                        self.varKeepNewValuesEntries_InputNewRows = IntVar()
                        self.varKeepNewValuesEntries_InputNewRows.set(1)
                        self.checkboxKeepNewValuesEntries_InputNewRows = Checkbutton(
                            self.frame_10_InputNewRows,
                            variable=self.varKeepNewValuesEntries_InputNewRows,
                            text='Keep "New Values" entries displayed for subsequent inserts',
                            bg=self.InputNewRows_color_bg,
                            command=self.handlerClearRestoreNewValues,
                            )
                        self.checkboxKeepNewValuesEntries_InputNewRows.grid(
                            row=0,
                            column=2,
                            padx=5,
                            pady=0,
                            sticky='w',
                            )

# Header
# ... header0                                
                        varHeader0 = StringVar()
                        entryFieldLabel0 = Entry(
#                            frame_15.interior(),
                            self.frame_15_Canvas_Header_NewRowsManually,
                            textvariable=varHeader0,
                            width=self.InputNewRows_width_i,
                            bg=self.InputNewRows_color_bg,
                            fg='black',
                            justify=RIGHT,
 #                           font=self.headerFontSmall,
                            relief=FLAT,
                            state='disable',
                            disabledbackground=self.InputNewRows_color_bg,
                            disabledforeground='black',
                            )
                        entryFieldLabel0.grid(
                            row=0,
                            column=0,
                            padx=2,
                            pady=2,
                            sticky=S,
                            )
                        varHeader0.set('  # ')
# ... header1
                        varHeader1 = StringVar()
                        entryFieldLabel1 = Entry(
#                            frame_15.interior(),
                            self.frame_15_Canvas_Header_NewRowsManually,
                            textvariable=varHeader1,
                            width=self.InputNewRows_width_Fields,
                            bg=self.InputNewRows_color_bg,
                            fg='black',
#                            font=self.headerFontSmall,
                            relief=FLAT,
                            state='disable',
                            disabledbackground=self.InputNewRows_color_bg,
                            disabledforeground='black',
                            )
                        entryFieldLabel1.grid(
                            row=0,
                            column=1,
                            padx=2,
                            pady=2,
                            sticky=S,
                            )
                        varHeader1.set('  Fields')
# ... header2
                        varHeader2 = StringVar()
                        entryFieldLabel2 = Entry(
#                            frame_15.interior(),
                            self.frame_15_Canvas_Header_NewRowsManually,
                            textvariable=varHeader2,
                            width=self.InputNewRows_width_Datatypes,
                            bg=self.InputNewRows_color_bg,
#                            font=self.headerFontSmall,
                            relief=FLAT,
                            state='disable',
                            disabledbackground=self.InputNewRows_color_bg,
                            disabledforeground='black',
                            )
                        entryFieldLabel2.grid(
                            row=0,
                            column=2,
                            padx=2,
                            pady=2,
                            sticky=S,
                            )
                        varHeader2.set('  Datatypes')
# ... header3
                        varHeader3 = StringVar()
                        entryFieldLabel3 = Entry(
#                            frame_15.interior(),
                            self.frame_15_Canvas_Header_NewRowsManually,
                            textvariable=varHeader3,
                            width=(
                                self.InputNewRows_width_NewValues # + widthIncrementDueToScrollbar
                                ),
                            bg=self.InputNewRows_color_bg,
#                            font=self.headerFontSmall,
                            relief=FLAT,
                            state='disable',
                            disabledbackground=self.InputNewRows_color_bg,
                            disabledforeground='black',
                            )
                        entryFieldLabel3.grid(
                            row=0,
                            column=3,
                            padx=2,
                            pady=2,
                            sticky=S,
                            )
                        varHeader3.set('  New values')
# ... header 4 - clear new values
                        buttonClearNewValues = Button(
#                            frame_15.interior(),
                            self.frame_15_Canvas_Header_NewRowsManually,
                            text='Clear New Values',
                            width=15,
                            borderwidth=5,
                            relief=RAISED,
                            justify=CENTER,
                            bg='white',
                            fg='blue',
#                            font=self.buttonFontSmall,
                            font=self.entryDefaultFont,
                            command=self.handlerInputNewRows_ClearNewValues,
                            )
                        buttonClearNewValues.grid(
                            row=0,
                            column=3,
                            padx=2,
                            pady=2,
                            sticky=E,
                            ) 

# initialize new values to blank fields
                        self.inputNewRows_SaveNewValues = []
                        for row in range(len(self.tableStructure) - 1):
                            self.inputNewRows_SaveNewValues.append('')
                            
# display current fields and datatypes for inserting new values;
#   rest of window stays same

                        self.InputNewRows_DisplayFields()
 
# insert into table button   
                        buttonInsertNewRow = Button(
                            frame_30,
                            text='Insert new row into table',
                            borderwidth=5,
                            width=25,
                            bg='white',
                            fg='blue',
                            relief=RAISED,
                            justify=CENTER,
                            command= self.handlerInputNewRowsManually_InsertIntoTable,
                            )
                        buttonInsertNewRow.grid(
                            row=0,
                            column=0,
                            padx=5,
                            pady=5,
                            )
# cancel button
                        buttonCancelNewRow = Button(
                            frame_30,
                            text='Close',
                            borderwidth=5,
                            width=25,
                            relief=RAISED,
                            justify=CENTER,
                            command=self.handlerDestroyToplevelInputNewRowsManually,
                            )
                        buttonCancelNewRow.grid(
                            row=0,
                            column=1,
                            padx=5,
                            pady=5,
                            )
                        
                        return
# invalid table     
                stringTableNotFound = (
                    'The following table was not found in list of current tables:\n\n' +
                    ' Table: %s\n' +
                    ' Database: %s\n\n' +
                    'Select another table.\n' +
                    'This operation is canceled.'
                    ) % (myTable, myDatabase)
                self.MySQL_Output(
                    1,
                    stringTableNotFound
                    )
                showerror(
                    'Error: table not found',
                    stringTableNotFound
                    )
                return
# invalid database
        stringDatabaseNotFound = (
            'The following database was not found:\n\n' +
                    ' Database: %s\n\n' +
                    'Select another database.\n' +
                    'This operation is canceled.'
                    ) % (myDatabase)
        self.MySQL_Output(
            1,
            stringDatabaseNotFound
            )
        showerror(
            'Error: database not found',
            stringDatabaseNotFound
            )
            
        return
        
        
    def handlerClearRestoreNewValues(self):
        '''
        Purpose:
        Clear or restore values in the 'New Values' column of the 
        'Insert New Rows Into Table' window
        '''
        
        checked = self.varKeepNewValuesEntries_InputNewRows.get()
                
        if checked:
# ... update current values and display in window                 
            for i in range(len(self.tableStructure) - 1):
                self.scrolledtext_InputNewRows_NewValues[i].setvalue(
#                    self.inputNewRows_SaveNewValues[i].strip()
                    self.storeValues[i]
                    )
        
        else:
# store the most recent values when checkbox was checked or unchecked last
            self.storeValues = []
            for i in range(len(self.tableStructure) - 1):
                self.storeValues.append(
                    self.scrolledtext_InputNewRows_NewValues[i].getvalue().strip()
                    )
# blank fields
            for i in range(len(self.tableStructure) - 1):
                self.scrolledtext_InputNewRows_NewValues[i].setvalue(
                    ''
                    )
        
    def handlerInputXScrollFrame15Frame20(self,*args):
        '''
        allows synchronized scrolling between two frames
       '''
        self.canvas_15_Header_NewRowsManually.xview(*args)
        self.canvas_20_InputNewRows.xview(*args)
       
        return
       
       
    def handlerInputYScrollFrame20(self,*args):
        '''
        allows scrolling of one frame
       '''
        self.canvas_20_InputNewRows.yview(*args)
        
        return
        
        
    def InputNewRows_DisplayFields(self):
        '''
        Purpose:
            display fields for input of new rows into database table
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'InputNewRows_DisplayFields')
                
# clear canvas
        self.clear_grid(self.frame_20_Canvas_Header_InputNewRows)
        
# define empty list
        self.entryField1_InputNewRowsManually = []
        self.scrolledtext_InputNewRows_NewValues = []
        
# define constants
        width_i = self.InputNewRows_width_i
        width_Fields = self.InputNewRows_width_Fields
        width_Datatypes = self.InputNewRows_width_Datatypes
        width_NewValues = self.InputNewRows_width_NewValues
        

# use to set text box height
        heightEntries = self.comboboxInputNewRows_TextHeight.get()
# check whether to use horizontal and/or vertical scrollbars;
#   values are either 'static' for display, or 'none' for do not display
        hscrollmode_InputNewRows = self.statusInputNewRows_HorizontalScrollbar
        vscrollmode_InputNewRows = self.statusInputNewRows_VerticalScrollbar

        
# scrollable canvas for fields, datatypes, current values, etc.                            
        rowCount = 3
        self.frame_20_InputNewRows = Frame(
            self.toplevelInputNewRowsManually,
            bg=self.InputNewRows_color_bg,
            borderwidth=2,
            relief=RIDGE,
            )
        self.frame_20_InputNewRows.grid(
            row=rowCount,
            column=0,
            padx=2,
            pady=2,
            sticky=N+E+W
            )

        yScroll_frame_20 = Scrollbar(
            self.toplevelInputNewRowsManually,
            orient=VERTICAL,
            command=self.handlerInputYScrollFrame20,
            )
        yScroll_frame_20.grid(
            row=rowCount,
            column=1,
            padx=3,
            sticky=N+S+W,
            )
        rowCount += 1
        xScroll_frame_20 = Scrollbar(
            self.toplevelInputNewRowsManually,
            orient=HORIZONTAL,
            command=self.handlerInputXScrollFrame15Frame20,
            )
        xScroll_frame_20.grid(
            row=rowCount,
            column=0,
            sticky=N+E+W,
            )
        self.canvas_20_InputNewRows = Canvas(
            self.frame_20_InputNewRows,
            bg=self.InputNewRows_color_bg,
            confine=0,
            width=750,
            height=620,
            xscrollcommand=xScroll_frame_20.set,
            yscrollcommand=yScroll_frame_20.set, 
            )
        self.canvas_20_InputNewRows.grid(
            row=0,
            column=0,
            padx=2,
            pady=2,
            sticky=N,
            )
        self.frame_20_Canvas_Header_InputNewRows = Frame(
            self.canvas_20_InputNewRows,
            bg=self.InputNewRows_color_bg,
            padx=1,
            )   
        
# determine which scrolledlist_items to use for 
#    'Select height of "Values" boxes'
        if (
        hscrollmode_InputNewRows == 'static' 
        or
        vscrollmode_InputNewRows == 'static'
        ):
            self.comboboxInputNewRows_TextHeight = Pmw.ComboBox(
                self.InputNewRows_frame_00,
                scrolledlist_items=self.heightsForInputWidgets_WithScrollbar,
                listheight=140,
                entry_width=5,
                label_text='Select height of "Values" box: ',
                labelpos='w',
                label_background=self.InputNewRows_color_bg,
                selectioncommand=self.handlerInputNewRows_TextHeight,
                scrolledlist_hull_width=500,
                )
            self.comboboxInputNewRows_TextHeight.grid(
                row=2,
                column=0,
                padx=0,
                pady=5,
                )
            if eval(heightEntries) >= 3:
                self.comboboxInputNewRows_TextHeight.setentry(heightEntries)
            else:
                self.comboboxInputNewRows_TextHeight.setentry('3')
        else:
            self.comboboxInputNewRows_TextHeight = Pmw.ComboBox(
                self.InputNewRows_frame_00,
                scrolledlist_items=self.heightsForInputWidgets_NoScrollbar,
                listheight=140,
                entry_width=5,
                label_text='Select height of "Values" box: ',
                labelpos='w',
                label_background=self.InputNewRows_color_bg,
                selectioncommand=self.handlerInputNewRows_TextHeight,
                scrolledlist_hull_width=500,
                )
            self.comboboxInputNewRows_TextHeight.grid(
                row=2,
                column=0,
                padx=0,
                pady=5,
                )
            if heightEntries == '':
                self.comboboxInputNewRows_TextHeight.setentry('1')
            else:
                self.comboboxInputNewRows_TextHeight.setentry(heightEntries)

# re-calculate heightEntries to incorporate whether scrollbars have been invoked                    
        heightEntries = self.comboboxInputNewRows_TextHeight.get()


# display structure for each field; do not include auto_index
        for i in range(len(self.tableStructure) - 1):
            myField, myDatatype, myNull, myKey, myDefault, myExtra = \
                self.tableStructure[i]
#                            print(
#                                '%3s. %20s %20s %3s %3s %20s %20s' % 
#                                (i+1, myField, myDatatype, myNull, myKey, myDefault, myExtra)
#                                )
            self.MySQL_Output(
                0,
                '%4s. | %-12s | %-15s | %-3s | %-3s | %-15s | %-15s |' % 
                (i+1, myField, myDatatype, myNull, myKey, myDefault, myExtra)
                )
                
# if already graphed, save current values to update "New Values" when window refreshes;
#   if not already graphed, initialize to blanks
            '''
            try:
                save_NewValues = self.scrolledtext_InputNewRows_NewValues[i].get().strip()
            except:
                save_NewValues = ''
                
            if DEBUG_INSERT:
                stringSaveNewValues = (
                    'For row = %s, field = %s, save_NewValues = %s'
                    )
                print('\n' + stringSaveNewValues % (i, myField, save_NewValues))
            '''
            
# Field frames - 4 total

            columnCount=0
# ... field 0
            varField0 = StringVar()
            entryField0 = Entry(
#                self.InputNewRows_frame_20.interior(),
                self.frame_20_Canvas_Header_InputNewRows,
                textvariable = varField0,
                bg=self.InputNewRows_color_bg,
                width=width_i,
                justify=RIGHT,
                relief=FLAT,
                state='disable',
                disabledbackground=self.InputNewRows_color_bg,
                disabledforeground='black',
                )
            entryField0.grid(
                row=i,
                column=columnCount,
                padx=2,
                pady=2,
                sticky='n',
                )
            varField0.set(str(i+1) + '.')
# ... field 1 (field name)
            columnCount+=1
            self.entryField1_InputNewRowsManually.append('')
            self.entryField1_InputNewRowsManually[i] = Pmw.EntryField(
#                self.InputNewRows_frame_20.interior(),
                self.frame_20_Canvas_Header_InputNewRows,
                entry_width=width_Fields,
#                relief=SUNKEN,
                entry_state='disabled',
                entry_disabledbackground='white',
                entry_disabledforeground='black',
                )
            self.entryField1_InputNewRowsManually[i].grid(
                row=i,
                column=columnCount,
                padx=2,
                pady=2,
                sticky='n',
                ) 
            self.entryField1_InputNewRowsManually[i].setvalue(myField)

# ... field 2 - datatype
            columnCount+=1
            varField2 = StringVar()
            entryField2 = Entry(
#                self.InputNewRows_frame_20.interior(),
                self.frame_20_Canvas_Header_InputNewRows,
                textvariable = varField2,
                width=width_Datatypes,
                relief=SUNKEN,
                state='disable',
                disabledbackground='white',
                disabledforeground='black',
                )
            entryField2.grid(
                row=i,
                column=columnCount,
                padx=2,
                pady=2,
                sticky='n',
                )
            varField2.set(myDatatype)

# ... field 3 - new values
            columnCount+=1
            self.scrolledtext_InputNewRows_NewValues.append('')
            self.scrolledtext_InputNewRows_NewValues[i] = Pmw.ScrolledText(
#                self.InputNewRows_frame_20.interior(),
                self.frame_20_Canvas_Header_InputNewRows,
                columnheader=0,
                rowheader=0,
                text_wrap='none',
                hscrollmode=hscrollmode_InputNewRows,
                vscrollmode=vscrollmode_InputNewRows,
                scrollmargin=2,
                usehullsize=0,
                text_font=self.entryDefaultFont,
                text_width=width_NewValues,
                text_height=heightEntries,
                text_background='white',
                text_foreground='black',
                text_state=NORMAL,
                )
            self.scrolledtext_InputNewRows_NewValues[i].grid(
                row=i,
                column=columnCount,
                padx=2,
                pady=2,
                sticky='n',
                )
            self.scrolledtext_InputNewRows_NewValues[i].setvalue(
                self.inputNewRows_SaveNewValues[i].strip()
                )
            
# reposition widgets to be gridded correctly at top of frame
# ... frame_15
        self.frame_15_Canvas_Header_NewRowsManually.grid_rowconfigure(1,weight=1)
        self.canvas_15_Header_NewRowsManually.create_window(
            0,
            0,
            anchor=NW,
            window=self.frame_15_Canvas_Header_NewRowsManually
                )
        self.frame_15_Canvas_Header_NewRowsManually.update_idletasks()
        self.canvas_15_Header_NewRowsManually.config(
            scrollregion=self.canvas_15_Header_NewRowsManually.bbox('all')
            )
# ... frame_20
        self.frame_20_Canvas_Header_InputNewRows.grid_rowconfigure(1,weight=1)
        self.canvas_20_InputNewRows.create_window(
            0,
            0,
            anchor=NW,
            window=self.frame_20_Canvas_Header_InputNewRows
            )
        self.frame_20_Canvas_Header_InputNewRows.update_idletasks()
        self.canvas_20_InputNewRows.config(
            scrollregion=self.canvas_20_InputNewRows.bbox('all')
             )

        return
        
        
    def handlerInputNewRows_HorizontalScrollbar(self):
        '''
        Purpose:
            determine whether horizontal scrollbar is displayed
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerInputNewRows_HorizontalScrollbar')
        
        if self.varInputNewRows_HorizontalScrollbar.get():
            self.statusInputNewRows_HorizontalScrollbar = 'static'
        else:
            self.statusInputNewRows_HorizontalScrollbar = 'none'
            
        self.handlerInputNewRows_TextHeight(0)
        
        return
        
        
    def handlerInputNewRows_VerticalScrollbar(self):
        '''
        Purpose:
            determine whether vertical scrollbar is displayed
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerInputNewRows_VerticalScrollbar')
        
        if self.varInputNewRows_VerticalScrollbar.get():
            self.statusInputNewRows_VerticalScrollbar = 'static'
        else:
            self.statusInputNewRows_VerticalScrollbar = 'none'
            
        self.handlerInputNewRows_TextHeight(0)
        
        return
            
        
    def handlerInputNewRows_TextHeight(self,value):
        '''
        Purpose:
            update height of entry boxes
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerInputNewRows_TextHeight')

# save values in new fields
        self.inputNewRows_SaveNewValues = []
        for row in range(len(self.tableStructure) - 1):
            self.inputNewRows_SaveNewValues.append(
                self.scrolledtext_InputNewRows_NewValues[row].get().strip()
                )

# clear the scrolled text boxes; otherwise, if height is selected that is less
#   than previous height, the bottom of the previous text boxes will persist and
#   will still display -- not what is wanted; so destroy previous text boxes first
        for row in range(len(self.scrolledtext_InputNewRows_NewValues)):
            self.scrolledtext_InputNewRows_NewValues[row].destroy()
            
# restore values in new fields
        '''
        for row in range(len(self.tableStructure) - 1):
            self.scrolledtext_InputNewRows_NewValues.setvalue(
                saveNewValues[row]
                )
        '''

        self.InputNewRows_DisplayFields()
            
        return
        
        
    def handlerInputNewRows_ClearNewValues(self):
        '''
        Purpose:
            clear "New values" in window "Input New Rows For Table ..."
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerInputNewRows_ClearNewValues')
                
        for row in range(len(self.scrolledtext_InputNewRows_NewValues)):
            self.scrolledtext_InputNewRows_NewValues[row].clear()
        
        
    def handlerInputNewRowsManually_InsertIntoTable(self):
        '''
        Insert new row into database
        
        Fields:     self.entryField1_InputNewRowsManually[i]
        Values:     self.scrolledtext_InputNewRows_NewValues[i]
          where 
          i in range(len(self.tableStructure) - 1)
        '''
            
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerInputNewRowsManually_InsertIntoTable')
            
        myTable = self.comboboxDbTableSelect.get().strip()
        myDatabase = self.comboboxDbSelect.get().strip()
        currentTableRow = str(len(self.tableValues) + 1)
        
        self.inputNewRows_SaveNewValues = []
        
# save checked fields
        self.saveCheckedFieldNames()  

# get auto_index of last row; new row will have value (auto_index + 1)
        if DEBUG_INSERTROW:
            print('\nself.tableValues = ')
            print(self.tableValues)
            print('len(self.tableValues) = %s' % str(len(self.tableValues)))
        
        '''
        if len(self.tableValues):
            autoIndexList = []
            for index in range(len(self.tableValues)):
                autoIndexList.append(self.tableValues[index][len(self.tableValues) - 1])
            if DEBUG_INSERTROW:
                print('\nautoIndexList = ')
                print(autoIndexList)
            autoIndex = max(autoIndexList)
        else:
            autoIndex = 0
        if DEBUG_INSERTROW:
            print('\nlast autoIndex value before insert = %s' % autoIndex)
            
# update to next autoindex
        autoIndex += 1
        '''
        
# determine whether to display blanked new fields or previous values  
        if self.varKeepNewValuesEntries_InputNewRows.get():
            for i in range(len(self.tableStructure) - 1):
                self.inputNewRows_SaveNewValues.append( 
                    self.scrolledtext_InputNewRows_NewValues[i].getvalue().strip()
                    )
        else:
            for i in range(len(self.tableStructure) - 1):
                self.inputNewRows_SaveNewValues.append('')
                
# check if all fields are blank
        blankFields = True
        for i in range(len(self.tableStructure) - 1):
            if self.inputNewRows_SaveNewValues[i] <> '':
                blankFields = False

# if all fields are blank, ask user if really want to insert blank row                
        if blankFields == True:
            stringEmpty = (
                'All fields to be inserted into Row %s are blank.\n\n' +
                'Do you REALLY want to insert a blank row?'
                ) % (
                str(len(self.tableValues) + 1)
                )
            print('\n' + stringEmpty)
            self.MySQL_Output(
                0,
                stringEmpty
                )
            ans = askyesno(
                'Warning: blank row',
                stringEmpty,
                parent=self.toplevelInputNewRowsManually
                )
            if ans:
                stringInsertInto = (
                    "INSERT INTO " + myDatabase + "." + myTable + " values ()"
                    )
                if DEBUG_INSERTROW:
                    print('\nstringInsertInto = %s' % stringInsertInto)
# insert blank row
                try:
                    self.cursorHandleMySQL.execute(stringInsertInto)
                    self.flagInputNewRows_ChangesMade = True
                except:
                    stringErrorDuringUpdate = (
                        'Unable to update table with new row.\n\n' +
                        'Possible reasons:\n\n' +
                        ' - you do not have write permissions to database\n' +
                        ' - database bug\n' +
                        ' - server is down\n\n' +
                        'This operation cannot continue and must exit.'
                        ) 
                    print('\n' + stringErrorDuringUpdate) 
                    self.MySQL_Output(
                        0,
                        stringErrorDuringUpdate
                        )
                    showerror(
                        'Error: unable to update table',
                        stringErrorDuringUpdate,
                        parent=self.toplevelInputNewRowsManually
                        )
                    self.flagInputNewRows_ChangesMade = False
                    return
            else:
                self.flagInputNewRows_ChangesMade = False
                return

# determine update stats; for this case, we update every field with a blank                
            iUpdateCount = len(self.tableStructure) - 1
            iNoUpdateCount = 0
            
# determine number of fields to update
            numberFieldNamesToUpdate = iUpdateCount

             
        else:
# blankFields == False
# get field names
            myFields = []
            if DEBUG_INSERTROW:
                self.MySQL_Output(
                    0,
                    '\nTable structure for inserting new row:'
                    )
            for i in range(len(self.tableStructure) - 1):
#            print('\nI. SELF.TABLESTRUCTURE[I] = %s. %s' % (i,self.tableStructure[i]))
                myFieldTemp, myDatatype, myNull, myKey, myDefault, myExtra = \
                    self.tableStructure[i]
                myFields.append(myFieldTemp)
                if DEBUG_INSERTROW:
                    self.MySQL_Output(
                        0,
                        '%4s. | %-12s | %-15s | %-3s | %-3s | %-15s | %-15s |' % 
                        (i+1, myFields[i], myDatatype, myNull, myKey, myDefault, myExtra)
                        )      
                
            if DEBUG_INSERTROW:
                print('\nMYFIELD VALUES: %s' % myFields)
                print('\nself.inputNewRows_SaveNewValues = %s' % self.inputNewRows_SaveNewValues)
                print('\n len() = %s' % len(self.inputNewRows_SaveNewValues))
                
# use INSERT to insert a new row at end of database; then put values into new row
#   using "UPDATE where auto_index = XX"; have to use this approach since INSERT does
#   not use auto_index, and inserting one value at a time produces one row for each 
#   insert (not what we want to do). We want to insert one value at a time for one
#   row instead so that we can keep track of which values are inserted properly and
#   which are not, which is the best for debugging

# insert new blank row
            stringInsertInto = (
                "INSERT INTO " + myDatabase + "." + myTable + " values ()"
                )
            try:
                self.cursorHandleMySQL.execute(stringInsertInto)
                self.flagInputNewRows_ChangesMade = True
            except:
                stringErrorDuringReplace = (
                    'Unable to update table with new row.\n\n' +
                    'Possible reasons:\n\n' +
                    ' - you do not have write permissions to database\n' +
                    ' - database bug\n' +
                    ' - server is down\n\n' +
                    'This operation cannot continue.'
                    ) 
                print('\n' + stringErrorDuringReplace) 
                self.MySQL_Output(
                    0,
                    stringErrorDuringReplace
                    )
                showerror(
                    'Error: unable to update table',
                    stringUpdateCount,
                    parent=self.toplevelInputNewRowsManually
                    )
                self.flagInputNewRows_ChangesMade = False
                return

        
# get new values to insert into selected table row
            valuesToUpdate = []
            fieldNumbersToUpdate = []
            fieldNamesToUpdate = []
            icount = 0
            for row in range(len(self.inputNewRows_SaveNewValues)):
                value = self.inputNewRows_SaveNewValues[row]
                if DEBUG_INSERTROW:
                    print('\n>> row %s: value = %s' % (row,value))
                if value == 'NULL' or value == '' or value == None or value == ' ':
                    valuesToUpdate.append(' ')
                else:
                    valuesToUpdate.append(value)
                    fieldNumbersToUpdate.append(row)
                    fieldNamesToUpdate.append(myFields[row])
                    if DEBUG_INSERTROW:
                        print('>> field Number %s: fieldName = %s, value = %s' % 
                            (
                            fieldNumbersToUpdate[icount],
                            fieldNamesToUpdate[icount],
                            valuesToUpdate[icount]
                            )
                            )
                    icount += 1
                
            if DEBUG_INSERTROW:
                print('\nFIELDNAMESTOUPDATE = %s' % fieldNamesToUpdate)

# form update string
            stringUpdateSet = (
            "UPDATE " + myDatabase + "." + myTable + ' SET '
            )
            
# get the most recent auto_index after executing the UPDATE statement;
#   there is no other reliable way of getting this number!
            stringGetAutoIndex = "select last_insert_id()"
            self.cursorHandleMySQL.execute(stringGetAutoIndex)
            autoIndex = self.cursorHandleMySQL.fetchall()[0][0]  # tuple with zeroth element
 
# table rows are not listing in correct order
# check other UPDATE statements that need auto_index and revise as above

            if DEBUG_INSERTROW:
                print('\ncurrent auto_index based on UPDATE statement: %s' % autoIndex)
            
            stringAutoIndex = ' where auto_index = ' + str(autoIndex)
            
# form fields and values
            emptyString = True
        
# update every field one at a time except auto_index; this way, in case of an error, 
#   we can keep track of which fields did not update properly
            iUpdateCount = 0
            iNoUpdateCount = 0
#            for i in range(len(self.tableStructure) - 1):
            icount = 0
            for i in fieldNumbersToUpdate:
# ... get first two characters of column header datatype and check if field is numerical
                varfirst2 = self.tableStructure[i][1][0:2]
                fieldIsNumerical = self.checkIsFieldNumerical(varfirst2)
                stringField = ''
                stringValue = ''
#                stringField = str(self.entryField1_InputNewRowsManually[i].getvalue().strip())
                stringField = fieldNamesToUpdate[icount]
                if self.scrolledtext_InputNewRows_NewValues[i].getvalue().strip() <> '':
                    emptyString = False
                    stringValue = (
                        '"' + self.scrolledtext_InputNewRows_NewValues[i].getvalue().strip() + '"'
                        )
                else:
                    if fieldIsNumerical:
                        stringValue = 'NULL'
                    else:
                        stringValue = "''" 
        
                stringUpdate = (
                    stringUpdateSet + stringField + '=' + stringValue + ' ' + stringAutoIndex
                    )
                    
                if DEBUG_INSERTROW:
                    print('\n%s. stringUpdate:\n%s' % (i,stringUpdate))
        
                try:
                    self.cursorHandleMySQL.execute(stringUpdate)
                    iUpdateCount += 1
                except:
                    iNoUpdateCount += 1
                    stringErrorDuringReplace = (
                        'Unable to update \n\n' +
                        '  Field name: %s. %s\n' +
                        '  Database: %s\n' +
                        '  Table: %s\n' +
                        '  Row: %s\n' +
                        '\n' +
                        'Possible reasons:\n\n' +
                        ' - double quotes in text field (use only single quotes)\n' +
                        ' - wrong datatype\n' +
                        ' - you do not have write permissions to database\n' +
                        ' - database bug\n' +
                        ' - cannot blank a numeric field\n' +
                        ' - server is down\n\n' +
                        'Use PylotDB to check the database and/or table structure format\n' +
                        'to ensure new values conform to their expected datatype.\n\n' +
                        'Click YES if you wish to continue updating fields, NO to cancel.'
                        ) % (
                        fieldNumbersToUpdate[icount] + 1,
                        fieldNamesToUpdate[icount],
                        myDatabase,
                        myTable,
                        currentTableRow,
                        )
                    print('\n' + stringErrorDuringReplace) 
                    self.MySQL_Output(
                        0,
                        stringErrorDuringReplace
                        )
                    ans = askyesno(
                        'Error: cannot update field',
                        stringErrorDuringReplace,
                        parent=self.toplevelInputNewRowsManually
                        )
                    if not ans: 
                        stringUpdateCount = (
                            'So far, for Table row %s:\n\n' +
                            '  - Number of fields updated: %s\n\n' +
                            '  - Number of fields unable to update: %s\n\n' +
                            '  - Number of fields specified to update: %s\n'
                            ) % (
                            currentTableRow,
                            iUpdateCount,
                            iNoUpdateCount,
                            len(fieldNamesToUpdate),
                            ) 
                        print('\n' + stringUpdateCount)
                        self.MySQL_Output(
                            0,
                            stringUpdateCount
                            )
                        showinfo(
                            'Info: stats',
                            stringUpdateCount,
                            parent=self.toplevelInputNewRowsManually
                            )
                        break 
                icount += 1
                        
# determine number of fields to update                        
            numberFieldNamesToUpdate = len(fieldNamesToUpdate)

        if iUpdateCount > 0: 
            stringSuccess = (
                'Final stats for Table row %s, auto_index = %s:\n' +
                '  - Total number of fields (excluding auto_index): %s\n' +
                '  - Number of fields updated: %s\n' +
                '  - Number of fields unable to update: %s\n' +
                '  - Number of fields specified to update: %s'
                ) % (
                currentTableRow,
                autoIndex,
                len(self.tableStructure) - 1,
                iUpdateCount,
                iNoUpdateCount,
                numberFieldNamesToUpdate,
                )
            print('\n' + stringSuccess)
            self.MySQL_Output(
                0,
                stringSuccess
                )      
            showinfo(
                'Info: update status',
                stringSuccess,
                parent=self.toplevelInputNewRowsManually
                )
            
# ... update current values and display in window                 
            for i in range(len(self.tableStructure) - 1):
                self.scrolledtext_InputNewRows_NewValues[i].setvalue(
                    self.inputNewRows_SaveNewValues[i].strip()
                    )
                    
# look for auto_index field
            flagAutoIndex = False
            for eachItem in self.tableStructureOriginal:
                if 'auto_index' in eachItem:
                    flagAutoIndex = True
                    break
              
# ... get current table values
            if flagAutoIndex:
                stringTableValues = (
                    "SELECT * FROM " + myDatabase + "." + myTable 
                    + ' order by auto_index'
                    )
            else:
                stringTableValues = (
                    "SELECT * FROM " + myDatabase + "." + myTable 
                    )
                
# ...   execute the command
            self.cursorHandleMySQL.execute(
                stringTableValues
                )
            self.tableValues = self.cursorHandleMySQL.fetchall()
            
            if DEBUG_INSERTROW:
                print('\nAfter updating rows...')
                print('self.tableValues:')
                print(self.tableValues)
        
# sub-title -- display which row is being generated                           
            self.labelInputNewRows_CurrentRowNumber = Label(
                self.InputNewRows_frame_00,
                text='This insert will generate Row %s' % 
                    str(len(self.tableValues) + 1),
                font=self.labelFontMediumBold,
                bg=self.InputNewRows_color_bg,
                justify=CENTER,
                )
            self.labelInputNewRows_CurrentRowNumber.grid(
                row=1,
                column=0,
                columnspan=2,
                pady=5,
                )
                
# restore checked fields
        self.restoreCheckedFieldNames()  
            
        return
            
        
    def handlerDestroyToplevelTableStructure(self):
        '''
        Purpose:
            close the following window but save the last location
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerDestroyToplevelTableStructure')
            
        self.tablestructure_xWindowLocation = self.toplevelTableStructure.winfo_rootx() - self.offsetWindowX
        self.tablestructure_yWindowLocation = self.toplevelTableStructure.winfo_rooty() - self.offsetWindowY
        self.toplevelTableStructure.destroy()
        
        return
        
        
    def handlerDestroyToplevelInputNewRowsManually(self):
        '''
        Purpose:
            close the following window but save the last location
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerDestroyToplevelInputNewRowsManually')
            
# save checked fields
        self.saveCheckedFieldNames()  
                
        self.inputnewrowsmanually_xWindowLocation = self.toplevelInputNewRowsManually.winfo_rootx() - self.offsetWindowX
        self.inputnewrowsmanually_yWindowLocation = self.toplevelInputNewRowsManually.winfo_rooty() - self.offsetWindowY
        self.toplevelInputNewRowsManually.destroy()
        
# check if main window exists
        try:
            mapped = self.toplevelTableValues.winfo_exists()
        except:
            mapped = False
        
        if self.flagInputNewRows_ChangesMade:
            if mapped:
                stringManualRefresh = (
                    'REMINDER!\n\n' +
                    'The database has been updated, but the displayed table needs\n' +
                    'to be refreshed to reflect any changes you have made.\n\n' +
                    'Click OK to refresh table, Cancel to not refresh table.'
                    )
                print('\n' + stringManualRefresh)
                self.MySQL_Output(
                    0,
                    stringManualRefresh
                    )    
                ans = askokcancel(
                    'Info: refresh table with new rows',
                    stringManualRefresh
                    )  
                if ans:

# update table values for INPUT NEW ROWS MANUALLY     
                    try:
                        mapped = self.toplevelTableValues.winfo_exists()
                    except:
                        mapped = False
                                
                    if mapped:
                            self.handlerDisplayLimitedRows()    # PEEK handler
# update filter window
                            try:
                                mapped = self.toplevelSelectDisplayOrderedFields.winfo_exists()
                            except:
                                mapped = False
            
                            if mapped:
                                self.handlerSelectDisplayOrderedFields_Update()
                    
                self.flagInputNewRows_ChangesMade = False
                
# restore checked fields
                self.restoreCheckedFieldNames()  
                
                return
                
            else:
                stringManualRefresh = 'The database has been updated.'
                print('\n' + stringManualRefresh)
                self.MySQL_Output(
                    0,
                    stringManualRefresh
                    )
                showinfo(
                    'INFO: database updated',
                    stringManualRefresh
                    )
        else:
            stringNoChanges = (
                'No changes have been made to the database.'
                )
            print('\n' + stringNoChanges)
            self.MySQL_Output(
                0,
                stringNoChanges
                )
            try:
                showinfo(
                    'Info: no changes',
                    stringNoChanges,
                    parent=self.toplevelTableValues
                    )
            except:
                showinfo(
                    'Info: no changes',
                    stringNoChanges
                    )
                
        return
        
        
    def handlerDestroyToplevelEditSelectedRows(self):
        '''
        Purpose:
            close the following window but save the last location
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerDestroyToplevelEditSelectedRows')
            
        self.editselectedrows_xWindowLocation = self.toplevelEditSelectedRows.winfo_rootx() - self.offsetWindowX
        self.editselectedrows_yWindowLocation = self.toplevelEditSelectedRows.winfo_rooty() - self.offsetWindowY
        self.toplevelEditSelectedRows.destroy()

# check if main window exists
        try:
            mapped = self.toplevelTableValues.winfo_exists()
        except:
            mapped = False        

        if self.flagEditSelectedRows_ChangesMade:
            if mapped:
                stringManualRefresh = (
                    'REMINDER!\n\n' +
                    'The database has been updated, but the displayed table needs\n' +
                    'to be refreshed to reflect any changes you have made.\n\n' +
                    'Click OK to refresh table, Cancel to not refresh table.'
                    )
                print('\n' + stringManualRefresh)
                self.MySQL_Output(
                    0,
                    stringManualRefresh
                    )      
                ans = askokcancel(
                    'Info: refresh table with edited rows',
                    stringManualRefresh
                    )  
                    
                if ans:
# update table values for EDIT SELECTED ROWS  
                    try:
                        mapped = self.toplevelTableValues.winfo_exists()
                    except:
                        mapped = False
                                
                    if mapped:
                        self.handlerDisplayLimitedRows()    # PEEK handler
# update filter window
                        try:
                            mapped = self.toplevelSelectDisplayOrderedFields.winfo_exists()
                        except:
                            mapped = False
            
                        if mapped:
                            self.handlerSelectDisplayOrderedFields_Update()
                    
                self.flagEditSelectedRows_ChangesMade = False
                
                return
                
            else:
                stringManualRefresh = 'The database has been updated.'
                print('\n' + stringManualRefresh)
                self.MySQL_Output(
                    0,
                    stringManualRefresh
                    )
                showinfo(
                    'INFO: database updated',
                    stringManualRefresh
                    )
        else:
            stringNoChanges = (
                'No changes have been made to the database.'
                )
            print('\n' + stringNoChanges)
            self.MySQL_Output(
                0,
                stringNoChanges
                )
            try:
                showinfo(
                    'Info: no changes',
                    stringNoChanges,
                    parent=self.toplevelTableValues
                    )
            except:
                showinfo(
                    'Info: no changes',
                    stringNoChanges
                    )
            
        return
        
        
    def handlerTableFunctionsShowValues_Command(self):
        '''
        Purpose:
        to reset the self.addPrimaryKey flag before calling handlerTableFunctionsShowValues
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerTableFunctionsShowValues_Command')
            
        self.addPrimaryKey = 1
        
# save checked field names before re-defining self.dictColumnHeadersOriginal
        self.saveCheckedFieldNames()
        
        self.handlerTableFunctionsShowValues(1,'all')
        
        return
        
        
    def handlerTableFunctionsShowValues_Command_Peek(self):
        '''
        Purpose:
        to reset the self.addPrimaryKey flag before calling handlerTableFunctionsShowValues;
        also to save and restore checked field names
        
        Called by:
            'Show table' widget; only called once per table display
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerTableFunctionsShowValues_Command_Peek')
                
# check if current toplevelTableValues window is opened; if so, 
#   ask user if ok to close
        try:
            mapped = self.toplevelTableValues.winfo_exists()
        except:
            mapped = False
            
        if mapped:
            stringAskUser = (
                'A table is currently open in the "VALUES FOR TABLE" window.\n\n' +
                'Opening a new table will close the current table window.\n\n' +
                'Continue?'
                )
#            print('\n' + stringAskUser)
            self.MySQL_Output(
            0,
            stringAskUser
            )
            ans = askyesno(
                'Question',
                stringAskUser,
                parent=self.toplevelTableFunctions
                )
            if ans:
                '''
# ... X select value
                saveXSelectFieldName = ''
                if len(self.saveXSelectFieldName) > 0:
                    saveXSelectFieldName = self.saveXSelectFieldName
# ... Y select values
                saveYSelectFieldNames = []
                if len(self.saveYSelectFieldNames) > 0:
                    saveYSelectFieldNames = copy.deepcopy(self.saveYSelectFieldNames)
                '''
                
# destroy toplevel; also saves checked field names and x value
#                self.toplevelTableValues.destroy()  
                self.handlerDestroyToplevelTableValues()
                
# close "Filter Table" window
# ... (leave open; uncomment below to close this window, but better if left open)
                '''
                try:
                    self.toplevelSelectDisplayOrderedFields.destroy()
                except:
                    pass
                '''
                    
                try:
                    self.toplevelQuikSelectXY.destroy()
                except:
                    pass
                    
            else:
                return

# set flag for primary key
        self.addPrimaryKey = 1
        
# display table values
        self.handlerTableFunctionsShowValues(1,'limit')
        
        if DEBUG_COMMAND_PEEK:
            try:
                print('\nsaveXSelectFieldName = %s' % saveXSelectFieldName)
            except:
                pass
            try:
                print('saveYSelectFieldNames = ')
                print(saveYSelectFieldNames)
            except:
                pass
            try:
                print('self.saveXSelectFieldName = %s' % self.saveXSelectFieldName)
            except:
                pass
            try:
                print('self.saveYSelectFieldNames =')
                print(self.saveYSelectFieldNames)
            except:
                pass
            print('')
        
# check if list of checked fields has values; if so, ask user if want to check fields to see if
#   new table fields should be checked
# will not be valid if no fields have been checked

        if self.saveXSelectFieldName <> '' or self.saveYSelectFieldNames <> []:
            if self.saveXSelectFieldName == '':
                indicatorXSelectFieldName = '<None>'
            else:
                indicatorXSelectFieldName = self.saveXSelectFieldName
            stringAskUser = (
                'The previous table had:\n\n' +
                '   Y-Select fields checked:  %s\n\n' +
                '   X-Select field checked:  %s\n\n' +
                'Find and check identical fields in the newly displayed table?'
                ) % (
                len(self.saveYSelectFieldNames),
                indicatorXSelectFieldName
                )
            ans = askyesno(
                'Question',
                stringAskUser,
                parent=self.toplevelTableValues
                )
            if ans:
                self.restoreCheckedFieldNames()
            else:
                self.saveXSelectFieldName = ''
                self.saveYSelectFieldNames = []

        
# set last button pressed
        self.lastButtonPressed(
            BUTTONLABEL_PEEK
            )
        
        return
        
        
    def totalRowsInTable(self):
        '''
        Purpose:
            determine total number of rows in table;
            this command uses little memory; 
            no need to load whole table just to count rows
        '''
            
        stringTableValues = (
            "SELECT COUNT(*) FROM " + self.myDatabase + "." + self.myTable
            )
                            
        self.MySQL_Commands(
            1,
            'self.cursorHandleMySQL.execute("' + stringTableValues + '")'
             )
# execute the command
        start=time.time()
        self.cursorHandleMySQL.execute(
            stringTableValues
            )
        numberTotalRowsInTable = self.cursorHandleMySQL.fetchall()[0][0]   # fetchall results in a tuple
        finish=time.time()
        delta_t = finish - start
        self.MySQL_Commands(
        0,
        '  (Time: %-7.4f secs)' % delta_t
        )
        
        if DEBUG_STATISTICS:
            print(
            '\nTotal number of rows in\n' +
            '   database: %s\n' +
            '   table: %s\n' +
            'is %s\n\n' 
            ) % (
            self.myDatabase, 
            self.myTable, 
            numberTotalRowsInTable
            )
            print('type(numberTotalRowsInTable) = %s' % type(numberTotalRowsInTable))
        
        return numberTotalRowsInTable
        
        
    def handlerTableFunctionsShowValues(self,pushedShowTable,limiter):
        '''
        Purpose:
          Displays values of a selected table, as well as constructs the widgets
        that go with the window.
        
        If 'limiter' equals 'all', download entire table from database server;
        if 'limiter' equals 'limit', download only a portion of the table -- used for 
          the initial display and selected by user when only part of a large table
          needs to be downloaded
        
          For re-constructing just the table after this Toplevel window is displayed,
        call 'self.handlerDisplayAllFields(self)'
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerTableFunctionsShowValues')
        
# check if connected to a MySQL server
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return 

# initialize these for X-Y plots from Storage Buffer
        self.varTextForHideShowFields_Buffer = StringVar()
        self.varTextForHideShowFields_Buffer.set('Hide\nuser fields')
        self.varHideShowSet = IntVar()
        self.varCheckbuttonBufferData = IntVar()
        self.varCheckbuttonTableData = IntVar()
# initialize these for Kiviat plots 
        self.varCheckbuttonBufferData_Kiviat = IntVar()
        self.varCheckbuttonTableData_Kiviat = IntVar()
# initialize these for Scatter plots 
        self.varCheckbuttonBufferData_Scatter = IntVar()
        self.varCheckbuttonTableData_Scatter = IntVar()
        
        '''
        self.myTable = self.comboboxTableFunctionsSelectTable.get()
        '''
        self.myTable = self.comboboxDbTableSelect.get()
        self.myDatabase = self.comboboxDbSelect.get()
        
        myTable = self.myTable
        myDatabase = self.myDatabase
        
# make sure a database and a table are selected        
        if (
            myTable == '' or
            myDatabase == ''
            ):
            stringError = '\nThe TABLE FUNCTION fields need values:\n\n'
            if myDatabase == '':
                stringError += ' "Select database:"\n\n'
            if myTable == '':
                stringError += ' "Select table:"\n\n'
            stringError += 'Please select values and try again.'
            self.MySQL_Output(
                1,
                stringError
                )
            showerror(
                'Error: missing fields',
                stringError
                )
            return
            
# print databases and tables
        if DEBUG_SHOW_VALUES:
            print('\n>> Databases:')
            print(self.myDatabases)
            print('\n>> Tables:')
            print(self.myDatabaseTables) # these are tuples
            print('\n>> myDatabase = %s' % myDatabase)
            print('\n>> myTable = %s' % myTable)

# check if database is valid
        for database in self.myDatabases:
            if myDatabase == database:
# check if table is valid
                for table in self.myDatabaseTables:
                    if myTable == table:
# if we get here, both database and table are valid, so assemble string to get field headers
                        stringTableStructure = (
                            "SHOW COLUMNS FROM " + myDatabase + "." + myTable
                            )
                        self.MySQL_Commands(
                            1,
                            'self.cursorHandleMySQL.execute("' + stringTableStructure + '")'
                            )
# execute the command
                        start=time.time()
                        self.cursorHandleMySQL.execute(
                            stringTableStructure
                            )
                        self.tableStructureOriginal = self.cursorHandleMySQL.fetchall()
                        finish=time.time()
                        delta_t = finish - start
                        self.MySQL_Commands(
                            0,
                            '  (Time: %-7.4f secs)' % delta_t
                            )
                            
                        self.MySQL_Output(
                            1,
                            'Structure for table "' + myTable + '":'
                            )
                        self.MySQL_Output(
                            0,
                            self.tableStructureOriginal
                            )
                        self.MySQL_Output(
                            0,
                            ''
                            )
                            
# look for auto_index field
                        flagAutoIndex = False
                        for eachItem in self.tableStructureOriginal:
                            if 'auto_index' in eachItem:
                                flagAutoIndex = True
                                break
                            
# assemble string to get field values
# ... limiter == 'all'
                        if limiter == 'all':
                            if flagAutoIndex:
                                stringTableValues = (
                                    "SELECT * FROM " + myDatabase + "." + myTable
                                    + ' order by auto_index'
                                    )
                            else:
# if system table, it will NOT have an auto_index field
                                stringTableValues = (
                                    "SELECT * FROM " + myDatabase + "." + myTable
                                    )
# ... limiter == 'limit'
                        elif limiter == 'limit':
                            numberOfRowsToDisplay = rowsMaxNumber_Peek
                            if numberOfRowsToDisplay == 0:
                                numberOfRowsToDisplay = 1
                            startAtRow = 0
                            if flagAutoIndex:
                                stringTableValues = (
                                    "SELECT * FROM " + myDatabase + "." + myTable
                                    + ' order by auto_index'
                                    " LIMIT " + str(startAtRow) + "," + str(numberOfRowsToDisplay)
                                    )
                            else:
                                stringTableValues = (
                                    "SELECT * FROM " + myDatabase + "." + myTable 
                                    + " LIMIT " + str(startAtRow) + "," + str(numberOfRowsToDisplay)
                                    )

# form command string                            
                        self.MySQL_Commands(
                            1,
                            'self.cursorHandleMySQL.execute("' + stringTableValues + '")'
                            )
                            
# execute the command
                        start=time.time()
                        self.cursorHandleMySQL.execute(
                            stringTableValues
                            )
                        self.tableValuesOriginal = self.cursorHandleMySQL.fetchall()
                        finish=time.time()
                        delta_t = finish - start
                        self.MySQL_Commands(
                            0,
                            '  (Time: %-7.4f secs)' % delta_t
                            )
            
                        if DEBUG_PRINTFIRSTFEWROWS:
# print to command window up to first 10 lines of table
                            maxRowsToPrint = 5
                            self.MySQL_Output(
                                1,
                                'Values for upto first %s lines of table "%s":'
                                ) % (maxRowsToPrint,myTable)
                            if len(self.tableValuesOriginal) < maxRowsToPrint:
                                rowsToPrint = len(self.tableValuesOriginal)
                            else:
                                rowsToPrint = maxRowsToPrint
                            for i in range(rowsToPrint):
                                self.MySQL_Output(
                                    0,
                                    self.tableValuesOriginal[i]
                                    )
                            self.MySQL_Output(
                                0,
                                ''
                                )
                            
# define dictionary for column headers
                        self.dictColumnHeadersOriginal = {}
                        icount=0
                        for i in range(len(self.tableStructureOriginal)):
                            icount+=1
                            self.dictColumnHeadersOriginal[self.tableStructureOriginal[i][0]]=icount
                        if DEBUG_COLUMN_HEADERS:
                            print '\n>> Dictionary of ORIGINAL Column Headers'
                            print self.dictColumnHeadersOriginal
                            self.MySQL_Output(
                                1,
                                ' Dictionary of ORIGINAL column headers:'
                                )
                            self.MySQL_Output(
                                0,
                                self.dictColumnHeadersOriginal
                                )
                            
# reassign original values to current values
                        '''
                        self.tableStructure = self.tableStructureOriginal
                        self.tableValues = self.tableValuesOriginal
                        self.dictColumnHeaders = self.dictColumnHeadersOriginal
                        '''
# use this dictionary to extract data from
#       - self.tableValues
#       - self.tableStructure
# to create
#           1. self.tableStructureTemp
#           2. self.tableValuesTemp
# and use these Temp tables to display and plot
        
# display in a text box with scrollbars

# FRAMES  
               
# check if toplevel is already open     
                        try:
                            mapped = self.toplevelTableValues.winfo_exists()
                        except:
                            mapped = False
            
# save values if mapped
                        if mapped:
                            try:
                                if pushedShowTable:
                                    self.tableStructure = self.tableStructureOriginal
                                    self.tableValues = self.tableValuesOriginal
                                    self.dictColumnHeaders = copy.deepcopy(self.dictColumnHeadersOriginal)
                                
                                saveFieldWidths = int(self.comboboxWidthField.get())
                                saveFieldHeights = int(self.comboboxHeightField.get())
                                saveFieldFonts = int(self.comboboxFontField.get())
                                saveMaxLinesToDisplay = int(self.comboboxMaxLinesToDisplay.get())
                                self.textMessagesToUser.configure(state='normal')
                                saveMessageToUser = self.textMessagesToUser.get(1.0,END)
                                self.textMessagesToUser.configure(state='disabled')
                                self.entryLastButtonPressed.configure(state='normal')
                                saveLastButtonPressed = self.varEntryLastButtonPressed.get()
                                self.entryLastButtonPressed.configure(state='disabled')
                                saveCheckbuttonFreezeTextMessageToUser = \
                                    self.varCheckbuttonFreezeTextMessageToUser.get()
# ... save number of displayed columns
                                saveDisplayedColumns = self.varEntryDisplayedColumns.get()
                                
                            except:
                                stringFieldValues = (
                                    'Invalid values have been entered into one of\n' +
                                    '  the width, height, font, or max_lines fields.\n\n' +
                                    'Please check values and try again.\n'
                                    )
                                self.MySQL_Output(
                                    1,
                                    stringFieldValues
                                    )
                                showerror(
                                    'Error: invalid value',
                                    '\n' + stringFieldValues
                                    )
                                return  
                                
                            if DEBUG_TABLEISMAPPED:
                                print(
                                    '\n *** toplevelTableValues is open!!! ###\n' +
                                    '     saveFieldWidths = %s\n' + 
                                    '     saveFieldHeights = %s\n' +
                                    '     saveFieldFonts = %s\n' + 
                                    '     saveMaxLinesToDisplay = %s\n' +
                                    '     saveMessageToUser = %s\n' +
                                    '     saveLastButtonPressed = %s\n' 
                                    ) % (saveFieldWidths, saveFieldHeights, 
                                        saveFieldFonts, saveMaxLinesToDisplay,
                                        saveMessageToUser, saveLastButtonPressed
                                    )                    
                        else:
# if not mapped
                            if DEBUG_TABLEISMAPPED:
                                print(
                                    '\n *** toplevelTableValues is NOT open!!!\n'
                                    )  
                                    
# reassign original values to current values to display entire table
                            self.tableStructure = self.tableStructureOriginal
                            self.tableValues = self.tableValuesOriginal
                            self.dictColumnHeaders = copy.deepcopy(self.dictColumnHeadersOriginal)
                            
# destroy any old toplevel frames; save location for next time this window is open
                        try:
#                            self.tableValues_xWindowLocation = self.toplevelTableValues.winfo_rootx() - self.offsetWindowX
#                            self.tableValues_yWindowLocation = self.toplevelTableValues.winfo_rooty() - self.offsetWindowY
#                            self.toplevelTableValues.destroy()
                            self.handlerDestroyToplevelTableValues()
                            
                            self.MySQL_Output(
                                1,
                                'Previous toplevel widget removed from screen.'
                                )

                        except: 
                            self.MySQL_Output(
                                1,
                                'No previous toplevel widget to remove from screen.'
                                )
                                
# delete 'Table Filtering Options' window if open, since it is only relevant to the last opened table
# DWB: DELETE THIS IF IT WORKS
                        '''
                        try:
                            self.toplevelSelectDisplayOrderedFields.destroy()
                        except:
                            pass
                        '''

# open Toplevel frame for entering database name
                        self.toplevelTableValues = Toplevel(
#            self.frameParent,
                            bg='tan',
                            )
                        self.toplevelTableValues.title(
                            'Server: ' + self.comboServerMySQL.get() + '     ' +
                            'Database: ' + self.varTableFunctionsSelectDatabase.get().strip() + '     ' +
                            'Table: ' + self.varEntryTableFunctionsSelectTable.get().strip() 
                            )
                        self.toplevelTableValues.transient(self.frameParent)
# place the top window
                        self.toplevelTableValues.geometry(
                            '+%d+%d' % (self.tableValues_xWindowLocation,self.tableValues_yWindowLocation)
                            )
# save currently displayed database and table, in case Table Functions window is closed
                        self.databaseDisplayedTableValues = self.varTableFunctionsSelectDatabase.get().strip()
                        self.tableDisplayedTableValues = self.varEntryTableFunctionsSelectTable.get().strip()

# Row 0
# ... frame for number of x and y's selected
                        frame_0 = Frame(
                            self.toplevelTableValues,
                            bg='tan',
#                            relief=RIDGE,
#                            borderwidth=2,
                            )
                        frame_0.grid(
                            row=0,
                            column=0,
                            columnspan=2,
                            padx=2,
                            pady=0,
                            sticky=E+W,
                            )
                        frame_0_00 = Frame(
                            frame_0,
                            bg='tan',
#                            relief=RIDGE,
#                            borderwidth=2,
                            )
                        frame_0_00.grid(
                            row=0,
                            column=0,
                            padx=2,
                            pady=2,
                            )
                        frame_0_01 = Frame(
                            frame_0,
                            bg='tan',
#                            relief=RIDGE,
#                            borderwidth=2,
                            )
                        frame_0_01.grid(
                            row=0,
                            column=1,
                            padx=2,
                            pady=2,
                            )
                        frame_0_10 = Frame(
                            frame_0,
                            bg='tan',
#                            relief=RIDGE,
#                            borderwidth=2,
                            )
                        frame_0_10.grid(
                            row=1,
                            column=0,
                            columnspan=2,
                            padx=2,
                            pady=2,
                            )
# ... title frame
                        frame_00 = Frame(
                            self.toplevelTableValues,
                            bg='tan',
#                            relief=RIDGE,
#                            borderwidth=2,
#                            width=600,
                            )
                        frame_00.grid(
                            row=0,
                            column=2,
                            padx=2,
                            pady=2,
                            sticky=E+W,
                            )
# ... title subframes
#       ... frame_00_00 - title
                        frame_00_00 = Frame(
                            frame_00,
                            bg='tan',
#                            borderwidth=2,
#                            relief=RIDGE,
                            )
                        frame_00_00.grid(
                            row=0,
                            column=0,
                            columnspan=99,
                            padx=0,
                            pady=0,
#                            sticky=E+W,
                            )
#       ... frame_00_10 - field width, height, font
                        frame_00_10 = Frame(
                            frame_00,
                            bg='tan',
#                            borderwidth=2,
#                            relief=RIDGE,
                            )
                        frame_00_10.grid(
                            row=1,
                            column=0,
                            padx=0,
                            pady=0,
                            sticky=W,
                            )
#       ... frame_00_11 - buffer store, display
                        frame_00_11 = Frame(
                            frame_00,
                            bg='tan',
#                            borderwidth=2,
#                            relief=RIDGE,
#                            width=300
                            )
                        frame_00_11.grid(
                            row=1,
                            column=1,
                            padx=15,
                            pady=0,
                            sticky=E+W,
                            )
#       ... frame_00_12 - update plot window
                        frame_00_12 = Frame(
                            frame_00,
                            bg='tan',
#                            borderwidth=2,
#                            relief=RIDGE,
                            )
                        frame_00_12.grid(
                            row=1,
                            column=2,
                            padx=0,
                            pady=0,
                            sticky=E,
                            )
                            
# Row 1
# ... header frame for selecting or de-selecting y-select, x-select                            
                        frame_10 = Frame(
                            self.toplevelTableValues,
                            bg='tan',
                            )
                        frame_10.grid(
                            row=1,
                            column=0,
                            columnspan=2,
                            padx=2,
                            pady=2,
                            )

# Row 2
# ... frame for buttons to show, plot, import, export                     
                        self.frame_20_MainButtons = Frame(
                            self.toplevelTableValues,
                            bg='tan',
#                            borderwidth=2,
#                            relief=RIDGE,
                            )
                        self.frame_20_MainButtons.grid(
                            row=2,
                            column=0,
                            rowspan=99,
                            padx=2,
                            pady=0,
                            sticky=N,
                            )  
                            
# sub-frames
                        self.frame_20_00_MainButtons = Frame(
                            self.frame_20_MainButtons,
                            bg='tan',
#                            borderwidth=2,
#                            relief=RIDGE,
                            )
                        self.frame_20_00_MainButtons.grid(
                            row=0,
                            column=0,
                            padx=2,
                            pady=0,
                            sticky=N,
                            )  
                        
                        self.frame_20_10_MainButtons = Frame(
                            self.frame_20_MainButtons,
                            bg='tan',
                            )
                        self.frame_20_10_MainButtons.grid(
                            row=1,
                            column=0,
                            padx=2,
                            pady=0,
                            sticky=N,
                            )
                            
                        self.frame_20_20_MainButtons = Frame(
                            self.frame_20_MainButtons,
                            bg='tan',
#                            borderwidth=2,
#                            relief=RIDGE,
                            )
                        self.frame_20_20_MainButtons.grid(
                            row=2,
                            column=0,
                            padx=2,
                            pady=0,
                            sticky=N,
                            ) 
                        
# grid table windows so they will be correct size for table
                        self.gridTableWindows()
        
# Row 3
# ... 'Clear' button                            
                        frame_31 = Frame(
                            self.toplevelTableValues,
                            bg='tan',
                            )
                        frame_31.grid(
                            row=3,
                            column=1,
                            padx=1,
                            pady=5,
                            )
# for table lines, max lines, etc
                        frame_32_statusLine = Frame(
                            self.toplevelTableValues,
                            bg='tan',
#                            relief=RIDGE,
#                            borderwidth=2,
                            )
                        frame_32_statusLine.grid(
                            row=3,
                            column=2,
                            padx=0,
                            pady=20,
                            sticky=S+E+W,
                            )
# ... subframe 32_00                           
                        frame_32_00_statusLine = Frame(
                            frame_32_statusLine,
                            bg='tan',
                            )
                        frame_32_00_statusLine.grid(
                            row=0,
                            column=0,
                            padx=3,
                            pady=0,
                            sticky=S,
                            )
# ... subframe 32_01
                        frame_32_01_statusLine = Frame(
                            frame_32_statusLine,
                            bg='tan',
                            )
                        frame_32_01_statusLine.grid(
                            row=0,
                            column=1,
                            padx=3,
                            pady=0,
                            sticky=S,
                            )
# ... subframe 32_02
                        frame_32_02_statusLine = Frame(
                            frame_32_statusLine,
                            bg='tan',
                            )
                        frame_32_02_statusLine.grid(
                            row=0,
                            column=2,
                            padx=3,
                            pady=0,
                            sticky=S,
                            )                            
# Row 4                            
# ... not used                       
                        frame_40 = Frame(
                            self.toplevelTableValues,
                            bg='tan',
                            )                            
                        frame_40.grid(
                            row=4,
                            column=2,
#                            columnspan=99,
                            padx=0,
                            pady=0,
                            )
                            
# text box for messages to user
                        self.frame_50_messages = Frame(
                            self.toplevelTableValues,
                            bg='tan',
                            )
                        self.frame_50_messages.grid(
                            row=5,
                            column=1,
                            columnspan=2,
                            padx=0,
                            pady=0,
                            )
                            
# Row 7                            
# ... Cancel button                       
                        frame_70 = Frame(
                            self.toplevelTableValues,
                            bg='tan',
                            )                            
                        frame_70.grid(
                            row=7,
                            column=1,
                            columnspan=3,
                            padx=0,
                            pady=0,
                            )

# -------------------------------------------           
# WIDGETS      

# ... number of x and y's selected
# ...   y values
                        label = Label(
                            frame_0_00,
                            text='Number of selected Y: ',
                            bg='tan',
                            justify=RIGHT,
                            font=self.buttonFontSmall,
                            )
                        label.grid(
                            row=0,
                            column=0,
                            padx=5,
                            pady=2,
                            sticky=E,
                            )
                            
                        self.varEntryNumberOfYValuesSelected = IntVar()
                        entryNumberOfYValuesSelected = Entry(
                            frame_0_00,
                            width=5,
                            disabledbackground='white',
                            disabledforeground='black',
                            font=self.buttonFontSmall,
                            state='disabled',
                            textvariable=self.varEntryNumberOfYValuesSelected,
                            )
                        entryNumberOfYValuesSelected.grid(
                            row=0,
                            column=1,
                            padx=0,
                            pady=2,
                            sticky=W,
                            )
                            
                        label = Label(
                            frame_0_00,
                            text='  Rows: ',
                            bg='tan',
                            justify=RIGHT,
                            font=self.buttonFontSmall,
                            )
                        label.grid(
                            row=0,
                            column=2,
                            padx=0,
                            pady=2,
                            sticky=E,
                            )
                            
                        self.varEntryNumberOfRowsSelected = IntVar()
                        entryNumberOfRowsSelected = Entry(
                            frame_0_00,
                            width=5,
                            disabledbackground='white',
                            disabledforeground='black',
                            font=self.buttonFontSmall,
                            state='disabled',
                            textvariable=self.varEntryNumberOfRowsSelected,
                            )
                        entryNumberOfRowsSelected.grid(
                            row=0,
                            column=3,
                            padx=0,
                            pady=2,
                            sticky=W,
                            )
                            
# ...  x values
                        label = Label(
                            frame_0_10,
                            text='Selected X field: ',
                            bg='tan',
                            justify=RIGHT,
                            font=self.buttonFontSmall,
                            )
                        label.grid(
                            row=0,
                            column=0,
                            padx=5,
                            pady=2,
                            sticky=E,
                            )
                            
                        self.varEntryXValueSelected = StringVar()
                        self.varEntryXValueSelected.set('')
                        entryXValueSelected = Entry(
                            frame_0_10,
                            width=25,
                            disabledbackground='white',
                            disabledforeground='black',
                            font=self.buttonFontSmall,
                            state='disabled',
                            textvariable=self.varEntryXValueSelected,
                            )
                        entryXValueSelected.grid(
                            row=0,
                            column=1,
                            padx=0,
                            pady=2,
                            sticky=W,
                            )

# ... title     
                        labelTableValuesMain = Label(
                            frame_00_00,
                            text='VALUES FOR TABLE "' + myTable + '" ',
#                            font=self.tableFont,
                            bg='tan',
                            justify=CENTER,
                            font=self.titleFont,
                            )
                        labelTableValuesMain.grid(
                            row=0,
                            column=0,
                            padx=0,
                            pady=2,
                            )
# ... width of fields
                        labelWidthField = Label(
                            frame_00_10,
                            text=('Field\nwidth:'),
                            font=self.buttonFontSmallest,
                            bg='tan',
                            fg='black',
                            )
                        labelWidthField.grid(
                            row=0,
                            column=0,
                            padx=1,
                            pady=0,
                            sticky=W,
                            ) 

                        def handlerValuesDisplayNewFieldWidthHeightFont(
                            event,
                            self=self,
                            tableStructure=self.tableStructure,
                            tableValues=self.tableValues
                            ):
                            return self.valuesDisplayNewFieldWidthHeightFont(tableStructure,tableValues)
                            
                        self.comboboxWidthField = Pmw.ComboBox(
                            frame_00_10,
                            scrolledlist_items=self.mytableFieldWidths,
                            entry_font=self.buttonFontSmallest,
                            listheight=130,
                            entry_width=5,
                            dropdown=1,
                            entry_state='disabled',
                            entry_disabledbackground='white',
                            entry_disabledforeground='black',
#                            selectioncommand=self.handlerRefreshTableView,
#                            selectioncommand=self.valuesDisplayRowDecimate,  # kills plot windows, too; not good
                            selectioncommand=handlerValuesDisplayNewFieldWidthHeightFont,
                            scrolledlist_hull_width=500,
                            )
                        self.comboboxWidthField.grid(
                            row=0,
                            column=1,
                            sticky=W,
                            padx=1,
                            pady=0,
                            )    
                            
# ... height of fields (lines)
                        labelHeightField = Label(
                            frame_00_10,
                            text=(' Field\n height:'),
                            font=self.buttonFontSmallest,
                            bg='tan',
                            fg='black',
                            )
                        labelHeightField.grid(
                            row=0,
                            column=2,
                            padx=1,
                            pady=0,
                            )       
                        self.comboboxHeightField = Pmw.ComboBox(
                            frame_00_10,
                            scrolledlist_items=self.mytableFieldHeights,
                            entry_font=self.buttonFontSmallest,
                            listheight=170,
                            entry_width=5,
                            dropdown=1,
                            entry_state='disabled',
                            entry_disabledbackground='white',
                            entry_disabledforeground='black',
#                            selectioncommand=self.handlerRefreshTableView,
                            selectioncommand=handlerValuesDisplayNewFieldWidthHeightFont,
                            scrolledlist_hull_width=500,
                            )
                        self.comboboxHeightField.grid(
                            row=0,
                            column=3,
                            sticky=W,
                            padx=1,
                            pady=0,
                            )
                        
# ... font of fields
                        labelFontField = Label(
                            frame_00_10,
                            text=(' Field\n font:'),
                            font=self.buttonFontSmallest,
                            bg='tan',
                            fg='black',
                            )
                        labelFontField.grid(
                            row=0,
                            column=4,
                            padx=2,
                            pady=0,
                            )       
                        self.comboboxFontField = Pmw.ComboBox(
                            frame_00_10,
                            scrolledlist_items=self.mytableFieldFonts,
                            entry_font=self.buttonFontSmallest,
                            listheight=80,
                            entry_width=5,
                            dropdown=1,
                            entry_state='disabled',
                            entry_disabledbackground='white',
                            entry_disabledforeground='black',
#                            selectioncommand=self.handlerRefreshTableView,
                            selectioncommand=handlerValuesDisplayNewFieldWidthHeightFont,
                            scrolledlist_hull_width=500,
                            )
                        self.comboboxFontField.grid(
                            row=0,
                            column=5,
                            sticky=W,
                            padx=2,
                            pady=0,
                            )
                            
                        if mapped: 
                            self.comboboxWidthField.setentry(saveFieldWidths)
                            self.comboboxHeightField.setentry(saveFieldHeights)
                            self.comboboxFontField.setentry(saveFieldFonts)
                        else:
                            self.comboboxWidthField.selectitem(self.mytableFieldWidths[2]) 
                            self.comboboxHeightField.selectitem(self.mytableFieldHeights[0])                        
                            self.comboboxFontField.selectitem(self.mytableFieldFonts[1])
                            
# set defaults for field width and height
                        self.buttonResetFieldSizeDefaults = Button(
                            frame_00_10,
                            text=('Reset'),
                            bg='white',
                            fg='blue',
                            borderwidth=3,
                            relief=RAISED,
                            font=self.buttonFontSmallest,
                            command=self.handlerResetFieldSizeDefaults,
                            )
                        self.buttonResetFieldSizeDefaults.grid(
                            row=0,
                            column=6,
                            sticky=W,
                            padx=2,
                            pady=0,
                            )
                        def handlerButtonResetFieldSizeDefaults(
                            event,
                            self=self
                            ):
                            return self.displayMessage(event,MSG_RESETFIELDSIZEDEFAULTS)
                        self.buttonResetFieldSizeDefaults.bind(
                            "<Enter>",
                            handlerButtonResetFieldSizeDefaults
                            )
# FRAME 00_11
# ... store x-y-select in buffer
#                        self.varSelectAnyRow_Buffer = []
                        self.buttonStoreXYSelect = Button(
                            frame_00_11,
                            text=BUTTONLABEL_BUFFERSTORE,
                            font=self.buttonFontSmallest,
                            borderwidth=3,
                            background='white',
                            foreground='blue',
                            command=self.handlerStoreXYinStorageBuffer_Table,
                            )
                        self.buttonStoreXYSelect.grid(
                            row=0,
                            column=0,
                            padx=3,
                            pady=0,
                            )
                        def handlerButtonStoreXYSelect(
                            event,
                            self=self
                            ):
                            return self.displayMessage(event,MSG_BUFFERSTORE)
                        self.buttonStoreXYSelect.bind(
                            "<Enter>",
                            handlerButtonStoreXYSelect
                            )
                            
# ... show storage buffer
                        self.countDisplayStorageBuffer = StringVar()
                        self.buttonShowStorageBuffer = Button(
                            frame_00_11,
#                            text='BUFFER: Display',
                            textvariable=self.countDisplayStorageBuffer,
                            font=self.buttonFontSmallest,
                            borderwidth=3,
                            background='white',
                            foreground='blue',
                            command=self.handlerDisplayStorageBufferValues_Call,
                            )
                        self.buttonShowStorageBuffer.grid(
                            row=0,
                            column=1,
                            padx=5,
                            pady=0
                            )
# display new total in main table window
                        self.countDisplayStorageBuffer.set(
                            'BUFFER: Display (' +
                            str(self.bufferRowStore_NumRows) + 
                            ' rows)'
                            )
                        def handlerButtonShowStorageBuffer(
                            event,
                            self=self
                            ):
                            return self.displayMessage(event,MSG_BUFFERDISPLAY)
                        self.buttonShowStorageBuffer.bind(
                            "<Enter>",
                            handlerButtonShowStorageBuffer
                            )
# FRAME 00_12
                            
# ... update plots
                        self.buttonUpdatePlotWindow = Button(
                            frame_00_12,
                            text="UPDATE PLOT WINDOW\nwith new table selections -->",
                            font=self.buttonFontSmallest,
                            borderwidth=3,
                            background='lightgreen',
                            foreground='black',
                            command=self.handlerUpdatePlotWindow_Table,
                            )
                        self.buttonUpdatePlotWindow.grid(
                            row=0,
                            column=0,
                            padx=3,
                            pady=0,
                            )
                        def handlerButtonUpdatePlotWindow(
                            event,
                            self=self
                            ):
                            return self.displayMessage(event,MSG_UPDATEPLOTWINDOW)
                        self.buttonUpdatePlotWindow.bind(
                            "<Enter>",
                            handlerButtonUpdatePlotWindow
                            )
                            
# current plot windows available:
# ... 'X-Y', 'Kiviat', 'Scatter', 'Bar'
                        self.comboListOfPlotWindows_Table = Pmw.ComboBox(
                            frame_00_12,
                            scrolledlist_items=self.listOfPlotWindowsAvailable,
                            dropdown=1,
                            entry_state='disabled',
                            entry_disabledbackground='white',
                            entry_disabledforeground='black',
                            entry_font=self.buttonFont,
                            listheight=90,
                            entry_width=10,
                            scrolledlist_hull_width=500,
#                            selectioncommand=None,
                            )
                        self.comboListOfPlotWindows_Table.grid(
                            row=0,
                            column=1,
                            padx=0,
                            pady=0,
                            )
                        self.comboListOfPlotWindows_Table.setentry(
                            self.listOfPlotWindowsAvailable[0]
                            )

# ... select all y   
                        self.varSelectYNumericalOrAll = IntVar()
                        self.varstringSelectYNumericalOrAll = StringVar()
                        self.checkbuttonYSelectNumericalOrAll = Checkbutton(
                            frame_10,
                            indicator=0,
                            textvariable=self.varstringSelectYNumericalOrAll,
                            variable=self.varSelectYNumericalOrAll,
                            width=22,
                            selectcolor='lightgray',
                            relief=RAISED,
                            borderwidth=3,
                            font=self.buttonFontSmallest,
                            command=self.handlerSelectYNumericalOrAll,
                            )
                        self.checkbuttonYSelectNumericalOrAll.grid(
                            row=0,
                            column=0,
                            columnspan=2,
                            padx=2,
                            pady=1,
                            )
                        self.varstringSelectYNumericalOrAll.set(
                            self.buttontextYNumerical
                            )
                        def handlerCheckbuttonYSelectNumericalOrAll(
                            event,
                            self=self
                            ):
                            return self.displayMessage(event,MSG_SELECTALLYORNUMERICALY)
                        self.checkbuttonYSelectNumericalOrAll.bind(
                            "<Enter>",
                            handlerCheckbuttonYSelectNumericalOrAll
                            )
                            
# ... de-select all y                            
                        self.buttonYSelectClear = Button(
                            frame_10,
                            text=BUTTONLABEL_DESELECTALLY,
                            width=12,
                            relief=RAISED,
                            borderwidth=3,
                            font=self.buttonFontSmallest,
                            command=self.handlerClearAllY,
                            )
                        self.buttonYSelectClear.grid(    
                            row=1,
                            column=0,
                            padx=2,
                            pady=1,
                            sticky=E,
                            ) 
                        def handlerButtonYSelectClear(
                            event,
                            self=self
                            ):
                            return self.displayMessage(event,MSG_DESELECTALLY)
                        self.buttonYSelectClear.bind(
                            "<Enter>",
                            handlerButtonYSelectClear
                            )

# ... y select
                        labelYSelect = Label(
                            frame_10,
                            text='Y-Select (one or multiple) -->',
                            bg='tan',
                            justify=RIGHT,
                            relief=FLAT,
                            font=self.buttonFontSmall
                            )
                        labelYSelect.grid(
                            row=1,
                            column=1,
                            padx=2,
                            pady=0,
                            sticky=N+E,
                            )

# ... De-select X
                        self.buttonDeselectX = Button(
                            frame_10,
                            text=BUTTONLABEL_DESELECTX,
                            width=12,
                            justify=CENTER,
                            font=self.buttonFontSmallest,
                            relief=RAISED,
                            borderwidth=3,
                            command=self.handlerDeselectX,
                            )
                        self.buttonDeselectX.grid(
                            row=2,
                            column=0,
#                            columnspan=2,
                            padx=2,
                            pady=1,
                            sticky=E,
                            )
                        def handlerButtonDeselectX(
                            event,
                            self=self
                            ):
                            return self.displayMessage(event,MSG_DESELECTX)
                        self.buttonDeselectX.bind(
                            "<Enter>",
                            handlerButtonDeselectX
                            )

# ... x select                                                      
                        labelXSelect = Label(
                            frame_10,
                            text= 'X-Select (one only) -->',
                            justify=RIGHT,
                            bg='tan',
                            font=self.buttonFontSmall,
                            )
                        labelXSelect.grid(
                            row=2,
#                            column=0,
                            column=1,
#                            columnspan=2,
                            padx=2,
                            pady=0,
                            sticky=N+E,
                            ) 

# ... quik-select X & Y
                        self.buttonQuikSelectXY = Button(
                            frame_10,
                            text=BUTTONLABEL_QUIKSELECTXY,
                            width=15,
                            justify=CENTER,
                            font=self.buttonFontSmallest,
                            relief=RAISED,
                            borderwidth=3,
                            command=self.handlerQuikSelectXY,
                            )
                        self.buttonQuikSelectXY.grid(
                            row=3,
                            column=0,
                            padx=2,
                            pady=1,
                            sticky=E,
                            )
                        def handlerButtonQuikSelectXY(
                            event,
                            self=self
                            ):
                            return self.displayMessage(event,MSG_QUIKSELECTXY)
                        self.buttonQuikSelectXY.bind(
                            "<Enter>",
                            handlerButtonQuikSelectXY
                            )

# ... column #                            
                        labelColumnNumber = Label(
                            frame_10,
                            text='Column #: -->',
                            justify=RIGHT,
                            bg='tan',
                            font=self.buttonFontSmall,
                            )
                        labelColumnNumber.grid( 
                            row=3,
#                            column=0,
#                            columnspan=2,
                            column=1,
                            padx=2,
                            pady=0,
                            sticky=N+E,
                            )
                            
# ... clear all row checkbuttons
                        self.varAllRowsClearOrSelect = IntVar()
                        checkbuttonAllRowsClearOrSelect = Checkbutton(
                            frame_31,
                            indicator=0,
                            text='/\\\nClear/Select\ndisplayed rows',
                            variable=self.varAllRowsClearOrSelect,
                            bg='white',
                            fg='blue',
                            borderwidth=5,
                            relief=RAISED,
                            justify=CENTER,
                            font=self.buttonFontSmallest,
                            command=self.handlerAllRowsClearOrSelect,
                            )
                        checkbuttonAllRowsClearOrSelect.grid(
                            row=0,
                            column=0,
                            padx=0,
                            pady=1,
                            sticky=N,
                            ) 
                        def handlerCheckbuttonAllRowsClearOrSelect(
                            event,
                            self=self
                            ):
                            return self.displayMessage(event,MSG_CLEARSELECTALL)
                        checkbuttonAllRowsClearOrSelect.bind(
                            "<Enter>",
                            handlerCheckbuttonAllRowsClearOrSelect
                            )
                        
# display MAIN button group
#                        self.displayMainButtonGroup(0)
# re-display current button group; if no group exists, display 'MAIN'
                        self.handlerKeepButtonGroup()
                                           
# STATUS line
# ... total rows
                        labelTotalLines = Label(
                            frame_32_00_statusLine,
                            text='Total rows\nin table',
                            font=self.buttonFontSmallest,
                            justify=RIGHT,
                            bg='tan',
                            fg='black',
                            )
                        labelTotalLines.grid(
                            row=0,
                            column=0,
                            padx=2,
                            pady=2,
                            )
#                        statusLine_linesTotal = len(self.tableValuesOriginal)
                        statusLine_linesTotal = self.totalRowsInTable()
                        self.varEntryTotalLines = IntVar()
                        self.entryTotalLines = Entry(
                            frame_32_00_statusLine,
                            width=6,
                            font=self.buttonFontSmallest,
                            textvariable=self.varEntryTotalLines,
                            disabledforeground='black',
                            disabledbackground='white',
                            )
                        self.entryTotalLines.grid(
                            row=0,
                            column=1,
                            padx=0,
                            pady=2,
                            )
                        self.entryTotalLines.configure(state='normal')
                        self.varEntryTotalLines.set(statusLine_linesTotal)
                        self.entryTotalLines.configure(state='disabled')
                        
# ... number of rows loaded
                        labelLoadedRows = Label(
                            frame_32_00_statusLine,
                            text='Rows in\nmemory',
                            font=self.buttonFontSmallest,
                            justify=RIGHT,
                            bg='tan',
                            fg='black',
                            )
                        labelLoadedRows.grid(
                            row=0,
                            column=2,
                            padx=2,
                            pady=2,
                            )
                        statusLine_rowsLoaded = len(self.tableValues)
                        self.varEntryLoadedRows = IntVar()
                        self.entryLoadedRows = Entry(
                            frame_32_00_statusLine,
                            width=6,
                            font=self.buttonFontSmallest,
                            textvariable=self.varEntryLoadedRows,
                            disabledforeground='black',
                            disabledbackground='white',
                            )
                        self.entryLoadedRows.grid(
                            row=0,
                            column=3,
                            padx=0,
                            pady=2,
                            )
# set values
                        self.varEntryLoadedRows.set(statusLine_rowsLoaded)
                        self.entryLoadedRows.configure(state='disabled')

# ... current rows
                        labelCurrentRows = Label(
                            frame_32_00_statusLine,
                            text='Rows in\ndisplay',
                            font=self.buttonFontSmallest,
                            justify=RIGHT,
                            bg='tan',
                            fg='black',
                            )
                        labelCurrentRows.grid(
                            row=0,
                            column=4,
                            padx=2,
                            pady=2,
                            )
                        statusLine_rowsDisplayed = len(self.tableValues)
                        self.varEntryDisplayedRows = IntVar()
                        self.entryDisplayedRows = Entry(
                            frame_32_00_statusLine,
                            width=6,
                            font=self.buttonFontSmallest,
                            textvariable=self.varEntryDisplayedRows,
                            disabledforeground='black',
                            disabledbackground='white',
                            )
                        self.entryDisplayedRows.grid(
                            row=0,
                            column=5,
                            padx=0,
                            pady=2,
                            )
# set this value after 'Max lines to display' is known, below
                        self.varEntryDisplayedRows.set(statusLine_rowsDisplayed)
                        self.entryDisplayedRows.configure(state='disabled')
                        
# ... total columns
                        labelTotalCols = Label(
                            frame_32_01_statusLine,
                            text='Total cols\nin table',
                            font=self.buttonFontSmallest,
                            justify=RIGHT,
                            bg='tan',
                            fg='black',
                            )
                        labelTotalCols.grid(
                            row=0,
                            column=0,
                            padx=2,
                            pady=2,
                            )
                            
# if table is empty, will raise an exception
                        try:
                            statusLine_colsTotal = len(self.tableValuesOriginal[0])
                        except:
                            statusLine_colsTotal = 0
                        self.varEntryTotalCols = IntVar()
                        self.entryTotalCols = Entry(
                            frame_32_01_statusLine,
                            width=6,
                            font=self.buttonFontSmallest,
                            textvariable=self.varEntryTotalCols,
                            disabledforeground='black',
                            disabledbackground='white',
                            )
                        self.entryTotalCols.grid(
                            row=0,
                            column=1,
                            padx=0,
                            pady=2,
                            )
                        self.entryTotalCols.configure(state='normal')
                        self.varEntryTotalCols.set(statusLine_colsTotal)
                        self.entryTotalCols.configure(state='disabled')

# ... current columns
                        labelCurrentColumns = Label(
                            frame_32_01_statusLine,
                            text='Cols in\ndisplay',
                            font=self.buttonFontSmallest,
                            justify=RIGHT,
                            bg='tan',
                            fg='black',
                            )
                        labelCurrentColumns.grid(
                            row=0,
                            column=2,
                            padx=2,
                            pady=2,
                            )
                            
# empty table will raise an exception here
                        try:
                            statusLine_columnsDisplayed = len(self.tableValues[0])
                        except:
                            statusLine_columnsDisplayed = 0
                        self.varEntryDisplayedColumns = IntVar()
                        self.entryDisplayedColumns = Entry(
                            frame_32_01_statusLine,
                            width=6,
                            font=self.buttonFontSmallest,
                            textvariable=self.varEntryDisplayedColumns,
                            state='disabled',
                            disabledforeground='black',
                            disabledbackground='white',
                            )
                        self.entryDisplayedColumns.grid(
                            row=0,
                            column=3,
                            padx=0,
                            pady=2,
                            )
#                        self.entryDisplayedColumns.configure(state='normal')
                        self.varEntryDisplayedColumns.set(statusLine_columnsDisplayed)
#                        self.entryDisplayedColumns.configure(state='disabled')
# ... max lines to display
                        labelMaxLinesToDisplay = Label(
                            frame_32_02_statusLine,
                            text=('Max lines to display\n' + 
                                  '(\'0\' shows all lines)'),
                            font=self.buttonFontSmallest,
                            justify=RIGHT,
                            bg='tan',
                            fg='black',
                            )
                        
                        labelMaxLinesToDisplay.grid(
                            row=0,
                            column=0,
                            padx=2,
                            pady=2,
                            )
                        self.comboboxMaxLinesToDisplay = Pmw.ComboBox(
                            frame_32_02_statusLine,
                            scrolledlist_items=self.statuslineMaxLinesToDisplay,
                            entry_font=self.buttonFontSmallest,
                            dropdown=1,
                            listheight=130,
#                            selectioncommand=self.handlerStatusLineRefresh,
                            entry_width=5,
                            entry_state='disabled',
                            entry_disabledbackground='white',
                            entry_disabledforeground='black',
                            scrolledlist_hull_width=500,
                            )
                        self.comboboxMaxLinesToDisplay.grid(
                            row=0,
                            column=1,
                            padx=0,
                            pady=2,
                            )
                        self.comboboxMaxLinesToDisplay.configure(scrolledlist_vscrollmode='dynamic')

                        if mapped:
                            rowsMaxToDisplay = saveMaxLinesToDisplay
                            self.comboboxMaxLinesToDisplay.setentry(saveMaxLinesToDisplay)
                        else:
                            rowsMaxToDisplay = self.statuslineMaxLinesToDisplay[3]
                            self.comboboxMaxLinesToDisplay.selectitem(rowsMaxToDisplay)
#                        MaxLinesToDisplay.configure(entry_width=5)
# now set 'Current rows'
# ... if total rows is larger than 'Max lines to display', set current rows to 'Max lines to display'
                        if statusLine_linesTotal > int(rowsMaxToDisplay):
                            self.varEntryDisplayedRows.set(int(rowsMaxToDisplay))
# ... if total rows is equal or smaller than 'Max lines to display', set current rows to total rows
                        else:
                            self.varEntryDisplayedRows.set(statusLine_linesTotal)
                        
# ... display options
                        labelDisplayOptions = Label(
                            frame_32_02_statusLine,
                            text='Partial\ndisplay',
                            font=self.buttonFontSmallest,
                            justify=RIGHT,
                            bg='tan',
                            fg='black',
                            )
                        labelDisplayOptions.grid(
                            row=0,
                            column=2,
                            padx=2,
                            pady=2,
                            )
# ... beginning
                        buttonDisplayBeginning = Button(
                            frame_32_02_statusLine,
                            text=BUTTONLABEL_TOP,
                            fg='blue',
                            font=self.buttonFontSmallest,
                            relief=RAISED,
                            borderwidth=3,
                            command=self.handlerBeginning,
                            )
                        buttonDisplayBeginning.grid(
                            row=0,
                            column=3,
                            padx=2,
                            pady=2,
                            )
                        def handlerButtonDisplayBeginning(
                            event,
                            self=self
                            ):
                            return self.displayMessage(event,MSG_TOP)
                        buttonDisplayBeginning.bind(
                            "<Enter>",
                            handlerButtonDisplayBeginning
                            )

# ... middle
                        buttonDisplayMiddle = Button(
                            frame_32_02_statusLine,
                            text=BUTTONLABEL_MIDDLE,
                            fg='blue',
                            font=self.buttonFontSmallest,
                            relief=RAISED,
                            borderwidth=3,
                            command=self.handlerMiddle,
                            )
                        buttonDisplayMiddle.grid(
                            row=0,
                            column=4,
                            padx=2,
                            pady=2,
                            )
                        def handlerButtonDisplayMiddle(
                            event,
                            self=self
                            ):
                            return self.displayMessage(event,MSG_MIDDLE)
                        buttonDisplayMiddle.bind(
                            "<Enter>",
                            handlerButtonDisplayMiddle
                            )

# ... end
                        buttonDisplayEnd = Button(
                            frame_32_02_statusLine,
                            text=BUTTONLABEL_BOTTOM,
                            fg='blue',
                            font=self.buttonFontSmallest,
                            relief=RAISED,
                            borderwidth=3,
                            command=self.handlerEnd,
                            )
                        buttonDisplayEnd.grid(
                            row=0,
                            column=5,
                            padx=2,
                            pady=2,
                            )
                        def handlerButtonDisplayEnd(
                            event,
                            self=self
                            ):
                            return self.displayMessage(event,MSG_BOTTOM)
                        buttonDisplayEnd.bind(
                            "<Enter>",
                            handlerButtonDisplayEnd
                            )

# ... range
                        buttonDisplayRange = Button(
                            frame_32_02_statusLine,
                            text=BUTTONLABEL_RANGE,
                            fg='blue',
                            font=self.buttonFontSmallest,
                            relief=RAISED,
                            borderwidth=3,
                            command=self.handlerRange,
                            )
                        buttonDisplayRange.grid(
                            row=0,
                            column=6,
                            padx=2,
                            pady=2,
                            )
                        def handlerButtonDisplayRange(
                            event,
                            self=self
                            ):
                            return self.displayMessage(event,MSG_RANGE)
                        buttonDisplayRange.bind(
                            "<Enter>",
                            handlerButtonDisplayRange
                            )
                            
# ... re-order auto_index field
                        buttonReorderAutoIndex = Button(
                            frame_32_02_statusLine,
                            text=BUTTONLABEL_REORDERAUTOINDEX,
                            font=self.buttonFontSmallest,
                            bg='white',
                            fg='black',
                            borderwidth=3,
                            width=8,
                            justify=CENTER,
                            command=self.resequenceAutoIndexFromMainWindow,
                            )
                        buttonReorderAutoIndex.grid(
                            row=0,
                            column=7,
                            padx=5,
                            pady=2,
                            )
                        def handlerButtonReorderAutoIndex(
                            event,
                            self=self
                            ):
                            return self.displayMessage(event,MSG_REORDERAUTOINDEX)
                        buttonReorderAutoIndex.bind(
                            "<Enter>",
                            handlerButtonReorderAutoIndex
                            )
                            
# last button pressed
                        labelLastButtonPressed = Label(
                           self.frame_50_messages,
                           text='Last button pressed: ',
                           bg='tan',
                           fg='black',
#                           font=self.dataFont,
                           font=self.buttonFont,
                           )
                        labelLastButtonPressed.grid(
                            row=0,
                            column=0,
                            padx=0,
                            pady=5,
                            sticky=E,
                            )
                        self.varEntryLastButtonPressed = StringVar()
                        self.entryLastButtonPressed = Entry(
                            self.frame_50_messages,
                            width=45,
                            font=self.buttonFont,
                            state='disabled',
                            disabledbackground='white',
                            disabledforeground='black',
                            textvariable=self.varEntryLastButtonPressed,
                            )
                        self.entryLastButtonPressed.grid(
                            row=0,
                            column=1,
                            padx=0,
                            pady=5,
                            sticky=W,
                            )
                            
# Text box for messages from PylotDB to user
# ... y (vertical) scrollbar
                        self.yScrollMyCode = Scrollbar(
                            self.frame_50_messages,
                            orient=VERTICAL,
                            )
                        self.yScrollMyCode.grid(
                            row=1,
                            column=2,
                            sticky=N+S,
                            padx=2,
                            pady=0
                            )                                                
                        self.textMessagesToUser = Text(
                            self.frame_50_messages,
                            bg='white',
                            fg='black',
                            borderwidth=3,
                            wrap=WORD,
#                            state=DISABLED,
                            width=120,
                            height=8,
                            font=self.dataFont,
                            yscrollcommand=self.yScrollMyCode.set,
                            )
                        self.textMessagesToUser.grid(
                            row=1,
                            column=0,
                            columnspan=2,
                            padx=0,
                            pady=0,
                            )
                        self.yScrollMyCode.configure(
                            command=self.textMessagesToUser.yview
                            )
                        self.textMessagesToUser.configure(state='normal')
                            
                        self.varCheckbuttonFreezeTextMessageToUser = IntVar()
                        self.checkbuttonFreezeTextMessageToUser = Checkbutton(
                            self.frame_50_messages,
                            text='Freeze display',
                            indicatoron=1,
                            bg='tan',
                            variable=self.varCheckbuttonFreezeTextMessageToUser,
                            font=self.buttonFontSmallest,
                            )
                        self.checkbuttonFreezeTextMessageToUser.grid(
                            row=2,
                            column=0,
                            padx=0,
                            pady=0,
                            sticky=W,
                            )
                        if mapped:
                            self.varCheckbuttonFreezeTextMessageToUser.set(
                                saveCheckbuttonFreezeTextMessageToUser
                                )
                        else:
                            self.varCheckbuttonFreezeTextMessageToUser.set(0)
                            
                        if mapped:
                            self.displayMessage('',saveMessageToUser)
                            self.entryLastButtonPressed.configure(state='normal')
                            self.varEntryLastButtonPressed.set(saveLastButtonPressed)
                            self.entryLastButtonPressed.configure(state='disabled')
                            self.textMessagesToUser.configure(state='normal')
                            self.textMessagesToUser.delete(1.0,END)
                            self.textMessagesToUser.insert(1.0,saveMessageToUser)
                            self.textMessagesToUser.configure(state='disabled')
                        else:
                            self.displayMessage('',MSG_INITIAL)
                            
                            
                            
# CANCEL button                           
                        buttonCancelTableValues = Button(
                            frame_70,
                            text='Cancel',
                            width=15,
                            borderwidth=5,
                            relief=RAISED,
                            justify=CENTER,
                            font=self.buttonFontSmall,
                            command=self.handlerDestroyToplevelTableValues,
                            )
                        buttonCancelTableValues.grid(
                            row=0,
                            column=0,
                            pady=5,
                            )
                            
# display table fields and rows up to 'Max lines to display'  
# ... updates parameters, self.varYSelect, self.varXSelect, etc.  
# ... calls 'valuesDisplayRowDecimate' which calls 'displayHeadersRowsValues'
                        self.valuesDisplayRowDecimate(self.tableStructure, self.tableValues)
                        
                        return
                        
# invalid table
                stringTableNotFound = (
                    'The following table was not found in list of current tables:\n\n' +
                    ' Table: %s\n' +
                    ' Database: %s\n\n' +
                    'Select another table.\n' +
                    'This operation is canceled.'
                    ) % (myTable, myDatabase)
                self.MySQL_Output(
                    1,
                    stringTableNotFound
                    )
                showerror(
                    'Error: table not found',
                    stringTableNotFound
                    )
                return
# invalid database
        stringDatabaseNotFound = (
            'The following database was not found:\n\n' +
                    ' Database: %s\n\n' +
                    'Select another database.\n' +
                    'This operation is canceled.'
                    ) % (myDatabase)
        self.MySQL_Output(
            1,
            stringDatabaseNotFound
            )
        showerror(
            'Error: database not found',
            stringDatabaseNotFound
            )
            
        return
        
        
    def handlerQuikSelectXY(self):
        '''
        Purpose:
            select X and Y header values without having to scroll table; 
            just list header values to choose from; checking a header here
            checks the header in the table values
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerQuikSelectXY')

# set variables
        colorbg = 'lightblue'
        colorbg= '#fff8e0fff' # light fucia
        colorbg = '#bb5c558a3'  # murky green
#        colorbg = '#bb5e237ce'  # pea greenish
        colorbg = '#fffb1134f' # pumpkin
        colorbg = '#b36c7ab84' # light gray
        
# Toplevel
        try:
            mapped = self.toplevelQuikSelectXY.winfo_exists()
        except:
            mapped = False
            
        if mapped:
# ask to destroy
            stringQuikSelectWindowIsOpen = (
                'The Quik-Select window is currently open.' 
                )
            showinfo(
                'Window open: Quik-Select X & Y',
                stringQuikSelectWindowIsOpen,
                parent=self.toplevelQuikSelectXY
                )
            return

        myDatabase = self.varTableFunctionsSelectDatabase.get().strip()
        myTable = self.varEntryTableFunctionsSelectTable.get().strip()
            
# ... open toplevel frame for Quik-Select X & Y
        self.toplevelQuikSelectXY = Toplevel(
            bg=colorbg,
            )
        self.toplevelQuikSelectXY.title(
            'Server: ' + self.comboServerMySQL.get() + '     ' +
            'Database: ' + myDatabase + '     ' +
            'Table: ' + myTable
            )
            
# ... define parent window
        self.toplevelQuikSelectXY.transient(self.toplevelTableValues)
        
# place the toplevel window relative to the Tables window
        x_Window = self.toplevelTableValues.winfo_rootx() + 50
        y_Window = self.toplevelTableValues.winfo_rooty() +200
        self.toplevelQuikSelectXY.geometry(
            '+%d+%d' % (x_Window, y_Window)
            )
            
# Frames

# ... title
        rowCount = 0
        frame_00_Title = Frame(
            self.toplevelQuikSelectXY,
            bg=colorbg,
            )
        frame_00_Title.grid(
            row=rowCount,
            column=0,
            padx=0,
            pady=2,
            sticky=N,
            )

# ... subtitle
        rowCount += 1
        frame_10_Subtitle = Frame(
            self.toplevelQuikSelectXY,
            bg=colorbg,
            )
        frame_10_Subtitle.grid(
            row=rowCount,
            column=0,
            padx=0,
            pady=2,
            sticky=N,
            )
            
# ... number of entries, database, and table
        rowCount += 1
        frame_20_NumberOfEntriesDatabaseTable = Frame(
            self.toplevelQuikSelectXY,
            bg=colorbg,
            )
        frame_20_NumberOfEntriesDatabaseTable.grid(
            row=rowCount,
            column=0,
            padx=0,
            pady=2,
            sticky=N,
            )
            
# ... selected X field, number of selected Y values
        rowCount += 1
        frame_25_SelectedXNumberOfSelectedYValues = Frame(
            self.toplevelQuikSelectXY,
            bg=colorbg,
            )
        frame_25_SelectedXNumberOfSelectedYValues.grid(
            row=rowCount,
            column=0,
            padx=10,
            pady=2,
#            sticky=E+W,
            )
        frame_25_00_SelectedXNumberOfSelectedYValues = Frame(
            frame_25_SelectedXNumberOfSelectedYValues,
            bg=colorbg,
            )
        frame_25_00_SelectedXNumberOfSelectedYValues.grid(
            row=0,
            column=0,
            padx=10,
            pady=2,
            sticky=W,
            )
        frame_25_01_SelectedXNumberOfSelectedYValues = Frame(
            frame_25_SelectedXNumberOfSelectedYValues,
            bg=colorbg,
            )
        frame_25_01_SelectedXNumberOfSelectedYValues.grid(
            row=0,
            column=1,
            padx=10,
            pady=2,
            sticky=W,
            )

# ... headers
        rowCount += 1
        frame_30_Headers = Pmw.ScrolledFrame(
            self.toplevelQuikSelectXY,
            usehullsize=1,
            hull_width=725,
            hull_height=25,
            hscrollmode='none',
            vscrollmode='none',
            horizflex='expand',
            vertflex='expand',
            )
        frame_30_Headers.grid(
            row=rowCount,
            column=0,
            padx=2,
            pady=2,
            )
        '''
        Pmw.Color.changecolor(
            self.toplevelQuikSelectXY,
            background=colorbg
            )
        '''

# ... scrolling values
        rowCount += 1
        frame_40_ScrollingValues = Pmw.ScrolledFrame(
            self.toplevelQuikSelectXY,
            usehullsize=1,
            hull_width=725,
            hull_height=420,
            hscrollmode='dynamic',
            vscrollmode='static',
            horizflex='expand',
            vertflex='expand',
            )
        frame_40_ScrollingValues.grid(
            row=rowCount,
            column=0,
            padx=0,
            pady=2,
            )
        Pmw.Color.changecolor(
            self.toplevelQuikSelectXY,
            background=colorbg
            )

# ... function buttons
        rowCount += 1
        frame_50_FunctionButtons = Frame(
            self.toplevelQuikSelectXY,
            bg=colorbg,
            )
        frame_50_FunctionButtons.grid(
            row=rowCount,
            column=0,
            padx=2,
            pady=2,
#            sticky=E+W,
            )

# ... cancel button
        rowCount += 1
        frame_60_CancelButton = Frame(
            self.toplevelQuikSelectXY,
            bg=colorbg,
            )
        frame_60_CancelButton.grid(
            row=rowCount,
            column=0,
            padx=0,
            pady=2,
            )

# -------  end of Frames ---------

# Widgets

# ... title
        labelTitle = Label(
            frame_00_Title,
            text='QUIK-SELECT X & Y',
            bg=colorbg,
            justify=CENTER,
            font=self.titleFontBig,
            )
        labelTitle.grid(
            row=0,
            column=0,
            padx=0,
            pady=2,
            )

# ... subtitle
        labelSubTitle = Label(
            frame_10_Subtitle,
            text=(
                'Selecting X and/or Y values here will ' +
                'select identical table values'
                ),
            bg=colorbg,
            justify=CENTER,
            font=self.titleFontBig
            )
        labelSubTitle.grid(
            row=0,
            column=0,
            padx=0,
            pady=2,
            )
            
# ... number of entries, database, and table
# ...   entries
        rowCount = 0
        labelNumberOfEntries = Label(
            frame_20_NumberOfEntriesDatabaseTable,
            text=(
                'Number of fields displayed: %s' % len(self.varYSelect)
                ),
            bg=colorbg,
            justify=CENTER,
            font=self.titleFontBig,
            )
        labelNumberOfEntries.grid(
            row=rowCount,
            column=0,
            padx=0,
            pady=0,
            )

# ...   table name
        rowCount += 1
        labelTable = Label(
            frame_20_NumberOfEntriesDatabaseTable,
            text=(
                'Table: %s' % myTable
                ),
            bg=colorbg,
            justify=CENTER,
            font=self.titleFontBig,
            )
        labelTable.grid(
            row=rowCount,
            column=0,
            padx=0,
            pady=0,
            )
            
# ...   selected X field
        label = Label(
            frame_25_00_SelectedXNumberOfSelectedYValues,
            text='Selected X field: ',
            bg=colorbg,
            justify=RIGHT,
            font=self.buttonFontSmall,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            sticky=E,
            )
                            
        self.varEntryQuikSelectXValueSelected = StringVar()
        entryQuikSelectXValueSelected = Entry(
            frame_25_00_SelectedXNumberOfSelectedYValues,
            width=25,
            disabledbackground='white',
            disabledforeground='black',
            font=self.buttonFontSmall,
            state='disabled',
            textvariable=self.varEntryQuikSelectXValueSelected,
            )
        entryQuikSelectXValueSelected.grid(
            row=0,
            column=1,
            padx=0,
            pady=2,
            sticky=W,
            )

# ...   number of selected Y values
        label = Label(
            frame_25_01_SelectedXNumberOfSelectedYValues,
            text='Number of selected Y: ',
            bg=colorbg,
            justify=RIGHT,
            font=self.buttonFontSmall,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=2,
            sticky=E,
            )
                            
        self.varEntryQuikSelectNumberOfYValuesSelected = IntVar()
        entryQuikSelectNumberOfYValuesSelected = Entry(
            frame_25_01_SelectedXNumberOfSelectedYValues,
            width=5,
            disabledbackground='white',
            disabledforeground='black',
            font=self.buttonFontSmall,
            state='disabled',
            textvariable=self.varEntryQuikSelectNumberOfYValuesSelected,
            )
        entryQuikSelectNumberOfYValuesSelected.grid(
            row=0,
            column=1,
            padx=0,
            pady=2,
            sticky=W,
            )
       
# define field widths for headers
        width_header_i = 6
        width_header_XYSelectButton = 3
        width_header_DatatypeOfHeaders = 15
        width_header_Headers = 60

# ... headers
# ...   #

        varHeader0 = StringVar()
        entryFieldLabel0 = Entry(
            frame_30_Headers.interior(),
            textvariable=varHeader0,
            bg=colorbg,
            width=width_header_i,
            justify=CENTER,
            relief=FLAT,
            state='disable',
            disabledbackground=colorbg,
#            disabledbackground='white',
            disabledforeground='black',
            )
        entryFieldLabel0.grid(
            row=0,
            column=0,
            padx=0,
            pady=2,
            )
        varHeader0.set('Field')
        
# ...   X-Select

        varHeader1 = StringVar()
        entryFieldLabel1 = Entry(
            frame_30_Headers.interior(),
            textvariable=varHeader1,
            bg=colorbg,
            width=width_header_XYSelectButton,
            justify=CENTER,
            relief=FLAT,
            state='disable',
            disabledbackground=colorbg,
#            disabledbackground='white',
            disabledforeground='black',
            )
        entryFieldLabel1.grid(
            row=0,
            column=1,
            padx=10,
            pady=2,
            )
        varHeader1.set('X')

# ...   Y-Select

        varHeader2 = StringVar()
        entryFieldLabel2 = Entry(
            frame_30_Headers.interior(),
            textvariable=varHeader2,
            bg=colorbg,
            width=width_header_XYSelectButton,
            justify=CENTER,
            relief=FLAT,
            state='disable',
            disabledbackground=colorbg,
#            disabledbackground='white',
            disabledforeground='black',
            )
        entryFieldLabel2.grid(
            row=0,
            column=2,
            padx=10,
            pady=2,
            )
        varHeader2.set('Y')

# ...   Header
        
        label3 = Label(
            frame_30_Headers.interior(),
            text='Datatype',
#            bg=colorbg,
            justify=LEFT,
            width=width_header_DatatypeOfHeaders,
            bg=colorbg,
            anchor='w',
            )
        label3.grid(
            row=0,
            column=3,
            padx=5,
            pady=0,
            )
            
        label4 = Label(
            frame_30_Headers.interior(),
            text='Headers',
#            bg=colorbg,
            justify=LEFT,
            width=width_header_Headers,
            bg=colorbg,
            anchor='w',
            )
        label4.grid(
            row=0,
            column=4,
            padx=2,
            pady=0,
            )

# scrollable values

# initialize
# ... define field widths
        width_values_i = 6
        width_values_XYSelectButton = 3
        width_values_DatatypeOfHeaders = 15
        width_values_Headers = 60
        PadY = 2
# ... radiobuttons
        self.varRadiobuttonsQuikSelectX = IntVar()
# ... checkboxes
        self.varCheckbuttonsQuikSelectY = []

# determine from displayed (not server) values which fields are displayed and their datatype; 
# ... then get field number and header; finally display 
        for i in range(len(self.tableStructure)):
            myField, myDatatype, myNull, myKey, myDefault, myExtra = self.tableStructure[i]
# column 0: number
            columnCount = 0
                
            varField0 = StringVar()
            entryField0 = Entry(
                frame_40_ScrollingValues.interior(),
                textvariable=varField0,
                bg='tan',
                width=width_values_i,
                justify=CENTER,
                relief=FLAT,
                state='disable',
                disabledbackground=colorbg,
                disabledforeground='black',
                )
            entryField0.grid(
                row=i,
                column=columnCount,
                padx=1,
                pady=PadY,
                sticky=W,
                )
            varField0.set(str(i+1) + '.')
            
# column 1: X-select radiobuttons
            columnCount += 1
            radiobuttonField1 = Radiobutton(
                frame_40_ScrollingValues.interior(),
                variable=self.varRadiobuttonsQuikSelectX,
                value=i+1,
                bg=colorbg,
                width=width_values_XYSelectButton,
                borderwidth=0,
                justify=CENTER,
                command=self.handlerRadiobuttonQuikSelectX,
                )
            radiobuttonField1.grid(
                row=i,
                column=columnCount,
                padx=1,
                pady=PadY,
                sticky=W,
                )
            
# column 2: Y-select checkboxes
            columnCount += 1
            varField2 = IntVar()
            checkbuttonField2 = Checkbutton(
                frame_40_ScrollingValues.interior(),
                variable=varField2,
                bg=colorbg,
                width=width_values_XYSelectButton,
                borderwidth=0,
                justify=CENTER,
                command=self.handlerCheckbuttonQuikSelectY,
                )
            checkbuttonField2.grid(
                row=i,
                column=columnCount,
                padx=1,
                pady=PadY,
                sticky=W,
                )
            self.varCheckbuttonsQuikSelectY.append(varField2)
            
# column 3: datatype
            columnCount += 1
            varField3 = StringVar()
            entryField3 = Entry(
                frame_40_ScrollingValues.interior(),
                textvariable=varField3,
                width=width_values_DatatypeOfHeaders,
                justify=LEFT,
                relief=FLAT,
                state='disable',
                disabledbackground='white',
                disabledforeground='black',
                )
            entryField3.grid(
                row=i,
                column=columnCount,
                padx=1,
                pady=PadY,
                sticky=W,
                )
            varField3.set(myDatatype)
            
# column 4: header
            columnCount += 1
            varField4 = StringVar()
            entryField4 = Entry(
                frame_40_ScrollingValues.interior(),
                textvariable=varField4,
                width=width_values_Headers,
                justify=LEFT,
                relief=FLAT,
                state='disable',
                disabledbackground='white',
                disabledforeground='black',
                )
            entryField4.grid(
                row=i,
                column=columnCount,
                padx=2,
                pady=PadY,
                sticky=W,
                )
            varField4.set(myField)
            
            
# upon opening this window, set number of Y values to those 
# ... in Table Values window
        
        if DEBUG_QUIKSELECT:
            print('\nself.dictColumnHeaders:')
            print(self.dictColumnHeaders)
            print('\nself.varYSelect:')
            for number,var in enumerate(self.varYSelect):
                print('  %s. %s' % (number+1, var.get()))
            print('')

# check Y values that are checked in Table Values window            
        self.varEntryQuikSelectNumberOfYValuesSelected.set(
            self.varEntryNumberOfYValuesSelected.get()
            )
        for i in range(len(self.varYSelect)):
            self.varCheckbuttonsQuikSelectY[i].set(
                self.varYSelect[i].get()
                )
            
# set X value to that selected in table
        index_XSelect = self.varXSelect.get()
        if index_XSelect> 0:
            self.varRadiobuttonsQuikSelectX.set(index_XSelect)
            
# set X entry field
        self.varEntryQuikSelectXValueSelected.set(
            self.varEntryXValueSelected.get()
            )

# ... function buttons        
        buttonDeSelectX = Button(
            frame_50_FunctionButtons,
            text=BUTTONLABEL_DESELECTX,
            borderwidth=5,
            background='white',
            foreground='blue',
            width=25,
            relief=RAISED,
            justify=CENTER,
           command=self.handlerQuikSelectClearX,
            )
        buttonDeSelectX.grid(
            row=0,
            column=0,
            padx=5,
            pady=0,
            sticky=W,
            )
            
        buttonDeSelectAllY = Button(
            frame_50_FunctionButtons,
            text=BUTTONLABEL_DESELECTALLY,
            borderwidth=5,
            background='white',
            foreground='blue',
            width=25,
            relief=RAISED,
            justify=CENTER,
            command=self.handlerQuikSelectClearAllY,
            )
        buttonDeSelectAllY.grid(
            row=0,
            column=1,
            padx=5,
            pady=0,
            sticky=W,
            )
            
        self.varQuikSelectYNumericalOrAll = IntVar()
        self.varstringQuikSelectYNumericalOrAll = StringVar()
        self.checkbuttonQuikSelectYNumericalOrAll = Checkbutton(
            frame_50_FunctionButtons,
            indicator=0,
            textvariable=self.varstringQuikSelectYNumericalOrAll,
            variable=self.varQuikSelectYNumericalOrAll,
            borderwidth=5,
            background='white',
            foreground='blue',
            selectcolor='white',
            width=25,
            relief=RAISED,
            justify=CENTER,
            command=self.handlerQuikSelectYNumericalOrAll,
            )
        self.checkbuttonQuikSelectYNumericalOrAll.grid(
            row=0,
            column=3,
            padx=5,
            pady=0,
            sticky=W,
            )
        self.varstringQuikSelectYNumericalOrAll.set(
            self.buttontextQuikSelectYNumerical
            )

# ... cancel button
        buttonCancel = Button(
            frame_60_CancelButton,
            text='Cancel',
            borderwidth=5,
            width=15,
            relief=RAISED,
            justify=CENTER,
            command=self.handlerQuikSelectCancelWindow,
            )
        buttonCancel.grid(
            row=0,
            column=0,
            padx=2,
            pady=5,
            )
      
# -------- end of Widgets ---------

# Check if any selections are checked in main window; check them
# ... here as well; also make sure any checks in the main window
# ... are checked simultaneously here if this toplevel is open

        return
        
        
    def handlerRadiobuttonQuikSelectX(self):
        '''
        Purpose:
            Value in Quik Select window is also selected in Table Values window
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerRadioButtonQuikSelect')
            
# check if a table has even been read in 
        emptyTableCheck = self.checkIfEmptyTable()
        if emptyTableCheck:
            return

# get index from Quik Select value            
        index = self.varRadiobuttonsQuikSelectX.get()
# set Table Window value
        self.varXSelect.set(index)
        
# get Header
        foundIt = False
        for key,value in self.dictColumnHeaders.iteritems():
            if value == index:
                xHeader = key
                break
        
# set Quik Select entry field to X value
        self.varEntryQuikSelectXValueSelected.set(
            '%s. %s' % (index, xHeader)
                )
# set Table Value entry field to X value
        self.varEntryXValueSelected.set(
            '%s. %s' % (index, xHeader)
                )
                
        return
        
        
    def handlerCheckbuttonQuikSelectY(self):   
        '''
        Purpose:
            Values selected in Quik Select window are also selected in Table Values window
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerCheckbuttonQuikSelectY')
            
# check if a table has even been read in 
        emptyTableCheck = self.checkIfEmptyTable()
        if emptyTableCheck:
            return
            
# set value in Table Values window
        icount = 0
        for i in range(len(self.varYSelect)):
            self.varYSelect[i].set(
                self.varCheckbuttonsQuikSelectY[i].get()
                )
            if self.varYSelect[i].get():
                icount += 1
# set Quik Select display
        self.varEntryQuikSelectNumberOfYValuesSelected.set(icount)
# set Table Values display
        self.varEntryNumberOfYValuesSelected.set(icount)
                                
        return
        
        
    def handlerQuikSelectClearSelectY(self):
        '''
        Purpose:
            Clear or select all checkbuttons for Quik Select
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerQuikSelectClearSelectY')
 
        length = len(self.varCheckbuttonsQuikSelectY)
# list comprehension
        if self.varQuikSelectClearSelectY.get():
            [self.varCheckbuttonsQuikSelectY[i].set(1) for i in range(length)]
        else:
            [self.varCheckbuttonsQuikSelectY[i].set(0) for i in range(length)]
            
        return
        
        
    def handlerQuikSelectYNumericalOrAll(self):
        '''
        Purpose:
            selects all Y-Select values (for writing out to a file, for example), 
            or just the numerical Y values (for plots) in the Quik Select window;
            syncs selections with Table Values window
            
        Called by:
            handlerQuikSelectXY
        
        Calls:
        
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerQuikSelectNumericalOrAll')
            
# check if a table has even been read in 
        emptyTableCheck = self.checkIfEmptyTable()
        if emptyTableCheck:
            return

# clear all Y-Select boxes in Table Values window
        self.handlerClearAllY()
        
# clear all Y-Select boxes in Quik Select window
        try:
            [self.varCheckbuttonsQuikSelectY[i].set(0) for i in range(len(self.tableStructure))]
        except:
            pass
            
# select just numerical fields only
        if self.varQuikSelectYNumericalOrAll.get():     # possible values are 0 or 1
# check all Y-Select boxes, except the one below which X-Select is possibly picked
            varDatatype = ''
            for (key,value) in self.dictColumnHeaders.iteritems():
# check if field is numerical or text; if text, ignore
                for struct in self.tableStructure:
                    if struct[0] == key:
                        varDatatype = struct[1]
                        break
                if varDatatype == '':
                    print '\nError: varDatatype not found in search thru self.tableStructure'
                    self.MySQL_Output(
                        1,
                        'Error: varDatatype not found in search thru self.tableStructure'
                        )
                    showerror(
                        'Error: varDatatype not found',
                        '\nvarDatatype not found in search thru self.tableStructure.' + '\n' +
                        '  This should not have happened, so cause is unknown.' + '\n\n' + 
                        '  Look in ' + MODULE + '/' + 'handerlSelectAllNumericalY\n' +
                        '  for cause.'
                        )
                    return
                    
# set Y-Select only if it is numerical and not equal to x-select if x-select has been selected;
#  also, field must not be the auto_increment field
                varfirst2 = varDatatype[0:2]
                fieldIsNumerical = self.checkIsFieldNumerical(varfirst2)
                if fieldIsNumerical:
                    headerCount=0
                    for header in self.varYSelect:
                        headerCount += 1
                        if value == headerCount and \
                        self.varXSelect.get() <> headerCount and \
                        struct[5] <> 'auto_increment':
                            header.set(1)
            
# set button text in Table Values window
            self.varstringSelectYNumericalOrAll.set(self.buttontextYAll)

# select button in Table Values window
            self.checkbuttonYSelectNumericalOrAll.select()
            
# set button text in Quik Select window
            self.varstringQuikSelectYNumericalOrAll.set(self.buttontextQuikSelectYAll)
            
# set button to opposite
#            self.checkbuttonQuikSelectYNumericalOrAll.select()     
                        
        else:
        
# select all y's, including x if selected and auto-increment
            [self.varYSelect[i].set(1) for i in range(len(self.varYSelect))]
            
# set button text in Table Values window
            self.varstringSelectYNumericalOrAll.set(self.buttontextYNumerical)
            
# set button text in Quik Select window
            self.varstringQuikSelectYNumericalOrAll.set(self.buttontextQuikSelectYNumerical)

# de-select button in Table Values window
            self.checkbuttonYSelectNumericalOrAll.deselect()
          
# set all Y checkboxes in Quik Select window
            [self.varCheckbuttonsQuikSelectY[i].set(1) for i in range(len(self.varCheckbuttonsQuikSelectY))]
           
# ---------
        
# set number of y selections 
# ... in Table Values window; includes Quik Select window
        self.handlerDisplayNumberOfYValuesSelected()
        
        return
        
        
    def handlerQuikSelectClearX(self):
        '''
        Purpose:
            Clear the X-selected radiobutton for Quik Select and Table Values window
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerQuikSelectClearX')

# check if a table has even been read in 
        emptyTableCheck = self.checkIfEmptyTable()
        if emptyTableCheck:
            return
            
# de-select in Quik Select window            
        self.varRadiobuttonsQuikSelectX.set(0)
# de-select in Table Value window     
        self.varXSelect.set(0)
        
# clear entry fields
# ... in Quik Select window
        self.varEntryQuikSelectXValueSelected.set('')  
# ... in Table Values window
        self.varEntryXValueSelected.set('')
        
        return
        
        
    def handlerQuikSelectClearAllY(self):
        '''
        Purpose
            Clear the Y-selected checkboxes for Quik Select and Table Values window
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerQuikSelectClearAllY')
            
# check if a table has even been read in 
        emptyTableCheck = self.checkIfEmptyTable()
        if emptyTableCheck:
            return

# de-select in Quik Select window            
        length = len(self.varCheckbuttonsQuikSelectY)
        [self.varCheckbuttonsQuikSelectY[i].set(0) for i in range(length)]
# de-select in Table Value window
        length = len(self.varYSelect)
        [self.varYSelect[i].set(0) for i in range(length)]
        
# clear entry fields
# ... in Quik Select window
        self.varEntryQuikSelectNumberOfYValuesSelected.set(0)
# ... in Table Values window
        self.varEntryNumberOfYValuesSelected.set(0)
        
        return
        

    def handlerQuikSelectCancelWindow(self):
        '''
        Purpose:
            close the Quik-Select window
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerCancelQuikSelectXY')
            
        try:
            self.toplevelQuikSelectXY.destroy()
        except:
            pass
        
        return
        
        
    def gridTableWindows(self):
        '''
        Purpose:
            grid or re-grid main table windows in frames 11, 21, 22, which show
            table headers, table rows, and table values, respectively
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'gridTableWindows')
            
        # re-Frame
# ... header frame for column headers                               
        self.frame_11_table_columns = Frame(
        self.toplevelTableValues,
            bg='tan',
            borderwidth=2,
            relief=RIDGE,
            )
        self.frame_11_table_columns.grid(
            row=1,
            column=2,
            padx=2,
            pady=2,
            sticky=N+E+W
            )
        self.canvas_11 = Canvas(
            self.frame_11_table_columns,
            bg='tan',
            highlightbackground='tan',
            confine=0,
            width=widthTableHeader,
            height=heightTableHeader,
            )
        self.canvas_11.grid(
            row=1,
            column=1,
            padx=2,
            pady=2,
            sticky=N,
            )
        self.frame_11_canvas = Frame(
            self.canvas_11,
            bg='tan',
            padx=1,
            )
        self.frame_11_canvas = Frame(
            self.canvas_11,
            bg='tan',
            padx=1,
            )
            
# ... frame for check buttons to select table rows      
        self.frame_21_TableRows = Frame(
            self.toplevelTableValues,
            bg='tan',
            borderwidth=2,
            relief=RIDGE,
            )
        self.frame_21_TableRows.grid(
            row=2,
            column=1,
            padx=2,
            pady=2,
            sticky=N,
            )
        self.canvas_21 = Canvas(
            self.frame_21_TableRows,
            bg='tan',
            highlightbackground='tan',
            width=widthTableRows,
            height=heightTableRows,
            )
        self.canvas_21.grid(
            row=0,
            column=0,
            padx=2,
            pady=2,
            sticky=N,
            )              
        self.frame_21_canvas = Frame(
            self.canvas_21,
            bg='tan',
            padx=5,
            ) 
            
# ... table values                            
        self.frame_22 = Frame(
            self.toplevelTableValues,
            bg='tan',
            borderwidth=2,
            relief=RIDGE,
            )
        self.frame_22.grid(
            row=2,
            column=2,
            padx=0,
            pady=2,
            sticky=N+E+W
            )                                  
        yScroll_frame_22 = Scrollbar(
            self.toplevelTableValues,
            orient=VERTICAL,
            )
        yScroll_frame_22.grid(
            row=2,
            column=3,
            padx=3,
            sticky=N+S+W,
            )
        xScroll_frame_22 = Scrollbar(
            self.toplevelTableValues,
            orient=HORIZONTAL,
            )
        xScroll_frame_22.grid(
            row=3,
            column=2,
            sticky=N+E+W,
            )
        self.canvas_22 = Canvas(
            self.frame_22,
            bg='tan',
            confine=0,
            width=widthTable,
            height=heightTable,
            highlightbackground='tan',
            xscrollcommand=xScroll_frame_22.set,
            yscrollcommand=yScroll_frame_22.set,
            )
        self.canvas_22.grid(
            row=0,
            column=0,
            padx=2,
            pady=2,
            sticky=N,
            )            
        self.frame_22_canvas = Frame(
            self.canvas_22,
            bg='tan',
            padx=1,
            )
        xScroll_frame_22.config(
            command=self.handlerXScrollTwoFrames
            ) 
        yScroll_frame_22.config(
            command=self.handlerYScrollTwoFrames
            )
        
        return
        
        
    def displayMainButtonGroup(self, flag):
        '''
        Purpose:
            display HOME button group
         
        if flag == 0:  initial call; set up all widgets
        if flag == 1:  no need to setup header widget and radiobutton, 
                            but setup rest of widgets
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'displayMainButtonGroup')
        
# clear frame of other widgets
        self.clear_grid(self.frame_20_20_MainButtons)
        
# set params
        widthTableValueButtons = 22
        borderWidth = 5
        backGroundColor = 'white'
        foreGroundColor = 'blue'
        fontStyle = self.buttonFont
        padX = 2
        padY = 2
        
# display button to change button groups
        if flag == 0:
            self.varButtonChangeButtonGroups = StringVar()
            self.buttonChangeButtonGroups = Button(
                self.frame_20_00_MainButtons,
                textvariable=self.varButtonChangeButtonGroups,
                relief=RAISED,
                borderwidth=3,
                bg='tan',
                fg='black',
                width=20,
                font=self.titleFontBigBold,
                command=self.handlerChangeButtonGroups,
                )
            self.buttonChangeButtonGroups.grid(
                row=0,
                column=0,
                columnspan=99,
                padx=2,
                pady=2,
                )           
        self.varButtonChangeButtonGroups.set(
            'MAIN'
            )

# limit Right and Left buttons to toplevel
        self.toplevelTableValues.bind(
            "<KeyPress-Right>",
            self.handlerChangeButtonGroupsToRight
            )
        self.toplevelTableValues.bind(
             "<KeyPress-Left>",
            self.handlerChangeButtonGroupsToLeft
            )

        if flag == 0:
        
# set page indicator button widgets

            columnCount = 0
            
# ... radiobutton for MAIN
            self.radiobuttonPageIndicator_Main = Radiobutton(
                self.frame_20_10_MainButtons,
                indicatoron=1,
                selectcolor='green',
                bg='tan',
                fg='green',
                disabledforeground='tan',
                anchor=N,
                )
            self.radiobuttonPageIndicator_Main.grid(
                row=0,
                column=columnCount,
                )
                
# ... radiobutton for PLOTS
            columnCount += 1
            self.radiobuttonPageIndicator_Plots = Radiobutton(
                self.frame_20_10_MainButtons,
                indicatoron=1,
                selectcolor='green',
                bg='tan',
                fg='green',
                disabledforeground='tan',
                anchor=N,
                )
            self.radiobuttonPageIndicator_Plots.grid(
                row=0,
                column=columnCount,
                )
                
# ... radiobutton for IMPORT/EXPORT/EDIT
            columnCount += 1
            self.radiobuttonPageIndicator_ImportExportEdit = Radiobutton(
                self.frame_20_10_MainButtons,
                indicatoron=1,
                selectcolor='green',
                bg='tan',
                fg='green',
                disabledforeground='tan',
                anchor=N,
                )
            self.radiobuttonPageIndicator_ImportExportEdit.grid(
                row=0,
                column=columnCount,
                )
 
# disable all but the 'MAIN' page indicator
        self.radiobuttonPageIndicator_Main.configure(state='normal')
        self.radiobuttonPageIndicator_Plots.configure(state='disabled')
        self.radiobuttonPageIndicator_ImportExportEdit.configure(state='disabled')

# start rowcount at 0
        myRowCount=0
# peek at table - necessary when accessing large tables
        self.buttonPeekAtTableValues = Button(
            self.frame_20_20_MainButtons,
            text=BUTTONLABEL_PEEK,
            width=widthTableValueButtons,
            borderwidth=borderWidth,
            relief=RAISED,
            justify=CENTER,
            font=fontStyle,
            background=backGroundColor,
            foreground=foreGroundColor,
            command=self.handlerDisplayLimitedRows,
            )
        self.buttonPeekAtTableValues.grid(
            row=myRowCount,
            column=0,
            padx=padX,
            pady=padY,
            sticky=N,
            )
# inline function
        def handlerButtonPeekAtTableValues(
            event,
            self=self
            ):
            return self.displayMessage(event,MSG_PEEK)
        self.buttonPeekAtTableValues.bind(
            "<Enter>",
            handlerButtonPeekAtTableValues
            )
            
        myRowCount+=1
# ... show all fields
        self.buttonTableValuesShowAll = Button(
            self.frame_20_20_MainButtons,
            text=BUTTONLABEL_LOAD,
            width=widthTableValueButtons,
            borderwidth=borderWidth,
            relief=RAISED,
            justify=CENTER,
            font=fontStyle,
            background=backGroundColor,
            foreground=foreGroundColor,
            command=self.handlerDisplayAllFields,
            )
        self.buttonTableValuesShowAll.grid(
            row=myRowCount,
            column=0,
            padx=padX,
            pady=padY,
            sticky=N,
            )
        def handlerButtonTableValuesShowAll(
            event,
            self=self
            ):
            return self.displayMessage(event,MSG_LOAD)
        self.buttonTableValuesShowAll.bind(
            "<Enter>",
            handlerButtonTableValuesShowAll
            )
            
# ... show numerical fields only                          
        myRowCount+=1
        buttonTableValuesNumericalOnly = Button(
            self.frame_20_20_MainButtons,
            text=BUTTONLABEL_SHOWNUMERICALFIELDS,
            width=widthTableValueButtons,
            borderwidth=borderWidth,
            relief=RAISED,
            justify=CENTER,
            font=fontStyle,
            background=backGroundColor,
            foreground=foreGroundColor,
            command=self.handlerTableValuesNumericalOnly,
            )
        buttonTableValuesNumericalOnly.grid(
            row=myRowCount,
            column=0,
            padx=padX,
            pady=padY,
            sticky=N,
            )
        def handlerButtonTableValuesNumericalOnly(
            event,
            self=self
            ):
            return self.displayMessage(event,MSG_SHOWNUMERICALFIELDS)
        buttonTableValuesNumericalOnly.bind(
            "<Enter>",
            handlerButtonTableValuesNumericalOnly
            )

# ... show text fields only                        
        myRowCount+=1
        buttonTableValuesTextOnly = Button(
            self.frame_20_20_MainButtons,
            text=BUTTONLABEL_SHOWTEXTFIELDS,
            width=widthTableValueButtons,
            borderwidth=borderWidth,
            relief=RAISED,
            justify=CENTER,
            font=fontStyle,
            background=backGroundColor,
            foreground=foreGroundColor,
            command=self.handlerTableValuesTextOnly,
            )
        buttonTableValuesTextOnly.grid(
            row=myRowCount,
            column=0,
            padx=padX,
            pady=padY,
            sticky=N,
            ) 
        def handlerButtonTableValuesTextOnly(
            event,
            self=self
            ):
            return self.displayMessage(event,MSG_SHOWTEXTFIELDS)
        buttonTableValuesTextOnly.bind(
            "<Enter>",
            handlerButtonTableValuesTextOnly
            )

# ... show selected rows
        myRowCount+=1
#   ... this button is disabled when displaying Beginning, Middle, End, or Range of table
        self.buttonTableValuesSelectedRows = Button(
            self.frame_20_20_MainButtons,
            text=BUTTONLABEL_SHOWSELECTEDROWS,
            width=widthTableValueButtons,
            disabledforeground='darkgray',
            borderwidth=borderWidth,
            relief=RAISED,
            justify=CENTER,
            font=fontStyle,
            background=backGroundColor,
            foreground=foreGroundColor,
            command=self.handlerTableValuesSelectedRows,
            )
        self.buttonTableValuesSelectedRows.grid(
            row=myRowCount,
            column=0,
            padx=padX,
            pady=padY,
            sticky=N,
            )
        def handlerButtonTableValuesSelectedRows(
            event,
            self=self
            ):
            return self.displayMessage(event,MSG_SHOWSELECTEDROWS)
        self.buttonTableValuesSelectedRows.bind(
            "<Enter>",
            handlerButtonTableValuesSelectedRows
            )

# ... summarize x-select field and show statistics
        myRowCount+=1
        self.buttonTableValuesSummarizeField = Button(
            self.frame_20_20_MainButtons,
            text=BUTTONLABEL_STATS,
            width=widthTableValueButtons,
            borderwidth=borderWidth,
            relief=RAISED,
            justify=CENTER,
            font=fontStyle,
            background=backGroundColor,
            foreground=foreGroundColor,
            command=self.handlerSummarizeField,
            )
        self.buttonTableValuesSummarizeField.grid(
            row=myRowCount,
            column=0,
            padx=padX,
            pady=padY,
            sticky=N,
            )
        def handlerButtonTableValuesSummarizeField(
            event,
            self=self
            ):
            return self.displayMessage(event,MSG_STATS)
        self.buttonTableValuesSummarizeField.bind(
            "<Enter>",
            handlerButtonTableValuesSummarizeField
            )

# select & display ordered fields
        myRowCount+=1
        buttonTableValuesSelectDisplay = Button(
            self.frame_20_20_MainButtons,
            text=BUTTONLABEL_FILTER,
            width=widthTableValueButtons,
            borderwidth=borderWidth,
            relief=RAISED,
            justify=CENTER,
            font=fontStyle,
            background=backGroundColor,
            foreground=foreGroundColor,
            command=self.handlerSelectDisplayOrderedFields,
            )
        buttonTableValuesSelectDisplay.grid(
            row=myRowCount,
            column=0,
            padx=padX,
            pady=padY,
            sticky=N,
            ) 
        def handlerButtonTableValuesSelectDisplay(
            event,
            self=self
            ):
            return self.displayMessage(event,MSG_FILTER)
        buttonTableValuesSelectDisplay.bind(
            "<Enter>",
            handlerButtonTableValuesSelectDisplay
            )
            
        return        
        
    
    def displayPlotsButtonGroup(self):
        '''
        Purpose:
            display PLOTS button group
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'displayPlotsButtonGroup')
        
# clear frame of other widgets
        self.clear_grid(self.frame_20_20_MainButtons)
        
# set params
        widthTableValueButtons = 22
        borderWidth = 5
        backGroundColor = 'white'
        foreGroundColor = 'blue'
        fontStyle = self.buttonFont
        padX = 2
        padY = 2
            
# display button to change button groups
        self.varButtonChangeButtonGroups = StringVar()
        self.buttonChangeButtonGroups = Button(
            self.frame_20_00_MainButtons,
            textvariable=self.varButtonChangeButtonGroups,
            relief=RAISED,
            borderwidth=3,
            bg='tan',
            fg='black',
            width=20,
            font=self.titleFontBigBold,
            command=self.handlerChangeButtonGroups,
            )
        self.buttonChangeButtonGroups.grid(
            row=0,
            column=0,
            columnspan=99,
            padx=2,
            pady=2,
            )
        self.varButtonChangeButtonGroups.set(
            'PLOTS'
            )
            
# limit Right and Left buttons to toplevel
        self.toplevelTableValues.bind(
            "<KeyPress-Right>",
            self.handlerChangeButtonGroupsToRight
            )
        self.toplevelTableValues.bind(
            "<KeyPress-Left>",
            self.handlerChangeButtonGroupsToLeft
            )
            
# set page indicator buttons
# ... MAIN
        columnCount = 0
        self.radiobuttonPageIndicator_Main = Radiobutton(
            self.frame_20_10_MainButtons,
            indicatoron=1,
            selectcolor='green',
            bg='tan',
            fg='green',
            disabledforeground='tan',
            )
        self.radiobuttonPageIndicator_Main.grid(
            row=0,
            column=columnCount,
            )
# ... PLOTS
        columnCount += 1
        self.radiobuttonPageIndicator_Plots = Radiobutton(
            self.frame_20_10_MainButtons,
            indicatoron=1,
            selectcolor='green',
            bg='tan',
            fg='green',
            disabledforeground='tan',
            )
        self.radiobuttonPageIndicator_Plots.grid(
            row=0,
            column=columnCount,
            )
# ... IMPORT/EXPORT/EDIT
        columnCount += 1
        self.radiobuttonPageIndicator_ImportExportEdit = Radiobutton(
            self.frame_20_10_MainButtons,
            indicatoron=1,
            selectcolor='green',
            bg='tan',
            fg='green',
            disabledforeground='tan',
            )
        self.radiobuttonPageIndicator_ImportExportEdit.grid(
            row=0,
            column=columnCount,
            )
 
# disable all but the 'PLOTS' page indicator
        self.radiobuttonPageIndicator_Main.configure(state='disabled')
        self.radiobuttonPageIndicator_Plots.configure(state='normal')
        self.radiobuttonPageIndicator_ImportExportEdit.configure(state='disabled')
        
# start rowcount at 0
        myRowCount=0
# x-y plot using select fields
        self.buttonTableValuesPlotFields = Button(
            self.frame_20_20_MainButtons,
            text=BUTTONLABEL_XYPLOTS,
            width=widthTableValueButtons,
            borderwidth=borderWidth,
            relief=RAISED,
            justify=CENTER,
            font=fontStyle,
            background=backGroundColor,
            foreground=foreGroundColor,
#                            command=self.handlerXYPlotPreprocess,
#                            command=self.handlerUpdateXYPlots_Table,
            command=self.handlerUpdateXYPlots_Table_Initialize,
            )
        self.buttonTableValuesPlotFields.grid(
            row=myRowCount,
            column=0,
            padx=padX,
            pady=padY,
            sticky=N,
            ) 
        def handlerButtonTableValuesPlotFields(
            event,
            self=self
            ):
            return self.displayMessage(event,MSG_XYPLOTS)
        self.buttonTableValuesPlotFields.bind(
            "<Enter>",
            handlerButtonTableValuesPlotFields
            )
            
# ... Kiviat plots using y-select fields and select rows
        myRowCount+=1
        self.buttonTableValuesKiviatPlots = Button(
            self.frame_20_20_MainButtons,
            text=BUTTONLABEL_KIVIATPLOTS,
            width=widthTableValueButtons,
            borderwidth=borderWidth,
            relief=RAISED,
            justify=CENTER,
            font=fontStyle,
            background=backGroundColor,
            foreground=foreGroundColor,
            command=self.handlerUpdateKiviatPlots_Table_Initialize,
            )
        self.buttonTableValuesKiviatPlots.grid(
            row=myRowCount,
            column=0,
            padx=padX,
            pady=padY,
            sticky=N,
            )
        def handlerButtonTableValuesKiviatPlots(
            event,
            self=self
            ):
            return self.displayMessage(event,MSG_KIVIATPLOTS)
        self.buttonTableValuesKiviatPlots.bind(
            "<Enter>",
            handlerButtonTableValuesKiviatPlots
            )

# ... build scatter plots
        myRowCount+=1
        self.buttonBuildAnalyzeScatterPlots = Button(
            self.frame_20_20_MainButtons,
            text=BUTTONLABEL_SCATTERPLOTS,
            width=widthTableValueButtons,
            borderwidth=borderWidth,
            relief=RAISED,
            justify=CENTER,
            font=fontStyle,
            background=backGroundColor,
            foreground=foreGroundColor,
            command=self.handlerUpdateScatterPlots_Table_Initialize,
            )
        self.buttonBuildAnalyzeScatterPlots.grid(
            row=myRowCount,
            column=0,
            padx=padX,
            pady=padY,
            sticky=N,
            ) 
        def handlerButtonBuildAnalyzeScatterPlots(
            event,
            self=self
            ):
            return self.displayMessage(event,MSG_SCATTERPLOTS)
        self.buttonBuildAnalyzeScatterPlots.bind(
            "<Enter>",
            handlerButtonBuildAnalyzeScatterPlots
            )
   
        return
        
    
    def displayImportExportEditButtonGroup(self):
        '''
        Purpose:
            display IMPORT EXPORT EDIT button group
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'displayImportExportEditButtonGroup')
        
# clear frame of other widgets
        self.clear_grid(self.frame_20_20_MainButtons)
        
# set params
        widthTableValueButtons = 22
        borderWidth = 5
        backGroundColor = 'white'
        foreGroundColor = 'blue'
        fontStyle = self.buttonFont
        padX = 2
        padY = 2
            
# display button to change button groups

        self.varButtonChangeButtonGroups = StringVar()
        self.buttonChangeButtonGroups = Button(
            self.frame_20_00_MainButtons,
#            text='IMPORT/EXPORT/EDIT',
            textvariable=self.varButtonChangeButtonGroups,
            relief=RAISED,
            borderwidth=3,
            bg='tan',
            fg='black',
            width=20,
            font=self.titleFontBigBold,
            command=self.handlerChangeButtonGroups,
            )
        self.buttonChangeButtonGroups.grid(
            row=0,
            column=0,
            columnspan=99,
            padx=2,
            pady=2,
            )
        self.varButtonChangeButtonGroups.set(
            'IMPORT/EXPORT/EDIT'
            )
            
# limit Right and Left buttons to toplevel
        self.toplevelTableValues.bind(
            "<KeyPress-Right>",
            self.handlerChangeButtonGroupsToRight
            )
        self.toplevelTableValues.bind(
            "<KeyPress-Left>",
            self.handlerChangeButtonGroupsToLeft
            )
            
# set page indicator buttons
# ... MAIN
        columnCount = 0
        self.radiobuttonPageIndicator_Main = Radiobutton(
            self.frame_20_10_MainButtons,
            indicatoron=1,
            selectcolor='green',
            bg='tan',
            fg='green',
            disabledforeground='tan',
            )
        self.radiobuttonPageIndicator_Main.grid(
            row=0,
            column=columnCount,
            )
# ... PLOTS
        columnCount += 1
        self.radiobuttonPageIndicator_Plots = Radiobutton(
            self.frame_20_10_MainButtons,
            indicatoron=1,
            selectcolor='green',
            bg='tan',
            fg='green',
            disabledforeground='tan',
            )
        self.radiobuttonPageIndicator_Plots.grid(
            row=0,
            column=columnCount,
            )
# ... IMPORT/EXPORT/EDIT
        columnCount += 1
        self.radiobuttonPageIndicator_ImportExportEdit = Radiobutton(
            self.frame_20_10_MainButtons,
            indicatoron=1,
            selectcolor='green',
            bg='tan',
            fg='green',
            disabledforeground='tan',
            )
        self.radiobuttonPageIndicator_ImportExportEdit.grid(
            row=0,
            column=columnCount,
            )
 
# disable all but the 'MAIN' page indicator
        self.radiobuttonPageIndicator_Main.configure(state='disabled')
        self.radiobuttonPageIndicator_Plots.configure(state='disabled')
        self.radiobuttonPageIndicator_ImportExportEdit.configure(state='normal')
        
# start rowcount at 0
        myRowCount=0
# ... import select test data to table
        buttonTableValuesImportTestData = Button(
            self.frame_20_20_MainButtons,
            text=BUTTONLABEL_IMPORTCOPYLOTDATA,
            width=widthTableValueButtons,
            borderwidth=borderWidth,
            relief=RAISED,
            justify=CENTER,
            background=backGroundColor,
            foreground=foreGroundColor,
            font=fontStyle,
            command=self.handlerImportCoPylotDBMySQLFile,
            )
        buttonTableValuesImportTestData.grid(
            row=myRowCount,
            column=0,
            padx=padX,
            pady=padY,
            sticky=N,
            )
        def handlerButtonTableValuesImportTestData(
            event,
            self=self
            ):
            return self.displayMessage(event,MSG_IMPORTCOPYLOTDATA)
        buttonTableValuesImportTestData.bind(
            "<Enter>",
            handlerButtonTableValuesImportTestData
            )

# ... import CSV data to table
        myRowCount+=1
        buttonTableValuesImport = Button(
            self.frame_20_20_MainButtons,
            text=BUTTONLABEL_IMPORTCSVDATA,
            width=widthTableValueButtons,
            borderwidth=borderWidth,
            relief=RAISED,
            justify=CENTER,
            font=fontStyle,
            background=backGroundColor,
            foreground=foreGroundColor,
            command=self.handlerImportCsvData,
            )
        buttonTableValuesImport.grid(
            row=myRowCount,
            column=0,
            padx=padX,
            pady=padY,
            sticky=N,
            )
        def handlerButtonTableValuesImport(
            event,
            self=self
            ):
            return self.displayMessage(event,MSG_IMPORTCSVDATA)
        buttonTableValuesImport.bind(
            "<Enter>",
            handlerButtonTableValuesImport
            )
 
# ... manually edit multiple select rows
        myRowCount+=1
        buttonTableValuesEditSelectRowsManually = Button(
            self.frame_20_20_MainButtons,
            text=BUTTONLABEL_EDITSELECTROWS,
            width=widthTableValueButtons,
            borderwidth=borderWidth,
            relief=RAISED,
            justify=CENTER,
            background=backGroundColor,
            foreground=foreGroundColor,
            font=fontStyle,
            command=self.handlerEditSelectedRow,
            )
        buttonTableValuesEditSelectRowsManually.grid(
            row=myRowCount,
            column=0,
            padx=padX,
            pady=padY,
            sticky=N,
            ) 
        def handlerButtonTableValuesEditSelectRowsManually(
            event,
            self=self
            ):
            return self.displayMessage(event,MSG_EDITSELECTROWS)
        buttonTableValuesEditSelectRowsManually.bind(
            "<Enter>",
            handlerButtonTableValuesEditSelectRowsManually
            )

# ... manually input row data to table
        myRowCount+=1
        buttonTableValuesInputRowsManually = Button(
            self.frame_20_20_MainButtons,
            text=BUTTONLABEL_INSERTNEWROWS,
            width=widthTableValueButtons,
            borderwidth=borderWidth,
            relief=RAISED,
            justify=CENTER,
            background=backGroundColor,
            foreground=foreGroundColor,
            font=fontStyle,
            command=self.handlerInputNewRowsManually,
            )
        buttonTableValuesInputRowsManually.grid(
            row=myRowCount,
            column=0,
            padx=padX,
            pady=padY,
            sticky=N,
            )
        def handlerButtonTableValuesInputRowsManually(
            event,
            self=self
            ):
            return self.displayMessage(event,MSG_INSERTNEWROWS)
        buttonTableValuesInputRowsManually.bind(
            "<Enter>",
            handlerButtonTableValuesInputRowsManually
            )

# ... write select fields to CSV file
        myRowCount += 1
        buttonTableValuesExportFields = Button(
            self.frame_20_20_MainButtons,
            text=BUTTONLABEL_EXPORTTOCSV,
            width=widthTableValueButtons,
            borderwidth=borderWidth,
            relief=RAISED,
            justify=CENTER,
            background=backGroundColor,
            foreground=foreGroundColor,
            font=fontStyle,
            command=self.handlerExportYSelectFieldsToCsvFile,
            )
        buttonTableValuesExportFields.grid(
            row=myRowCount,
            column=0,
            padx=padX,
            pady=padY,
            sticky=N,
            )
        def handlerButtonTableValuesExportFields(
            event,
            self=self
            ):
            return self.displayMessage(event,MSG_EXPORTTOCSV)
        buttonTableValuesExportFields.bind(
            "<Enter>",
            handlerButtonTableValuesExportFields
            )

# ... extract data from select formats and fill in table fields; 
# ...   auto-create table fields if they do not exist;
# ...   this is the general form of filling in the database;
# ...   can extract using YAML or regular expressions
        myRowCount += 1
        buttonExtractTestData = Button(
            self.frame_20_20_MainButtons,
            text=BUTTONLABEL_EXTRACTDATAANDFILLTABLE,
            width=widthTableValueButtons,
            borderwidth=borderWidth,
            relief=RAISED,
            justify=CENTER,
            background=backGroundColor,
            foreground=foreGroundColor,
            font=fontStyle,
            command=self.handlerExtractAndFill,
            )
        buttonExtractTestData.grid(
            row=myRowCount,
            column=0,
            padx=padX,
            pady=padY,
            sticky=N,
            )
        def handlerButtonExtractTestData(
            event,
            self=self
            ):
            return self.displayMessage(event,MSG_EXTRACTDATAANDFILLTABLE)
        buttonExtractTestData.bind(
            "<Enter>",
            handlerButtonExtractTestData
            )
            
        return
        
        
    def handlerChangeButtonGroupsToRight(self,event):
        '''
        Purpose:
            if Right-Arrow is pressed, change button group to right
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerChangeButtonGroupsToRight')
            
        if self.varButtonChangeButtonGroups.get() == 'MAIN':
# switch to PLOTS
            self.displayPlotsButtonGroup()
  
        elif self.varButtonChangeButtonGroups.get() == 'PLOTS':
# switch to IMPORT/EXPORT/EDIT
            self.displayImportExportEditButtonGroup()

        elif self.varButtonChangeButtonGroups.get() == 'IMPORT/EXPORT/EDIT':
# switch to MAIN
            self.displayMainButtonGroup(1)

        else:
# error in button text
            stringError = (
                'Invalid value in button text above button groups.\n\n' +
                'This should not have happened.\n\n' +
                'Please report this to code administrator.'
                )
            print(stringError)
            self.MySQL_Output(
                0,
                stringError
                )
            showerror(
                'Error: invalid value',
                stringError,
                parent=self.toplevelTableValues
                )
        
        return
        
        
    def handlerChangeButtonGroupsToLeft(self,event):
        '''
        Purpose:
            if Left-Arrow is pressed, change button group to left
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerChangeButtonGroupsToLeft')
        
        if self.varButtonChangeButtonGroups.get() == 'MAIN':
# switch to IMPORT/EXPORT/EDIT
            self.displayImportExportEditButtonGroup()

        elif self.varButtonChangeButtonGroups.get() == 'IMPORT/EXPORT/EDIT':
# switch to PLOTS
            self.displayPlotsButtonGroup()

        elif self.varButtonChangeButtonGroups.get() == 'PLOTS':
# switch to MAIN
            self.displayMainButtonGroup(1)

        else:
# error in button text
            stringError = (
                'Invalid value in button text above button groups.\n\n' +
                'This should not have happened.\n\n' +
                'Please report this to code administrator.'
                )
            print(stringError)
            self.MySQL_Output(
                0,
                stringError
                )
            showerror(
                'Error: invalid value',
                stringError,
                parent=self.toplevelTableValues
                )
            
        return
            
            
    def handlerChangeButtonGroups(self):
        '''
        Purpose:
            cycle thru button groups in table display window
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerChangeButtonGroups')
            
        if self.varButtonChangeButtonGroups.get() == 'MAIN':
# switch to PLOTS
            self.displayPlotsButtonGroup()

        elif self.varButtonChangeButtonGroups.get() == 'PLOTS':
# switch to IMPORT/EXPORT/EDIT
            self.displayImportExportEditButtonGroup()

        elif self.varButtonChangeButtonGroups.get() == 'IMPORT/EXPORT/EDIT':
# switch to MAIN
            self.displayMainButtonGroup(1)

        else:
# error in button text
            stringError = (
                'Invalid value in button text above button groups.\n\n' +
                'This should not have happened.\n\n' +
                'Please report this to code administrator.'
                )
            print(stringError)
            self.MySQL_Output(
                0,
                stringError
                )
            showerror(
                'Error: invalid value',
                stringError,
                parent=self.toplevelTableValues
                )
            
        return
        
     
    def handlerKeepButtonGroup(self):
        '''
        Purpose:
            keep button groups in table display window same as
            before refresh of the table
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerChangeButtonGroups')
            
        try:
            buttonGroup = self.varButtonChangeButtonGroups.get()
        except:
            buttonGroup = 'MAIN'
            
        if buttonGroup == 'MAIN':
# display 'MAIN'
            self.displayMainButtonGroup(0)

        elif buttonGroup == 'PLOTS':
# display 'PLOTS'
            self.displayPlotsButtonGroup()

        elif buttonGroup == 'IMPORT/EXPORT/EDIT':
# display 'IMPORT/EXPORT/EDIT'
            self.displayImportExportEditButtonGroup()

        else:
# error in button text
            stringError = (
                'Invalid value in button text above button groups.\n\n' +
                'This should not have happened.\n\n' +
                'Please report this to code administrator.'
                )
            print(stringError)
            self.MySQL_Output(
                0,
                stringError
                )
            showerror(
                'Error: invalid value',
                stringError,
                parent=self.toplevelTableValues
                )
            
        return
        
        
    def handlerUpdatePlotWindow_Table(self):
        '''
        Purpose:
            for updating plot windows
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerUpdatePlotWindow_Table')

# set last button pressed
        self.lastButtonPressed(
            BUTTONLABEL_UPDATEPLOTWINDOW
            )
                
        value = self.comboListOfPlotWindows_Table.get()
        
        if value == 'X-Y':
            self.handlerUpdateXYPlots_Table()
        elif value == 'Kiviat':
            self.handlerUpdateKiviatPlots_Table()
        elif value == 'Scatter':
            self.handlerUpdateScatterPlots_Table()
        elif value == 'Bar':
            self.handlerUpdateBarCharts_Table()
        else:
            stringNoPlotWindowToUpdate = (
                'An error has occurred in method "handlerUpdatePlotWindow_Table".\n\n' +
                'This should not have occurred.\n\n' +
                'Current value: %s\n\n' +
                'There is no such value to be used in this method. Please\n' +
                'inform code administrator.'
                ) % value
            print(stringNoPlotWindowToUpdate)
            self.MySQL_Output(
                1,
                stringNoPlotWindowToUpdate
                )
            showerror(
                'Error: no such value',
                stringNoPlotWindowToUpdate,
                parent=self.toplevelTableValues
                )
                
        return
        
      
    def handlerUpdatePlotWindow_Buffer(self):
        '''
        Purpose:
            for updating plot windows from storage buffer window
            
        Notes:
            the buffer storage is not used to update kiviat plots
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerUpdatePlotWindow_Buffer')
                
        value = self.comboListOfPlotWindows_Buffer.get()
        
        if value == 'X-Y':
            self.handlerUpdateXYPlots_Buffer()
#        elif value == 'Kiviat Plots':
#            self.handlerUpdateKiviatPlots_Buffer()
        elif value == 'Scatter':
            self.handlerUpdateScatterPlots_Buffer()
        elif value == 'Bar':
            self.handlerUpdateBarCharts_Buffer()
        else:
            stringNoPlotWindowToUpdate = (
                'An error has occurred in method "handlerUpdatePlotWindow_Buffer".\n\n' +
                'This should not have occurred.\n\n' +
                'Current value: %s\n\n' +
                'There is no such value to be used in this method. Please\n' +
                'inform code administrator.'
                ) % value
            print(stringNoPlotWindowToUpdate)
            self.MySQL_Output(
                1,
                stringNoPlotWindowToUpdate
                )
            showerror(
                'Error: no such value',
                stringNoPlotWindowToUpdate,
                parent=self.toplevelShowStorageBuffer
                )
                
        return
        
        
    def handlerImportCoPylotDBMySQLFile(self):
        '''
        Purpose:
            read MySQL file as exported from CoPylotDB; execute
            the MySQL command from the file
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerImportCoPylotDBMySQLFile')
                
# set last button pressed
        self.lastButtonPressed(
            BUTTONLABEL_IMPORTCOPYLOTDATA
            )
                
# define toplevel with following widgets

# ... select filename
# ... select database and table
# ... insert/cancel ('insert' command executes handler below)

# constants
        colorbg = 'lightgreen'

# FRAMES
# destroy any old toplevel frames
        try:
            mapped = self.toplevelImportCoPylotDBMySQLFile.winfo_exists()
        except:
            mapped = False
            
        if mapped:
            stringAskToDestroy = (
                'A window for importing the CoPylotDB file is already displayed.\n\n' +
                'If you wish to close that window (all entries will be lost)\n' +
                'and start a new one, click "OK". To keep the existing\n' +
                'window, click "Cancel".'
                )
            yes = askokcancel(
                    'Window open: Import CoPylotDB',
                    stringAskToDestroy
                    )
            if yes:
                self.toplevelImportCoPylotDBMySQLFile.destroy()
                self.MySQL_Output(
                    1,
                    'Previous toplevel widget removed from screen.'
                    )
            else:
                return
        else: 
            self.MySQL_Output(
                1,
                'No previous toplevel widget to remove from screen.'
                )
                
# get database and table; error check
        stringGetDatabaseAndTable = ''
        try:
            myDatabase = self.varTableFunctionsSelectDatabase.get().strip()
        except:
            stringGetDatabaseAndTable += (
                '\n - Cannot determine database.'
                )        
        try:
            myDatabaseTable = self.varEntryTableFunctionsSelectTable.get().strip()
        except:
            stringGetDatabaseAndTable += (
                '\n - Cannot determine database table.'
                )
        if myDatabase == '' or myDatabaseTable == '':
            if myDatabase == '' and myDatabaseTable == '':
                stringGetDatabaseAndTable += (
                    '\n - Neither the database nor the table have been specified.'
                    )
            elif myDatabase == '':
                stringGetDatabaseAndTable += (
                    '\n - Database has not been specified'
                    )
            elif myDatabseTable == '':
                stringGetDatabaseAndTable += (
                    '\n - Database table has not been specified.'
                    )
            else:
                stringGetDatabaseAndTable += (
                    '\nERROR: PylotDB should have never reached this\n' +
                    '  code logic. This is a programming error.\n\n' +
                    '  Contact code administrator for help.'
                    )
        if stringGetDatabaseAndTable <> '':
            print(stringGetDatabaseAndTable)
            self.MySQL_Output(
                0,
                stringGetDatabaseAndTable
                )
            showerror(
                'Error: missing database and/or table',
                stringGetDatabaseAndTable
                )
            return               
            
# open Toplevel frame for entering database name
        self.toplevelImportCoPylotDBMySQLFile = Toplevel(
#            self.frameParent,
            bg=colorbg
            )
        self.toplevelImportCoPylotDBMySQLFile.title(
#            'Add table & fields...'
            'Server: ' + self.comboServerMySQL.get() + '     ' +
            'Database: ' + myDatabase + '     ' +
            'Table: ' + myDatabaseTable
            )
        self.toplevelImportCoPylotDBMySQLFile.transient(self.toplevelTableValues)
# place the top window
        x_Windows = self.importCoPylotDBMySQLFile_xWindowLocation
        y_Windows = self.importCoPylotDBMySQLFile_yWindowLocation
        
        self.toplevelImportCoPylotDBMySQLFile.geometry(
            '+%d+%d' % (x_Windows, y_Windows)
            )
            
# ==== FRAMES ====
# frame: header
        rowCount = 0
        frame_00 = Frame(
            self.toplevelImportCoPylotDBMySQLFile,
            bg=colorbg,
            )
        frame_00.grid(
            row=rowCount,
            column=0,
            padx=0,
            pady=5,
            sticky=N,
            )
            
# frame: sub-header
        rowCount += 1
        frame_10 = Frame(
            self.toplevelImportCoPylotDBMySQLFile,
            bg=colorbg,
            )
        frame_10.grid(
            row=rowCount,
            column=0,
            padx=0,
            pady=5,
            sticky=N,
            )
            
# frame: browse for file; unpickle file; list how many rows to insert;
#        list database and table
        rowCount += 1
        frame_20 = Frame(
            self.toplevelImportCoPylotDBMySQLFile,
            bg=colorbg,
            )
        frame_20.grid(
            row=rowCount,
            column=0,
            padx=0,
            pady=5,
            sticky=N,
            )
    
# frame: number of rows to insert
        rowCount += 1
        frame_30 = Frame(
            self.toplevelImportCoPylotDBMySQLFile,
            bg=colorbg,
            )
        frame_30.grid(
            row=rowCount,
            column=0,
            padx=0,
            pady=5,
            sticky=N,
            )
            
# frame: insert/cancel buttons
        rowCount += 1
        frame_40 = Frame(
            self.toplevelImportCoPylotDBMySQLFile,
            bg=colorbg,
            )
        frame_40.grid(
            row=rowCount,
            column=0,
            padx=0,
            pady=5,
            sticky=N,
            )
            
# ==== END OF FRAMES ====

# ==== WIDGETS ====

# ... header
        label = Label(
            frame_00,
            text='IMPORT MySQL COMMAND FILE FROM Co-PylotDB',
            font=self.titleFont,
            bg=colorbg,
            )
        label.grid(
            row=0,
            column=0,
            padx=5,
            pady=5,
            )
            
# ... sub-heaer
        label = Label(
            frame_10,
            text = 'Using database: ',
            bg=colorbg,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=2,
            sticky=E,
            )
        self.varDatabaseForMySQLFile = StringVar()
        self.varDatabaseForMySQLFile.set(myDatabase)
        self.entryDatabaseForMySQLFile = Entry(
            frame_10,
            textvariable=self.varDatabaseForMySQLFile,
            width=25,
            relief=FLAT,
            bg='white',
            fg='black',
            disabledbackground='white',
            disabledforeground='black',
            state='disabled',
            )
        self.entryDatabaseForMySQLFile.grid(
            row=0,
            column=1,
            padx=0,
            pady=2,
            sticky=W,
            )
        label = Label(
            frame_10,
            text = 'Inserting into table: ',
            bg=colorbg,
            )
        label.grid(
            row=1,
            column=0,
            padx=0,
            pady=2,
            sticky=E,
            )
        self.varDatabaseTableForMySQLFile = StringVar()
        self.varDatabaseTableForMySQLFile.set(myDatabaseTable)
        self.entryDatabaseTableForMySQLFile = Entry(
            frame_10,
            textvariable=self.varDatabaseTableForMySQLFile,
            width=25,
            relief=FLAT,
            bg='white',
            fg='black',
            disabledbackground='white',
            disabledforeground='black',
            state='disabled',
            )
        self.entryDatabaseTableForMySQLFile.grid(
            row=1,
            column=1,
            padx=0,
            pady=2,
            sticky=W,
            )
            
# ... browse for MySQL command file
        label = Label(
            frame_20,
            text=(
                'MySQL Command file\nfrom Co-PylotDB: '
                ),
            bg=colorbg,
            justify=RIGHT,
            font=self.labelFontMedium,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            sticky=E,
            )
# ... MySQL file entry field
        self.varMySQLCommandFileName = StringVar()
        self.entryMySQLCommandFileName = Entry(
            frame_20,
            textvariable=self.varMySQLCommandFileName,
            bg='white',
            fg='black',
            disabledbackground='white',
            disabledforeground='black',
            width=50,
            relief=FLAT,
            font=self.labelFontMedium,
            state='disabled',
            )
        self.entryMySQLCommandFileName.grid(
            row=0,
            column=1,
            padx=5,
            pady=0,
            sticky=S+W,
            )        
# ... browse button
        buttonBrowseForMySQLCommandFileName = Button(
            frame_20,
            text='Browse',
            width=10,
            borderwidth=3,
            relief=RAISED,
            background='white',
            foreground='blue',
            font=self.labelFontMedium,
            command=self.handlerBrowseMySQLCommandFile,
            )
        buttonBrowseForMySQLCommandFileName.grid(
            row=1,
            column=1,
            padx=0,
            pady=3,
            sticky=N,
            )
            
# ... number of data rows to insert
        label = Label(
            frame_30,
            text=(
                'Number of rows to insert into table: '
                ),
            bg=colorbg,
            justify=RIGHT,
            font=self.labelFontMedium,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=5,
            sticky=E,
            )
        self.varMySQLCommandData_NumberOfRows = IntVar()
        self.varMySQLCommandData_NumberOfRows.set(0)
        entryMySQLCommandData_NumberOfRows = Entry(
            frame_30,
            textvariable=self.varMySQLCommandData_NumberOfRows,
            bg='white',
            fg='black',
            disabledbackground='white',
            disabledforeground='black',
            width = 5,
            relief=FLAT,
            font=self.labelFontMedium,
            state='disabled',
            )
        entryMySQLCommandData_NumberOfRows.grid(
            row=0,
            column=1,
            padx=0,
            pady=5,
            sticky=W,
            )        
          
# ... insert/cancel buttons
        buttonInsertMySQLCommandData = Button(
            frame_40,
            text='Insert',
            borderwidth=5,
            width=15,
            bg='white',
            fg='blue',
            relief=RAISED,
            justify=CENTER,
            command=self.insertCoPylotDBMySQLFileIntoDatabaseTable,
            )
        buttonInsertMySQLCommandData.grid(
            row=0,
            column=0,
            padx=5,
            pady=5,
            )
        buttonCancelMySQLCommand = Button(
            frame_40,
            text='Cancel',
            borderwidth=5,
            width=15,
            relief=RAISED,
            justify=CENTER,
            command=self.handlerDestroyToplevelImportCoPylotDBMySQLFile,
            )
        buttonCancelMySQLCommand.grid(
            row=0,
            column=1,
            padx=5,
            pady=5,
            )                     

        return
        
        
    def handlerDestroyToplevelImportCoPylotDBMySQLFile(self):
        '''
        Purpose:
            save current toplevel window location for next time;
            kill the toplevel window
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerDestroyToplevelImportCoPylotDBMySQLFile')
                
        self.importCoPylotDBMySQLFile_xWindowLocation = (
            self.toplevelImportCoPylotDBMySQLFile.winfo_rootx() - self.offsetWindowX
            )
        
        self.importCoPylotDBMySQLFile_yWindowLocation = (
            self.toplevelImportCoPylotDBMySQLFile.winfo_rooty() - self.offsetWindowY
            )
        self.toplevelImportCoPylotDBMySQLFile.destroy()
        
        return
        
        
    def handlerBrowseMySQLCommandFile(self):
        '''
        Purpose:
            browse for MySQL Command file containing 'INSERT' statement
            and data to be inserted into current database table
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerBrowseMySQLCommandFile')
                
# define dictionary of options for askopenfilename()
        options = {}
        options = {
            'defaultextension' : '.cop',
            'filetypes' : [('Co-PylotDB MySQL Command file','.cop'),('All files','*')],
            'initialdir' : '.',
            'initialfile' : '',
            'parent' : self.toplevelImportCoPylotDBMySQLFile,
            'title' : 'Pick MySQL Command filename'
            }      
# get current filename in entry field
#        currentFileName = self.varEntryPlotFileData_AllCurvesOnePlot.get()
#        print '     Current filename:',currentFileName
        
# clear current selection
        self.varMySQLCommandFileName.set('')
# set number of rows to insert to zero
        self.varMySQLCommandData_NumberOfRows.set(0)
# get filename using askopenfilename
#        dirname, filename = os.path.split(tkFileDialog.askopenfilename(**options))
        self.fullpath_FileNameForMySQLCommandFileName = tkFileDialog.askopenfilename(**options)
        dirname, filename = os.path.split(self.fullpath_FileNameForMySQLCommandFileName)
# dwb - NOTE
#   os.path.split(askopenfilename()) gives forward slashes in the filename
#   os.getcwd() gives backward slashes in the filename
#       Hence, one cannot compare the results of these two methods to ensure 
#         the user stays in the same directory.
#       Too bad :(
#        if filename == '' and currentFileName == '':
        if filename == '':
            print '   No filename selected!'
            showinfo(
                '\nNo filename selected ...',
                'You must enter a filename.\n\n'
                )
            return            
            
        stringFileNameSelected = (
            ' - dirname = %s\n' +
            ' - filename = %s\n' +
            ' - full pathname = %s\n' 
            ) % (
            dirname,
            filename,
            self.fullpath_FileNameForMySQLCommandFileName
            )
        print(stringFileNameSelected)
        self.MySQL_Output(
            0,
            stringFileNameSelected
            )
        self.varMySQLCommandFileName.set(filename)
        
# error check extension
        extensionFileName = os.path.splitext(filename)[1]
        if extensionFileName <> '.cop':
            stringCheckExtension = (
                'The expected filename extension should be\n\n' +
                ' - .cop\n\n' +
                'Instead, you just selected a file with extension\n\n' +
                ' - %s\n\n' +
                'Are you sure you want to continue with the current file?'
                ) % (
                extensionFileName
                )
            print(stringCheckExtension)
            self.MySQL_Output(
                0,
                stringCheckExtension
                )
            ans = askyesno(
                'Continue?',
                stringCheckExtension
                )
            print('answer = %s' % ans)
            self.MySQL_Output(
                0,
                'Answer = %s\n'
                ) % (
                ans
                )
            if ans == 'no':
# clear current entry
                self.varMySQLCommandFileName.set('')
                return
        
# open unpickle file
        try:
            file2UnPickle = open(self.fullpath_FileNameForMySQLCommandFileName,'rU')
        except:
            stringCannotOpenFile = (
                'Cannot open file %s.\n\n' +
                'Check file permissions, or select another\n' +
                'filename and try again.'
                ) % self.fullpath_FileNameForMySQLCommandFileName
            print stringCannotOpenFile
            self.MySQL_Output(
                0,
                stringCannotOpenFile
                )
            showerror(
                'Error: cannot open file',
                stringCannotOpenFile
                )
            return
            
# instantiate pickler object
        try:
            self.listMySQLCommandForInsert = pickle.Unpickler(file2UnPickle).load()
        except:
            stringNoUnPickle = (
                'Cannot unpickle().load() the file\n\n' +
                '%s\n\n' +
                'The file must not be a properly pickled file.\n\n' +
                'Select another file and try again.'
                ) % self.fullpath_FileNameForMySQLCommandFileName
            print stringNoUnPickle
            self.MySQL_Output(
                0,
                stringNoUnPickle
                )
            showerror(
                'Error: cannot unpickle file',
                stringNoUnPickle
                )
            return
        if self.listMySQLCommandForInsert == '':
            stringNoContent = (
                'No content was found in the unpickled file\n\n' +
                '%s\n\n' +
                'Process halted.'
                )
            print(stringNoContent)
            self.MySQL_Output(
                0,
                stringNoContent
                )
            showerror(
                'Error: no content',
                stringNoContent
                )
            return             
            
# determine number of insert commands
        countInsertCommands = 0
        for stringNumber in range(len(self.listMySQLCommandForInsert)):
            countInsertCommands += \
                self.listMySQLCommandForInsert[stringNumber][0].count('INSERT')

# insert value into window
        self.varMySQLCommandData_NumberOfRows.set(countInsertCommands)          
            
# close file
        file2UnPickle.close()
            
        return
               
                

    def insertCoPylotDBMySQLFileIntoDatabaseTable(self):
        '''
        Purpose:
            run checks on MySQL file
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'insertCoPylotDBMySQLFileIntoDatabaseTable')

# number of rows of data to insert into database table                
        numRows = self.varMySQLCommandData_NumberOfRows.get()
        
# error check
        if numRows == '' or numRows == 0:
            stringNoRowsToInsert = (
                'No rows to insert into table.\n\n' +
                'Choose another file and try again.'
                )
            print('\n' + stringNoRowsToInsert)
            self.MySQL_Output(
                0,
                stringNoRowsToInsert
                )
            try:
                showerror(
                    'Error: no data',
                    stringNoRowsToInsert,
                    parent=self.toplevelImportCoPylotDBMySQLFile
                    )
            except:
                showerror(
                    'Error: no data',
                    stringNoRowsToInsert
                    )
            return
            
# save checked fields
        self.saveCheckedFieldNames()  
            
# cycle through commands to insert data into database table
        myDatabase = self.varDatabaseForMySQLFile.get()
        myDatabaseTable = self.varDatabaseTableForMySQLFile.get()
        
# make sure still connected to a database
        self.checkMySQLConnection()
        if not self.connectionFlag:
            return

# iterate over number of insert statements in MySQL command file from Co-PylotDB
        for row in range(numRows):
            commandString = self.listMySQLCommandForInsert[row][0].replace(
                'XXDATABASE.YYTABLE', 
                myDatabase + '.' + myDatabaseTable
                )
            if DEBUG_PRINT_MISC:
                print('\n>>> for row %s' % str(row+1))
                print('myDatabase, myDatabaseTable = %s, %s' % (myDatabase, myDatabaseTable))
                print('XXDATABASE.YYTABLE occurs %s times' % commandString.count('XXDATABSE.YYTABLE'))
            if commandString.count('XXDATABASE.YYTABLE') > 0:
                stringNoReplace = (
                    'Not able to replace "XXDATABASE.YYTABLE" in Co-PylotDB file.\n\n' +
                    'Check table format.'
                    )
                print('\n' + stringNoReplace)
                self.MySQL_Output(
                    0,
                    stringNoReplace
                    )
                showerror(
                    'Error: cannot replace',
                    stringNoReplace
                    )
                return
            if DEBUG_PRINT_MYSQLCOMMANDFORINSERT:
                stringPrint = (
                '\nFor row %s of %s rows, command string is\n %s'
                ) % (
                row + 1,
                numRows,
                commandString
                )
                print(stringPrint)
# insert into database table
            try:
                self.cursorHandleMySQL.execute(
                    commandString
                    )
            except:
                stringInsertionNotValid = (
                    'Cannot insert data from \n\n' +
                    ' file: %s\n\n' +
                    ' row: %s of %s rows\n\n' +
                    'Check file for proper data and format.\n\n' +
                    'Make sure fields in file strings match fields\n' +
                    'in database.'
                    ) % (
                    self.fullpath_FileNameForMySQLCommandFileName,
                    row + 1,
                    numRows
                    )
                print('\n' + stringInsertionNotValid)
                self.MySQL_Output(
                    0,
                    stringInsertionNotValid
                    )
                try:
                    showerror(
                        'Error: invalid data',
                        stringInsertionNotValid,
                        parent=self.toplevelImportCoPylotDBMySQLFile
                        )
                except:
                    showerror(
                        'Error: invalid data',
                        stringInsertionNotValid
                        )
                return
                
# success
        stringSuccess = (
            ' SUCCESS:\n' +
            '%s new rows have been inserted into\n\n' +
            ' - database: %s\n' +
            ' - table: %s\n\n' +
            'REMINDER!\n\n' +
            'The database has been updated, but the displayed table needs\n' +
            'to be refreshed to reflect any changes you have made.\n\n' +
            'Click OK to refresh table, Cancel to not refresh table.'
            ) % (
            numRows,
            myDatabase,
            myDatabaseTable
            ) 
        print('\n' + stringSuccess)
        self.MySQL_Output(
            0,
            stringSuccess
            )
        try:
            ans = askokcancel(
                'Info: success',
                stringSuccess,
                parent=self.toplevelImportCoPylotDBMySQLFile
                )
        except:
            ans = askokcancel(
                'Info: success',
                stringSuccess
                )
                
        if ans:
# update table values for INSERT CO-PYLOT MYSQL FILE    
            try:
                mapped = self.toplevelTableValues.winfo_exists()
            except:
                mapped = False
                                
            if mapped:
                self.handlerDisplayLimitedRows()    # PEEK handler
            
# update filter window
                try:
                    mapped = self.toplevelSelectDisplayOrderedFields.winfo_exists()
                except:
                    mapped = False
            
                if mapped:
                    self.handlerSelectDisplayOrderedFields_Update()
            
        else:
            stringManualRefresh = 'The database has been updated.'
            print('\n' + stringManualRefresh)
            self.MySQL_Output(
                0,
                stringManualRefresh
                )
            showinfo(
                'INFO: database updated',
                stringManualRefresh
                )
                
# reset indices for checked fields
        self.resetVarXYSelect()
                
# restore checked fields
        self.restoreCheckedFieldNames()  

        return

        
        
    def resequenceAutoIndexFromMainWindow(self):
        '''
        Purpose:
            resequence auto_index field without having to filter data first
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'resequenceAutoIndexFromMainWindow')
                
# set last button pressed
        self.lastButtonPressed(
            BUTTONLABEL_REORDERAUTOINDEX
            )
                
# check if a table has even been read in 
        emptyTableCheck = self.checkIfEmptyTable()
        if emptyTableCheck:
            return
            
# save checked fields
        self.saveCheckedFieldNames()  
                
        success = self.resequenceAutoIncrementPrimaryKeyField(
            self.toplevelTableValues
            )
            
        if not success:
            return
 
# get all values from database table    
        '''
        stringGetAllFields = (
            'SELECT * FROM ' + self.myDatabase + '.' + self.myTable
            )
        self.cursorHandleMySQL.execute(stringGetAllFields)
        self.tableValues = self.cursorHandleMySQL.fetchall()
        self.tableValuesOriginal = self.tableValues
        '''
        
# replot the same database table as before, but get values from table
#    as auto_index has been changed
#        itemList = self.dictColumnHeaders.keys()
        itemList = []
        for item in self.tableStructure:
            itemList.append(item[0])
#        tableStructureTemp = []
        stringCommand = 'SELECT '
        stringTemp = ''
        headerCount = 0
        for item in itemList:
            headerCount += 1
            if headerCount > 1:
                stringTemp += ',' + item
            else:
                stringTemp += item
#            tableStructureTemp.append(self.tableStructure[headerCount - 1])
            
        stringCommand += stringTemp + ' '
# update table structure
#        self.tableStructure = tableStructureTemp
 
# update dictColumnHeaders
        self.dictColumnHeaders = {}
        icount = 0
        for i in range(len(self.tableStructure)):
            icount += 1
            self.dictColumnHeaders[self.tableStructure[i][0]] = icount
            
# look for auto_index field
        flagAutoIndex = False
        for eachItem in self.tableStructureOriginal:
            if 'auto_index' in eachItem:
                flagAutoIndex = True
                break
            
        if flagAutoIndex:
            stringCommand += (
                'FROM ' + self.myDatabase + '.' + self.myTable 
                + ' order by auto_index'
                )
        else:
            stringCommand += (
                'FROM ' + self.myDatabase + '.' + self.myTable 
                )
           
# print entire string
        self.MySQL_Commands(
            1,
            'self.cursorHandleMySQL.execute("' + stringCommand + '")'
            )
# execute command
        start = time.time()
        try:
            self.cursorHandleMySQL.execute(stringCommand)
        except:
            print(
                '\nError in MySQL command string.\n' +
                ' Examine following command string for errors and try again.\n' +
                ' Command string:\n' +
                '   ' + stringCommand
                )
            showerror(
                'Error: bad MySQL command string',
                '\nExamine following command string for errors and try again.\n\n' +
                'Command string:\n\n' +
                stringCommand
                )
            return

        self.tableValues=self.cursorHandleMySQL.fetchall()
        finish=time.time()
        delta_t = finish - start
        self.MySQL_Commands(
            0,
            '  (Time: %-7.4f secs)' % delta_t
            )
            
        if DEBUG_RESEQUENCE_AUTO_INDEX:
            print('\nself.tableValues from MySQL command = ')
            print(self.tableValues)
            print('\nself.tableStructure from MySQL command =')
            print(self.tableStructure)

# display (refresh database table)
        self.valuesDisplayRowDecimate(self.tableStructure,self.tableValues)
        
# update status line
        maxLinesDisplay = int(self.comboboxMaxLinesToDisplay.get())
        if maxLinesDisplay == 0 or maxLinesDisplay > len(self.tableValues):
            maxLinesDisplay = len(self.tableValues)     
        self.handlerStatusLineRefresh(maxLinesDisplay)
        
# restore checked fields
        self.restoreCheckedFieldNames()  
        
        return
        
        
    def saveCheckedFieldNames(self):
        '''
        Purpose:
            saves field names of checked fields before they are filtered and
            displayed again
        '''
        if DEBUG_PRINT_METHOD:
            print('\n***** In ' + MODULE + '/' + 'saveCheckedFieldNames')
    
# get X-Select field name first, if it exists
        self.saveXSelectFieldName = ''
        try:
            if DEBUG_SAVE_CHECKED_FIELD_NAMES:
                print('\n\nSAVE CHECKED FIELD NAMES - Part 1:')
                print('\n  self.varXSelect.get() = %s' % self.varXSelect.get())
                print('\n  self.dictColumnHeaders:')
                print(self.dictColumnHeaders)
                print('\n  self.varYSelect:')
                for (num,i) in enumerate(self.varYSelect):
                    print('  %s. %s' % (num+1, self.varYSelect[num].get()))
# get X-Select name               
            indexXSelect = self.varXSelect.get()
            for key,value in self.dictColumnHeaders.iteritems():
                if value == indexXSelect:
                    self.saveXSelectFieldName = key
                    if DEBUG_SAVE_CHECKED_FIELD_NAMES:
                        print('\n  self.saveXSelectFieldName = %s' % self.saveXSelectFieldName)
                    break
        except:
            if DEBUG_SAVE_CHECKED_FIELD_NAMES:
                print('\n---- exception raised: saveCheckedFieldNames 1 --------')
            
# get Y_Select field names, if they exist
        self.saveYSelectFieldNames = []
        if DEBUG_SAVE_CHECKED_FIELD_NAMES:
            print('\n  self.saveYSelectFieldNames:')
        try:
            j_index = 0     # index for self.varYSelect
            j_count = 0     # index for list self.saveYSelectFieldNames
            for var in self.varYSelect:
                j_index += 1
                if var.get():
# make sure saveCheckedFieldNames is called BEFORE self.dictColumnHeaders is 
#   updated in the calling method; restoreCheckedFieldNames should then be called
#   next time the database table values are displayed
                    for key,value in self.dictColumnHeaders.iteritems():
                        if value == j_index:
                            self.saveYSelectFieldNames.append(key)
                            if DEBUG_SAVE_CHECKED_FIELD_NAMES:
                                print('\n j_index = %s, value = %s, key = %s' % (j_index, value, key))
                                print('   %s. %s' % (j_index, self.saveYSelectFieldNames[j_count]))
                                print(' self.saveYSelectFieldNames = %s' % self.saveYSelectFieldNames)
                                j_count += 1
                                break
        except:
            if DEBUG_SAVE_CHECKED_FIELD_NAMES:
                print('\n---- exception raised: saveCheckedFieldNames 2 --------')
            pass
                        
        if DEBUG_SAVE_CHECKED_FIELD_NAMES:
            try:
                print('\n\nSAVE CHECKED FIELD NAMES - Part 2:')
                print('\n  self.varXSelect.get() = %s' % self.varXSelect.get())
                print('\n  self.saveXSelectFieldName = %s' % self.saveXSelectFieldName)
                print('\n  self.saveYSelectFieldNames =')
                print(self.saveYSelectFieldNames)
                print('\n  self.dictColumnHeaders = %s' % self.dictColumnHeaders)
                print('\n  Y-Select fields checked:')
                for (num,var) in enumerate(self.varYSelect):
                    print('   %s. %s' % (num + 1,self.varYSelect[num].get()))
            except:
                print('\n---- exception raised: saveCheckedFieldNames 3 --------')
            
        return
        
        
    def restoreCheckedFieldNames(self):
        '''
        Purpose:
            uses saved field names that were checked before to restore
            the checked fields if the saved field name appears in the currently
            displayed table
            
        Must call saveCheckedFieldNames first to get everything correct!
        '''
        if DEBUG_PRINT_METHOD:
            print('\n***** In ' + MODULE + '/' + 'restoreCheckedFieldNames')
            
        if DEBUG_RESTORE_CHECKED_FIELD_NAMES:
            try:
                print('\n\nRESTORE CHECKED FIELD NAMES - Part 1:')
                print('\n  self.saveXSelectFieldName = %s' % self.saveXSelectFieldName)
                print('\n  self.varXSelect.get() = %s' % self.varXSelect.get())
                print('\n  self.saveYSelectFieldNames = %s' % self.saveYSelectFieldNames)
                print('\n  self.varYSelect:')
                for (num,i) in enumerate(self.varYSelect):
                    print('  %s. %s' % (num+1, self.varYSelect[num].get()))
            except:
                print('\nRESTORE:')
                print('\n  EXCEPT: cannot print values in module "restoreCheckedFieldNames"')
            
# if both self.saveXSelectFieldName and self.saveYSelectFieldNames are empty, just return
        try:
            if (self.saveXSelectFieldName == '' and self.saveYSelectFieldNames == []):
                if DEBUG_RESTORE_CHECKED_FIELD_NAMES:
                    print('\n  -- no X or Y field names have been selected')
                return
        except:
# then neither exists, so return
            if DEBUG_RESTORE_CHECKED_FIELD_NAMES:
                print('\n  ---- exception raised: restoreCheckedFieldNames 1 --------')
            return
            
# search thru current field names in self.dictColumnHeaders to see if any fields 
#   need to be checked
# X-Select index first

        if self.saveXSelectFieldName in self.dictColumnHeaders:
            self.varXSelect.set(self.dictColumnHeaders[self.saveXSelectFieldName])
            
# Y-Select indices next
        indexYSelect = []
        try:
            for field in self.saveYSelectFieldNames:
                if field in self.dictColumnHeaders:
                    indexYSelect.append(self.dictColumnHeaders[field])    
                    
# sort in place
            indexYSelect.sort()
            if DEBUG_SAVE_CHECKED_FIELD_NAMES:
                print('\n indexYSelect:')
                for (num, index) in enumerate(indexYSelect):
                    print('  %s. %s' % (num+1,index))
            
# check field names in self.varYSelect
            if len(indexYSelect) > 0:
                j_index = 0
                for var in self.varYSelect:
                    j_index += 1
                    if j_index in indexYSelect:
                        var.set(1)
                        
            if DEBUG_SAVE_CHECKED_FIELD_NAMES:
                print('\n self.varYSelect new values:')
                for (num, var) in enumerate(self.varYSelect):
                    print(' %s. %s' % (num+1, var.get()))
                        
# fill in entry fields for 'Number of selected Y' and 'Selected X' values in 
#   main 'VALUES FOR TABLE' window
# ... for y values selected
            self.handlerDisplayNumberOfYValuesSelected()
# ... for x value selected
            self.handlerDisplayXValueSelected()
            
        except:
            if DEBUG_RESTORE_CHECKED_FIELD_NAMES:
                print('\n---- exception raised: restoreCheckedFieldNames 2 --------')
            pass
                    
        if DEBUG_RESTORE_CHECKED_FIELD_NAMES:
            try:
                print('\n\nRESTORE CHECKED FIELD NAMES - Part 2:')
                print('\n  indexYSelect = ')
                print(indexYSelect)
                print('\n  Y-Select fields checked:')
                fieldNum = 0
                for var in self.varYSelect:
                    fieldNum += 1
                    print('   %s. %s' % (fieldNum,var.get()))
            except:
                print('\n  ---- exception raised: restoreCheckedFieldNames 3 --------')
                
        return
        
        
    def resetVarXYSelect(self):
        '''
        Purpose:
            re-set indices for X-Select and Y-Select checked values for new column
            headers, but only if old header names exist in the new header lists;
            usually called AFTER a new list of self.dictColumnHeaders is generated;
            uses old header names to set new header names
            
        Prominent variables:
            self.varXSelect - table column in which radiobutton for X-Select is selected
            self.varYSelect - list of instances of which Y-Select checkboxes are checked
        '''
        if DEBUG_PRINT_METHOD:
            print('\n***** In ' + MODULE + '/' + 'resetVarXYSelect')

# ... set self.varXSelect
        try:
            if DEBUG_VARXYSELECT:
                print('\n\nRESET INDICES - Part 1:')
                print('\n  self.saveXSelectFieldName = %s' % self.saveXSelectFieldName)
                print('\n  self.dictColumnHeaders:')
                print(self.dictColumnHeaders)
                print('\n  self.varYSelect:')
                for (num,i) in enumerate(self.varYSelect):
                    print('  %s. %s' % (num+1, self.varYSelect[num].get()))
            if self.saveXSelectFieldName in self.dictColumnHeaders:
                self.varXSelect.set(self.dictColumnHeaders[self.saveXSelectFieldName])
            else:
                self.varXSelect.set(0)
            if DEBUG_VARXYSELECT:
                print('\n  self.varXSelect = %s' % self.varXSelect.get())
        except:
            if DEBUG_VARXYSELECT:
                print('\n---- exception raised: resetVarXYSelect 1 --------')
            pass
                                
# ... print some values to check logic
        if DEBUG_VARXYSELECT:
            print('\n self.saveYSelectFieldNames:')
            print(self.saveYSelectFieldNames)
            print('\nself.dictColumnHeaders:')
            print(self.dictColumnHeaders)
            print('\nself.varYSelect:')
            try:
                for (num,var) in enumerate(self.varYSelect):
                    print(' %s. %s' % (num+1,var.get()))
            except:
                if DEBUG_VARXYSELECT:
                    print('\n---- exception raised: resetVarXYSelect 2 --------')
                pass

# ... set self.varYSelect
        try:
#            for var in self.varYSelect:
#                var.set(0)
            if DEBUG_VARXYSELECT:
                print('\n\nRESET INDICES - Part 2:')
                print('\n Before determining self.varYSelect:')
                print('\n  self.saveYSelectFieldNames =')
                print(self.saveYSelectFieldNames)
                
            for fieldYSelectName in self.saveYSelectFieldNames:
                if DEBUG_VARXYSELECT:
                    print('\n  Using field = %s' % fieldYSelectName)
                if fieldYSelectName in self.dictColumnHeaders:
                    index = self.dictColumnHeaders[fieldYSelectName] - 1
                    if DEBUG_VARXYSELECT:
                        print('\n  index to set: %s' % (index + 1))
                    self.varYSelect[index].set(1)  
                    print('       %s. %s ' % (index, self.varYSelect[index].get()))
                else:
                    if DEBUG_VARXYSELECT:
                        print('    ... field NOT in self.dictColumnHeaders')
                    
            if DEBUG_VARXYSELECT:
                print('\n  self.varYSelect:')
                for (num,var) in enumerate(self.varYSelect):
                    print('   %s. %s' % (num+1, var.get()))
        except:
            if DEBUG_VARXYSELECT:
                print('\n---- exception raised: resetVarXYSelect 3 --------')
            pass            
                
        return
        
        
    def handlerExportYSelectFieldsToCsvFile(self):
        '''
        Purpose:
            export Y-select data to file using CSV format
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerExportYSelectFieldsToCsvFile')
            
# set last button pressed
        self.lastButtonPressed(
            BUTTONLABEL_EXPORTTOCSV
            )
            
# check if a table has even been read in 
        emptyTableCheck = self.checkIfEmptyTable()
        if emptyTableCheck:
            return
        
# determine which columns are selected
# determine y index and header
        i = 0
        j = 0
        yHeaders = []
        index_Y = []
        for var in self.varYSelect:
            if var.get():
                index_Y.append(j)
                yHeaders.append(self.tableStructure[index_Y[i]][0])
                i += 1
            j+=1
            
# checks
        if yHeaders == []:
            stringNoInput = (
                'No Y-Select values have been chosen.\n\n' + 
                'Check the Y-Select values desired and try again.'
                )
            print stringNoInput
            showerror(
                'Error: no input',
                stringNoInput
                )
            return
# ------ end of checks ----------
            
# open file with write privileges
# ... define dictionary of options for askopenfilename()
        options = {}
        options = {
            'defaultextension' : '.csv',
            'filetypes' : [('Comma-Separated Values','.csv'),('All files','*')],
            'initialdir' : '.',
            'initialfile' : '',
            'parent' : self.toplevelTableValues,
            'title' : 'Pick csv filename'
            }   

        self.fullpath_ExportToCsv = tkFileDialog.asksaveasfilename(**options)
        dirname, filename = os.path.split(self.fullpath_ExportToCsv)

        if filename == '':
            print '   No filename chosen!'
            showinfo(
                '\nNo filename chosen...',
                'You must enter a filename.\n\n'
                )
            return            
        else:
            print
            print ' dirname =',dirname
            print ' filename =',filename
            print ' full path name = ',self.fullpath_ExportToCsv
            print  

        fileCsv = open(self.fullpath_ExportToCsv, 'w')
        
# ... write to file using csv module
# ...       instantiate the object
        w = csv.writer(fileCsv)
        
# find out which rows are checked, and count the number of rows checked
        icount = 0
        rowCount = 0
        rowIndex = []
        for var in self.varSelectAnyRow:
            if var.get():
                rowCount += 1
                rowIndex.append(icount)
            icount += 1
# get the y indices
        jcount = 0
        colCount = 0
        colIndex = []
        for var in self.varYSelect:
            if var.get():
                colCount += 1
                colIndex.append(jcount)
            jcount += 1
            
# checks
        if not colCount:
            stringNoYSelect = (
                'No Y-Select values have been chosen.\n\n' +
                'Select a Y-Select value and try again.'
                )
            print stringNoYSelect
            showerror(
                'Error: no Y-Select values',
                stringNoYSelect
                )
            return
# --------- end of checks ----------
# write headers to CSV file
        w.writerow(yHeaders)
            
# if some or all rows are checked, write the partial data    
        if rowCount:
            for row in rowIndex:
                dataOneRow = []
                for column in colIndex:
                    dataOneRow.append(self.tableValues[row][column])
                if DEBUG_CSV:
                    print('%s: %s' % (row+1,dataOneRow))
                w.writerow(dataOneRow)        
        else:
# write all the data
            for row in range(len(self.tableValues)):
                dataOneRow = []
                for column in colIndex:
                    dataOneRow.append(self.tableValues[row][column])
                if DEBUG_CSV:
                    print('%s: %s' % (row+1,dataOneRow))
                w.writerow(dataOneRow)
                
        fileCsv.close()

        return
        
            
    def handlerTableFunctionsTable(self,myDatabaseTable):
        '''
        redefines tables for selected database
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerTableFunctionsTable')
        
# check if connected to a MySQL server
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return   

#
#        self.comboboxTableFunctionsTable.configure(scrolledlist_items=self.myDatabaseTables)
        
        return
        

    def handlerTableFunctionsDatabase(self,myDatabase):
        '''
        In Table Functions, allows selection of database, clears
            'Select table', and redefines tables list corresponding
            to the selected database
            
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerTableFunctionsDatabase\n')
            
        self.MySQL_Output(
            1,
            'Using database ' + myDatabase
            )

# check if connected to a MySQL server
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return           
        
# clear table selection
        self.comboboxTableFunctionsSelectTable.clear()
        
# get tables associated with selected database
        if (
            myDatabase == '' or 
            myDatabase == None
            ):
            self.MySQL_Output(
                1,
                'No database has been specified.'
                )
            showerror(
                'Error: no database',
                'No database has been chosen for this\n' +
                'operation.\n\n' +
                'Please choose a database.'
                )
            return
        for database in self.myDatabases:
            if database == myDatabase:
# redo tables list
                self.refreshTables()
# regrid 'Select table:' combobox; taken from "handlerDatabaseTableFunctions"
                self.comboboxTableFunctionsSelectTable = Pmw.ComboBox(
                    self.frame_00_comboboxTableFunctions,
                    scrolledlist_items=self.myDatabaseTables,
                    scrolledlist_hull_width=500,
                    )
                self.comboboxTableFunctionsSelectTable.grid(
                    row=2,
                    column=1,
                    padx=5,
                    pady=5,
                    sticky=W,
                    )
              
                return
                
# if we get this far, no database match
        self.MySQL_Output(
            1,
            'Database is not in current list.'
            )
        showerror(
            'Error: database does not exist.',
            'The database for which you are trying to generate\n' +
            'a table does not exist in the current list of\n' +
            'databases.\n\n' +
            'Please create the database before trying to add\n' +
            'a table to it.'
            ) 
        
        return
        

    def handlerFieldFunctionsDatabase(self,myDatabase):
        '''
        In Field Functions, allows selection of database, clears
            'Select table', and redefines tables list corresponding
            to the selected database
            
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerFieldFunctionsDatabase\n')
            
        self.MySQL_Output(
            1,
            'Using database ' + myDatabase
            )

# check if connected to a MySQL server
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return           
        
# clear table selection
        self.comboboxFieldFunctionsTable.clear()
        
# get tables associated with selected database
        if (
            myDatabase == '' or 
            myDatabase == None
            ):
            self.MySQL_Output(
                1,
                'No database has been specified.'
                )
            showerror(
                'Error: no database',
                'No database has been chosen for this\n' +
                'operation.\n\n' +
                'Please choose a database.'
                )
            return
        for database in self.myDatabases:
            if database == myDatabase:
                self.refreshTables()

# regrid 'Select table:' combobox; taken from "handlerDatabaseTableFunctions"
                self.comboboxFieldFunctionsTable = Pmw.ComboBox(
                    self.frame_00_comboboxFieldFunctions,
                    scrolledlist_items=self.myDatabaseTables,
                    scrolledlist_hull_width=500,
                    )
                self.comboboxFieldFunctionsTable.grid(
                    row=2,
                    column=1,
                    padx=5,
                    pady=5,
                    sticky=W,
                    )
              
                return
                
# if we get this far, no database match
        self.MySQL_Output(
            1,
            'Database is not in current list.'
            )
        showerror(
            'Error: database does not exist.',
            'The database for which you are trying to generate\n' +
            'a table does not exist in the current list of\n' +
            'databases.\n\n' +
            'Please create the database before trying to add\n' +
            'a table to it.'
            )  
        
        return
                    
        
    def handlerDatabaseFieldsAdd(self):
        '''
        Purpose:
        Add a field in an existing table. 
        A field cannot be created, since a table must be created
        with at least one field. Subsequent fields must be 'added', not 'created'.
        
        Called by:
        createWidgets
        
        Calls:
        handlerDatabaseFieldAddOneField
        
        Input variables:
        current connection: self.myDbConnection
        current database:   self.comboboxDbSelect.get().strip()
        current table:      self.comboboxDbTableSelect.get().strip()
        .
        all databases:      self.myDatabases
        all tables:         self.myDatabaseTables
        all fields:         self.myDatabaseFields
        
        
        Output variables:
        
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerDatabaseFieldsAdd')

# check if connected to a MySQL server
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return
        
# destroy any old frames
        self.destroyAllDatabaseTableFieldFrames()
        
# check if database and table have been specified        
# ... get current database and table 
        currentDatabaseForField = self.comboboxDbSelect.get().strip()      
        currentTableForField = self.comboboxDbTableSelect.get().strip()      
# ... check if a database and table have been selected
        if (
            currentDatabaseForField == '' or currentTableForField == ''
            ):
            stringNoDatabaseOrTableSelected = ''
            stringNoDatabaseOrTableSelected = (
                'The following needs correcting:\n\n'
                )
            if currentDatabaseForField == '':
                stringNoDatabaseOrTableSelected += '  > No database has been selected.\n\n'
            if currentTableForField == '':
                stringNoDatabaseOrTableSelected += '  > No table has been selected.\n\n'
            stringNoDatabaseOrTableSelected += (
                'Please select the database and/or table and try again.'
                )
            self.MySQL_Output(
                0,
                stringNoDatabaseOrTableSelected
                )
            showinfo(
                'Add field ...',
                stringNoDatabaseOrTableSelected
                )  
            return
                    
# open Toplevel frame for entering database name
        self.toplevelFieldAdd = Toplevel(
            self.frameParent,
            bg='tan'
            )
        self.toplevelFieldAdd.title(
#            'Add field'
            'FIELDS IN TABLE'
            )
        self.toplevelFieldAdd.transient(self.frameParent)
# place the top window
#        x_Windows = self.addField_xWindowLocation
#        y_Windows = self.addField_yWindowLocation
        x_Windows = self.frameParent.winfo_rootx() + 0
        y_Windows = self.frameParent.winfo_rooty() - 100
        
        self.toplevelFieldAdd.geometry(
            '+%d+%d' % (x_Windows, y_Windows)
            )

# add frames to toplevel
        frame_00 = Frame(
            self.toplevelFieldAdd,
            bg='tan',
            )
        frame_00.grid(
            row=0,
            column=0,
            padx=2,
            pady=10
            )
            
        self.frame_10_Add_Field = Frame(
            self.toplevelFieldAdd,
            bg='tan',
            )
        self.frame_10_Add_Field.grid(
            row=1,
            column=0,
            padx=2,
            pady=5
            )
            
        frame_20 = Frame(
            self.toplevelFieldAdd,
            bg='tan',
            )
        frame_20.grid(
            row=2,
            column=0,
            padx=2,
            pady=5,
            )
            
# WIDGETS
# ... frame_00
        labelTitleDatabaseFieldAddTables = Label(
            frame_00,
            text=(
                'ADD FIELD\n' + 
                'Cannot add "PRIMARY KEY auto_increment" field here;\n' +
                'pick any Database or Table'
                ),
            bg='tan',
            justify=CENTER,
            font=self.labelFontMediumBold,
            )
        labelTitleDatabaseFieldAddTables.grid(
            row=0,
            column=0,
            columnspan=2,
            padx=5,
            pady=10,
            )
        labelEnterDatabaseFieldAddTables = Label(
            frame_00,
            text='Database: ',
            bg='tan',
            justify=RIGHT,
            )
        labelEnterDatabaseFieldAddTables.grid(
            row=1,
            column=0,
            pady=5,
            sticky=E,
            )       
                
        self.varEnterDatabaseFieldAddDatabases = StringVar()
        self.entryEnterDatabaseFieldAddDatabases = Entry(
            frame_00,
            textvariable=self.varEnterDatabaseFieldAddDatabases,
            disabledforeground='black',
            disabledbackground='white',
            state='disabled',
            width=30,
            )
        self.entryEnterDatabaseFieldAddDatabases.grid(
            row=1,
            column=1,
            padx=5,
            pady=5,
            sticky=W,
            )
        self.varEnterDatabaseFieldAddDatabases.set(currentDatabaseForField)
            
        labelEnterDatabaseFieldAddTables = Label(
            frame_00,
            text='Table: ',
            bg='tan',
            justify=RIGHT,
            )
        labelEnterDatabaseFieldAddTables.grid(
            row=2,
            column=0,
            pady=5,
            sticky=E,
            )
        
        self.varEnterDatabaseFieldAddTables = StringVar()
        self.varEnterDatabaseFieldAddTables.set(currentTableForField)
        self.entryEnterDatabaseFieldAddTables = Entry(
            frame_00,
            textvariable=self.varEnterDatabaseFieldAddTables,
            disabledforeground='black',
            disabledbackground='white',
            state='disabled',
            width=30,
            )
        self.entryEnterDatabaseFieldAddTables.grid(
            row=2,
            column=1,
            padx=5,
            pady=5,
            sticky=W,
            )
            
# ... self.frame_10_Add_Field           
        labelEnterDatabaseFieldAdd = Label(
            self.frame_10_Add_Field,
            text=(
                'Enter new field name: \n' +
                '(no special characters; all lowercase; \n' + 
                'underscores ok) '
                ),
            bg='tan',
            justify=RIGHT,
            )
        labelEnterDatabaseFieldAdd.grid(
            row=0,
            column=0,
            rowspan=2,
            pady=5,
            sticky=E,
            )
            
        self.varEnterDatabaseFieldAdd = StringVar()
        self.entryEnterDatabaseFieldAdd = Entry(
            self.frame_10_Add_Field,
            textvariable=self.varEnterDatabaseFieldAdd,
            width=30,
            )
        self.entryEnterDatabaseFieldAdd.grid(
            row=0,
            column=1,
            pady=1,
            sticky=W,
            )  
                    
        buttonClearDatabaseFieldAdd = Button(
            self.frame_10_Add_Field,
            text='Clear',
            font=self.buttonFontSmallest,
            borderwidth=2,
            relief=RAISED,
            width=8,
            background='white',
            foreground='blue',
            command=self.handlerClearDatabaseFieldAdd,
            )
        buttonClearDatabaseFieldAdd.grid(
            row=1,
            column=1,
            padx=0,
            pady=0,
            sticky=N,
            )
            
        labelEnterDatabaseFieldAdd_Datatype = Label(
            self.frame_10_Add_Field,
            text='... with field datatype: ',
            bg='tan',
            justify=RIGHT,
            )
        labelEnterDatabaseFieldAdd_Datatype.grid(
            row=2,
            column=0,
            pady=5,
            sticky=E,
            )
            
        self.comboboxEnterDatabaseFieldAdd_Datatype = Pmw.ComboBox(
            self.frame_10_Add_Field,
            scrolledlist_items=self.fieldDataTypes,
            listheight=150,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            selectioncommand=self.handlerEnterDatabaseFieldAdd_Datatype,
            entry_width=30,
            scrolledlist_hull_width=500,
            )
        self.comboboxEnterDatabaseFieldAdd_Datatype.grid(
            row=2,
            column=1,
            pady=5,
            sticky=W,
            )

# DATATYPES and their lengths
# 1     BIGINT            255     opt     integer number range: -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807
# 2     CHAR              255     req'd   max: 255 characters
# 3     DATE              b       b       input: YYYY-MM-DD; storage format: YYY-MM-DD
# 4     DECIMAL           255     opt     stores fixed-point numbers
# 5     DOUBLE            b       opt     stores floating point numbers
# 6     FLOAT             b       opt     stores floating point numbers
# 7     INTEGER           255     opt     range: -2,147,483,648 to 2,147,483,647
# 8     INTEGER UNSIGNED  255     opt     range: 0 to 4,294,967,295
# 9     LONGTEXT          b       b       upto 4GB
# 10    MEDIUMTEXT        b       b       up to 16MB
# 11    SMALLINT          255     opt     integer number range: -32,768 to 32,767
# 12    SMALLINT_UNSIGNED 255     opt     integer number range: 0 to 65500
# 13    TEXT              b       b       max: 65500 bytes
# 14    TIME              b       b       input: DD HH:MM:SS; storage format: HHH:MM:SS 
# 15    TIMESTAMP         b       b       input: YYYY-MM-DD HH:MM:SS; storage format: YYY-MM-DD HH:MM:SS; assign NULL to set current date and time
# 16    TINYTEXT          b       b       max: 255 bytes
# 17    VARCHAR           65500   req'd   max: 65500 characters  
 
        labelEnterDatabaseFieldAdd_DatatypeLength = Label(
            self.frame_10_Add_Field,
            text=(
                '... of length: \n' +
                '(integer only; grayed if not applicable; \n' +
                ' otherwise, suggested value shown) '
                ),
            bg='tan',
            justify=RIGHT,
            )
        labelEnterDatabaseFieldAdd_DatatypeLength.grid(
            row=3,
            column=0,
            pady=5,
            sticky=E,
            )
            
        self.varEntryEnterDatabaseFieldAdd_DatatypeLength = StringVar()
        self.entryEnterDatabaseFieldAdd_DatatypeLength = Entry(
            self.frame_10_Add_Field,
            textvariable=self.varEntryEnterDatabaseFieldAdd_DatatypeLength,
            disabledbackground='gray',
            disabledforeground='black',
            state=NORMAL,
            width=30,
            )
        self.entryEnterDatabaseFieldAdd_DatatypeLength.grid(
            row=3,
            column=1,
            pady=5,
            sticky=W,
            )
      
            
        labelEnterDatabaseFieldAdd_Position = Label(
            self.frame_10_Add_Field,
            text='... to be positioned: ',
            bg='tan',
            justify=RIGHT,
            )
        labelEnterDatabaseFieldAdd_Position.grid(
            row=5,
            column=0,
            pady=5,
            sticky=E,
            )
# ... first column
        self.varFieldAddPosition = StringVar()
        self.radiobuttonFieldAddPosition_First = Radiobutton(
            self.frame_10_Add_Field,
            variable=self.varFieldAddPosition,
            value='first',
            text='In FIRST column',
            bg='tan'
            )
        self.radiobuttonFieldAddPosition_First.grid(
            row=4,
            column=1,
            pady=5,
            sticky=W,
            )
            
# ... after column x
        self.radiobuttonFieldAddPosition_After = Radiobutton(
            self.frame_10_Add_Field,
            variable=self.varFieldAddPosition,
            value='after',
            text='After column ...',
            bg='tan',
            )           
        self.radiobuttonFieldAddPosition_After.grid(
            row=5,
            column=1,
            pady=5,
            sticky=W,
            )
# do not include last 'auto_index' column in scrolled list
        tempMyDatabaseFields = []
        for number,field in enumerate(self.myDatabaseFields[0:-1]):
            tempMyDatabaseFields.append(str(number + 1) + '. ' + field)
# ... combobox for column
        self.comboboxFieldAddPosition_AfterColumn = Pmw.ComboBox(
            self.frame_10_Add_Field,
#            scrolledlist_items=self.myDatabaseFields,
            scrolledlist_items=tempMyDatabaseFields,
            listheight=150,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            selectioncommand=self.handlerSetRadiobuttonAfter,
            entry_width=30,
            scrolledlist_hull_width=500,
            )
        self.comboboxFieldAddPosition_AfterColumn.grid(
            row=6,
            column=1,
            pady=0,
            sticky=N+E,
            )

# ... next-to-last column
        self.radiobuttonFieldAddPosition_Last = Radiobutton(
            self.frame_10_Add_Field,
            variable=self.varFieldAddPosition,
            value='next2last',
            text='In NEXT-TO-LAST column\n(last column = auto_index)',
            bg='tan',
            )
        self.radiobuttonFieldAddPosition_Last.grid(
            row=7,
            column=1,
            pady=5,
            sticky=W,
            )
# ... select last column as default
        self.varFieldAddPosition.set('next2last')
# ... frame_20
# graph Add and Cancel buttons
        self.buttonOkEnterDatabaseFieldAdd = Button(
            frame_20,
            text='Add',
            borderwidth=3,
            relief=RAISED,
            justify=CENTER,
            width=10,
            background='white',
            foreground='blue',
            font=self.buttonFontSmall,
            command=self.handlerDatabaseFieldAddOneField,
            )
        self.buttonOkEnterDatabaseFieldAdd.grid(
            row=0,
            column=0,
            padx=5,
            pady=5,
            )
            
        self.buttonCancelEnterDatabaseFieldAdd = Button(
            frame_20,
            text='Cancel',
            borderwidth=5,
            relief=RAISED,
            justify=CENTER,
            width=20,
            command=self.handlerToplevelFieldAddDestroy,
            )
        self.buttonCancelEnterDatabaseFieldAdd.grid(
            row=1,
            column=0,
            padx=5,
            pady=10,
            ) 
        
        return
        
        
    def handlerToplevelFieldAddDestroy(self):
        '''
        Purpose:
            destroy 'Add Field' window
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerToplevelFieldAddDestroy')

# save location for next time window is opened
        self.addField_xWindowLocation = \
            self.toplevelFieldAdd.winfo_rootx() - self.offsetWindowX
        self.addField_yWindowLocation = \
            self.toplevelFieldAdd.winfo_rooty() - self.offsetWindowY

# destroy current toplevel            
        self.toplevelFieldAdd.destroy()
        
        return
        

    def handlerSetRadiobuttonAfter(self,entryValue):
        '''
        Purpose:
            set 'After column ...' radiobutton whenever
            a column (field) is selected
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerSetRadiobuttonAfter')
            
        self.varFieldAddPosition.set('after')
        
        return


    def handlerDatabaseFieldAddOneField(self):
        '''
        Purpose:
            Add field to current database and table
            
        Calls:
            None
            
        Called by:
            handlerDatabaseFieldsAdd
            
        Input variables:
            self.entryEnterDatabaseFieldAdd                 # name for field to add
            self.comboboxEnterDatabaseFieldAdd_Datatype     # field datatype
            self.entryEnterDatabaseFieldAdd_DatatypeLength  # length of field datatype
            self.varFieldAddPosition                        # column location of field (first, after, last)
              self.comboboxFieldAddPosition_AfterColumn     # column location if 'After column...' radiobutton is selected
            self.entryEnterDatabaseFieldAddTables           # table to which field will be added
            self.entryEnterDatabaseFieldAddDatabases        # database in which table and field are located

        
        Output variables:
        
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerDatabaseFieldAddOneField')
        
# check if connected to a MySQL server
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return
        
# shorten names - valid just for scope of this method
        try:
            field = self.entryEnterDatabaseFieldAdd.get().strip()
            datatype = self.comboboxEnterDatabaseFieldAdd_Datatype.get().strip()
            datatypeLength = self.entryEnterDatabaseFieldAdd_DatatypeLength.get().strip()
            position = self.varFieldAddPosition.get().strip()
            if position == 'after':
                positionAfterColumn = self.comboboxFieldAddPosition_AfterColumn.get().split('.')[1].strip()
            table = self.entryEnterDatabaseFieldAddTables.get().strip()
            database = self.entryEnterDatabaseFieldAddDatabases.get().strip()
        except:
            stringInputError = (
                'Input data has not been entered correctly.\n\n' +
                'Check all input values and try again.'
                )
            print('\n' + stringInputError)
            self.MySQL_Output(
                0,
                stringInputError
                )
            try:
                showerror(
                    'Error: invalid entries',
                    stringInputError,
                    parent=self.toplevelFieldAdd
                    )
            except:
                showerror(
                    'Error: invalid entries',
                    stringInputError
                    )
            return
        
        self.MySQL_Output(
            1,
            'List of relevant parameters for this operation:'
            )
        self.MySQL_Output(
            0,
            ' field = ' + field + '\n' +
            ' datatype = ' + datatype + '\n' +
            ' datatypeLength = ' + datatypeLength + '\n' +
            ' position =' + position
            )
        if position == 'after':
            try:
                self.MySQL_Output(
                    1,
                    ' positionAfterColumn = ' + positionAfterColumn
                    )
            except:
                self.MySQL_Output(
                    1,
                    'Error: missing column position.'
                    )
                showerror(
                    'Error: missing column position',
                    'You must select a column after which the new\n'
                    'column can be positioned when\n' +
                    'selecting "After column ..."\n'
                    )
                return
        self.MySQL_Output(
            1,
            ' table = ' + table + '\n' +
            ' database = ' + database 
            )
        print('')
        
# do some basic checks on input
        if ( field == '' or datatype == '' or position == '' or table == '' or database == ''):
            stringError = '\nError: the following fields are blank:\n'
            if field == '':
                stringError+='\n > Field name'
            if datatype == '':
                stringError+='\n > Datatype'
            if position == '':
                stringError+='\n > Column position'
            if table == '':
                stringError+='\n > Table name'
            if database == '':
                stringError+='\n > Database name'
            stringError+='\n\nPlease correct these errors before continuing.'
            self.MySQL_Output(
                1,
                'Error: missing fields' + '\n' + stringError
                )
            showerror(
                'Error: missing fields',
                stringError
                )
            return
            
        if position == 'after' and positionAfterColumn == '':
            self.MySQL_Output(
                1,
                'Error: missing column position.'
                )
            showerror(
                'Error: missing column position',
                '\n\nYou must select a column after which the new\n'
                'column can be positioned when\n' +
                'selecting "After column ..."\n'
                )
            return
            
# at this point, all checks look good
        
# use current database
        stringUseDatabase = (
            'USE' + ' ' + database
            )
        for myDatabase in self.myDatabases:
            self.MySQL_Output(
                1,
                'myDatabase = ' + '"' + myDatabase + '", ' +
                'database = ' + database
                )
            if myDatabase == database:
                self.MySQL_Commands(
                    1,
                    'self.cursorHandleMySQL.execute("' + stringUseDatabase + '")'
                    )
                self.cursorHandleMySQL.execute(stringUseDatabase)
                self.MySQL_Output(
                    1,
                    'Now using database: ' + database
                    )
# now check to make sure table is in current database
                self.MySQL_Commands(
                    1,
                    'self.cursorHandleMySQL.execute("SHOW TABLES")'
                    )
                self.cursorHandleMySQL.execute("SHOW TABLES")
                tempTables = self.cursorHandleMySQL.fetchall() # tuples;

# make tempTables (tuples) into a list
                currentTables = []
                for tempTable in tempTables:
                    currentTables.append(tempTable[0])
                currentTables.sort()
                    
                self.MySQL_Output(
                    1,
                    '\nCurrent table choices for adding a field:'
                    )
                self.MySQL_Output(
                    0,
                    currentTables
                    )
                    
                for myTable in currentTables:
                    print('\ntype(myTable) = %s\n' % type(myTable))
                    self.MySQL_Output(
                        0,
                        'myTable = ' + myTable + ', ' + 'table = ' + table
                        )
                    if myTable == table:
                        self.MySQL_Output(
                            1,
                            'Now using table: ' + table
                            )
# we are go to add field, but only if it is unique, so ...
                        self.MySQL_Output(
                            1,
                            'Following two fields should NOT match:'
                            )
                        for existingField in self.myDatabaseFields:
                            self.MySQL_Output(
                                1,
                                'existingField = ' + existingField + ', ' + 'field = ' + field
                                )
# reduce both to lowercase to compare; MySQL field names are not case sensitive
                            if existingField.lower() == field.lower():
                                self.MySQL_Output(
                                    1,
                                    'New field name is not unique. Please re-enter.'
                                    )
                                showerror(
                                    'Error: field name',
                                    '\nThe new field name,\n\n"' + 
                                    field + '"\n\n' +
                                    'already exists.\n\n' +
                                    'MySQL field names are NOT case sensitive, so\n' +
                                    'combinations of upper and lower case letters\n' +
                                    'for the same name are NOT unique.\n\n' +
                                    'Enter a unique new field name, all lowercase.'              
                                    )
                                return
                                
# ... if we get this far, field string is unique, so ...
# ... assemble string to add field        
                        stringAddField = (
                            'ALTER TABLE' + ' ' + table + ' ' + 
                            'ADD' + ' ' + field + ' '
                            )
                            
                        datatypeLength_min = 0
                        datatypeLength_max = 100000
                        
                        print('\ndatatype = %s' % datatype)
                        print('\ndatatypeLength = %s' % datatypeLength)
                                                  
                        if datatypeLength <> '' and datatypeLength.count(',') == 0:
                            if(
                                int(datatypeLength) > datatypeLength_min and 
                                int(datatypeLength) < datatypeLength_max
                                ):
                                if datatype == 'INTEGER UNSIGNED':
                                    stringAddField += 'INT(' + datatypeLength + ') UNSIGNED' + ' '
                                else:
                                    stringAddField += datatype + '(' + datatypeLength + ') '

                            else:
                                stringOutOfBounds = (
                                    'Datatype length is out of bounds. Value must be\n' +
                                    'a positive integer between %s and %s.\n\n' +
                                    'Check value in input box.'
                                    ) % (
                                    datatypeLength_min,
                                    datatypeLength_max
                                    )
                                self.MySQL_Output(
                                    1,
                                    stringOutOfBounds
                                    )
                                try:
                                    showerror(
                                        'Error: datatype length',
                                        stringOutOfBounds,
                                        parent=self.toplevelFieldAdd
                                        )
                                except:
                                    showerror(
                                        'Error: datatype length',
                                        stringOutOfBounds
                                        )
                                return
                                
# datatype = DECIMAL                                
                        elif datatypeLength.count(',') > 0:
                            datatype_Split = datatypeLength.split(',')
                            if datatypeLength.count(',') > 1:
                                stringWrongCount = (
                                    'The datatype length is in the wrong format.\n\n' +
                                    'Check input and try again.'
                                    )
                                self.MySQL_Output(
                                    1,
                                    stringWrongCount
                                    )
                                try:
                                    showerror(
                                        'Error: datatype length',
                                        stringWrongCount,
                                        parent=self.toplevelFieldAdd
                                        )
                                except:
                                    showerror(
                                        'Error: datatype length',
                                        stringWrongCount
                                        )
                                return
                                        
                            elif(
                                int(datatype_Split[0]) > datatypeLength_min and
                                int(datatype_Split[1]) > datatypeLength_min and
                                int(datatype_Split[0]) < datatypeLength_max and
                                int(datatype_Split[1]) < datatypeLength_max
                                ):
                                
                                stringAddField += datatype + '(' + datatypeLength + ')'
                                
                            else:
                                stringOutOfBounds = (
                                    'Datatype length is out of bounds. Value must be\n' +
                                    'a positive integer between %s and %s.\n\n' +
                                    'Check value in input box.'
                                    ) % (
                                    datatypeLength_min,
                                    datatypeLength_max
                                    )
                                self.MySQL_Output(
                                    1,
                                    stringOutOfBounds
                                    )
                                try:
                                    showerror(
                                        'Error: datatype length',
                                        stringOutOfBounds,
                                        parent=self.toplevelFieldAdd
                                        )
                                except:
                                    showerror(
                                        'Error: datatype length',
                                        stringOutOfBounds
                                        )
                                return
  
# datatype = DOUBLE, FLOAT, etc.                                
                        else:
                            stringAddField += datatype + ' '
                            
                        if position == 'first':
                            stringAddField += 'FIRST '
                        
                        elif position == 'after':
                            if positionAfterColumn == '':
                                self.MySQL_Output(
                                    1,
                                    'No column name specified after which to place field.\n' +
                                    'Please correct by specifying an existing field name\n' +
                                    'after which the new field name will be placed.'
                                    )
                                showerror(
                                    'Error: no column name',
                                    '\nNo column name specified after which to place field.\n\n' +
                                    'Please correct by specifying an existing field name\n' +
                                    'after which the new field name will be placed.\n\n'
                                    )
                                return
                            else:
                                self.MySQL_Output(
                                    1,
                                    ('New column to be "%s" in table "%s" in database "%s":' % (field, table, database))
                                    )
                                stringAddField += 'AFTER ' + positionAfterColumn
                                self.MySQL_Output(
                                    1,
                                    'Added to stringAddField: "AFTER + positionAfterColumn"'
                                    )
                        
                        elif position == 'next2last':
# find next-to-last field
                            stringShowFields = (
                                'SHOW COLUMNS FROM ' + database + '.' + table
                                )
                            self.cursorHandleMySQL.execute(stringShowFields)
                            currentFieldsTuple = self.cursorHandleMySQL.fetchall()
                            if len(currentFieldsTuple) >= 2:
                                fieldNext2Last = currentFieldsTuple[(len(currentFieldsTuple)-1) - 1][0]
                                print('\nNext-to-last field = %s' % fieldNext2Last)
                            else:
                                stringErrorNumColumns = (
                                    'An error has occurred regarding the number of fields\n' +
                                    'of table %s.\n\n' +
                                    'There should always be at least 2 or more fields for a table\n' +
                                    'to exist in PylotDB. Please contact code administrator.'
                                    ) % (table)
                                print stringErrorNumColumns
                                showerror(
                                    'Error: number of columns',
                                    stringErrorNumColumns
                                    )
                                return  
                            self.MySQL_Output(
                                1,
                                ('New column to be "%s" in table "%s" in database "%s":' % (field, table, database))
                                )
                            stringAddField += 'AFTER ' + fieldNext2Last
                            self.MySQL_Output(
                                1,
                                'Added to stringAddField: "AFTER + fieldNext2Last"'
                                )
                        
# include this logic if ever a field needs to be added in the last column. We don't typically
#   want this for PylotDB since we desire the last column to ALWAYS be "auto_index".
                        elif position == 'last':
# 'last' is the default value; nothing needs to be done here
                            pass
# this should never happen, but just in case...
                        elif position == '':
                            stringErrorNoPosition = (
                                'Parameter "position" in handlerDatabaseFieldsAdd in\n' +
                                'module "' + MODULE + '" is blank.\n\n' +
                                'This should not have happened. Please contact code\n' +
                                'administrator as this is a coding error.'
                                )
                            print stringErrorNoPosition
                            showerror(
                                'Error: blank position parameter',
                                stringErrorNoPosition
                                )
                            return

# ... now confirm with user
                        self.MySQL_Output(
                            1,
                            'The following string will be used to add the field \n' +
                            field + ' to database ' + database + ':\n' + 
                            stringAddField 
                            )
                        
                        ans = askokcancel(
                            'Add field...',
                            'You are about to add field\n\n' +
                            '"' + field + '"\n\n' +
                            'to table\n\n' +
                            '"' + table + '"\n\n' +
                            'located in database\n\n' + 
                            '"' + database +'"\n\n' +
                            'Click on OK to continue, Cancel to\n' +
                            'quit this process.\n'
                            )
                            
                        if ans:
# execute the string thus assembled
                            self.MySQL_Commands(
                                1,
                                'self.cursorHandleMySQL.execute("' + stringAddField + '")'
                                )
                            try:
                                print('\nupdate command: %s' % stringAddField)
                                self.cursorHandleMySQL.execute(stringAddField)
                            except:
                                stringCannotAddField = (
                                    'Unable to add the field\n' +
                                    ' - %s\n\n' +
                                    'Possible errors are:\n' +
                                    ' > unallowed characters are in name\n' +
                                    ' > duplicate field names\n' +
                                    ' > name is a keyword\n\n' +
                                    'Inspect the field name for errors and try again.'
                                    ) % (
                                    field
                                    )
                                print('\n' + stringCannotAddField)
                                self.MySQL_Output(
                                    0,
                                    stringCannotAddField
                                    )
                                try:
                                    showerror(
                                        'Error: unable to add field',
                                        stringCannotAddField,
                                        parent=self.frameParent
                                        )
                                except:
                                    showerror(
                                        'Error: unable to add field',
                                        stringCannotAddField
                                        )
                                return
                                    
# re-calculae self.myDatabaseFields; refresh the Fields box in main window
                            self.refreshFields()
# regrid 'Add field...' box so the drop-down box for the field listing is updated
#                            self.handlerDatabaseFieldsAdd()
# if table window is open, refresh complete table
#                            if self.toplevelTableValues.winfo_exists():
#                                self.buttonTableValuesShowAll.invoke()                            

# if position = 'after', re-graph dropdown menu in 'Add Field' window with new field
                            if position == 'after':
# do not include last 'auto_index' column in scrolled list
                                tempMyDatabaseFields = []
                                for number,field in enumerate(self.myDatabaseFields[0:-1]):
                                    tempMyDatabaseFields.append(str(number + 1) + '. ' + field)
# ... combobox for column
                                self.comboboxFieldAddPosition_AfterColumn = Pmw.ComboBox(
                                    self.frame_10_Add_Field,
#            scrolledlist_items=self.myDatabaseFields,
                                    scrolledlist_items=tempMyDatabaseFields,
                                    listheight=150,
                                    entry_state='disabled',
                                    entry_disabledbackground='white',
                                    entry_disabledforeground='black',
                                    selectioncommand=self.handlerSetRadiobuttonAfter,
                                    entry_width=30,
                                    scrolledlist_hull_width=500,
                                    )
                                self.comboboxFieldAddPosition_AfterColumn.grid(
                                    row=6,
                                    column=1,
                                    pady=0,
                                    sticky=N+E,
                                    )

# update table values only if current ADD FIELD database and table correspond to 
#   the displayed database and table
                            try:
                                mapped = self.toplevelTableValues.winfo_exists()
                            except:
                                mapped = False                    
                                
                            if mapped:
# make sure databases and tables are same for ADD FIELD and for the displayed table values; 
#   otherwise, don't need to update
                                if (
                                self.databaseDisplayedTableValues == self.varEnterDatabaseFieldAddDatabases.get().strip()
                                and
                                self.tableDisplayedTableValues == self.varEnterDatabaseFieldAddTables.get().strip()
                                ):
                                    self.handlerDisplayLimitedRows()    # PEEK handler                             
# update filter window, which should not be displayed if the Table Values window is not displayed
                                    try:
                                        mapped = self.toplevelSelectDisplayOrderedFields.winfo_exists()
                                    except:
                                        mapped = False
            
                                    if mapped:
                                        self.handlerSelectDisplayOrderedFields_Update()
                                        
# kill the Quik-Select window
                                    self.handlerQuikSelectCancelWindow() 
                            
                                    return
                            
                        else:
                            self.MySQL_Output(
                                1,
                                'This process was canceled'
                                )
                                
                        return
                
# if we get this far, table not found in current list of tables
                               
# if we get this far, database not found in current list of databases 
        stringDatabaseNotFound = (
            'The database\n\n' +
            '   %s\n\n' +
            'is not in the list of available databases.\n\n' +
            'You must enter a name for an existing database.\n\n' + 
            'Operation canceled.'
            ) % database
        self.MySQL_Output(
            1,
            stringDatabaseNotFound
            )
        showerror (
            'Error: not a valid database',
            stringDatabaseNotFound
            )
            
        return
    
        
    def handlerDatabaseFieldsDelete(self):
        '''
        Purpose:
        Delete a field in an existing table
        
        Called by:
        createWidgets
        
        Input variables:
        self.comboboxDbFieldSelect                  # current field
        self.comboboxDbTableSelect                  # current table
        self.comboboxDbSelect                       # current database
        .
        self.comboboxEnterDatabaseFieldDelete       # field to delete
        self.entryEnterDatabaseFieldDeleteTables    # table from which field will be delete
        self.entryEnterDatabaseFieldDeleteDatabases # database in which table and field are located
        
        Output variables:
        
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerDatabaseFieldsDelete')
        
# check if connected to the database server - MySQL
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return
        
# destroy any old frames
        self.destroyAllDatabaseTableFieldFrames()
         
# check if database and table have been specified        
# ... get current database and table 
        currentDatabaseForField = self.comboboxDbSelect.get().strip()      
        currentTableForField = self.comboboxDbTableSelect.get().strip()      
# ... check if a database and table have been selected
        if (
            currentDatabaseForField == '' or currentTableForField == ''
            ):
            stringNoDatabaseOrTableSelected = ''
            stringNoDatabaseOrTableSelected = (
                'The following needs correcting:\n\n'
                )
            if currentDatabaseForField == '':
                stringNoDatabaseOrTableSelected += '  > No database has been selected.\n\n'
            if currentTableForField == '':
                stringNoDatabaseOrTableSelected += '  > No table has been selected.\n\n'
            stringNoDatabaseOrTableSelected += (
                'Please select the database and/or table and try again.'
                )
            self.MySQL_Output(
                0,
                stringNoDatabaseOrTableSelected
                )
            showinfo(
                'Delete field ...',
                stringNoDatabaseOrTableSelected
                )  
            return
            
# get current field, table, database from main tab window
        if (
        self.comboboxDbFieldSelect.get().strip() <> ''
        and
        self.comboboxDbFieldSelect.get().split('.')[1].strip() <> "auto_index"
        ):
            currentFieldWithNumberForField = self.comboboxDbFieldSelect.get().strip()
            currentFieldForField = self.comboboxDbFieldSelect.get().split('.')[1].strip()
            currentNumberForField = self.comboboxDbFieldSelect.get().split('.')[0].strip()
        else:
            currentFieldWithNumberForField = ''
            currentFieldForField = ''
            currentNumberForField = ''
                    
# open Toplevel frame for entering database name
        self.toplevelFieldDelete = Toplevel(
            self.frameParent,
            bg='tan'
            )
        self.toplevelFieldDelete.title(
#            'Delete field'
            'FIELDS IN TABLE'
            )
        self.toplevelFieldDelete.transient(self.frameParent)
        
# place the top window
#        x_Windows = self.deleteField_xWindowLocation
#        y_Windows = self.deleteField_yWindowLocation
        x_Windows = self.frameParent.winfo_rootx() + 100
        y_Windows = self.frameParent.winfo_rooty() + 100
        
        self.toplevelFieldDelete.geometry(
            '+%d+%d' % (x_Windows, y_Windows)
            )

# add frames to toplevel
        frame_00 = Frame(
            self.toplevelFieldDelete,
            bg='tan',
            )
        frame_00.grid(
            row=0,
            column=0,
            padx=5,
            pady=5,
            )
            
        frame_10 = Frame(
            self.toplevelFieldDelete,
            bg='tan',
            )
        frame_10.grid(
            row=1,
            column=0,
            padx=5,
            pady=5,
            )
            
        frame_20 = Frame(
            self.toplevelFieldDelete,
            bg='tan',
            )
        frame_20.grid(
            row=2,
            column=0,
            pady=5,
            padx=5,
            )
           
        frame_30 = Frame(
            self.toplevelFieldDelete,
            bg='tan',
            )
        frame_30.grid(
            row=3,
            column=0,
            padx=5,
            pady=5,
            )
            
# WIDGETS
# ... title
        labelTitleDatabaseFieldDeleteTables = Label(
            frame_00,
            text='DELETE FIELD\npick any Database, Table, or Field',
            bg='tan',
            justify=CENTER,
            font=self.labelFontMediumBold,
            )
        labelTitleDatabaseFieldDeleteTables.grid(
            row=0,
            column=0,
            padx=5,
            pady=10,
            )
# ... Database            
        labelEnterDatabaseFieldDeleteTables = Label(
            frame_10,
            text='Database: ',
            bg='tan',
            justify=RIGHT,
            )
        labelEnterDatabaseFieldDeleteTables.grid(
            row=0,
            column=0,
            pady=5,
            sticky=E,
            )       
                
        self.varEnterDatabaseFieldDeleteDatabases = StringVar()
        self.entryEnterDatabaseFieldDeleteDatabases = Entry(
            frame_10,
            textvariable=self.varEnterDatabaseFieldDeleteDatabases,
            disabledforeground='black',
            disabledbackground='white',
            state='disabled',
            width=30,
            )
        self.entryEnterDatabaseFieldDeleteDatabases.grid(
            row=0,
            column=1,
            padx=5,
            pady=5,
            sticky=W,
            )
        self.varEnterDatabaseFieldDeleteDatabases.set(currentDatabaseForField)
        
# ... Table            
        labelEnterDatabaseFieldDeleteTables = Label(
            frame_10,
            text='Table: ',
            bg='tan',
            justify=RIGHT,
            )
        labelEnterDatabaseFieldDeleteTables.grid(
            row=1,
            column=0,
            pady=5,
            sticky=E,
            )
        
        self.varEnterDatabaseFieldDeleteTables = StringVar()
        self.varEnterDatabaseFieldDeleteTables.set(currentTableForField)
        self.entryEnterDatabaseFieldDeleteTables = Entry(
            frame_10,
            textvariable=self.varEnterDatabaseFieldDeleteTables,
            disabledforeground='black',
            disabledbackground='white',
            state='disabled',
            width=30,
            )
        self.entryEnterDatabaseFieldDeleteTables.grid(
            row=1,
            column=1,
            padx=5,
            pady=5,
            sticky=W,
            )

# ... choose Field           
        labelEnterDatabaseFieldDelete = Label(
            frame_20,
            text='Field: ',
            bg='tan',
            justify=RIGHT,
            )
        labelEnterDatabaseFieldDelete.grid(
            row=0,
            column=0,
            pady=5,
            sticky=E,
            )
        
# ... use entry field for field
        self.varEntryEnterDatabaseFieldDelete = StringVar()
#        if self.comboboxDbFieldSelect.get():
        self.varEntryEnterDatabaseFieldDelete.set(
            self.comboboxDbFieldSelect.get()
            )
        self.entryEnterDatabaseFieldDelete = Entry(
            frame_20,
            textvariable=self.varEntryEnterDatabaseFieldDelete,
            width=30,
            disabledforeground='black',
            disabledbackground='white',
            state='disabled',
            )
        self.entryEnterDatabaseFieldDelete.grid(
            row=0,
            column=1,
            padx=5,
            pady=5,
            sticky=W,
            )
            
# widgets for Delete and Cancel buttons
        self.buttonOkEnterDatabaseFieldDelete = Button(
            frame_20,
            text='Delete field',
            borderwidth=3,
            relief=RAISED,
            justify=CENTER,
            background='white',
            foreground='blue',
            font=self.buttonFontSmall,
            width=10,
            command=self.handlerDatabaseFieldDeleteOneField,
            )
        self.buttonOkEnterDatabaseFieldDelete.grid(
            row=1,
            column=1,
            padx=5,
            pady=5,
            sticky=N,
            )
            
        self.buttonCancelEnterDatabaseFieldDelete = Button(
            frame_30,
            text='Cancel',
            borderwidth=5,
            relief=RAISED,
            justify=CENTER,
            width=20,
            command=self.handlerToplevelFieldDeleteDestroy,
            )
        self.buttonCancelEnterDatabaseFieldDelete.grid(
            row=0,
            column=0,
            padx=5,
            pady=10,
            ) 
        
        return
        
        
    def handlerToplevelFieldDeleteDestroy(self):
        '''
        Purpose:
            destroy 'Delete Field' window
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerToplevelFieldDeleteDestroy')

# save location for next time window is opened
        self.deleteField_xWindowLocation = \
            self.toplevelFieldDelete.winfo_rootx() - self.offsetWindowX
        self.deleteField_yWindowLocation = \
            self.toplevelFieldDelete.winfo_rooty() - self.offsetWindowY

# destroy current toplevel            
        self.toplevelFieldDelete.destroy()
        
        return
        

    def handlerDatabaseFieldDeleteOneField(self):
        '''
        Purpose:
        Delete one field in the selected table in the selected database
        
        Called by:
        handlerDatabaseFieldsDelete
        
        Input variables:
        self.comboboxEnterDatabaseFieldDelete       # field to delete
        self.entryEnterDatabaseFieldDeleteTables    # table from which field will be delete
        self.entryEnterDatabaseFieldDeleteDatabases # database in which table and field are located
        .
        self.myDatabases                            # all current databases
        self.myDatabaseTables                       # all current tables
        self.myDatabaseFields                       # all current fields
        
        
        Ouput variables:
        
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerDatabaseFieldDeleteOneField')
            
        myDatabase = self.entryEnterDatabaseFieldDeleteDatabases.get().strip()
        myTable = self.entryEnterDatabaseFieldDeleteTables.get().strip()
#        myField = self.comboboxEnterDatabaseFieldDelete.get().split('.')[1].strip()
#        myFieldWithNumber = self.comboboxEnterDatabaseFieldDelete.get().strip()

        try:
            myFieldWithNumber = self.varEntryEnterDatabaseFieldDelete.get().strip()
            myField = myFieldWithNumber.split('.')[1].strip()
        except:
            myField = ''
        
# check that all fields are valid
#        if self.comboboxEnterDatabaseFieldDelete.get():
        if(
        myDatabase == ''
        or
        myTable == ''
        or
        myField == ''
        ):
            stringNoData = ''
            if myDatabase == '':
                stringNoData += (
                    ' - database\n'
                    )
            if myTable == '':
                stringNoData += (
                    ' - table\n'
                    )
            if myField == '':
                stringNoData += (
                    ' - field\n'
                    )
            stringInvalidData = (
                'The following entries are missing:\n\n' +
                '%s\n'
                'Select the missing values from the main window\n' +
                'and try again.'
                ) % stringNoData
            print('\n' + stringInvalidData)
            self.MySQL_Output(
                0,
                stringInvalidData
                )
            showerror(
                'Error: missing entries',
                stringInvalidData
                )
            return        
        
        self.MySQL_Output(
            0,
            ' myField = ' + myField + '\n' +
            ' myTable = ' + myTable + '\n' +
            ' myDatabase = ' + myDatabase
            )
            
        self.MySQL_Output(
            1,
            'List of databases available:'
            )
        self.MySQL_Output(
            0,
            self.myDatabases
            )
        
# check database
        for database in self.myDatabases:
            if database == myDatabase:
# ... check table
                for table in self.myDatabaseTables:
                    if table == myTable:
# ... check field
                        for field in self.myDatabaseFields:
                            if field == myField:
# ... ok to delete field
# ...... specify database to use
                                self.MySQL_Commands(
                                    1,
                                    'self.cursorHandleMySQL.execute("USE' + ' ' + myDatabase + '")'
                                    )
                                self.cursorHandleMySQL.execute('USE' + ' ' + myDatabase)
# ...... assemble delete string
                                '''
                                if len(self.myDatabaseFields) == 1:
                                    self.MySQL_Output(
                                        1,
                                        'Warning: deleting the last field of a table will delete the table.\n'
                                        )
                                    ans = askokcancel(
                                        'WARNING: last field of table',
                                        '\nYou are about to delete the last field of table\n\n' + 
                                        '"' + myTable + '"\n\n' +
                                        'which will also delete the table, since MySQL does not\n' +
                                        'allow empty tables.\n\n' +
                                        'Click OK to continue, or CANCEL to quit this process.\n\n'
                                        )
                                    if ans:
                                        self.MySQL_Output(
                                            1,
                                            'Deleting last field "' + myField + '" as well as its including table "' + 
                                            myTable + '"'
                                            )
                                        stringDeleteTable = 'DROP TABLE ' + myTable
                                        self.MySQL_Commands(
                                            1,
                                            'self.cursorHandleMySQL.execute("' + stringDeleteTable + '")'
                                            )
                                        self.cursorHandleMySQL.execute(stringDeleteTable)
# ... refresh both Tables and Fields main windows
# ...... relist the fields in the main window
#                                        self.refreshFields()
                                        self.clearDbFields()
# ...... relist the tables in the main window           
# ............ get new Tables list
                                        self.mysql_GetDatabaseTables()
# ............ if no table left, clear field
                                        if len(self.myDatabaseTables) == 0:
# ............ clear Tables window
                                            self.clearDbTables()
                                        else:
# ............ regrid Tables window
                                            self.mysql_ComboDatabaseTables()
                                            
                                        return
                                        
                                    else:
                                        self.MySQL_Output(
                                            1,
                                            'Canceled deleting the last field of table ' + myTable
                                            )
                                        return
                    
                                else:
                                '''
                                ans = askokcancel(
                                    'Delete field...',
                                    '\nYou are about to delete field\n\n' +
                                    '"' + myField +'"\n\n' +
                                    'from table\n\n' +
                                    '"' + myTable + '"\n\n' +
                                    'located in database\n\n' +
                                    '"' + myDatabase + '"\n\n' +
                                    'Click on OK to continue, or Cancel to\n' +
                                    'stop this process.\n\n'
                                    )
                                    
                                if ans:
                                    
                                    stringDeleteField = 'ALTER TABLE' + ' ' + myTable + ' ' + 'DROP' + ' ' + myField
                                    self.MySQL_Commands(
                                        1,
                                        'self.cursorHandleMySQL.execute("' + stringDeleteField + '")'
                                        )
                                    self.MySQL_Output(
                                        1,
                                        'Deleting field "' + myField + '" ' + 'from table' + ' "' + myTable + '"'
                                        )
# ...... delete the field
                                    try:
                                        self.cursorHandleMySQL.execute(stringDeleteField)
                                    except:
                                        stringCannotDeleteField = (
                                            'Unable to delete the field\n' +
                                            ' - %s\n\n' +
                                            'Possible errors are:\n' +
                                            ' > unallowed characters are in name\n' +
                                            ' > duplicate field names\n' +
                                            ' > name is a keyword\n\n' +
                                            'Inspect the field name for errors and try again.'
                                            ) % (
                                            field
                                            )
                                        print('\n' + stringCannotDeleteField)
                                        self.MySQL_Output(
                                            0,
                                            stringCannotDeleteField
                                            )
                                        try:
                                            showerror(
                                                'Error: unable to delete field',
                                                stringCannotDeleteField,
                                                parent=self.frameParent
                                                )
                                        except:
                                            showerror(
                                                'Error: unable to delete field',
                                                stringCannotDeleteField
                                                )
                                        return
# ...... relist the fields in the main window
#   ...     get list of fields from database
                                    self.refreshFields()
#   ...     re-graph combobox for fields
                                    self.mysql_ComboDatabaseFields()
#   ...     
                                    self.handlerDatabaseFieldsDelete()
                                    
# update table values only if current DELETE FIELD database and table correspond to  
#   the displayed database and table  
                                    try:
                                        mapped = self.toplevelTableValues.winfo_exists()
                                    except:
                                        mapped = False
                                
                                    if mapped:
# make sure databases and tables are same for ADD FIELD and for the displayed table values; 
#   otherwise, don't need to update
                                        if (
                                        self.databaseDisplayedTableValues == self.varEnterDatabaseFieldDeleteDatabases.get().strip()
                                        and
                                        self.tableDisplayedTableValues == self.varEnterDatabaseFieldDeleteTables.get().strip()
                                        ):
                                            self.handlerDisplayLimitedRows()    # PEEK handler
# update filter window
                                            try:
                                                mapped = self.toplevelSelectDisplayOrderedFields.winfo_exists()
                                            except:
                                                mapped = False
            
                                            if mapped:
                                                self.handlerSelectDisplayOrderedFields_Update()
                                                
# kill the Quik-Select window
                                            self.handlerQuikSelectCancelWindow()   
                                        
                                            return
                                        
                                else:
                                    self.MySQL_Output(
                                        1,
                                        'Delete has been canceled.'
                                        )
# ...... we are done
                                return
                           
# ... field error                            
                        self.MySQL_Output(
                            1,
                            'Error: the field you selected does not' + '\n' +
                            'exist in the current list of fields.'
                            )
                        showerror(
                            'Error: invalid field',
                            '\nThe field you selected,\n\n' +
                            myField + '\n' +
                            '\ndoes not exist in the current list of fields.\n' +
                            '\nPlease re-enter a valid field name.\n\n'
                            )
                        return                   
# ... table error                    
                self.MySQL_Output(
                    1,
                    'Error: the table you selected does not' + '\n' +
                    'exist in the current list of tables.'
                    )
                showerror(
                    'Error: invalid table',
                    '\nThe table you selected,\n\n' +
                    myTable + '\n' +
                    '\ndoes not exist in the current list of tables.\n' +
                    '\nPlease re-enter a valid table name.\n\n'
                    )
                return
# ... database error           
        self.MySQL_Output(
            1,
            'Error: the database you selected does not' + '\n' +
            'exist in the current list of databases.'
            )
        showerror(
            'Error: invalid database',
            '\nThe database you selected,\n\n' +
            myDatabase + '\n' +
            '\ndoes not exist in the current list of databases.\n' +
            '\nPlease re-enter a valid database name.\n\n'
            )
            
        return
                    
        
    def handlerDatabaseFieldsFunctions(self):
        '''
        Purpose:
        Various functions that act on fields, such as:
            > show all values for the selected field, listed with 'key' values ('key' values are unique)
            
        
        Called by:
        createWidgets
        
        Input variables:
        
        Output variables:
        
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerDatabaseFieldsFunctions')
            
        return
        
 
    def clearDbTables(self):
        '''
        reset Tables combobox and totals
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'clearDbTables')
        
# clear Tables combobox
        self.comboboxDbTableSelect.clear()
# reset total to zero
        self.varDbTablesTotal.set(0)
        
        return
        
        
    def clearDbFields(self):
        '''
        reset Fields combobox and totals
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'clearDbFields')
            
# clear Fields combobox
        self.comboboxDbFieldSelect.clear()
# reset total to zero
        self.varDbFieldsTotal.set(0)  
        
        return
        

    def MySQL_Commands(self,prepend,msg):
        '''
        Purpose:
        print to special I/O Windows if they exist; otherwise,
        print to standard output; can prepend prefix if desired.
        
        Inputs: 
        prepend
        msg
        Window: self.textMySQLCommandsWindows_IO
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'MySQL_Commands')
            
        if prepend != 0 and prepend != 1:
            self.wrongPrependValue(prepend,'Commands', MODULE)
            return
        
        if self.textMySQLCommandsWindows_IO:
# windows IO exist, so display there instead of stdout
            if prepend:
# use prefix         
                try:
                    self.textMySQLCommandsWindows_IO.insert(
                        END,
                        prefix + msg + '\n'
                        )
                except:
# separate since cannot combine list and tuple in one command
                    self.textMySQLCommandsWindows_IO.insert(
                        END,
                        prefix + ' '
                        )
                    self.textMySQLCommandsWindows_IO.insert(
                        END,
                        msg
                        )
                    self.textMySQLCommandsWindows_IO.insert(
                        END,
                        '\n'
                        )
                        
            else:
# do not use prefix
                try:
                    self.textMySQLCommandsWindows_IO.insert(
                        END,
                        msg + '\n'
                        )
                except:
                    self.textMySQLCommandsWindows_IO.insert(
                        END,
                        msg
                        )
                    self.textMySQLCommandsWindows_IO.insert(
                        END,
                        ' ' + '\n'
                        )
            self.textMySQLCommandsWindows_IO.see(
                END
                )
        else:
            print msg
            
        self.textMySQLCommandsWindows_IO.update_idletasks()
        
        return
        
            
    def MySQL_Output(self,prepend,msg):
        '''
        Purpose:
        print to special I/O Windows if they exist; otherwise,
        print to standard output; can prepend prefix if desired.
        
        Inputs: 
        prepend
        msg
        Window: self.textMySQLOutputWindows_IO
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'MySQL_Output')
            
        if prepend != 0 and prepend != 1:
            self.wrongPrependValue(prepend,'Output', MODULE)
            return
            
        if self.textMySQLOutputWindows_IO:
# windows IO exist, so display there instead of stdout
            if prepend:
# use prefix
                try:
                    self.textMySQLOutputWindows_IO.insert(
                        END,
                        prefix + msg + '\n'
                        )
                except:
# separate since cannot combine list and tuple in one command
                    self.textMySQLOutputWindows_IO.insert(
                        END,
                        prefix + ' '
                        )
                    self.textMySQLOutputWindows_IO.insert(
                        END,
                        '\n'
                        )
            else:
# do not use prefix
                try:
                    self.textMySQLOutputWindows_IO.insert(
                        END,
                        msg + '\n'
                        )
                except:
                    self.textMySQLOutputWindows_IO.insert(
                        END,
                        msg
                        )
                    self.textMySQLOutputWindows_IO.insert(
                        END,
                        ' ' + '\n'
                        )
            self.textMySQLOutputWindows_IO.see(
                END
                )            
        else:
            if DEBUG_PRINT_MISC:
                print msg               
            
        self.textMySQLOutputWindows_IO.update_idletasks()
        
        return
        
            
    def handlerDeleteRow(self, tag, state):
        '''
        multiple radioselect buttons to allow for
        deleting rows in the displayed table
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerDeleteRow')
        
        if state:
            action = 'selected'
        else:
            action = 'cleared'
            
        self.MySQL_Output(
            1,
            'Delete-Row Button ' + tag + 'was ' + action + '\n' +
            'Selection: '
            )
        self.MySQL_Output(
            0,
            self.radioselectDeleteRow.getcurselection()
            )
        
        return

        
# ----------------------------------------------------------------------------
# misc defs
    def wrongPrependValue(self,value,window,module):
        '''
        Purpose:
        tell user that the wrong prepend value was used, and what
        module to check
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'wrongPrependValue')
            
        showerror(
            'Error: incorrect prepend value',
            '\nError in determining whether to prepend a\n' +
            'print statement with a prompt. The value must be\n' +
            'either 0 or 1. The current value is\n' +
            '   prepend = ' + value + '\n\n' +
            'Check code in the following file:\n' +
            '   ' + module + ' for the ' + window + ' window.' +  '\n' 
            )
            
        return 


# ===== handlers for scrolling =====
    def handlerXScrollTwoFrames(self,*args):
        '''
        allows synchronized scrolling of two frames
        '''
        self.canvas_11.xview(*args)
        self.canvas_22.xview(*args)
        
        return
        
    def handlerYScrollTwoFrames(self,*args):
        '''
        allows synchronized scrolling of two frames
        '''
        self.canvas_21.yview(*args)
        self.canvas_22.yview(*args)
        
        return
        
    def handlerXScrollOneFrame(self,*args):
        '''
        scrolls one frame only
        '''
        self.canvas_11.xview(*args)
        
        return
        
# for buffer storage
    def handlerXScrollTwoFramesBuffer(self,*args):
        '''
        allows synchronized scrolling of two frames
        '''
        self.canvas_11_Buffer.xview(*args)
        self.canvas_22_Buffer.xview(*args)
        
        return
        
    def handlerYScrollTwoFramesBuffer(self,*args):
        '''
        allows synchronized scrolling of two frames
        '''
        self.canvas_21_Buffer.yview(*args)
        self.canvas_22_Buffer.yview(*args)
        
        return
        
# ===== end of handlers for scrolling =====

# ==== scatter plots ======

    def handlerScatterPlotPreprocess(self):
        '''
        Generates SCATTER PLOT SPECS window; creates widgets for preprocessing plots
        
        Calls:
            handlerPlotScatterSelect
            
        Called by:
            handlerTableFunctionsShowValues
            
        Significant variables:
            self.varNumberOfTableCurves         IntVar                  entry field
                (self.entryNumberOfTableCurves)
            self.varNumberOfStorageBufferCurves        IntVar                  entry field
                (self.entryNumberOfBufferCurves)
            self.varNumberOfTotalCurves         IntVar                  entry field
                (self.entryNumberOfTotalCurves)
            -----
            self.varSingleCurvePerPlot          IntVar                  radiobutton
                (self.radiobuttonSingleCurvePerPlot)
            -----
            self.checkbuttonShowGrid_SingleCurvePerPlot                 checkbutton
            -----
            self.varAllCurvesOnePlot            IntVar                  radiobutton
                (self.radiobuttonAllCurvesOnePlot)
            -----
            self.checkbuttonShowTitle_AllCurvesOnePlot                  checkbutton
            -----
            self.varEntryShowTitle_AllCurvesOnePlot  StringVar               entry field
                (self.entryShowTitle_AllCurvesOnePlot)
            -----
            self.varShowLabelY_AllCurvesOnePlot StringVar               entry field
                (self.entryShowLabelY_AllCurvesOnePlot)
            -----
            self.checkbuttonShowLabelX_AllCurvesOnePlot                 checkbutton
            -----
            self.comboboxShowLabelX_AllCurvesOnePlot
            -----
            self.checkbuttonShowGrid_AllCurvesOnePlot                   checkbutton
            -----
            self.checkbuttonShowReferenceCurve_AllCurvesOnePlot         checkbutton
            -----
            self.comboboxShowReferenceCurveMultiplier_AllCurvesOnePlot  combobox
            -----
            self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot     combobox
            -----
            
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerScatterPlotPreprocess')
            
# set last button pressed
        self.lastButtonPressed(
            BUTTONLABEL_SCATTERPLOTS
            )
            
        self.MySQL_Output(
            0,
            '  Database: ' + self.myDatabase + '  Table: ' +
            self.myTable
            )
        
# background color
        colorbg='lightyellow'
                
# from STORAGE BUFFER
#   (number of Storage Buffer curves total: len(self.varSelectAnyRow_Buffer)


#        jcountBuffer = 0
#        self.jcountBuffer = 0
#        self.listWhichBufferRowsAreChecked = []
#        inumWhichBufferRowsAreChecked = 0
        
        
# if plot window is mapped (displayed), then if 'Include select curves from Storage Buffer' is checked, calculate number of curves
# ... if not, leave count at zero.
# if plot window is NOT mapped, then assume 'Include select curves from Storage Buffer' is checked if self.jcountBuffer is greater than zero
# ... otherwise, if self.jcountBuffer is zero, leave unchecked
        
                
                
# always destroy and regenerate legend label generation window
        try:
            self.labels_xWindowLocationAll = self.toplevelLegendLabelsScatterPlot.winfo_rootx() - self.offsetWindowX
            self.labels_yWindowLocationAll = self.toplevelLegendLabelsScatterPlot.winfo_rooty() - self.offsetWindowY
            self.toplevelLegendLabelsAllCurvesOnePlot.destroy()
        except:
            pass
            
# ... see if main plot window is open              
        try:
            mappedPlotPreprocess_Scatter = self.toplevelScatterPlotPreprocess.winfo_exists()
        except:
            mappedPlotPreprocess_Scatter = False
            
# ... see if storage buffer window is open           
        try:
            mappedShowStorageBuffer = self.toplevelShowStorageBuffer.winfo_exists()
        except:
            mappedShowStorageBuffer = False

# if plot window exists, determine how many storage buffer rows have been selected       
        jcountBuffer_Scatter = 0
        self.listWhichBufferRowsAreChecked_Scatter = []
        
        if mappedShowStorageBuffer:
# storage buffer window is open
            for (inum,var) in enumerate(self.varSelectAnyRow_Buffer):
#                inumWhichBufferRowsAreChecked += 1
                if var.get(): 
                    jcountBuffer_Scatter += 1
                    self.listWhichBufferRowsAreChecked_Scatter.append(
#                        inumWhichBufferRowsAreChecked
                        inum + 1
                        )
                        
# display number of rows selected
            self.varEntryNumberOfRowsSelected_Buffer.set(jcountBuffer_Scatter)

            if mappedPlotPreprocess_Scatter:
# scatter plot window is displayed
                if self.jcountTable_Scatter <> self.varNumberOfTableCurves_Scatter.get():
                    if DEBUG_SCATTER:
                        print '\n#1'
                    if self.varCheckbuttonBufferData.get():
                        self.jcountBuffer_Scatter = jcountBuffer_Scatter
                    else:
                        self.jcountBuffer_Scatter = 0
                    
                elif (
                 self.varCheckbuttonBufferData.get()
                  and
                 self.varNumberOfStorageBufferCurves_Scatter.get() == jcountBuffer_Scatter
                  and
                 self.varNumberOfStorageBufferCurves_Scatter.get() <> 0
                  ):
                    if DEBUG_SCATTER:
                        print '\n#2'
                    self.jcountBuffer_Scatter = jcountBuffer_Scatter
                    
                elif (
                self.varCheckbuttonBufferData_Scatter.get()
                and
                self.varNumberOfStorageBufferCurves_Scatter.get() == 0
                ):
                    if jcountBuffer_Scatter == 0:
                        if DEBUG_SCATTER:
                            print '\n#3'
                        self.jcountBuffer_Scatter = 0
                    else:
                        self.jcountBuffer_Scatter = jcountBuffer_Scatter
                    
                elif (
                 self.varNumberOfStorageBufferCurves_Scatter.get() == 0
                  and
                 jcountBuffer_Scatter > 0
                  ):
                    if DEBUG_SCATTER:
                        print '\n#4'
                    self.varCheckbuttonBufferData_Scatter.set(1)
                    self.jcountBuffer_Scatter = jcountBuffer_Scatter
                    
                elif (
                self.varNumberOfStorageBufferCurves_Scatter.get() <> 0
                and
                self.varCheckbuttonBufferData_Scatter.get() == 1
                ):
                    if DEBUG_SCATTER:
                        print '\n#5'
                    self.jcountBuffer_Scatter = jcountBuffer_Scatter
                    
                else:
                    if DEBUG_SCATTER:
                        print '\n#6'
                    self.jcountBuffer_Scatter = 0
            else:
                if DEBUG_SCATTER:
                    print '\n#7'
                self.jcountBuffer_Scatter = jcountBuffer_Scatter
        else:
# storage buffer window is NOT displayed
            if mappedPlotPreprocess_Scatter:
                if self.varCheckbuttonBufferData_Scatter.get():
                    if DEBUG_SCATTER:
                        print '\n#8'
                    self.jcountBuffer_Scatter = jcountBuffer_Scatter
                else:
                    if DEBUG_SCATTER:
                        print '\n#9'
                    self.jcountBuffer_Scatter = 0
            else:
                if DEBUG_SCATTER:
                    print '\n#10'
                self.jcountBuffer_Scatter = jcountBuffer_Scatter
                

        if mappedPlotPreprocess_Scatter:
            self.previousWindow_Scatter = True

# save current state of window variables, to restore after toplevel is regenerated

# ... include table data
            includeTableData_checkbutton_status = self.varCheckbuttonTableData_Scatter.get()
            numberOfPreviousTableCurves = self.varNumberOfTableCurves_Scatter.get()
            
# ... include buffer data
            includeBufferData_checkbutton_status = self.varCheckbuttonBufferData_Scatter.get()
            numberOfPreviousStorageBufferCurves = self.varNumberOfStorageBufferCurves_Scatter.get()
            
# ... replot
            replot_checkbutton_status = self.varReplotInCurrentWindow_Scatter.get()
            
# ... erase previous plot
            keep_previous_plot_status = self.varKeepPreviousPlotInCurrentWindow_Scatter.get()
            
# ... plot style radiobutton
            plot_Style_Scatter = self.var_radiobuttonPlotStyle_Scatter.get()

# ... base for log plots
            plot_BaseForLogPlotsX = self.comboboxBaseForLogPlotsX_Scatter.get()
            plot_BaseForLogPlotsY = self.comboboxBaseForLogPlotsY_Scatter.get()
            
# ... connect data points with dashed line
            connectDataPoints = self.varCheckbuttonConnectDataMarkers_Scatter.get()
            
# ... line width
            lineWidthAllPlots = self.comboboxLineWidthPlots_Scatter.get()
            
# ... marker size
            markerSizeAllPlots = self.comboboxMarkerSizePlots_Scatter.get()

# ... all - show titles
            all_showTitles_checkbutton_status = self.varCheckbuttonShowTitle_AllCurvesOnePlot_Scatter.get()
            all_showTitles_entryfield_value = self.varEntryShowTitle_AllCurvesOnePlot_Scatter.get()
            all_fontTitles_combobox_value = self.comboboxFontTitle_AllCurvesOnePlot_Scatter.get()
            all_colorTitles_combobox_value = self.comboboxColorTitle_AllCurvesOnePlot_Scatter.get()
            
# ... all - show y label
            all_showYLabel_checkbutton_status = self.varCheckbuttonShowLabelY_AllCurvesOnePlot_Scatter.get()
            all_showYLabel_entryfield_value = self.varEntryShowLabelY_AllCurvesOnePlot_Scatter.get().strip()  
            
# ... all - show x label
            all_showXLabel_checkbutton_status = self.varCheckbuttonShowLabelX_AllCurvesOnePlot_Scatter.get()
            
# ... all - x label entry
# ...       account for fact that self.headerNames_X[0] can be undefined if no table or buffer values 
# ...           have been selected
            try:
                all_showXLabel_entryfield_value = self.comboboxShowLabelX_AllCurvesOnePlot_Scatter.get()
            except:
                all_showXLabel_entryfield_value = ''
                
# ... all xy-label font
            all_fontXYLabels_combobox_values = self.comboboxFontXYLabels_AllCurvesOnePlot_Scatter.get()
            
# ... all xy-label color
            all_colorXYLabels_combobox_value = self.comboboxColorXYLabels_AllCurvesOnePlot_Scatter.get()
            
# ... all - show legend
            all_showLegend_checkbutton_status = self.varCheckbuttonShowLegend_AllCurvesOnePlot_Scatter.get()
            all_showLegend_combobox_value = self.comboboxShowLegendLocation_AllCurvesOnePlot_Scatter.get()
            all_fontLegend_combobox_value = self.comboboxFontLegend_AllCurvesOnePlot_Scatter.get()
            all_showLegendShadow_checkbutton_status = self.varCheckbuttonShowLegendShadow_AllCurvesOnePlot_Scatter.get()
            
# ... all - show grid
            all_showGrid_checkbutton_status = self.varCheckbuttonShowGrid_AllCurvesOnePlot_Scatter.get()

# ... all - show curve fit using polynomial
            all_showCurveFit_checkbutton_status = \
                self.varCheckbuttonShowPolynomialCurveFit_AllCurvesOnePlot_Scatter.get()
            all_showCurveFit_polynomial_degree = \
                self.comboboxPolynomialDegree_AllCurvesOnePlot_Scatter.get()
            all_showCurveFit_number_of_points_used = \
                self.comboboxPolynomialNumberOfPoints_AllCurvesOnePlot_Scatter .get()
            all_showCurveFit_coefficient_decimal_places = \
                self.comboboxPolynomialCoefficientDecimalPlaces_AllCurvesOnePlot_Scatter.get()
            all_showCurveFit_coefficient_output_format = \
                self.comboboxPolynomialCoefficientOutputFormat_AllCurvesOnePlot_Scatter.get()
            all_plotLesserDegreePolynomials_checkbutton_status = \
                self.varCheckbuttonPlotAllLesserDegreePolynomials_AllCurvesOnePlot_Scatter.get()
            
# ... all - show reference curve
            all_showRefCurve_checkbutton_status = \
                self.varCheckbuttonShowReferenceCurve_AllCurvesOnePlot_Scatter.get()
            all_showRefCurve_Multiplier_combobox_value = \
                self.comboboxShowReferenceCurveMultiplier_AllCurvesOnePlot_Scatter.get()

# ... all = show sloped straight line reference curve
            all_showSlopedStraightLineRefCurve_checkbutton_status = \
                self.varCheckbuttonShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter.get()
            all_showSlopedStraightLineRefCurve_x_initial = \
                self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xinitial_Scatter.get()
            all_showSlopedStraightLineRefCurve_x_final = \
                self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xfinal_Scatter.get()
            all_showSlopedStraightLineRefCurve_y_initial = \
                self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yinitial_Scatter.get()
            all_showSlopedStraightLineRefCurve_y_final = \
                self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yfinal_Scatter.get()
            all_showSlopedStraightLineRefCurve_UserLabel_checkbutton_status = \
                self.varCheckbuttonLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter.get()
            all_showSlopedStraightLineRefCurve_UserLabel = \
                self.entryfieldLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter.get()
            all_showSlopedStraightLineRefCurve_ShowSlope_checkbutton_status = \
                self.varCheckbuttonLabelSlopeDegreesSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter.get()
                
# ... all - show horizontal straight line reference curve
            all_showHorizontalStraightLineRefCurve_checkbutton_status = \
                self.varCheckbuttonShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter.get()
            all_showHorizontalStraightLineRefCurve_x_initial = \
                self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xinitial_Scatter.get()
            all_showHorizontalStraightLineRefCurve_x_final = \
                self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xfinal_Scatter.get()
            all_showHorizontalStraightLineRefCurve_y = \
                self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Y_Scatter.get()
            all_showHorizontalStraightLineRefCurve_UserLabel_checkbutton_status = \
                self.varCheckbuttonLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter.get()
            all_showHorizontalStraightLineRefCurve_UserLabel = \
                self.entryfieldLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter.get()
            all_showHorizontalStraightLineRefCurve_yValue_checkbutton_status = \
                self.varCheckbuttonLabelYMaxHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter.get()
                
# ... all - show vertical straight line reference curve
            all_showVerticalStraightLineRefCurve_checkbutton_status = \
                self.varCheckbuttonShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Scatter.get()
            all_showVerticalStraightLineRefCurve_y_initial = \
                self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yinitial_Scatter.get()
            all_showVerticalStraightLineRefCurve_y_final = \
                self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yfinal_Scatter.get()
            all_showVerticalStraightLineRefCurve_x = \
                self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_X_Scatter.get()
            all_showVerticalStraightLineRefCurve_UserLabel_checkbutton_status = \
                self.varCheckbuttonLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot_Scatter.get()
            all_showVerticalStraightLineRefCurve_UserLabel = \
                self.entryfieldLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot_Scatter.get()
            all_showVerticalStraightLineRefCurve_XValue_checkbutton_status = \
                self.varCheckbuttonLabelXMaxVerticalStraightLineReferenceCurve_AllCurvesOnePlot_Scatter.get()
                
# ... all - plot x-y data from CSV file
            all_plotCsvFileData_checkbutton_status = self.varCheckbuttonPlotCsvFileData_AllCurvesOnePlot_Scatter.get()
            all_plotCsvFileData_entry_value = self.varEntryPlotCsvFileData_AllCurvesOnePlot_Scatter.get()
            all_plotCsvFileData_x_column_value = self.comboboxPlotCsvFileData_X_Column_AllCurvesOnePlot_Scatter.get()
            all_plotCsvFileData_y_column_value = self.comboboxPlotCsvFileData_Y_Column_AllCurvesOnePlot_Scatter.get()

# ... all - x-ticks size and color
            all_fontXTicks_combobox_value = self.comboboxFontXTicks_AllCurvesOnePlot_Scatter.get()
            all_colorXTicks_combobox_value = self.comboboxColorXTicks_AllCurvesOnePlot_Scatter.get()
            
# ... all - y-ticks size and color
            all_fontYTicks_combobox_value = self.comboboxFontYTicks_AllCurvesOnePlot_Scatter.get()
            all_colorYTicks_combobox_value = self.comboboxColorYTicks_AllCurvesOnePlot_Scatter.get()
            
# ... all - background color
            all_colorBackground_combobox_value = self.comboboxColorBackground_AllCurvesOnePlot_Scatter.get()
            
# ... all - plot border color
            all_colorPlotBorder_combobox_value = self.comboboxColorPlotBorder_AllCurvesOnePlot_Scatter.get()
            
# now destroy window 
            self.plottingspecs_xWindowLocation_Scatter= self.toplevelScatterPlotPreprocess.winfo_rootx() - self.offsetWindowX
            self.plottingspecs_yWindowLocation_Scatter= self.toplevelScatterPlotPreprocess.winfo_rooty() - self.offsetWindowY
            self.toplevelScatterPlotPreprocess.destroy()
            
# will regenerate below, then reapply settings
        else:
            if DEBUG_SCATTER:
                print(
                    '\nDEBUG: not saving state\n'
                    )
            self.previousWindow_Scatter = False
            

# open Toplevel frame for entering database name
        self.toplevelScatterPlotPreprocess = Toplevel(
            self.toplevelTableValues,
            bg=colorbg,
            )
        self.toplevelScatterPlotPreprocess.title(
            'Server: ' + self.comboServerMySQL.get() + '     ' +
            'Database: ' + self.varTableFunctionsSelectDatabase.get() + '     ' +
            'Table: ' + self.varEntryTableFunctionsSelectTable.get().strip()
            )

        self.toplevelScatterPlotPreprocess.transient(self.toplevelTableValues)
        
# place the top window
        self.toplevelScatterPlotPreprocess.geometry(
            '+%d+%d' % (
                        self.plottingspecs_xWindowLocation_Scatter,
                        self.plottingspecs_yWindowLocation_Scatter
                        )
            )        
            
# Row 0
        rowFrame = 0
# ... title frame
        frame_00 = Frame(
            self.toplevelScatterPlotPreprocess,
            bg=colorbg,
#                            relief=RIDGE,
#                            borderwidth=2,
            )
        frame_00.grid(
            row=rowFrame,
            column=0,
            padx=2,
            pady=1,
            )
# ... number of curves
        rowFrame += 1
        frame_05 = Frame(
            self.toplevelScatterPlotPreprocess,
            bg=colorbg,
            )
        frame_05.grid(
            row=rowFrame,
            column=0,
            padx=5,
            pady=1,
            sticky=E+W,
            )
# plots from storage buffer
        rowFrame += 1
        frame_12 = Frame(
            self.toplevelScatterPlotPreprocess,
            bg=colorbg,
            )
        frame_12.grid(  
            row=rowFrame,
            column=0,
            padx=2,
            pady=1,
            sticky=E+W,
            )
        rowFrame += 1
        frame_14 = Frame(
            self.toplevelScatterPlotPreprocess,
            bg=colorbg,
            )
        frame_14.grid(  
            row=rowFrame,
            column=0,
            padx=2,
            pady=1,
            sticky=E+W,
            )
        rowFrame += 1
        frame_15 = Frame(
            self.toplevelScatterPlotPreprocess,
            bg=colorbg,
            )
        frame_15.grid(  
            row=rowFrame,
            column=0,
            padx=20,
            pady=1,
            sticky=E+W,
            )
            
# ... number of curves
        rowFrame += 1
        frame_10 = Frame(
            self.toplevelScatterPlotPreprocess,
            bg=colorbg,
            )
        frame_10.grid(
            row=rowFrame,
            column=0,
            padx=2,
            pady=1,
            sticky=E+W,
            )
# ... plot style
        rowFrame += 1
        frame_11 = Frame(
            self.toplevelScatterPlotPreprocess,
            bg=colorbg,
            )
        frame_11.grid(
            row=rowFrame,
            column=0,
            padx=2,
            pady=1,
            sticky=E+W
            )
# ... connect data points with dashed line
        rowFrame += 1
        frame_11a = Frame(
            self.toplevelScatterPlotPreprocess,
            bg=colorbg,
            )
        frame_11a.grid(
            row=rowFrame,
            column=0,
            padx=2,
            pady=1,
            sticky=E+W
            )     
# ... line width, marker size
        rowFrame += 1
        frame_11b = Frame(
            self.toplevelScatterPlotPreprocess,
            bg=colorbg,
            )
        frame_11b.grid(
            row=rowFrame,
            column=0,
            columnspan=99,
            padx=2,
            pady=1,
#            sticky=E+W
            )                    

# for line separator
        rowFrame += 1
        frame_13 = Frame(
            self.toplevelScatterPlotPreprocess,
            bg=colorbg,
            )
        frame_13.grid(  
            row=rowFrame,
            column=0,
#            columnspan=99,
            padx=2,
            pady=1,
            sticky=E+W,
            )

# ... show title, x label, y label, plot grid
        rowFrame += 1
        self.frame_60_Scatter = Frame(
            self.toplevelScatterPlotPreprocess,
            bg=colorbg,
            )
        self.frame_60_Scatter.grid(
            row=rowFrame,
            column=0,
            padx=30,
            pady=1,
            sticky=W,
            )
# ... polynomial curve fit
        rowFrame += 1
        self.frame_65_Scatter = Frame(
            self.toplevelScatterPlotPreprocess,
            bg=colorbg,
            )
        self.frame_65_Scatter.grid(
            row=rowFrame,
            column=0,
            padx=30,
            pady=1,
            sticky=W,
            )
        rowFrame += 1
        self.frame_66_Scatter = Frame(
            self.toplevelScatterPlotPreprocess,
            bg=colorbg,
            )
        self.frame_66_Scatter.grid(
            row=rowFrame,
            column=0,
            padx=0,
            pady=1,
            sticky=W,
            )
# ... <field> times curve labeled <field>
        rowFrame += 1
        self.frame_70_Scatter = Frame(
            self.toplevelScatterPlotPreprocess,
            bg=colorbg,
            )
        self.frame_70_Scatter.grid(
            row=rowFrame,
            column=0,
            padx=30,
            pady=1,
            sticky=W,
            )
# ... sloped straight line reference curve
        rowFrame += 1
        frame_71 = Frame(
            self.toplevelScatterPlotPreprocess,
            bg=colorbg,
            )
        frame_71.grid(
            row=rowFrame,
            column=0,
            padx=30,
            pady=1,
            sticky=W,
            )
# ... label for sloped straight line reference curve
        rowFrame += 1
        frame_71a = Frame(
            self.toplevelScatterPlotPreprocess,
            bg=colorbg,
            )
        frame_71a.grid(
            row=rowFrame,
            column=0,
            padx=60,
            pady=1,
            sticky=W,
            )
# ... horizontal straight line reference curve
        rowFrame += 1
        frame_72 = Frame(
            self.toplevelScatterPlotPreprocess,
            bg=colorbg
            )
        frame_72.grid(
            row=rowFrame,
            column=0,
            padx=30,
            pady=1,
            sticky=W,
            )
# ... label for horizontal straight line reference curve
        rowFrame += 1
        frame_73 = Frame(
            self.toplevelScatterPlotPreprocess,
            bg=colorbg
            )
        frame_73.grid(
            row=rowFrame,
            column=0,
            padx=60,
            pady=1,
            sticky=W,
            )

# ... vertical straight line reference curve
        rowFrame += 1
        frame_74 = Frame(
            self.toplevelScatterPlotPreprocess,
            bg=colorbg
            )
        frame_74.grid(
            row=rowFrame,
            column=0,
            padx=30,
            pady=1,
            sticky=W,
            )
# ... label for vertical straight line reference curve
        rowFrame += 1
        frame_74a = Frame(
            self.toplevelScatterPlotPreprocess,
            bg=colorbg
            )
        frame_74a.grid(
            row=rowFrame,
            column=0,
            padx=60,
            pady=1,
            sticky=W,
            )            

            
# ... include plot data from file...
        rowFrame += 1
        frame_75 = Frame(
            self.toplevelScatterPlotPreprocess,
            bg=colorbg,
            )
        frame_75.grid(
            row=rowFrame,
            column=0,
            padx=30,
            pady=1,
            sticky=W,
            )
# ... x-y ticks, color, chart background color, chart border color
        rowFrame += 1
        self.frame_80_Scatter = Frame(
            self.toplevelScatterPlotPreprocess,
            bg=colorbg,
            )
        self.frame_80_Scatter.grid(
            row=rowFrame,
            column=0,
            padx=10,
            pady=5,
#            sticky=W,
            )
# ... for x-y tick marks font size, color, etc.            
        self.frame_80a_Scatter = Frame(
            self.frame_80_Scatter,
            bg=colorbg,
            )
        self.frame_80a_Scatter.grid(
            row=0,
            column=0,
            padx=5,
            pady=0,
            )
# ... for plot, close all plots, reset all, cancel
        frame_80b_Scatter = Frame(
            self.frame_80_Scatter,
            bg=colorbg,
            )
        frame_80b_Scatter.grid(
            row=0,
            column=1,
            padx=5,
            pady=0,
            )
            
            
# ... for bottom row, if needed
        '''
        frame_99 = Frame(
            self.toplevelScatterPlotPreprocess,
            bg=colorbg,
            )
        frame_99.grid(
            row=99,
            column=0,
            padx=1,
            pady=1,
            )
        '''

# WIDGETS
                
# ... title
        labelTitle = Label(
            frame_00,
            text='SCATTER PLOT SPECS',
            font=self.titleFontBig,
            justify=CENTER,
            bg=colorbg,
            )
        labelTitle.grid(
            row=0,
            column=0,
            )
            
# ... number of Table, Buffer, and Total curves
#...    table curves
        labelNumberOfTableCurves = Label(
            frame_05,
            text='Number of curves to plot from table:',
            justify=RIGHT,
            bg=colorbg,
            )
        labelNumberOfTableCurves.grid(
            row=0,
            column=0,
            padx=2,
            pady=0,
            sticky=E,
            )
# ... entry field
        self.varNumberOfTableCurves_Scatter = IntVar()
        self.entryNumberOfTableCurves_Scatter = Entry(
            frame_05,
            width=5,
            justify=LEFT,
            textvariable=self.varNumberOfTableCurves_Scatter,
            disabledbackground='white',
            disabledforeground='black',
            )
        self.entryNumberOfTableCurves_Scatter.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            sticky=W,
            )
#        self.entryNumberOfTableCurves.configure(state='normal')
        self.varNumberOfTableCurves_Scatter.set(self.jcountTable_Scatter)
        self.entryNumberOfTableCurves_Scatter.configure(state='disabled')
        
# ...   buffer curves
        labelNumberOfBufferCurves = Label(
            frame_05,
            text='  from storage buffer:',
            justify=RIGHT,
            bg=colorbg,
            )
        labelNumberOfBufferCurves.grid(
            row=0,
            column=2,
            padx=2,
            pady=0,
            sticky=E,
            )
# ... entry field
        self.varNumberOfStorageBufferCurves_Scatter = IntVar()
        self.entryNumberOfBufferCurves_Scatter = Entry(
            frame_05,
            width=5,
            justify=LEFT,
            textvariable=self.varNumberOfStorageBufferCurves_Scatter,
            disabledbackground='white',
            disabledforeground='black',
            )
        self.entryNumberOfBufferCurves_Scatter.grid(
            row=0,
            column=3,
            padx=0,
            pady=0,
            sticky=W,
            )
#        self.entryNumberOfTableCurves.configure(state='normal')
        self.varNumberOfStorageBufferCurves_Scatter.set(self.jcountBuffer_Scatter)
        self.entryNumberOfBufferCurves_Scatter.configure(state='disabled')

        if DEBUG_SCATTER:
            print('-'*50 + '\n')
            print('\n** In ' + MODULE + '/' + 'handlerScatterPlotPreprocess **')
            print('\nself.headerNames_X_Table_Scatter = %s' % self.headerNames_X_Table_Scatter)
            print('\nself.headerNames_Y_Table_Scatter = %s' % self.headerNames_Y_Table_Scatter)
            print('\nself.headerNames_X_Buffer_Scatter = %s' % self.headerNames_X_Buffer_Scatter)
            print('\nself.headerNames_Y_Buffer_Scatter = %s' % self.headerNames_Y_Buffer_Scatter)
            print('self.jcountTable_Scatter = %s' % self.jcountTable_Scatter)
            print('self.jcountBuffer_Scatter = %s' % self.jcountBuffer_Scatter)
            print('-'*50 + '\n')
        
# ...   total curves
        labelNumberOfTotalCurves = Label(
            frame_05,
            text='  Total plots (max displayed 25):',
            justify=RIGHT,
            bg=colorbg,
            )
        labelNumberOfTotalCurves.grid(
            row=0,
            column=4,
            padx=2,
            pady=0,
            sticky=E,
            )
# ... entry field
        self.varNumberOfTotalCurves_Scatter = IntVar()
        self.entryNumberOfTotalCurves_Scatter = Entry(
            frame_05,
            width=5,
            justify=LEFT,
            textvariable=self.varNumberOfTotalCurves_Scatter,
            disabledbackground='white',
            disabledforeground='black',
            )
        self.entryNumberOfTotalCurves_Scatter.grid(
            row=0,
            column=5,
            padx=0,
            pady=0,
            sticky=W,
            )
#        self.entryNumberOfTableCurves.configure(state='normal')
        self.varNumberOfTotalCurves_Scatter.set(self.jcountTable_Scatter + self.jcountBuffer_Scatter)
        self.entryNumberOfTotalCurves_Scatter.configure(state='disabled')
        
# FRAME 12

# Plot curves from Table 
        self.checkbuttonTableData_Scatter = Checkbutton(
            frame_12,
            bg=colorbg,
            variable=self.varCheckbuttonTableData_Scatter,
            command=self.handlerRefreshReferenceCurveList_Scatter,
            )
        self.checkbuttonTableData_Scatter.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            sticky=W,
            )       
        labelTableData = Label(
            frame_12,
            text='Plot curves from Table',
            justify=LEFT,
            bg=colorbg,
            )
        labelTableData.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            sticky=W,
            )
            
# filler label
        labelFiller = Label(
            frame_12,
            text='       ',
            justify=CENTER,
            bg=colorbg,
            )
        labelFiller.grid(
            row=0,
            column=2,
            padx=0,
            pady=0,
            )
            
# Plot curves from Storage Buffer
#        self.varCheckbuttonBufferData = IntVar()
        self.checkbuttonBufferData_Scatter = Checkbutton(
            frame_12,
            bg=colorbg,
            variable=self.varCheckbuttonBufferData_Scatter,
            command=self.handlerRefreshReferenceCurveList_Scatter,
            )
        self.checkbuttonBufferData_Scatter.grid(
            row=0,
            column=3,
            padx=0,
            pady=0,
            sticky=W,
            )
# ... label
        labelBufferData = Label(
            frame_12,
            text='Plot curves from Storage Buffer:',
            justify=LEFT,
            bg=colorbg,
            )
        labelBufferData.grid(
            row=0,
            column=4,
            padx=0,
            pady=0,
            sticky=W,
            )
 # ... show buffer details
        buttonDisplayBufferData = Button(
            frame_12,
            textvariable=self.countDisplayStorageBuffer,
            width=20,
            font=self.buttonFontSmallest,
            borderwidth=3,
            relief=RAISED,
            background='white',
            foreground='blue',
            command=self.handlerDisplayStorageBufferValues_Call,
            )
        buttonDisplayBufferData.grid(
            row=0,
            column=5,
            padx=5,
            pady=0,
            sticky=E,
            )
                    
# ... choice to re-plot in current plot window
        self.varReplotInCurrentWindow_Scatter = IntVar()
        self.checkbuttonReplotInCurrentWindow_Scatter = Checkbutton(
            frame_14,
            bg=colorbg,
            variable=self.varReplotInCurrentWindow_Scatter,
            command=self.handlerReplotInCurrentWindow_Scatter,
            )
        self.checkbuttonReplotInCurrentWindow_Scatter.grid(
            row=0,
            column=0,
#            columnspan=99,
            padx=0,
            pady=0,
            sticky=W,
            )
        labelReplotInCurrentWindow = Label(
            frame_14,
            text=(
                'Plot subsequent plots in current plot window'
                ),
            justify=LEFT,
            bg=colorbg,
            )
        labelReplotInCurrentWindow.grid(
            row=0,
            column=1,
            columnspan=99,
            padx=0,
            pady=0,
            sticky=W,
            )
#        self.checkbuttonReplotInCurrentWindow.deselect()
# ... choice to erase previous plot before re-plotting
        self.varKeepPreviousPlotInCurrentWindow_Scatter = IntVar()
        self.checkbuttonKeepPreviousPlotInCurrentWindow_Scatter = Checkbutton(
            frame_14,
            text=(
                'Show current curve(s) on next plot ' +
                '(legend will not show current curves)'
                ),
            justify=LEFT,
            bg=colorbg,
            variable=self.varKeepPreviousPlotInCurrentWindow_Scatter,
            )
        self.checkbuttonKeepPreviousPlotInCurrentWindow_Scatter.grid(
            row=1,
            column=1,
            columnspan=99,
            padx=0,
            pady=0,
            sticky=W,
            )
            
# ... plot style: 1) cartesian, 2) semilog-X, 3) semilog-Y, 4) log-log, and base (for log plots)
# ...       cartesian
        self.var_radiobuttonPlotStyle_Scatter = StringVar()
        self.radiobuttonPlotStyleCartesian_Scatter = Radiobutton(
            frame_11,
            variable=self.var_radiobuttonPlotStyle_Scatter,
            value='cartesian',
            text='Cartesian',
            bg=colorbg,
            command=self.handlerBaseForLogPlots_Scatter,
            )
        self.radiobuttonPlotStyleCartesian_Scatter.grid(
            row=0,
            column=0,
            padx=5,
            pady=1,
            sticky=W,
            )
# ...       semilog-X
        self.radiobuttonPlotStyleSemiLogX_Scatter = Radiobutton(
            frame_11,
            variable=self.var_radiobuttonPlotStyle_Scatter,
            value='semilogx',
            text='SemiLog-X',
            bg=colorbg,
            command=self.handlerBaseForLogPlots_Scatter,
            )
        self.radiobuttonPlotStyleSemiLogX_Scatter.grid(
            row=0,
            column=1,
            padx=5,
            pady=1,
            sticky=W,
            )
# ...       semilog-Y            
        self.radiobuttonPlotStyleSemiLogY_Scatter = Radiobutton(
            frame_11,
            variable=self.var_radiobuttonPlotStyle_Scatter,
            value='semilogy',
            text='SemiLog-Y',
            bg=colorbg,
            command=self.handlerBaseForLogPlots_Scatter,
            )
        self.radiobuttonPlotStyleSemiLogY_Scatter.grid(
            row=0,
            column=2,
            padx=5,
            pady=1,
            sticky=W,
            )
# ...       Log-log            
        self.radiobuttonPlotStyleLogLog_Scatter = Radiobutton(
            frame_11,
            variable=self.var_radiobuttonPlotStyle_Scatter,
            value='loglog',
            text='Log-Log',
            bg=colorbg,
            command=self.handlerBaseForLogPlots_Scatter,
            )
        self.radiobuttonPlotStyleLogLog_Scatter.grid(
            row=0,
            column=3,
            padx=5,
            pady=1,
            sticky=W,
            )
# ...       base for log plots along X axis
        self.comboboxBaseForLogPlotsX_Scatter = Pmw.ComboBox(
            frame_11,
            scrolledlist_items=self.baseForLogPlots,
            listheight=140,
            entry_width=7,
            label_text='Base for log plots:  X ',
            labelpos='w',
            label_background=colorbg,
            scrolledlist_hull_width=500,
            )
        self.comboboxBaseForLogPlotsX_Scatter.grid(
            row=0,
            column=4,
            padx=10,
            pady=1,
            sticky=W,
            )
# ...       base for log plots along Y axis
        self.comboboxBaseForLogPlotsY_Scatter = Pmw.ComboBox(
            frame_11,
            scrolledlist_items=self.baseForLogPlots,
            listheight=140,
            entry_width=7,
            label_text='  Y ',
            labelpos='w',
            label_background=colorbg,
            scrolledlist_hull_width=500,
            )
        self.comboboxBaseForLogPlotsY_Scatter.grid(
            row=0,
            column=5,
            padx=10,
            pady=1,
            sticky=W,
            )
            
# ...       connect identical data markers with dashed line
        self.varCheckbuttonConnectDataMarkers_Scatter = IntVar()
        self.checkbuttonConnectDataMarkers_Scatter = Checkbutton(
            frame_11a,
            bg=colorbg,
            variable=self.varCheckbuttonConnectDataMarkers_Scatter,
            command=self.handlerConnectSymbols_AllCurvesOnePlot_Scatter,
            )
        self.checkbuttonConnectDataMarkers_Scatter.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            sticky=W,
            )
        labelConnectDataMarkers_Scatter = Label(
            frame_11a,
            text=(
                'Connect identical datapoint symbols with dashed line'
                ),
            justify=LEFT,
            bg=colorbg,
            )
        labelConnectDataMarkers_Scatter.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            sticky=W,
            )
            
# ...       line width for curve fit only
        self.comboboxLineWidthPlots_Scatter = Pmw.ComboBox(
            frame_11b,
            scrolledlist_items=self.listLineWidth_Plots_Scatter,
            listheight=100,
            entry_width=4,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            label_text='Line width for curve fits: ',
            labelpos='w',
            label_background=colorbg,
            scrolledlist_hull_width=500,
            ) 
        self.comboboxLineWidthPlots_Scatter.grid(
            row=0,
            column=0,
            padx=5,
            pady=1,
            sticky=E,
            )
            
# ...       marker size for data points
        self.comboboxMarkerSizePlots_Scatter = Pmw.ComboBox(
            frame_11b,
            scrolledlist_items=self.listDataMarkerSize,
            listheight=120,
            entry_width=4,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            label_text='Symbol size for data points: ',
            labelpos='w',
            label_background=colorbg,
            scrolledlist_hull_width=500,
            ) 
        self.comboboxMarkerSizePlots_Scatter.grid(
            row=0,
            column=1,
            padx=5,
            pady=1,
            sticky=W,
            )
            
# ...       separator line
        labelSeparatorLine = Label(
            frame_13,
            text='-'*100,
            bg=colorbg,
            justify=CENTER,
            )
        labelSeparatorLine.grid(
            row=0,
            column=0,
            columnspan=99,
            padx=5,
            pady=1,
            sticky=E+W,
            )

# ... show title, x label, y label, plot grid, show reference curve
#       row 0
        self.varCheckbuttonShowTitle_AllCurvesOnePlot_Scatter = IntVar()
        self.checkbuttonShowTitle_AllCurvesOnePlot_Scatter = Checkbutton(
            self.frame_60_Scatter,
            bg=colorbg,
            variable=self.varCheckbuttonShowTitle_AllCurvesOnePlot_Scatter,
            command=self.handlerShowTitle_AllCurvesOnePlot_Scatter,
            )
        self.checkbuttonShowTitle_AllCurvesOnePlot_Scatter.grid(
            row=0,
            column=0,
            padx=2,
            pady=1,
            sticky=W,
            )
#        self.checkbuttonShowTitle_AllCurvesOnePlot_Scatter.configure(state='disabled')
        labelShowTitle_AllCurvesOnePlot = Label(
            self.frame_60_Scatter,
            text='Show title: ',
            bg=colorbg,
            justify=LEFT,
            )
        labelShowTitle_AllCurvesOnePlot.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            sticky=W,
            )
        self.varEntryShowTitle_AllCurvesOnePlot_Scatter = StringVar()
        self.entryShowTitle_AllCurvesOnePlot_Scatter = Entry(
            self.frame_60_Scatter,
            width=20,
            textvariable=self.varEntryShowTitle_AllCurvesOnePlot_Scatter,
            disabledbackground='lightgray',
            )
        self.entryShowTitle_AllCurvesOnePlot_Scatter.grid(
            row=0,
            column=2,
            padx=5,
            pady=0,
            sticky=W,
            )
# ...   title font
        self.comboboxFontTitle_AllCurvesOnePlot_Scatter = Pmw.ComboBox(
            self.frame_60_Scatter,
            scrolledlist_items=self.fontsizesChartTitle,
            listheight=150,
            label_text='size:',
            label_background=colorbg,
            labelpos='w',
            entry_width=5,
            scrolledlist_hull_width=500,
            )
        self.comboboxFontTitle_AllCurvesOnePlot_Scatter.grid(
            row=0,
            column=3,
            padx=5,
            pady=0,
            sticky=W,
            )

# ...   title color
        self.comboboxColorTitle_AllCurvesOnePlot_Scatter = Pmw.ComboBox(
            self.frame_60_Scatter,
            scrolledlist_items=self.colorsChartLabels,
            listheight=150,
            label_text='color:',
            label_background=colorbg,
            labelpos='w',
            entry_width=10,
            scrolledlist_hull_width=500,
            )
        self.comboboxColorTitle_AllCurvesOnePlot_Scatter.grid(
            row=0,
            column=4,
            padx=5,
            pady=0,
            sticky=W,
            )
        
#       row 1
        self.varCheckbuttonShowLabelY_AllCurvesOnePlot_Scatter = IntVar()
        self.checkbuttonShowLabelY_AllCurvesOnePlot_Scatter = Checkbutton(
            self.frame_60_Scatter,
            bg=colorbg,
            variable=self.varCheckbuttonShowLabelY_AllCurvesOnePlot_Scatter,
            command=self.handlerShowLabelY_AllCurvesOnePlot_Scatter,
            )
        self.checkbuttonShowLabelY_AllCurvesOnePlot_Scatter.grid(
            row=1,
            column=0,
            padx=2,
            pady=0,
            sticky=W,
            )
#        self.checkbuttonShowLabelY_AllCurvesOnePlot.configure(state='disabled')
        labelShowLabelY_AllCurvesOnePlot = Label(
            self.frame_60_Scatter,
            text='Show Y label (specify):',
            justify=LEFT,
            bg=colorbg,
            )
        labelShowLabelY_AllCurvesOnePlot.grid(
            row=1,
            column=1,
            padx=0,
            pady=0,
            sticky=W,
            )
        self.varEntryShowLabelY_AllCurvesOnePlot_Scatter = StringVar()
        self.entryShowLabelY_AllCurvesOnePlot_Scatter = Entry(
            self.frame_60_Scatter,
            width=20,
            textvariable=self.varEntryShowLabelY_AllCurvesOnePlot_Scatter,
            )
        self.entryShowLabelY_AllCurvesOnePlot_Scatter.grid(
            row=1,
            column=2,
            padx=5,
            pady=0,
            sticky=W,
            )
#        self.entryShowLabelY_AllCurvesOnePlot.configure(state='normal')
#        self.varShowLabelY_AllCurvesOnePlot.set('')
#        self.entryShowLabelY_AllCurvesOnePlot.configure(state='disabled')
        
#       row 2
        self.varCheckbuttonShowLabelX_AllCurvesOnePlot_Scatter = IntVar()
        self.checkbuttonShowLabelX_AllCurvesOnePlot_Scatter = Checkbutton(
            self.frame_60_Scatter,
            bg=colorbg,
            variable=self.varCheckbuttonShowLabelX_AllCurvesOnePlot_Scatter,
            command=self.handlerShowLabelX_AllCurvesOnePlot_Scatter,
            )
        self.checkbuttonShowLabelX_AllCurvesOnePlot_Scatter.grid(
            row=2,
            column=0,
            padx=2,
            pady=0,
            sticky=W,
            )
#        self.checkbuttonShowLabelX_AllCurvesOnePlot.configure(state='normal')
#        self.checkbuttonShowLabelX_AllCurvesOnePlot.select()
#        self.checkbuttonShowLabelX_AllCurvesOnePlot.configure(state='disabled')
        labelShowLabelX_AllCurvesOnePlot = Label(
            self.frame_60_Scatter,
            text='Show X label:',
            justify=LEFT,
            bg=colorbg,
            )
        labelShowLabelX_AllCurvesOnePlot.grid(
            row=2,
            column=1,
            padx=0,
            pady=0,
            sticky=W,
            )

        self.comboboxShowLabelX_AllCurvesOnePlot_Scatter = Pmw.ComboBox(
            self.frame_60_Scatter,
            scrolledlist_items=self.listitemsShowLabelX_AllCurvesOnePlot_Scatter,
            dropdown=1,
#            entry_state='normal',
            listheight=150,
            entry_width=20,
            entry_justify=LEFT,
            scrolledlist_hull_width=500,
            )
        self.comboboxShowLabelX_AllCurvesOnePlot_Scatter.grid(
            row=2,
            column=2,
            padx=5,
            pady=0,
            sticky=W,
            )
           
            
#        self.entryShowLabelX_AllCurvesOnePlot.configure(state='normal')
#        self.varShowLabelX_AllCurvesOnePlot.set(headerNameX)
#        self.entryShowLabelX_AllCurvesOnePlot.configure(state='disabled')

# ... x-y label font size
        self.comboboxFontXYLabels_AllCurvesOnePlot_Scatter = Pmw.ComboBox(
            self.frame_60_Scatter,
            scrolledlist_items=self.fontsizesChartLabels,
            listheight=140,
            label_text='size:',
            label_background=colorbg,
            labelpos='w',
            entry_width=5,
            scrolledlist_hull_width=500,
            )
        self.comboboxFontXYLabels_AllCurvesOnePlot_Scatter.grid(
            row=1,
            rowspan=2,
            column=3,
            padx=5,
            pady=0,
            sticky=W,
            )
# ... x-y label color    
        self.comboboxColorXYLabels_AllCurvesOnePlot_Scatter = Pmw.ComboBox(
            self.frame_60_Scatter,
            scrolledlist_items=self.colorsChartLabels,
            listheight=150,
            label_text='color:',
            label_background=colorbg,
            labelpos='w',
            entry_width=10,
            entry_state='disabled',
            scrolledlist_hull_width=500,
            )
        self.comboboxColorXYLabels_AllCurvesOnePlot_Scatter.grid(
            row=1,
            rowspan=2,
            column=4,
            padx=0,
            pady=0,
            sticky=W,
            )
    
# ... show legend
# ...       checkbutton
        self.varCheckbuttonShowLegend_AllCurvesOnePlot_Scatter = IntVar()
        self.checkbuttonShowLegend_AllCurvesOnePlot_Scatter = Checkbutton(
            self.frame_60_Scatter,
            bg=colorbg,
            variable=self.varCheckbuttonShowLegend_AllCurvesOnePlot_Scatter,
            command=self.handlerShowLegend_AllCurvesOnePlot_Scatter,
            )
        self.checkbuttonShowLegend_AllCurvesOnePlot_Scatter.grid(
            row=3,
            column=0,
            padx=2,
            pady=0,
            sticky=W,
            )
#        self.checkbuttonShowLegend_AllCurvesOnePlot.configure(state='disabled')
# ...       text
        labelShowLegend_AllCurvesOnePlot_Scatter = Label(
            self.frame_60_Scatter,
            text='Show legend, located ',
            justify=LEFT,
            bg=colorbg,
            )
        labelShowLegend_AllCurvesOnePlot_Scatter.grid(
            row=3,
            column=1,
            padx=0,
            pady=0,
            sticky=W
            )
# ...       legend location
        self.comboboxShowLegendLocation_AllCurvesOnePlot_Scatter = Pmw.ComboBox(
            self.frame_60_Scatter,
            scrolledlist_items=self.legendLocations,
            listheight=200,
            entry_width=20,
            scrolledlist_hull_width=500,
            )
        self.comboboxShowLegendLocation_AllCurvesOnePlot_Scatter.grid(
            row=3,
            column=2,
            padx=5,
            pady=0,
            sticky=W,
            )
#        self.comboboxShowLegendLocation_AllCurvesOnePlot.selectitem(self.legendLocations[0]) 
#        self.comboboxShowLegendLocation_AllCurvesOnePlot.configure(entry_width=10)
#        self.comboboxShowReferenceCurveMultiplier_AllCurvesOnePlot.component('entryfield').component('entry').configure(state=DISABLED)
#        self.comboboxShowLegendLocation_AllCurvesOnePlot._entryWidget['state']=DISABLED
# ...       legend font
        self.comboboxFontLegend_AllCurvesOnePlot_Scatter = Pmw.ComboBox(
            self.frame_60_Scatter,
            scrolledlist_items=self.fontsizesLegend,
            listheight=120,
            label_text='size:',
            label_background=colorbg,
            labelpos='w',
            entry_width=5,
            scrolledlist_hull_width=500,
            )
        self.comboboxFontLegend_AllCurvesOnePlot_Scatter.grid(
            row=3,
            column=3,
            padx=5,
            pady=0,
            sticky=W,
            )
# ...   show shadow
        self.varCheckbuttonShowLegendShadow_AllCurvesOnePlot_Scatter = IntVar()
        self.checkbuttonShowLegendShadow_AllCurvesOnePlot_Scatter = Checkbutton(
            self.frame_60_Scatter,
            text='Show shadow behind legend',
            bg=colorbg,
            variable=self.varCheckbuttonShowLegendShadow_AllCurvesOnePlot_Scatter,
            )
        self.checkbuttonShowLegendShadow_AllCurvesOnePlot_Scatter.grid(
            row=3,
            column=4,
            padx=4,
            pady=0,
            sticky=W,
            )
      
#       row 4
        self.varCheckbuttonShowGrid_AllCurvesOnePlot_Scatter = IntVar()
        self.checkbuttonShowGrid_AllCurvesOnePlot_Scatter = Checkbutton(
            self.frame_60_Scatter,
            bg=colorbg,
            variable=self.varCheckbuttonShowGrid_AllCurvesOnePlot_Scatter,
            )
        self.checkbuttonShowGrid_AllCurvesOnePlot_Scatter.grid(
            row=4,
            column=0,
            padx=2,
            pady=0,
            sticky=W,
            )
#        self.checkbuttonShowGrid_AllCurvesOnePlot.configure(state='normal')
#        self.checkbuttonShowGrid_AllCurvesOnePlot.select()
#        self.checkbuttonShowGrid_AllCurvesOnePlot.configure(state='disabled')
        labelShowGrid_AllCurvesOnePlot = Label(
            self.frame_60_Scatter,
            text='Show grid',
            justify=LEFT,
            bg=colorbg,
            )
        labelShowGrid_AllCurvesOnePlot.grid(
            row=4,
            column=1,
            padx=0,
            pady=0,
            sticky=W
            )
            
#       row 1
# ... polynomial curve fit
        self.varCheckbuttonShowPolynomialCurveFit_AllCurvesOnePlot_Scatter = IntVar()
        self.checkbuttonShowPolynomialCurveFit_AllCurvesOnePlot_Scatter = Checkbutton(
            self.frame_65_Scatter,
            bg=colorbg,
            variable=self.varCheckbuttonShowPolynomialCurveFit_AllCurvesOnePlot_Scatter,
            command=self.handlerShowPolynomialCurveFit_AllCurvesOnePlot_Scatter
            )
        self.checkbuttonShowPolynomialCurveFit_AllCurvesOnePlot_Scatter.grid(
            row=0,
            column=0,
            padx=2,
            pady=0,
            sticky=W,
            )
# ... label
        '''
        labelShowPolynomialCurveFit_AllCurvesOnePlot = Label(
            self.frame_65_Scatter,
            text='Show curve fit using polynomial of degree: ',
            justify=LEFT,
            bg=colorbg,
            )
        labelShowPolynomialCurveFit_AllCurvesOnePlot.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            sticky=W
            )
        '''
# ... degree of polynomial
        self.comboboxPolynomialDegree_AllCurvesOnePlot_Scatter = Pmw.ComboBox(
            self.frame_65_Scatter,
            scrolledlist_items=self.listPolynomialDegreesAvailable,
            listheight=105,
            label_text='Show curve fit using polynomial of degree: ',
            label_background=colorbg,
            labelpos='w',
            entry_width=5,
            entry_state='disabled',
            scrolledlist_hull_width=500,
            )
        self.comboboxPolynomialDegree_AllCurvesOnePlot_Scatter.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            sticky=W,
            )
# ... number of points used to plot polynomial
        self.comboboxPolynomialNumberOfPoints_AllCurvesOnePlot_Scatter = Pmw.ComboBox(
            self.frame_65_Scatter,
            scrolledlist_items=self.listNumberOfPointsForCurveFit,
            listheight=120,
            label_text='  number of points used to plot curve fit:',
            label_background=colorbg,
            labelpos='w',
            entry_width=5,
            entry_state='disabled',
            scrolledlist_hull_width=500,
            )
        self.comboboxPolynomialNumberOfPoints_AllCurvesOnePlot_Scatter.grid(
            row=0,
            column=2,
            padx=0,
            pady=0,
            sticky=W,
            )
# ... polynomial coefficient decimal places
        self.comboboxPolynomialCoefficientDecimalPlaces_AllCurvesOnePlot_Scatter = Pmw.ComboBox(
            self.frame_65_Scatter,
            scrolledlist_items=self.listNumberOfDecimalPlacesForCurveFit,
            listheight=120,
            label_text='  coefficient decimal places:',
            label_background=colorbg,
            labelpos='w',
            entry_width=5,
            entry_state='disabled',
            scrolledlist_hull_width=500,
            )
        self.comboboxPolynomialCoefficientDecimalPlaces_AllCurvesOnePlot_Scatter.grid(
            row=1,
            column=1,
            padx=0,
            pady=0,
            sticky=E,
            )
# ... format for polynomial coefficients
        self.comboboxPolynomialCoefficientOutputFormat_AllCurvesOnePlot_Scatter = Pmw.ComboBox(
            self.frame_65_Scatter,
            scrolledlist_items=self.listFormatPolynomialCoefficients,
            listheight=120,
            label_text='  coefficient output format:',
            label_background=colorbg,
            labelpos='w',
            entry_width=5,
            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxPolynomialCoefficientOutputFormat_AllCurvesOnePlot_Scatter.grid(
            row=1,
            column=2,
            padx=0,
            pady=0,
            sticky=E,
            )
# ... plot all lesser degree polynomial curve fits
        self.varCheckbuttonPlotAllLesserDegreePolynomials_AllCurvesOnePlot_Scatter = IntVar()
        self.checkbuttonPlotAllLesserDegreePolynomials_AllCurvesOnePlot_Scatter = Checkbutton(
            self.frame_65_Scatter,
            text=(
                'Plot all lesser-degree polynomials for comparison'
                ),
            justify=LEFT,
            bg=colorbg,
            variable=self.varCheckbuttonPlotAllLesserDegreePolynomials_AllCurvesOnePlot_Scatter,
            )
        self.checkbuttonPlotAllLesserDegreePolynomials_AllCurvesOnePlot_Scatter.grid(
            row=2,
            column=1,
            padx=0,
            pady=0,
            sticky=W,
            )
# move last displayed curve fits to buffer
#        self.varSelectAnyRow_Buffer = []
        self.buttonStoreCurveFits_Buffer_Scatter = Button(
            self.frame_65_Scatter,
            text="BUFFER: Store all last-displayed curve fits",
            font=self.buttonFontSmallest,
            borderwidth=3,
            background='white',
            foreground='blue',
            disabledforeground='#777777',
            command=self.handlerStoreXYinStorageBuffer_Scatter,
            )
        self.buttonStoreCurveFits_Buffer_Scatter.grid(
            row=2,
            column=2,
#            columnspan=99,
            padx=5,
            pady=5,
            )
            
# frame_70

# ... reference curve derived from existing curve

        self.varCheckbuttonShowReferenceCurve_AllCurvesOnePlot_Scatter = IntVar()
        self.checkbuttonShowReferenceCurve_AllCurvesOnePlot_Scatter = Checkbutton(
            self.frame_70_Scatter,
            bg=colorbg,
            variable=self.varCheckbuttonShowReferenceCurve_AllCurvesOnePlot_Scatter,
            command=self.handlerShowReferenceCurve_AllCurvesOnePlot_Scatter,
            )
        self.checkbuttonShowReferenceCurve_AllCurvesOnePlot_Scatter.grid(
            row=0,
            column=0,
            padx=2,
            pady=0,
            sticky=W,
            )
            
#        self.checkbuttonShowReferenceCurve_AllCurvesOnePlot.configure(state='disabled')
        labelShowReferenceCurve_AllCurvesOnePlot = Label(
            self.frame_70_Scatter,
            text='Show reference curve:',
            justify=LEFT,
            bg=colorbg,
            )
        labelShowReferenceCurve_AllCurvesOnePlot.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            sticky=W
            )
            
# ... <field> times curve labeled <field>
        self.comboboxShowReferenceCurveMultiplier_AllCurvesOnePlot_Scatter = Pmw.ComboBox(
            self.frame_70_Scatter,
            scrolledlist_items=self.multipliersReferenceCurve,
            listheight=150,
            entry_width=6,
            scrolledlist_hull_width=500,
            )
        self.comboboxShowReferenceCurveMultiplier_AllCurvesOnePlot_Scatter.grid(
            row=0,
            column=2,
            padx=2,
            pady=0,
            sticky=W,
            )
#        self.comboboxShowReferenceCurveMultiplier_AllCurvesOnePlot.selectitem(self.multipliersReferenceCurve[4])   
#        self.comboboxShowReferenceCurveMultiplier_AllCurvesOnePlot.configure(entry_width=6)
#        self.comboboxShowReferenceCurveMultiplier_AllCurvesOnePlot.component('entryfield').component('entry').configure(state=DISABLED)
# or
#        self.comboboxShowReferenceCurveMultiplier_AllCurvesOnePlot._entryWidget['state']=DISABLED
        
        labelShowReferenceCurveMultiply_AllCurvesOnePlot = Label(
            self.frame_70_Scatter,
            text='times curve labeled',
            bg=colorbg,
            )
        labelShowReferenceCurveMultiply_AllCurvesOnePlot.grid(
            row=0,
            column=3,
            padx=2,
            pady=0,
            sticky=W,
            )
        # regraph Reference Curve widget with 'scrolledlist_items' based on checked widgets
        self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot_Scatter = Pmw.ComboBox(
            self.frame_70_Scatter,
# scrolledlist_items defined in method "handlerRefreshReferenceCurveList_Scatter" after determining
#   which table columns have been selected
#            scrolledlist_items = self.legendNamesForCurveLabeled,
            listheight=100,
            entry_width=35,
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot_Scatter.grid(
            row=0,
            column=4,
            padx=2,
            pady=0,
            sticky=W,
            )
                 

# frame 71

# ... sloped straight line reference curve

        self.varCheckbuttonShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter = IntVar()
        self.checkbuttonShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter = Checkbutton(
            frame_71,
            bg=colorbg,
            variable=self.varCheckbuttonShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter,
            command=self.handlerShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter,
            )
        self.checkbuttonShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter.grid(
            row=0,
            column=0,
            padx=2,
            pady=0,
            sticky=W,
            )
            
        self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xinitial_Scatter = Pmw.EntryField(
            frame_71,
            entry_width=10,
            label_bg=colorbg,
            labelpos='w',
            label_text='Show sloped reference line between X(initial) = ',
#            textvariable=self.varShowStraightReferenceCurve_AllCurvesOnePlot_Xinitial,
            entry_disabledbackground='lightgray',
            validate = {'validator' : 'real'},
#                        'min' : 10, 'max' : 99, 'minstrict' : 0},
#            entry_state='normal',
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            )
        self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xinitial_Scatter.grid(
            row=0,
            column=2,
            padx=0,
            pady=0,
            sticky=W,
            )
        
        self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yinitial_Scatter = Pmw.EntryField(
            frame_71,
            entry_width=10,
            label_bg=colorbg,
            labelpos='w',
            label_text=', Y(initial) = ',
#            textvariable=self.varShowStraightReferenceCurve_AllCurvesOnePlot_Xinitial,
            entry_disabledbackground='lightgray',
            validate = {'validator' : 'real'},
#                        'min' : 10, 'max' : 99, 'minstrict' : 0},
#            entry_state='normal',
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            )
        self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yinitial_Scatter.grid(
            row=0,
            column=3,
            padx=0,
            pady=0,
            sticky=W,
            )

        self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xfinal_Scatter = Pmw.EntryField(
            frame_71,
            entry_width=10,
            labelpos='w',
            label_bg=colorbg,
            label_text='and X(final) = ',
            entry_disabledbackground='lightgray',
            validate = {'validator' : 'real'},
#                        'min' : 10, 'max' : 99, 'minstrict' : 0},
#            entry_state='normal',
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            )
        self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xfinal_Scatter.grid(
            row=1,
            column=2,
            padx=0,
            pady=0,
            sticky=E,
            )
        self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yfinal_Scatter = Pmw.EntryField(
            frame_71,
            entry_width=10,
            label_bg=colorbg,
            labelpos='w',
            label_text=',   Y(final) = ',
#            textvariable=self.varShowStraightReferenceCurve_AllCurvesOnePlot_Xinitial,
            entry_disabledbackground='lightgray',
            validate = {'validator' : 'real'},
#                        'min' : 10, 'max' : 99, 'minstrict' : 0},
#            entry_state='normal',
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            )
        self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yfinal_Scatter.grid(
            row=1,
            column=3,
            padx=0,
            pady=0,
            sticky=W,
            )

            
# FRAME 71a
# label for sloped straight line reference curve
# Row 0
# ... checkbutton and entry field for user-specified label
        labelText = Label(
            frame_71a,
            text='     using concatenated label: ',
            justify=LEFT,
            bg=colorbg,
            )
        labelText.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            sticky=W
            )
        self.varCheckbuttonLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter = IntVar()
        self.checkbuttonLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter = Checkbutton(
            frame_71a,
            bg=colorbg,
            borderwidth=0,
            variable=self.varCheckbuttonLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter,
#            command=??,
            )
        self.checkbuttonLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            sticky=E,
            )
        self.entryfieldLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter = Pmw.EntryField(
            frame_71a,
            entry_width=15,
            labelpos='w',
            label_bg=colorbg,
            label_text='user-specified ',
            entry_disabledbackground='lightgray',
#            validate = {'validator' : 'alphanumeric','max' : 20, 'min' : 0},
#            entry_state='normal',
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            )
        self.entryfieldLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter.grid(
            row=0,
            column=2,
            padx=0,
            pady=0,
            sticky=W,
            )
# ... add plus sign
        labelText = Label(
            frame_71a,
            text='  +  ',
            justify=CENTER,
            bg=colorbg,
            )
        labelText.grid(
            row=0,
            column=3,
            padx=0,
            pady=0,
#            sticky=W
            )
# ... checkbutton and entry field for using y value in label
        self.varCheckbuttonLabelSlopeDegreesSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter = IntVar()
        self.checkbuttonLabelSlopeDegreesSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter = Checkbutton(
            frame_71a,
            bg=colorbg,
            borderwidth=0,
            variable=self.varCheckbuttonLabelSlopeDegreesSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter
            )
        self.checkbuttonLabelSlopeDegreesSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter.grid(
            row=0,
            column=4,
            padx=0,
            pady=0,
            sticky=E,
            )
        labelText = Label(
            frame_71a,
            text='slope (degs)',
            justify=LEFT,
            bg=colorbg,
            )
        labelText.grid(
            row=0,
            column=5,
            padx=0,
            pady=0,
            sticky=W
            )

# ... label text showing "[ref]" will always be included in label
        labelText = Label(
            frame_71a,
            text=' +  [ref]',
            justify=LEFT,
            bg=colorbg,
            )
        labelText.grid(
            row=0,
            column=6,
            padx=0,
            pady=0,
#            sticky=W
            )           
                 
# frame 72

# ... horizontal straight line reference curve

        self.varCheckbuttonShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter = IntVar()
        self.checkbuttonShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter = Checkbutton(
            frame_72,
            bg=colorbg,
            variable=self.varCheckbuttonShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter,
            command=self.handlerShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter,
            )
        self.checkbuttonShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter.grid(
            row=0,
            column=0,
            padx=2,
            pady=0,
            sticky=W,
            )          
#        self.checkbuttonShowReferenceCurve_AllCurvesOnePlot.configure(state='disabled')

        self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xinitial_Scatter = Pmw.EntryField(
            frame_72,
            entry_width=10,
            label_bg=colorbg,
            labelpos='w',
            label_text='Show horizontal reference line between X(initial) = ',
#            textvariable=self.varShowStraightReferenceCurve_AllCurvesOnePlot_Xinitial,
            entry_background='white',
            entry_disabledbackground='lightgray',
            validate = {'validator' : 'real'},
#                        'min' : 10, 'max' : 99, 'minstrict' : 0},
#            entry_state='normal',
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            )
        self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xinitial_Scatter.grid(
            row=0,
            column=2,
            padx=0,
            pady=0,
            sticky=W,
            )

        self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xfinal_Scatter = Pmw.EntryField(
            frame_72,
            entry_width=10,
            labelpos='w',
            label_bg=colorbg,
            label_text=' and X(final) = ',
            entry_disabledbackground='lightgray',
            validate = {'validator' : 'real'},
#                        'min' : 10, 'max' : 99, 'minstrict' : 0},
#            entry_state='normal',
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            )
        self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xfinal_Scatter.grid(
            row=0,
            column=4,
            padx=5,
            pady=0,
            sticky=W,
            )
        self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Y_Scatter = Pmw.EntryField(
            frame_72,
            entry_width=10,
            labelpos='w',
            label_bg=colorbg,
            label_text=' at Y = ',
            entry_disabledbackground='lightgray',
            validate = {'validator' : 'real'},
#                        'min' : 10, 'max' : 99, 'minstrict' : 0},
#            entry_state='normal',
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            )
        self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Y_Scatter.grid(
            row=0,
            column=6,
            padx=5,
            pady=0,
            sticky=W,
            )
            
# FRAME 73
# label for straight line reference curve
# Row 0
# ... checkbutton and entry field for user-specified label
        labelText = Label(
            frame_73,
            text='     using concatenated label: ',
            justify=LEFT,
            bg=colorbg,
            )
        labelText.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            sticky=W
            )
        self.varCheckbuttonLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter = IntVar()
        self.checkbuttonLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter = Checkbutton(
            frame_73,
            bg=colorbg,
            borderwidth=0,
            variable=self.varCheckbuttonLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter,
#            command=??,
            )
        self.checkbuttonLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            sticky=E,
            )
        self.entryfieldLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter = Pmw.EntryField(
            frame_73,
            entry_width=15,
            labelpos='w',
            label_bg=colorbg,
            label_text='user-specified ',
            entry_disabledbackground='lightgray',
#            validate = {'validator' : 'alphanumeric','max' : 20, 'min' : 0},
#            entry_state='normal',
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            )
        self.entryfieldLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter.grid(
            row=0,
            column=2,
            padx=0,
            pady=0,
            sticky=W,
            )
# ... add plus sign
        labelText = Label(
            frame_73,
            text='  +  ',
            justify=CENTER,
            bg=colorbg,
            )
        labelText.grid(
            row=0,
            column=3,
            padx=0,
            pady=0,
#            sticky=W
            )
# ... checkbutton and entry field for using y value in label
        self.varCheckbuttonLabelYMaxHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter = IntVar()
        self.checkbuttonLabelYMaxHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter = Checkbutton(
            frame_73,
            bg=colorbg,
            borderwidth=0,
            variable=self.varCheckbuttonLabelYMaxHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter,
#            command=??,
            )
        self.checkbuttonLabelYMaxHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter.grid(
            row=0,
            column=4,
            padx=0,
            pady=0,
            sticky=E,
            )
        labelText = Label(
            frame_73,
            text='Y value',
            justify=LEFT,
            bg=colorbg,
            )
        labelText.grid(
            row=0,
            column=5,
            padx=0,
            pady=0,
            sticky=W
            )

# ... label text showing "[ref]" will always be included in label
        labelText = Label(
            frame_73,
            text=' +  [ref]',
            justify=LEFT,
            bg=colorbg,
            )
        labelText.grid(
            row=0,
            column=6,
            padx=0,
            pady=0,
#            sticky=W
            )           
            
# frame 74

# ... vertical straight line reference curve

        self.varCheckbuttonShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Scatter = IntVar()
        self.checkbuttonShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Scatter = Checkbutton(
            frame_74,
            bg=colorbg,
            variable=self.varCheckbuttonShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Scatter,
            command=self.handlerShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Scatter,
            )
        self.checkbuttonShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Scatter.grid(
            row=0,
            column=0,
            padx=2,
            pady=0,
            sticky=W,
            )          
#        self.checkbuttonShowReferenceCurve_AllCurvesOnePlot.configure(state='disabled')

        self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yinitial_Scatter = Pmw.EntryField(
            frame_74,
            entry_width=10,
            label_bg=colorbg,
            labelpos='w',
            label_text='Show vertical reference line between Y(initial) = ',
#            textvariable=self.varShowStraightReferenceCurve_AllCurvesOnePlot_Xinitial,
            entry_disabledbackground='lightgray',
            validate = {'validator' : 'real'},
#                        'min' : 10, 'max' : 99, 'minstrict' : 0},
#            entry_state='normal',
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            )
        self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yinitial_Scatter.grid(
            row=0,
            column=2,
            padx=0,
            pady=0,
            sticky=W,
            )

        self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yfinal_Scatter = Pmw.EntryField(
            frame_74,
            entry_width=10,
            labelpos='w',
            label_bg=colorbg,
            label_text=' and Y(final) = ',
            entry_disabledbackground='lightgray',
            validate = {'validator' : 'real'},
#                        'min' : 10, 'max' : 99, 'minstrict' : 0},
#            entry_state='normal',
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            )
        self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yfinal_Scatter.grid(
            row=0,
            column=4,
            padx=5,
            pady=0,
            sticky=W,
            )
        self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_X_Scatter = Pmw.EntryField(
            frame_74,
            entry_width=10,
            labelpos='w',
            label_bg=colorbg,
            label_text=' at X = ',
            entry_disabledbackground='lightgray',
            validate = {'validator' : 'real'},
#                        'min' : 10, 'max' : 99, 'minstrict' : 0},
#            entry_state='normal',
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            )
        self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_X_Scatter.grid(
            row=0,
            column=6,
            padx=5,
            pady=0,
            sticky=W,
            )
            
# FRAME 74a
# label for vertical straight line reference curve
# Row 0
# ... checkbutton and entry field for user-specified label
        labelText = Label(
            frame_74a,
            text='     using concatenated label: ',
            justify=LEFT,
            bg=colorbg,
            )
        labelText.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            sticky=W
            )
        self.varCheckbuttonLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot_Scatter = IntVar()
        self.checkbuttonLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot_Scatter = Checkbutton(
            frame_74a,
            bg=colorbg,
            borderwidth=0,
            variable=self.varCheckbuttonLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot_Scatter,
#            command=??,
            )
        self.checkbuttonLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot_Scatter.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            sticky=E,
            )
        self.entryfieldLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot_Scatter = Pmw.EntryField(
            frame_74a,
            entry_width=15,
            labelpos='w',
            label_bg=colorbg,
            label_text='user-specified ',
            entry_disabledbackground='lightgray',
#            validate = {'validator' : 'alphanumeric','max' : 20, 'min' : 0},
#            entry_state='normal',
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            )
        self.entryfieldLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot_Scatter.grid(
            row=0,
            column=2,
            padx=0,
            pady=0,
            sticky=W,
            )
# ... add plus sign
        labelText = Label(
            frame_74a,
            text='  +  ',
            justify=CENTER,
            bg=colorbg,
            )
        labelText.grid(
            row=0,
            column=3,
            padx=0,
            pady=0,
#            sticky=W
            )
# ... checkbutton and entry field for using x value in label
        self.varCheckbuttonLabelXMaxVerticalStraightLineReferenceCurve_AllCurvesOnePlot_Scatter = IntVar()
        self.checkbuttonLabelXMaxVerticalStraightLineReferenceCurve_AllCurvesOnePlot_Scatter = Checkbutton(
            frame_74a,
            bg=colorbg,
            borderwidth=0,
            variable=self.varCheckbuttonLabelXMaxVerticalStraightLineReferenceCurve_AllCurvesOnePlot_Scatter,
#            command=??,
            )
        self.checkbuttonLabelXMaxVerticalStraightLineReferenceCurve_AllCurvesOnePlot_Scatter.grid(
            row=0,
            column=4,
            padx=0,
            pady=0,
            sticky=E,
            )
        labelText = Label(
            frame_74a,
            text='X value',
            justify=LEFT,
            bg=colorbg,
            )
        labelText.grid(
            row=0,
            column=5,
            padx=0,
            pady=0,
            sticky=W
            )

# ... label text showing "[ref]" will always be included in label
        labelText = Label(
            frame_74a,
            text=' +  [ref]',
            justify=LEFT,
            bg=colorbg,
            )
        labelText.grid(
            row=0,
            column=6,
            padx=0,
            pady=0,
#            sticky=W
            )              

# FRAME 75
# include CSV-formatted plot data from a file
# Row 0
# ... checkbutton
        self.varCheckbuttonPlotCsvFileData_AllCurvesOnePlot_Scatter = IntVar()
        self.checkbuttonPlotCsvFileData_AllCurvesOnePlot_Scatter = Checkbutton(
            frame_75,
            bg=colorbg,
            variable=self.varCheckbuttonPlotCsvFileData_AllCurvesOnePlot_Scatter,
            command=self.handlerCheckbuttonPlotCsvFileData_AllCurvesOnePlot_Scatter,
            )
        self.checkbuttonPlotCsvFileData_AllCurvesOnePlot_Scatter.grid(
            row=0,
            column=0,
            padx=2,
            pady=0,
            sticky=W,
            )
# ... label
        labelPlotCsvFileData_AllCurvesOnePlot = Label(
            frame_75,
            text='Plot x-y from CSV file:',
            justify=LEFT,
            bg=colorbg,
            )
        labelPlotCsvFileData_AllCurvesOnePlot.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            sticky=W
            )
# ... entry field for file
        self.varEntryPlotCsvFileData_AllCurvesOnePlot_Scatter = StringVar()
        self.entryPlotCsvFileData_AllCurvesOnePlot_Scatter = Entry(
            frame_75,
            width=20,
            textvariable=self.varEntryPlotCsvFileData_AllCurvesOnePlot_Scatter,
            )
        self.entryPlotCsvFileData_AllCurvesOnePlot_Scatter.grid(
            row=0,
            column=2,
            padx=2,
            pady=0,
            )
# ... label for x column
        labelPlotCsvFileData_X_Column_AllCurvesOnePlot = Label(
            frame_75,
            text='X col:',
            justify=RIGHT,
            bg=colorbg,
            )
        labelPlotCsvFileData_X_Column_AllCurvesOnePlot.grid(
            row=0,
            column=3,
            padx=2,
            pady=0,
            )
# ... combobox for x column
        self.comboboxPlotCsvFileData_X_Column_AllCurvesOnePlot_Scatter = Pmw.ComboBox(
            frame_75,
            scrolledlist_items=self.headers_PlotFileData_X_Column,
            entry_width=10,
            listheight=100,
            scrolledlist_hull_width=500,
            )
        self.comboboxPlotCsvFileData_X_Column_AllCurvesOnePlot_Scatter.grid(
            row=0,
            column=4,
            padx=0,
            pady=0,
            )
# ... label for y column
        labelPlotCsvFileData_Y_Column_AllCurvesOnePlot = Label(
            frame_75,
            text='Y col:',
            justify=RIGHT,
            bg=colorbg,
            )
        labelPlotCsvFileData_Y_Column_AllCurvesOnePlot.grid(
            row=0,
            column=5,
            padx=2,
            pady=0,
            )
# ... combobox for y column
        self.comboboxPlotCsvFileData_Y_Column_AllCurvesOnePlot_Scatter = Pmw.ComboBox(
            frame_75,
            scrolledlist_items=self.headers_PlotFileData_Y_Column,
            entry_width=10,
            listheight=100,
            scrolledlist_hull_width=500,
            )
        self.comboboxPlotCsvFileData_Y_Column_AllCurvesOnePlot_Scatter.grid(
            row=0,
            column=6,
            padx=0,
            pady=0,
            )
# Row 1
# ... browse for plot x-y file
        buttonBrowseForPlotCsvFileData_AllCurvesOnePlot = Button(
            frame_75,
            text='Browse',
            width=10,
            font=self.buttonFontSmallest,
            borderwidth=3,
            relief=RAISED,
            background='white',
            foreground='blue',
            command=self.handlerButtonBrowseForPlotCsvFileData_AllCurvesOnePlot_Scatter,
            )
        buttonBrowseForPlotCsvFileData_AllCurvesOnePlot.grid(
            row=1,
            column=2,
            padx=0,
            pady=0,
            sticky=N,
            )

# frame_80a_Scatter
# x-tick size
        labelFontLabels = Label(
            self.frame_80a_Scatter,
            text='X-Ticks size:',
            bg=colorbg,
            )
        labelFontLabels.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            sticky=E,
            )
        self.comboboxFontXTicks_AllCurvesOnePlot_Scatter = Pmw.ComboBox(
            self.frame_80a_Scatter,
            scrolledlist_items=self.fontsizesTickX,
            listheight=160,
            entry_width=5,
            scrolledlist_hull_width=500,
            )
        self.comboboxFontXTicks_AllCurvesOnePlot_Scatter.grid(
            row=0,
            column=1,
            padx=5,
            pady=0,
            sticky=W,
            )
# x-tick color
        self.comboboxColorXTicks_AllCurvesOnePlot_Scatter = Pmw.ComboBox(
            self.frame_80a_Scatter,
            scrolledlist_items=self.colorsTickX,
            listheight=150,
            label_text='color:',
            label_background=colorbg,
            labelpos='w',
            entry_width=10,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxColorXTicks_AllCurvesOnePlot_Scatter.grid(
            row=0,
            column=2,
            padx=5,
            pady=0,
            sticky=W,
            )
# y-tick size
        labelFontLabels = Label(
            self.frame_80a_Scatter,
            text='Y-Ticks size:',
            bg=colorbg,
            )
        labelFontLabels.grid(
            row=1,
            column=0,
            padx=0,
            pady=0,
            sticky=E,
            )
        self.comboboxFontYTicks_AllCurvesOnePlot_Scatter = Pmw.ComboBox(
            self.frame_80a_Scatter,
            scrolledlist_items=self.fontsizesTickY,
            listheight=160,
            entry_width=5,
            scrolledlist_hull_width=500,
            )
        self.comboboxFontYTicks_AllCurvesOnePlot_Scatter.grid(
            row=1,
            column=1,
            padx=5,
            pady=0,
            sticky=W,
            )
# y-tick color
        self.comboboxColorYTicks_AllCurvesOnePlot_Scatter = Pmw.ComboBox(
            self.frame_80a_Scatter,
            scrolledlist_items=self.colorsTickY,
            listheight=150,
            label_text='color:',
            label_background=colorbg,
            labelpos='w',
            entry_width=10,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxColorYTicks_AllCurvesOnePlot_Scatter.grid(
            row=1,
            column=2,
            padx=5,
            pady=0,
            sticky=W,
            )
            
# chart background color      
        self.comboboxColorBackground_AllCurvesOnePlot_Scatter = Pmw.ComboBox(
            self.frame_80a_Scatter,
            scrolledlist_items=self.colorsChartBackground,
            listheight=150,
            label_text='Background color:',
            label_background=colorbg,
            labelpos='w',
            entry_width=10,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxColorBackground_AllCurvesOnePlot_Scatter.grid(
            row=0,
            column=3,
            columnspan=1,
            padx=5,
            pady=0,
            sticky=E,
            )
            
# chart border color    
        self.comboboxColorPlotBorder_AllCurvesOnePlot_Scatter = Pmw.ComboBox(
            self.frame_80a_Scatter,
            scrolledlist_items=self.colorsChartBackground,
            listheight=150,
            label_text='Border color:',
            label_background=colorbg,
            labelpos='w',
            entry_width=10,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxColorPlotBorder_AllCurvesOnePlot_Scatter.grid(
            row=1,
            column=3,
            columnspan=1,
            padx=5,
            pady=0,
            sticky=E,
            )
             
# frame_80b_Scatter
# ... reset all
        buttonResetAllPlots = Button(
            frame_80b_Scatter,
            text='Reset all',
            width=12,
            background='white',
            foreground='blue',
            font=self.buttonFontSmall,
            relief=RAISED,
            borderwidth=3,
            command=self.handlerResetAllPlotScatterSelect,
            )
        buttonResetAllPlots.grid(
            row=0,
            column=0,
            padx=5,
            pady=1,
            )
# ... close all plots if plots are present
        buttonCloseAllPlots = Button(
            frame_80b_Scatter,
            text='Close all plots',
            width=12,
            font=self.buttonFontSmall,
            relief=RAISED,
            borderwidth=3,
            command=self.handlerCloseAllScatterPlots,
            )
        buttonCloseAllPlots.grid(
            row=0,
            column=1,
            padx=5,
            pady=1,
            )
            
# ... plot
        self.buttonScatterPlottingSpecsPlot = Button(
            frame_80b_Scatter,
            text='Plot',
            width=15,
            relief=RAISED,
            borderwidth=5,
            command=self.handlerPlotScatterSelect,
            )
        self.buttonScatterPlottingSpecsPlot.grid(
            row=1,
            column=0,
            padx=5,
            pady=2,
            )
# ... cancel
        buttonCancel = Button(
            frame_80b_Scatter,
            text='Cancel',
            width=15,
            relief=RAISED,
            borderwidth=5,
            command=self.destroyPlotPreprocess_Scatter,
            )
        buttonCancel.grid(
            row=1,
            column=1,
            padx=1,
            pady=2,
            )

# set all variables, depending on whether there was a previous window
        if self.previousWindow_Scatter:
# Scatter Plot window exists; restore previous state of window
# ... include table data
            if (
                numberOfPreviousTableCurves == 0
                and
                self.varNumberOfTableCurves_Scatter.get() <> 0
                ):
                self.varCheckbuttonTableData_Scatter.set(1)
            elif (
                numberOfPreviousTableCurves <> 0
                and
                self.varNumberOfTableCurves_Scatter.get() <> 0
                ):
                self.varCheckbuttonTableData_Scatter.set(includeTableData_checkbutton_status)
            else:
                self.varCheckbuttonTableData_Scatter.set(0)
                
# ... include buffer data
            if (
                numberOfPreviousStorageBufferCurves == 0
                and
                self.varNumberOfStorageBufferCurves_Scatter.get() <> 0
                ):
                self.varCheckbuttonBufferData_Scatter.set(1)
            elif (
                numberOfPreviousStorageBufferCurves <> 0
                and
                self.varNumberOfStorageBufferCurves_Scatter.get() <> 0
                ):
                self.varCheckbuttonBufferData_Scatter.set(includeBufferData_checkbutton_status)
            else:
                self.varCheckbuttonBufferData_Scatter.set(0)

# ... replot
            self.varReplotInCurrentWindow_Scatter.set(replot_checkbutton_status)
            if replot_checkbutton_status:
                self.checkbuttonReplotInCurrentWindow_Scatter.select()
            else:
                self.checkbuttonReplotInCurrentWindow_Scatter.deselect()
                
# ... erase previous plot
            self.varKeepPreviousPlotInCurrentWindow_Scatter.set(keep_previous_plot_status)
            if keep_previous_plot_status:
                self.checkbuttonKeepPreviousPlotInCurrentWindow_Scatter.select()
            else:
                self.checkbuttonKeepPreviousPlotInCurrentWindow_Scatter.deselect()
# ... disable replot button if 'erase previous plot' button is not checked

            print ' **********   replot_checkbutton_status = ', replot_checkbutton_status
            if replot_checkbutton_status:
                self.checkbuttonKeepPreviousPlotInCurrentWindow_Scatter.configure(state='normal')
            else:
                self.checkbuttonKeepPreviousPlotInCurrentWindow_Scatter.configure(state='disabled')
                
# ... plot style radiobutton
            self.var_radiobuttonPlotStyle_Scatter.set(plot_Style_Scatter)
            
# ... base for log plots
            self.comboboxBaseForLogPlotsX_Scatter.setentry(plot_BaseForLogPlotsX)
            self.comboboxBaseForLogPlotsY_Scatter.setentry(plot_BaseForLogPlotsY)
            
# ... connect data points with dashed line
            self.varCheckbuttonConnectDataMarkers_Scatter.set(connectDataPoints)
            
# ... line width
            self.comboboxLineWidthPlots_Scatter.setentry(lineWidthAllPlots)
            
# ... marker size
            self.comboboxMarkerSizePlots_Scatter.setentry(markerSizeAllPlots)
            
# ... show as disabled if 'cartesian' is selected; partially disabled if semilogx or semilogy; o/w, show as normal
            if self.var_radiobuttonPlotStyle_Scatter.get().strip() == 'cartesian':
                self.comboboxBaseForLogPlotsX_Scatter._entryWidget['state']=DISABLED
                self.comboboxBaseForLogPlotsY_Scatter._entryWidget['state']=DISABLED
            elif self.var_radiobuttonPlotStyle_Scatter.get().strip() == 'semilogx':
                self.comboboxBaseForLogPlotsX_Scatter._entryWidget['state']=NORMAL
                self.comboboxBaseForLogPlotsY_Scatter._entryWidget['state']=DISABLED
            elif self.var_radiobuttonPlotStyle_Scatter.get().strip() == 'semilogy':
                self.comboboxBaseForLogPlotsX_Scatter._entryWidget['state']=DISABLED
                self.comboboxBaseForLogPlotsY_Scatter._entryWidget['state']=NORMAL
            else:
                self.comboboxBaseForLogPlotsX_Scatter._entryWidget['state']=NORMAL
                self.comboboxBaseForLogPlotsY_Scatter._entryWidget['state']=NORMAL


# ... all - show titles
            self.varCheckbuttonShowTitle_AllCurvesOnePlot_Scatter.set(all_showTitles_checkbutton_status)
            self.varEntryShowTitle_AllCurvesOnePlot_Scatter.set(all_showTitles_entryfield_value)
            try:
                self.comboboxFontTitle_AllCurvesOnePlot_Scatter.setentry(all_fontTitles_Combobox_value)
            except:
                self.comboboxFontTitle_AllCurvesOnePlot_Scatter.selectitem(self.fontsizesChartTitle[6])
            self.comboboxColorTitle_AllCurvesOnePlot_Scatter.setentry(all_colorTitles_combobox_value)
            
# ... all - show y label
            self.varCheckbuttonShowLabelY_AllCurvesOnePlot_Scatter.set(all_showYLabel_checkbutton_status)
# ... all - set entry
            self.varEntryShowLabelY_AllCurvesOnePlot_Scatter.set(all_showYLabel_entryfield_value)
# ...   enable/disable entry
            self.handlerShowLabelY_AllCurvesOnePlot_Scatter()
            
# ... all - show x label
# ... set checkbutton
            self.varCheckbuttonShowLabelX_AllCurvesOnePlot_Scatter.set(all_showXLabel_checkbutton_status)
# ...   set entry
            self.comboboxShowLabelX_AllCurvesOnePlot_Scatter.setentry(all_showXLabel_entryfield_value)
# ...   enable/disable entry 
            self.handlerShowLabelX_AllCurvesOnePlot_Scatter()
            
# ... all - set xy-label font
            try:
                self.comboboxFontXYLabels_AllCurvesOnePlot_Scatter.setentry(all_fontXYLabels_combobox_value)
            except:
                self.comboboxFontXYLabels_AllCurvesOnePlot_Scatter.selectitem(self.fontsizesChartLabels[4])
                self.comboboxFontXYLabels_AllCurvesOnePlot_Scatter.configure(entry_width=5)
                
# ... all - set xy-label color
            self.comboboxColorXYLabels_AllCurvesOnePlot_Scatter.setentry(all_colorXYLabels_combobox_value)
# ... all - enable/disable XY label font size and colors
            self.handlerRefreshXYLabelsColor_AllCurvesOnOnePlot_Scatter()
            
# ... all - show legend
            self.varCheckbuttonShowLegend_AllCurvesOnePlot_Scatter.set(all_showLegend_checkbutton_status)
            
# ... all - legend location
            try:
                self.comboboxShowLegendLocation_AllCurvesOnePlot_Scatter.setentry(
                    all_showLegend_combobox_value
                    )
            except:
                self.comboboxShowLegendLocation_AllCurvesOnePlot_Scatter.selectitem(self.legendLocations[0])
                
# ... all - font legend
            try:
                all_fontLegend_combobox_value = self.comboboxFontLegend_AllCurvesOnePlot_Scatter.setentry(
                    all_fontLegend_combobox_value
                    )
            except:
                self.comboboxFontLegend_AllCurvesOnePlot_Scatter.selectitem(self.fontsizesLegend[1])
#            self.comboboxShowLegendLocation_AllCurvesOnePlot_Scatter.configure(entry_width=10)
#            self.comboboxFontLegend_AllCurvesOnePlot_Scatter.configure(entry_width=5)
            
# ... all - show legend shadow
            self.varCheckbuttonShowLegendShadow_AllCurvesOnePlot_Scatter.set(all_showLegendShadow_checkbutton_status)
            
# ... all - show grid
            self.varCheckbuttonShowGrid_AllCurvesOnePlot_Scatter.set(all_showGrid_checkbutton_status)
            
# ... all - show curve fit using polynomial
            self.varCheckbuttonShowPolynomialCurveFit_AllCurvesOnePlot_Scatter.set(all_showCurveFit_checkbutton_status)
            self.comboboxPolynomialDegree_AllCurvesOnePlot_Scatter.setentry(all_showCurveFit_polynomial_degree)
            self.comboboxPolynomialNumberOfPoints_AllCurvesOnePlot_Scatter.setentry(all_showCurveFit_number_of_points_used)
            self.comboboxPolynomialCoefficientDecimalPlaces_AllCurvesOnePlot_Scatter.setentry(all_showCurveFit_coefficient_decimal_places)
            self.comboboxPolynomialCoefficientOutputFormat_AllCurvesOnePlot_Scatter.setentry(all_showCurveFit_coefficient_output_format)
            self.varCheckbuttonPlotAllLesserDegreePolynomials_AllCurvesOnePlot_Scatter.set(all_plotLesserDegreePolynomials_checkbutton_status)
            
# ... all - show reference curve
            self.varCheckbuttonShowReferenceCurve_AllCurvesOnePlot_Scatter.set(
                all_showRefCurve_checkbutton_status
                )
            if all_showRefCurve_checkbutton_status:
                self.checkbuttonShowReferenceCurve_AllCurvesOnePlot_Scatter.select()
            else:
                self.checkbuttonShowReferenceCurve_AllCurvesOnePlot_Scatter.deselect()
                
# ... all - reference curve multiplier
            try:
                self.comboboxShowReferenceCurveMultiplier_AllCurvesOnePlot_Scatter.setentry(
                    all_showRefCurve_Multiplier_combobox_value
                    )
            except:
                self.comboboxShowReferenceCurveMultiplier_AllCurvesOnePlot_Scatter.selectitem(
                    self.multipliersReferenceCurve[4]
                    )
                self.comboboxShowReferenceCurveMultiplier_AllCurvesOnePlot_Scatter.configure(entry_width=6)

# ... all - show sloped straight line reference curve
            self.varCheckbuttonShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter.set(
                all_showSlopedStraightLineRefCurve_checkbutton_status
                )
            if all_showSlopedStraightLineRefCurve_checkbutton_status:
                self.checkbuttonShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter.select()
            else:
                self.checkbuttonShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter.deselect()
            self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xinitial_Scatter.setvalue(
                all_showSlopedStraightLineRefCurve_x_initial
                )
            self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xfinal_Scatter.setvalue(
                all_showSlopedStraightLineRefCurve_x_final
                )
            self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yinitial_Scatter.setvalue(
                all_showSlopedStraightLineRefCurve_y_initial
                )
            self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yfinal_Scatter.setvalue(
                all_showSlopedStraightLineRefCurve_y_final
                ) 
            self.varCheckbuttonLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter.set(
                all_showSlopedStraightLineRefCurve_UserLabel_checkbutton_status
                )
            self.entryfieldLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter.setvalue(
                all_showSlopedStraightLineRefCurve_UserLabel
                )
#            self.varCheckbuttonLabelYMaxSlopedStraightReferenceCurve_AllCurvesOnePlot.set(all_showSlopedStraightLineRefCurve_yValue_checkbutton_status)
            self.varCheckbuttonLabelSlopeDegreesSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter.set(
                all_showSlopedStraightLineRefCurve_ShowSlope_checkbutton_status
                )
            
# ... all - show horizontal straight line reference curve
            self.varCheckbuttonShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter.set(
                all_showHorizontalStraightLineRefCurve_checkbutton_status
                )
            if all_showHorizontalStraightLineRefCurve_checkbutton_status:
                self.checkbuttonShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter.select()
            else:
                self.checkbuttonShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter.deselect()
            self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xinitial_Scatter.setvalue(
                all_showHorizontalStraightLineRefCurve_x_initial
                )
            self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xfinal_Scatter.setvalue(
                all_showHorizontalStraightLineRefCurve_x_final
                )
            self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Y_Scatter.setvalue(
                all_showHorizontalStraightLineRefCurve_y
                ) 
            self.varCheckbuttonLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter.set(
                all_showHorizontalStraightLineRefCurve_UserLabel_checkbutton_status
                )
            self.entryfieldLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter.setvalue(
                all_showHorizontalStraightLineRefCurve_UserLabel
                )
            self.varCheckbuttonLabelYMaxHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter.set(
                all_showHorizontalStraightLineRefCurve_yValue_checkbutton_status
                )
            
# ... all - show vertical straight line reference curve
            self.varCheckbuttonShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Scatter.set(
                all_showVerticalStraightLineRefCurve_checkbutton_status
                )
            if all_showVerticalStraightLineRefCurve_checkbutton_status:
                self.checkbuttonShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Scatter.select()
            else:
                self.checkbuttonShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Scatter.deselect()
            self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yinitial_Scatter.setvalue(
                all_showVerticalStraightLineRefCurve_y_initial
                )
            self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yfinal_Scatter.setvalue(
                all_showVerticalStraightLineRefCurve_y_final
                )
            self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_X_Scatter.setvalue(
                all_showVerticalStraightLineRefCurve_x
                ) 
            self.varCheckbuttonLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot_Scatter.set(
                all_showVerticalStraightLineRefCurve_UserLabel_checkbutton_status
                )
            self.entryfieldLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot_Scatter.setvalue(
                all_showVerticalStraightLineRefCurve_UserLabel
                )
            self.varCheckbuttonLabelXMaxVerticalStraightLineReferenceCurve_AllCurvesOnePlot_Scatter.set(
                all_showVerticalStraightLineRefCurve_XValue_checkbutton_status
                )
            
# ... all - plot x-y data from csv file in scatter plot
            self.varCheckbuttonPlotCsvFileData_AllCurvesOnePlot_Scatter.set(
                all_plotCsvFileData_checkbutton_status
                )
            self.varEntryPlotCsvFileData_AllCurvesOnePlot_Scatter.set(all_plotCsvFileData_entry_value)
            self.comboboxPlotCsvFileData_X_Column_AllCurvesOnePlot_Scatter.setentry(
                all_plotCsvFileData_x_column_value
                )
            self.comboboxPlotCsvFileData_Y_Column_AllCurvesOnePlot_Scatter.setentry(
                all_plotCsvFileData_y_column_value
                )
            
# ... x ticks size and color
            self.comboboxFontXTicks_AllCurvesOnePlot_Scatter.setentry(all_fontXTicks_combobox_value)
            self.comboboxColorXTicks_AllCurvesOnePlot_Scatter.setentry(all_colorXTicks_combobox_value)
            
# ... y ticks size and color
            self.comboboxFontYTicks_AllCurvesOnePlot_Scatter.setentry(all_fontYTicks_combobox_value)
            self.comboboxColorYTicks_AllCurvesOnePlot_Scatter.setentry(all_colorYTicks_combobox_value)
            
# ... background color
            self.comboboxColorBackground_AllCurvesOnePlot_Scatter.setentry(all_colorBackground_combobox_value)
            
# ... plot border color
            self.comboboxColorPlotBorder_AllCurvesOnePlot_Scatter.setentry(all_colorPlotBorder_combobox_value)
                     
                     
# use 'disabled' or 'normal' scatter plots widgets
            
# ... 'all' entry fields
# ... all - title
            self.checkbuttonShowTitle_AllCurvesOnePlot_Scatter.configure(state='normal')
            if all_showTitles_checkbutton_status:
                self.entryShowTitle_AllCurvesOnePlot_Scatter.configure(state='normal')
                self.comboboxFontTitle_AllCurvesOnePlot_Scatter._entryWidget['state'] = NORMAL
                self.comboboxColorTitle_AllCurvesOnePlot_Scatter._entryWidget['state'] = NORMAL
            else:
                self.entryShowTitle_AllCurvesOnePlot_Scatter.configure(state='disabled')
                self.comboboxFontTitle_AllCurvesOnePlot_Scatter._entryWidget['state'] = DISABLED
                self.comboboxColorTitle_AllCurvesOnePlot_Scatter._entryWidget['state'] = DISABLED
                
# ... all - y label
            self.checkbuttonShowLabelY_AllCurvesOnePlot_Scatter.configure(state='normal')
            if all_showYLabel_checkbutton_status:
                self.entryShowLabelY_AllCurvesOnePlot_Scatter.configure(state='normal')
            else:
                self.entryShowLabelY_AllCurvesOnePlot_Scatter.configure(state='disabled')
                
# ... all - x label
            self.checkbuttonShowLabelX_AllCurvesOnePlot_Scatter.configure(state='normal')
            if all_showXLabel_checkbutton_status:
#                    self.entryShowLabelX_AllCurvesOnePlot.configure(state='normal') 
                self.comboboxShowLabelX_AllCurvesOnePlot_Scatter._entryWidget['state']=NORMAL
            else:
#                    self.entryShowLabelX_AllCurvesOnePlot.configure(state='disabled')
                self.comboboxShowLabelX_AllCurvesOnePlot_Scatter._entryWidget['state']=DISABLED
                
# ... all - xy-label font and color
            if (
                self.varCheckbuttonShowLabelY_AllCurvesOnePlot_Scatter.get()
                or
                self.varCheckbuttonShowLabelX_AllCurvesOnePlot_Scatter.get()
                ):
                self.comboboxFontXYLabels_AllCurvesOnePlot_Scatter._entryWidget['state']=NORMAL
            else:
                self.comboboxFontXYLabels_AllCurvesOnePlot_Scatter._entryWidget['state']=DISABLED
            self.handlerRefreshXYLabelsColor_AllCurvesOnOnePlot_Scatter()
                
# ...  all - legend
            self.checkbuttonShowLegend_AllCurvesOnePlot_Scatter.configure(state='normal')
            if all_showLegend_checkbutton_status:
                self.comboboxShowLegendLocation_AllCurvesOnePlot_Scatter._entryWidget['state']=NORMAL
                self.comboboxFontLegend_AllCurvesOnePlot_Scatter._entryWidget['state']=NORMAL
            else:
                self.comboboxShowLegendLocation_AllCurvesOnePlot_Scatter._entryWidget['state']=DISABLED
                self.comboboxFontLegend_AllCurvesOnePlot_Scatter._entryWidget['state']=DISABLED
                
# ...  all - show grid
            self.checkbuttonShowGrid_AllCurvesOnePlot_Scatter.configure(state='normal')
            
# ... all - show curve fit using polynomial
            self.checkbuttonShowPolynomialCurveFit_AllCurvesOnePlot_Scatter.configure(state='normal')
            if self.varCheckbuttonShowPolynomialCurveFit_AllCurvesOnePlot_Scatter.get():
# ... normal
# ...   degree of polynomial
                self.comboboxPolynomialDegree_AllCurvesOnePlot_Scatter._entryWidget['disabledbackground'] = 'white'
                self.comboboxPolynomialDegree_AllCurvesOnePlot_Scatter._entryWidget['disabledforeground'] = 'black'
# ...   number of points
                self.comboboxPolynomialNumberOfPoints_AllCurvesOnePlot_Scatter._entryWidget['disabledbackground'] = 'white'
                self.comboboxPolynomialNumberOfPoints_AllCurvesOnePlot_Scatter._entryWidget['disabledforeground'] = 'black'
# ...   coefficient decimal places
                self.comboboxPolynomialCoefficientDecimalPlaces_AllCurvesOnePlot_Scatter._entryWidget['disabledbackground'] = 'white'
                self.comboboxPolynomialCoefficientDecimalPlaces_AllCurvesOnePlot_Scatter._entryWidget['disabledforeground'] = 'black'
# ...   coefficient output format
                self.comboboxPolynomialCoefficientOutputFormat_AllCurvesOnePlot_Scatter._entryWidget['disabledbackground'] = 'white'
                self.comboboxPolynomialCoefficientOutputFormat_AllCurvesOnePlot_Scatter._entryWidget['disabledforeground'] = 'black'
# ...   checkbutton for plotting all lesser degree polynomials
                self.checkbuttonPlotAllLesserDegreePolynomials_AllCurvesOnePlot_Scatter.configure(state='normal')
# ...   button for storing last-displayed curve fits
                self.buttonStoreCurveFits_Buffer_Scatter.configure(state='normal')
            else:
# ... disabled
                self.comboboxPolynomialDegree_AllCurvesOnePlot_Scatter._entryWidget['disabledbackground'] = 'lightgray'             
                self.comboboxPolynomialDegree_AllCurvesOnePlot_Scatter._entryWidget['disabledforeground'] = '#777777'   # dark gray          
# ...   number of points
                self.comboboxPolynomialNumberOfPoints_AllCurvesOnePlot_Scatter._entryWidget['disabledbackground'] = 'lightgray'
                self.comboboxPolynomialNumberOfPoints_AllCurvesOnePlot_Scatter._entryWidget['disabledforeground'] = '#777777'
# ...   coefficient decimal places
                self.comboboxPolynomialCoefficientDecimalPlaces_AllCurvesOnePlot_Scatter._entryWidget['disabledbackground'] = 'lightgray'
                self.comboboxPolynomialCoefficientDecimalPlaces_AllCurvesOnePlot_Scatter._entryWidget['disabledforeground'] = '#777777'
# ...   coefficient output format
                self.comboboxPolynomialCoefficientOutputFormat_AllCurvesOnePlot_Scatter._entryWidget['disabledbackground'] = 'lightgray'
                self.comboboxPolynomialCoefficientOutputFormat_AllCurvesOnePlot_Scatter._entryWidget['disabledforeground'] = '#777777'
# ...   checkbutton for plotting all lesser degree polynomials
                self.checkbuttonPlotAllLesserDegreePolynomials_AllCurvesOnePlot_Scatter.configure(state='disabled')
# ...   button for storing last-displayed curve fits
                self.buttonStoreCurveFits_Buffer_Scatter.configure(state='disabled')
            
# ... all - reference curve and X labels
            self.checkbuttonShowReferenceCurve_AllCurvesOnePlot_Scatter.configure(state='normal')
            if self.varCheckbuttonShowReferenceCurve_AllCurvesOnePlot_Scatter.get():
                self.comboboxShowReferenceCurveMultiplier_AllCurvesOnePlot_Scatter._entryWidget['state'] = NORMAL
                self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot_Scatter._entryWidget['state'] = NORMAL
            else:
                self.comboboxShowReferenceCurveMultiplier_AllCurvesOnePlot_Scatter._entryWidget['state'] = DISABLED
                self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot_Scatter._entryWidget['state'] = DISABLED
                
# ...       update reference curve list and X labels for 'all'
            self.handlerRefreshReferenceCurveList_Scatter()
                
# ... all - show sloped straight line reference curve
            self.checkbuttonShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter.configure(state='normal')
            if self.varCheckbuttonShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter.get():
                self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xinitial_Scatter.configure(entry_state='normal')
                self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xfinal_Scatter.configure(entry_state='normal')
                self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yinitial_Scatter.configure(entry_state='normal')
                self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yfinal_Scatter.configure(entry_state='normal')
                self.checkbuttonLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter.configure(state='normal')
                self.entryfieldLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter.configure(entry_state='normal')
                self.checkbuttonLabelSlopeDegreesSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter.configure(state='normal')
            else:
                self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xinitial_Scatter.configure(entry_state='disabled')
                self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xfinal_Scatter.configure(entry_state='disabled')
                self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yinitial_Scatter.configure(entry_state='disabled')
                self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yfinal_Scatter.configure(entry_state='disabled')
                self.checkbuttonLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter.configure(state='disabled')
                self.entryfieldLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter.configure(entry_state='disabled')
                self.checkbuttonLabelSlopeDegreesSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter.configure(state='disabled')
                
# ... all - show horizontal straight line reference curve
            self.checkbuttonShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter.configure(state='normal')
            if self.varCheckbuttonShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter.get():
                self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xinitial_Scatter.configure(entry_state='normal')
                self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xfinal_Scatter.configure(entry_state='normal')
                self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Y_Scatter.configure(entry_state='normal')
                self.checkbuttonLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter.configure(state='normal')
                self.entryfieldLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter.configure(entry_state='normal')
                self.checkbuttonLabelYMaxHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter.configure(state='normal')
            else:
                self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xinitial_Scatter.configure(entry_state='disabled')
                self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xfinal_Scatter.configure(entry_state='disabled')
                self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Y_Scatter.configure(entry_state='disabled')
                self.checkbuttonLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter.configure(state='disabled')
                self.entryfieldLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter.configure(entry_state='disabled')
                self.checkbuttonLabelYMaxHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter.configure(state='disabled')
                
# ... all - show vertical straight line reference curve
            self.checkbuttonShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Scatter.configure(state='normal')
            if self.varCheckbuttonShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Scatter.get():
                self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yinitial_Scatter.configure(entry_state='normal')
                self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yfinal_Scatter.configure(entry_state='normal')
                self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_X_Scatter.configure(entry_state='normal')
                self.checkbuttonLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot_Scatter.configure(state='normal')
                self.entryfieldLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot_Scatter.configure(entry_state='normal')
                self.checkbuttonLabelXMaxVerticalStraightLineReferenceCurve_AllCurvesOnePlot_Scatter.configure(state='normal')
            else:
                self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yinitial_Scatter.configure(entry_state='disabled')
                self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yfinal_Scatter.configure(entry_state='disabled')
                self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_X_Scatter.configure(entry_state='disabled')
                self.checkbuttonLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot_Scatter.configure(state='disabled')
                self.entryfieldLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot_Scatter.configure(entry_state='disabled')
                self.checkbuttonLabelXMaxVerticalStraightLineReferenceCurve_AllCurvesOnePlot_Scatter.configure(state='disabled')
                
# ... all - plot x-y from file               
            self.checkbuttonPlotCsvFileData_AllCurvesOnePlot_Scatter.configure(state='normal')
            if self.varCheckbuttonPlotCsvFileData_AllCurvesOnePlot_Scatter.get():
                self.entryPlotCsvFileData_AllCurvesOnePlot_Scatter.configure(state='normal')
                self.comboboxPlotCsvFileData_X_Column_AllCurvesOnePlot_Scatter._entryWidget['state']=NORMAL
                self.comboboxPlotCsvFileData_Y_Column_AllCurvesOnePlot_Scatter._entryWidget['state']=NORMAL
            else:
                self.entryPlotCsvFileData_AllCurvesOnePlot_Scatter.configure(state='disabled')
                self.comboboxPlotCsvFileData_X_Column_AllCurvesOnePlot_Scatter._entryWidget['state']=DISABLED
                self.comboboxPlotCsvFileData_Y_Column_AllCurvesOnePlot_Scatter._entryWidget['state']=DISABLED
                
# ... all - x-ticks size and color
            self.comboboxFontXTicks_AllCurvesOnePlot_Scatter._entryWidget['state'] = NORMAL

# ... all - y-ticks size and color
            self.comboboxFontYTicks_AllCurvesOnePlot_Scatter._entryWidget['state'] = NORMAL  

            
        else:
# scatter plot window did not exist; use default values
# initialize
# zero out attributes that are set in the called module
# ... these values are to be stored in storage buffer if user specifies
# ... one equation per curve, of course, so only one list here
            self.curvefit_CurveFitEquations_Scatter = []
# ... each curve has different y values, so this will be a list of lists
            self.curvefit_BestY_Scatter = []
# ... x values will be same for all curvefits, so only one list here
            self.curvefit_BestX_Scatter = []
# ... X and Y headers
            self.curvefit_YHeader_Scatter = ''
            self.curvefit_XHeader_Scatter = ''
# ... title
            self.curvefit_Title_Scatter = ''
            
# DEFAULT SETTINGS
# ... replot
            self.checkbuttonReplotInCurrentWindow_Scatter.deselect()
            
# ...  erase previous plot
            self.checkbuttonKeepPreviousPlotInCurrentWindow_Scatter.deselect()
            
# ...  disable replot button if 'erase previous plot' button is not checked
            if self.varReplotInCurrentWindow_Scatter.get():
                self.checkbuttonKeepPreviousPlotInCurrentWindow_Scatter.configure(state='normal')
            else:
                self.checkbuttonKeepPreviousPlotInCurrentWindow_Scatter.configure(state='disabled')
                
# ... if number of table curves is non-zero, check the 'Plot curves from Table' checkbutton
            if self.varNumberOfTableCurves_Scatter.get() <> 0:
                self.varCheckbuttonTableData_Scatter.set(1)
            else:
                self.varCheckbuttonTableData_Scatter.set(0)
                
# ... if number of buffer curves is non-zero, check the 'Plot curves from Storage Buffer' checkbutton
            if self.varNumberOfStorageBufferCurves_Scatter.get() <> 0:
                self.varCheckbuttonBufferData_Scatter.set(1)
            else:
                self.varCheckbuttonBufferData_Scatter.set(0)
                
# ... line width
            self.comboboxLineWidthPlots_Scatter.setentry(
                self.listLineWidth_Plots_Scatter[1]
                )
                
# ... marker size
            self.comboboxMarkerSizePlots_Scatter.setentry(
                self.listDataMarkerSize[3]
                )
                
# ... plot style radiobutton
            self.var_radiobuttonPlotStyle_Scatter.set('cartesian')
            
# ... base for log plots
            self.comboboxBaseForLogPlotsX_Scatter.setentry(
                self.baseForLogPlots[6]
                )
            self.comboboxBaseForLogPlotsY_Scatter.setentry(
                self.baseForLogPlots[6]
                )
            self.comboboxBaseForLogPlotsX_Scatter._entryWidget['state']=DISABLED
            self.comboboxBaseForLogPlotsY_Scatter._entryWidget['state']=DISABLED
          
# ------------  all -------------
            self.dictMultiCurvePerChartPlotParams_Scatter = \
                copy.deepcopy(self.dictMultiCurvePerChartPlotParams_Scatter_Defaults)

# ... connect data points with dashed line
            self.varCheckbuttonConnectDataMarkers_Scatter.set(
                self.dictMultiCurvePerChartPlotParams_Scatter['connectDataPoints']
                )
                
# ... all - show titles
            self.checkbuttonShowTitle_AllCurvesOnePlot_Scatter.configure(state='normal')
            self.varEntryShowTitle_AllCurvesOnePlot_Scatter.set('')
            if self.dictMultiCurvePerChartPlotParams_Scatter['showTitle']:
                self.checkbuttonShowTitle_AllCurvesOnePlot_Scatter.select()
                self.entryShowTitle_AllCurvesOnePlot_Scatter.configure(state='normal')
                self.comboboxFontTitle_AllCurvesOnePlot_Scatter._entryWidget['state'] = NORMAL
                self.comboboxColorTitle_AllCurvesOnePlot_Scatter._entryWidget['state'] = NORMAL
            else:
                self.checkbuttonShowTitle_AllCurvesOnePlot_Scatter.deselect()
                self.entryShowTitle_AllCurvesOnePlot_Scatter.configure(state='disabled')
                self.comboboxFontTitle_AllCurvesOnePlot_Scatter._entryWidget['state'] = DISABLED
                self.comboboxColorTitle_AllCurvesOnePlot_Scatter._entryWidget['state'] = DISABLED
# ... set title defaults
# ...   title
            self.varEntryShowTitle_AllCurvesOnePlot_Scatter.set(
                self.dictMultiCurvePerChartPlotParams_Scatter['showTitle_title']
                )
# ...   title font
            self.comboboxFontTitle_AllCurvesOnePlot_Scatter.setentry(
                self.dictMultiCurvePerChartPlotParams_Scatter['fontsizeTitle']
                )
# ...   title color
            self.comboboxColorTitle_AllCurvesOnePlot_Scatter.setentry(
                self.dictMultiCurvePerChartPlotParams_Scatter['colorTitle']
                )
            
# ... all - show y label
            self.checkbuttonShowLabelY_AllCurvesOnePlot_Scatter.configure(state='normal')
            self.varEntryShowLabelY_AllCurvesOnePlot_Scatter.set('')
            if self.dictMultiCurvePerChartPlotParams_Scatter['showYLabel']:
                self.checkbuttonShowLabelY_AllCurvesOnePlot_Scatter.select()
                self.entryShowLabelY_AllCurvesOnePlot_Scatter.configure(state='normal')
            else:
                self.checkbuttonShowLabelY_AllCurvesOnePlot_Scatter.deselect()
                self.entryShowLabelY_AllCurvesOnePlot_Scatter.configure(state='disabled')
# ... set y-label defaults
            self.varEntryShowLabelY_AllCurvesOnePlot_Scatter.set(
                self.dictMultiCurvePerChartPlotParams_Scatter['showYLabel_label']
                )
            
# ... all - show x label
            self.checkbuttonShowLabelX_AllCurvesOnePlot_Scatter.configure(state='normal')
            self.comboboxShowLabelX_AllCurvesOnePlot_Scatter.setentry('')
            if self.dictMultiCurvePerChartPlotParams_Scatter['showXLabel']:
# ... set x-label defaults 
                self.checkbuttonShowLabelX_AllCurvesOnePlot_Scatter.select()
                self.comboboxShowLabelX_AllCurvesOnePlot_Scatter._entryWidget['state'] = NORMAL
                self.comboboxShowLabelX_AllCurvesOnePlot_Scatter.setentry(
#                self.listitemsShowLabelX_AllCurvesOnePlot_Scatter[0]
                    self.dictMultiCurvePerChartPlotParams_Scatter['showXLabel_label']
                )
            else:
# ... leave blank; disable
                self.checkbuttonShowLabelX_AllCurvesOnePlot_Scatter.deselect()
                self.comboboxShowLabelX_AllCurvesOnePlot_Scatter._entryWidget['state'] = DISABLED
            
            if DEBUG_SCATTER:
                print('\nself.comboboxShowLabelX.. = %s' % self.comboboxShowLabelX_AllCurvesOnePlot_Scatter.get())
                print('\nself.dict..(showXLabel_label) = %s' % self.dictMultiCurvePerChartPlotParams_Scatter['showXLabel_label'])
                print('\nstate = %s' % self.comboboxShowLabelX_AllCurvesOnePlot_Scatter._entryWidget['state'])
            
# ... all - xy-labels font size
            if (
                self.dictMultiCurvePerChartPlotParams_Scatter['showXLabel'] 
                or
                self.dictMultiCurvePerChartPlotParams_Scatter['showYLabel']
                ):
                self.comboboxFontXYLabels_AllCurvesOnePlot_Scatter._entryWidget['state'] = NORMAL
                self.comboboxColorXYLabels_AllCurvesOnePlot_Scatter._entryWidget['disabledbackground'] = 'white'
                self.comboboxColorXYLabels_AllCurvesOnePlot_Scatter._entryWidget['disabledforeground'] = 'black'
            else:
                self.comboboxFontXYLabels_AllCurvesOnePlot_Scatter._entryWidget['state'] = DISABLED
                self.comboboxColorXYLabels_AllCurvesOnePlot_Scatter._entryWidget['disabledbackground'] = 'lightgray'
                self.comboboxColorXYLabels_AllCurvesOnePlot_Scatter._entryWidget['disabledforeground'] = '#777777'  # dark gray
                
# ... set x-label and y-label font and color defaults                
            self.comboboxFontXYLabels_AllCurvesOnePlot_Scatter.setentry(
                self.dictMultiCurvePerChartPlotParams_Scatter['fontsizeXYLabels']
                )
            self.comboboxColorXYLabels_AllCurvesOnePlot_Scatter.setentry(
                self.dictMultiCurvePerChartPlotParams_Scatter['colorXYLabels']
                )
                
# ... all - show legend
            self.checkbuttonShowLegend_AllCurvesOnePlot_Scatter.configure(state='normal')  
            if self.dictMultiCurvePerChartPlotParams_Scatter['showLegend']:
                self.checkbuttonShowLegend_AllCurvesOnePlot_Scatter.select()
                self.comboboxShowLegendLocation_AllCurvesOnePlot_Scatter._entryWidget['state']=NORMAL
                self.comboboxFontLegend_AllCurvesOnePlot_Scatter._entryWidget['state']=NORMAL
            else:
                self.checkbuttonShowLegend_AllCurvesOnePlot_Scatter.deselect()
                self.comboboxShowLegendLocation_AllCurvesOnePlot_Scatter._entryWidget['state']=DISABLED
                self.comboboxFontLegend_AllCurvesOnePlot_Scatter._entryWidget['state']=DISABLED
# ... set legend defaults
            self.comboboxShowLegendLocation_AllCurvesOnePlot_Scatter.selectitem(self.legendLocations[0]) 
            self.comboboxFontLegend_AllCurvesOnePlot_Scatter.setentry(
                self.dictMultiCurvePerChartPlotParams_Scatter['fontsizeLegend']
                )
            self.varCheckbuttonShowLegendShadow_AllCurvesOnePlot_Scatter.set(
                self.dictMultiCurvePerChartPlotParams_Scatter['showLegendShadow']
                )
            
# ... all - show grid
            self.checkbuttonShowGrid_AllCurvesOnePlot_Scatter.configure(state='normal')
            if self.dictMultiCurvePerChartPlotParams_Scatter['showGrid']:
                self.checkbuttonShowGrid_AllCurvesOnePlot_Scatter.select()
            else:
                self.checkbuttonShowGrid_AllCurvesOnePlot_Scatter.deselect()
                
# ... all - show curve fit using polynomial
            self.checkbuttonShowPolynomialCurveFit_AllCurvesOnePlot_Scatter.configure(state='normal')
            if self.dictMultiCurvePerChartPlotParams_Scatter_Defaults['showCurveFit']:
# ... normal
                self.checkbuttonShowPolynomialCurveFit_AllCurvesOnePlot_Scatter.select()
# ...   degree of polynomial
                self.comboboxPolynomialDegree_AllCurvesOnePlot_Scatter._entryWidget['disabledbackground'] = 'white'
                self.comboboxPolynomialDegree_AllCurvesOnePlot_Scatter._entryWidget['disabledforeground'] = 'black'
# ...   number of points
                self.comboboxPolynomialNumberOfPoints_AllCurvesOnePlot_Scatter._entryWidget['disabledbackground'] = 'white'
                self.comboboxPolynomialNumberOfPoints_AllCurvesOnePlot_Scatter._entryWidget['disabledforeground'] = 'black'
# ...   coefficient decimal places
                self.comboboxPolynomialCoefficientDecimalPlaces_AllCurvesOnePlot_Scatter._entryWidget['disabledbackground'] = 'white'
                self.comboboxPolynomialCoefficientDecimalPlaces_AllCurvesOnePlot_Scatter._entryWidget['disabledforeground'] = 'black'
# ...   coefficient output format
                self.comboboxPolynomialCoefficientOutputFormat_AllCurvesOnePlot_Scatter._entryWidget['disabledbackground'] = 'white'
                self.comboboxPolynomialCoefficientOutputFormat_AllCurvesOnePlot_Scatter._entryWidget['disabledforeground'] = 'black'
# ...   checkbutton for plotting all lesser degree polynomials
                self.checkbuttonPlotAllLesserDegreePolynomials_AllCurvesOnePlot_Scatter.configure(state='normal')
# ...   button for storing last-displayed curve fits
                self.buttonStoreCurveFits_Buffer_Scatter.configure(state='normal')
                
            else:
                self.checkbuttonShowPolynomialCurveFit_AllCurvesOnePlot_Scatter.deselect()
# ... disabled
                self.comboboxPolynomialDegree_AllCurvesOnePlot_Scatter._entryWidget['disabledbackground'] = 'lightgray'             
                self.comboboxPolynomialDegree_AllCurvesOnePlot_Scatter._entryWidget['disabledforeground'] = '#777777'             
# ...   number of points
                self.comboboxPolynomialNumberOfPoints_AllCurvesOnePlot_Scatter._entryWidget['disabledbackground'] = 'lightgray'
                self.comboboxPolynomialNumberOfPoints_AllCurvesOnePlot_Scatter._entryWidget['disabledforeground'] = '#777777'
# ...   coefficient decimal places
                self.comboboxPolynomialCoefficientDecimalPlaces_AllCurvesOnePlot_Scatter._entryWidget['disabledbackground'] = 'lightgray'
                self.comboboxPolynomialCoefficientDecimalPlaces_AllCurvesOnePlot_Scatter._entryWidget['disabledforeground'] = '#777777'
# ...   coefficient output format
                self.comboboxPolynomialCoefficientOutputFormat_AllCurvesOnePlot_Scatter._entryWidget['disabledbackground'] = 'lightgray'
                self.comboboxPolynomialCoefficientOutputFormat_AllCurvesOnePlot_Scatter._entryWidget['disabledforeground'] = '#777777'
# ...   checkbutton for plotting all lesser degree polynomials
                self.checkbuttonPlotAllLesserDegreePolynomials_AllCurvesOnePlot_Scatter.configure(state='disabled')
# ...   button for storing last-displayed curve fits
                self.buttonStoreCurveFits_Buffer_Scatter.configure(state='disabled')
                
# set curve fit defaults
            self.comboboxPolynomialDegree_AllCurvesOnePlot_Scatter.setentry(
                self.dictMultiCurvePerChartPlotParams_Scatter['polyDegree']
                )        
            self.comboboxPolynomialNumberOfPoints_AllCurvesOnePlot_Scatter.setentry(
                self.dictMultiCurvePerChartPlotParams_Scatter['numPointsForCurveFit']
                )
            self.comboboxPolynomialCoefficientDecimalPlaces_AllCurvesOnePlot_Scatter.setentry(
                self.dictMultiCurvePerChartPlotParams_Scatter['numberDecimalPlacesInEqn']
                )
            self.comboboxPolynomialCoefficientOutputFormat_AllCurvesOnePlot_Scatter.setentry(
                self.dictMultiCurvePerChartPlotParams_Scatter['formatPolyCoefs']
                )
            self.varCheckbuttonPlotAllLesserDegreePolynomials_AllCurvesOnePlot_Scatter.set(
                self.dictMultiCurvePerChartPlotParams_Scatter['plotAllLesserDegrees']
                )
            
# ... all - show reference curve
            self.checkbuttonShowReferenceCurve_AllCurvesOnePlot_Scatter.configure(state='normal')
# ...       to initialize...
            if self.dictMultiCurvePerChartPlotParams_Scatter['showReferenceCurve']:   
                self.checkbuttonShowReferenceCurve_AllCurvesOnePlot_Scatter.select()
                self.comboboxShowReferenceCurveMultiplier_AllCurvesOnePlot_Scatter._entryWidget['state']=NORMAL
                self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot_Scatter._entryWidget['state']=NORMAL
            else:
                self.checkbuttonShowReferenceCurve_AllCurvesOnePlot_Scatter.deselect()
                self.comboboxShowReferenceCurveMultiplier_AllCurvesOnePlot_Scatter._entryWidget['state']=DISABLED
                self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot_Scatter._entryWidget['state']=DISABLED
            self.comboboxShowReferenceCurveMultiplier_AllCurvesOnePlot_Scatter.selectitem(self.multipliersReferenceCurve[4])   
            
# ... set x value
            try:
                self.comboboxShowLabelX_AllCurvesOnePlot_Scatter.setentry(
                    (self.headernames_X_Table_Scatter + self.headernames_X_Buffer_Scatter)[0]
                    )
            except:
                self.comboboxShowLabelX_AllCurvesOnePlot_Scatter.setentry('')
                
# ... set reference curve value
            try:
                self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot_Scatter.setentry(
                    (self.headerNames_Y_Table_Scatter + self.headerNames_Y_Buffer_Scatter)[0]
                    )
            except:
                self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot_Scatter.setentry('')

# ...       update reference curve list and X labels
            self.handlerRefreshReferenceCurveList_Scatter()
                
# ... all - show sloped straight line reference curve
            self.checkbuttonShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter.configure(state='normal')
            if self.varCheckbuttonShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter.get():
                self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xinitial_Scatter.configure(entry_state='normal')
                self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xfinal_Scatter.configure(entry_state='normal')
                self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yinitial_Scatter.configure(entry_state='normal')
                self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yfinal_Scatter.configure(entry_state='normal')
                self.checkbuttonLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter.configure(state='normal')
                self.entryfieldLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter.configure(entry_state='normal')
                self.checkbuttonLabelSlopeDegreesSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter.configure(state='normal')
            else:
                self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xinitial_Scatter.configure(entry_state='disabled')
                self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xfinal_Scatter.configure(entry_state='disabled')
                self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yinitial_Scatter.configure(entry_state='disabled')
                self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yfinal_Scatter.configure(entry_state='disabled')
                self.checkbuttonLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter.configure(state='disabled')
                self.entryfieldLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter.configure(entry_state='disabled')
                self.checkbuttonLabelSlopeDegreesSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter.configure(state='disabled')
# ...     set values
            self.varCheckbuttonLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter.set(1)
            self.entryfieldLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter.setentry('s-ref line')
            
# ... all - show horizontal straight line reference curve
            self.checkbuttonShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter.configure(state='normal')
# ... show these widgets as 'normal' if by default the checkbutton is checked
            if self.varCheckbuttonShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter.get():
                self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xinitial_Scatter.configure(entry_state='normal')
                self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xfinal_Scatter.configure(entry_state='normal')
                self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Y_Scatter.configure(entry_state='normal')
                self.checkbuttonLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter.configure(state='normal')
                self.entryfieldLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter.configure(entry_state='normal')
                self.checkbuttonLabelYMaxHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter.configure(state='normal')            
            else:
                self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xinitial_Scatter.configure(entry_state='disabled')
                self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xfinal_Scatter.configure(entry_state='disabled')
                self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Y_Scatter.configure(entry_state='disabled')
                self.checkbuttonLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter.configure(state='disabled')
                self.entryfieldLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter.configure(entry_state='disabled')
                self.checkbuttonLabelYMaxHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter.configure(state='disabled')
# ...     set values regardless of whether checkbutton is checked
            self.varCheckbuttonLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter.set(1)
            self.entryfieldLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter.setentry('h-ref line')


# ... all - show vertical straight line reference curve
            self.checkbuttonShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Scatter.configure(state='normal')
            if self.varCheckbuttonShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Scatter.get():
                self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yinitial_Scatter.configure(entry_state='normal')
                self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yfinal_Scatter.configure(entry_state='normal')
                self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_X_Scatter.configure(entry_state='normal')
                self.checkbuttonLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot_Scatter.configure(state='normal')
                self.entryfieldLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot_Scatter.configure(entry_state='normal')
                self.checkbuttonLabelXMaxVerticalStraightLineReferenceCurve_AllCurvesOnePlot_Scatter.configure(state='normal')
            else:
                self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yinitial_Scatter.configure(entry_state='disabled')
                self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yfinal_Scatter.configure(entry_state='disabled')
                self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_X_Scatter.configure(entry_state='disabled')
                self.checkbuttonLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot_Scatter.configure(state='disabled')
                self.entryfieldLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot_Scatter.configure(entry_state='disabled')
                self.checkbuttonLabelXMaxVerticalStraightLineReferenceCurve_AllCurvesOnePlot_Scatter.configure(state='disabled')
# ...     set values
            self.varCheckbuttonLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot_Scatter.set(1)
            self.entryfieldLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot_Scatter.setentry('v-ref line')

# ... plot x-y from file
            self.checkbuttonPlotCsvFileData_AllCurvesOnePlot_Scatter.configure(state='normal')
            self.entryPlotCsvFileData_AllCurvesOnePlot_Scatter.configure(state='disabled')
            self.comboboxPlotCsvFileData_X_Column_AllCurvesOnePlot_Scatter._entryWidget['state']=DISABLED
            self.comboboxPlotCsvFileData_Y_Column_AllCurvesOnePlot_Scatter._entryWidget['state']=DISABLED
            
# ... x-ticks size and color
            self.comboboxFontXTicks_AllCurvesOnePlot_Scatter._entryWidget['state']=NORMAL
            self.comboboxFontXTicks_AllCurvesOnePlot_Scatter.setentry(
                self.dictMultiCurvePerChartPlotParams_Scatter['fontsizeXTicks']
                )

# ... y-ticks size and color
            self.comboboxFontYTicks_AllCurvesOnePlot_Scatter._entryWidget['state']=NORMAL
            self.comboboxFontYTicks_AllCurvesOnePlot_Scatter.setentry(
                self.dictMultiCurvePerChartPlotParams_Scatter['fontsizeYTicks']
                )

# x-ticks color, y-ticks color, chart background color, and chart plot border color
            self.comboboxColorXTicks_AllCurvesOnePlot_Scatter.setentry(
                self.dictMultiCurvePerChartPlotParams_Scatter['colorXTicks']
                )
            self.comboboxColorYTicks_AllCurvesOnePlot_Scatter.setentry(
                self.dictMultiCurvePerChartPlotParams_Scatter['colorYTicks']
                )
            self.comboboxColorBackground_AllCurvesOnePlot_Scatter.setentry(
                self.dictMultiCurvePerChartPlotParams_Scatter['colorBackground']
                )
            self.comboboxColorPlotBorder_AllCurvesOnePlot_Scatter.setentry(
                self.dictMultiCurvePerChartPlotParams_Scatter['colorPlotBorder']
                )
                
#------------------------------
                
# Now call plot labeling methods
        self.labels_AllCurvesOnePlot_Scatter(
            self.labels_xWindowLocationAll_Scatter,
            self.labels_yWindowLocationAll_Scatter
            )
        
        return
  

# ===== x-y plots =====
    def handlerXYPlotPreprocess(self):
        '''
        widgets for preprocessing plots
        
        Calls:
            handlerPlotXYSelect
            
        Called by:
            handlerTableFunctionsShowValues
            
        Significant variables:
            self.varNumberOfTableCurves         IntVar                  entry field
                (self.entryNumberOfTableCurves)
            self.varNumberOfStorageBufferCurves        IntVar                  entry field
                (self.entryNumberOfBufferCurves)
            self.varNumberOfTotalCurves         IntVar                  entry field
                (self.entryNumberOfTotalCurves)
            -----
            self.varSingleCurvePerPlot          IntVar                  radiobutton
                (self.radiobuttonSingleCurvePerPlot)
            -----
            self.checkbuttonShowGrid_SingleCurvePerPlot                 checkbutton
            -----
            self.varAllCurvesOnePlot            IntVar                  radiobutton
                (self.radiobuttonAllCurvesOnePlot)
            -----
            self.checkbuttonShowTitle_AllCurvesOnePlot                  checkbutton
            -----
            self.varEntryShowTitle_AllCurvesOnePlot  StringVar               entry field
                (self.entryShowTitle_AllCurvesOnePlot)
            -----
            self.varShowLabelY_AllCurvesOnePlot StringVar               entry field
                (self.entryShowLabelY_AllCurvesOnePlot)
            -----
            self.checkbuttonShowLabelX_AllCurvesOnePlot                 checkbutton
            -----
            self.comboboxShowLabelX_AllCurvesOnePlot
            -----
            self.checkbuttonShowGrid_AllCurvesOnePlot                   checkbutton
            -----
            self.checkbuttonShowReferenceCurve_AllCurvesOnePlot         checkbutton
            -----
            self.comboboxShowReferenceCurveMultiplier_AllCurvesOnePlot  combobox
            -----
            self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot     combobox
            -----
            
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerXYPlotPreprocess')
            
# set last button pressed
        self.lastButtonPressed(
            BUTTONLABEL_XYPLOTS
            )
            
        self.MySQL_Output(
            0,
            '  Database: ' + self.myDatabase + '  Table: ' +
            self.myTable
            )
        
# background color
        colorbg='lightblue'

# from TABLE
        '''
# get Y headers
        self.jcountTable = 0
# ... determine how many y-values are checked; then, display; also get headers
        self.headerNamesY_AllCurvesOnOnePlot = []
        jindex=1
        for var in self.varYSelect:
            if var.get():
                for key,value in self.dictColumnHeaders.iteritems():
                   if value == jindex:
                        self.headerNamesY_AllCurvesOnOnePlot.append(key)
                self.jcountTable += 1
            jindex += 1
        
# get X header
        index_X = self.varXSelect.get()
        self.headerNameX = ''
# ... now find the key that goes with this index value
        for key,value in self.dictColumnHeaders.iteritems():
            if value == index_X:
                self.headerNameX = key
                break
        '''
                
# from STORAGE BUFFER
#   (number of Storage Buffer curves total: len(self.varSelectAnyRow_Buffer)


#        jcountBuffer = 0
#        self.jcountBuffer = 0
#        self.listWhichBufferRowsAreChecked = []
#        inumWhichBufferRowsAreChecked = 0
        
        
# if plot window is mapped (displayed), then if 'Include select curves from Storage Buffer' is checked, calculate number of curves
# ... if not, leave count at zero.
# if plot window is NOT mapped, then assume 'Include select curves from Storage Buffer' is checked if self.jcountBuffer is greater than zero
# ... otherwise, if self.jcountBuffer is zero, leave unchecked
        
                
                
# always destroy and regenerate plot label generation window
        try:
            self.labels_xWindowLocationSingle = self.toplevelLabelsSinglePlotPerCurve.winfo_rootx() - self.offsetWindowX
            self.labels_yWindowLocationSingle = self.toplevelLabelsSinglePlotPerCurve.winfo_rooty() - self.offsetWindowY
            self.toplevelLabelsSinglePlotPerCurve.destroy()
        except:
            pass
            
        try:
            self.labels_xWindowLocationAll = self.toplevelLegendLabelsAllCurvesOnePlot.winfo_rootx() - self.offsetWindowX
            self.labels_yWindowLocationAll = self.toplevelLegendLabelsAllCurvesOnePlot.winfo_rooty() - self.offsetWindowY
            self.toplevelLegendLabelsAllCurvesOnePlot.destroy()
        except:
            pass

# ... see if main plot window is open            
        try:
            mappedPlotPreprocess_XY = self.toplevelXYPlotPreprocess.winfo_exists()
        except:
            mappedPlotPreprocess_XY = False
 
# ... see if storage buffer window is open 
        try:
            mappedShowStorageBuffer = self.toplevelShowStorageBuffer.winfo_exists()
        except:
            mappedShowStorageBuffer = False
            '''
            if self.toplevelShowStorageBuffer.winfo_exists():
                mappedShowStorageBuffer = True
            else:
                mappedShowStorageBuffer = False
        except:
            mappedShowStorageBuffer = False
            '''

# if plot window exists, determine how many storage buffer rows have been selected
        '''
        if mappedPlotPreprocess:
            for (inum,var) in enumerate(self.varSelectAnyRow_Buffer):
#                inumWhichBufferRowsAreChecked += 1
                if var.get(): 
                    jcountBuffer += 1
                    self.listWhichBufferRowsAreChecked.append(
#                        inumWhichBufferRowsAreChecked
                        inum + 1
                        )
        '''   

# if plot window exists, determine how many storage buffer rows have been selected 
        jcountBuffer = 0
        self.listWhichBufferRowsAreChecked = []
        
        if mappedShowStorageBuffer:
            for (inum,var) in enumerate(self.varSelectAnyRow_Buffer):
#                inumWhichBufferRowsAreChecked += 1
                if var.get(): 
                    jcountBuffer += 1
                    self.listWhichBufferRowsAreChecked.append(
#                        inumWhichBufferRowsAreChecked
                        inum + 1
                        )
                        
# display number of rows selected
            self.varEntryNumberOfRowsSelected_Buffer.set(jcountBuffer)

            if mappedPlotPreprocess_XY:
# X-Y Plot Specs window is displayed
                if self.jcountTable <> self.varNumberOfTableCurves.get():
                    if DEBUG_XY:
                        print '\n#1'
                    if self.varCheckbuttonBufferData.get():
                        self.jcountBuffer = jcountBuffer
                    else:
                        self.jcountBuffer = 0
                    
                elif (
                 self.varCheckbuttonBufferData.get()
                  and
                 self.varNumberOfStorageBufferCurves.get() == jcountBuffer
                  and
                 self.varNumberOfStorageBufferCurves.get() <> 0
                  ):
                    if DEBUG_XY:
                        print '\n#2'
                    self.jcountBuffer = jcountBuffer
                    
                elif (
                self.varCheckbuttonBufferData.get()
                and
                self.varNumberOfStorageBufferCurves.get() == 0
                ):
                    if jcountBuffer == 0:
                        if DEBUG_XY:
                            print '\n#3'
                        self.jcountBuffer = 0
                    else:
                        self.jcountBuffer = jcountBuffer
                    
                elif (
                 self.varNumberOfStorageBufferCurves.get() == 0
                  and
                 jcountBuffer > 0
                  ):
                    if DEBUG_XY:
                        print '\n#4'
                    self.varCheckbuttonBufferData.set(1)
                    self.jcountBuffer = jcountBuffer
                    
                elif (
                self.varNumberOfStorageBufferCurves.get() <> 0
                and
                self.varCheckbuttonBufferData.get() == 1
                ):
                    if DEBUG_XY:
                        print '\n#5'
                    self.jcountBuffer = jcountBuffer
                    
                else:
                    if DEBUG_XY:
                        print '\n#6'
                    self.jcountBuffer = 0
            else:
                if DEBUG_XY:
                    print '\n#7'
                self.jcountBuffer = jcountBuffer
        else:
# storage buffer window is NOT displayed
            if mappedPlotPreprocess_XY:
                if self.varCheckbuttonBufferData.get():
                    if DEBUG_XY:
                        print '\n#8'
                    self.jcountBuffer = jcountBuffer
                else:
                    if DEBUG_XY:
                        print '\n#9'
                    self.jcountBuffer = 0
            else:
                if DEBUG_XY:
                    print '\n#10'
                self.jcountBuffer = jcountBuffer
                
        
        if mappedPlotPreprocess_XY:
            self.previousWindow_XY = True

# save current state of window variables, to restore after toplevel is regenerated

# ... include table data
            includeTableData_checkbutton_status = self.varCheckbuttonTableData.get()
            numberOfPreviousTableCurves = self.varNumberOfTableCurves.get()
            
# ... include buffer data
            includeBufferData_checkbutton_status = self.varCheckbuttonBufferData.get()
            numberOfPreviousStorageBufferCurves = self.varNumberOfStorageBufferCurves.get()
            
# ... replot
            replot_checkbutton_status = self.varReplotInCurrentWindow.get()
            
# ... erase previous plot
            keep_previous_plot_status = self.varKeepPreviousPlotInCurrentWindow.get()
            
# ... plot style radiobutton
            plot_Style_XY = self.var_radiobuttonPlotStyle.get()
            
# ... base for log plots
            plot_BaseForLogPlotsX = self.comboboxBaseForLogPlotsX.get()
            plot_BaseForLogPlotsY = self.comboboxBaseForLogPlotsY.get()
            
# ... line width
            lineWidthAllPlots = self.comboboxLineWidthPlots_XY.get()
            
# ... marker size
            markerSizeAllPlots = self.comboboxMarkerSizePlots_XY.get()
            
# ... single or all radiobutton            
            single_or_all_radiobutton = self.varCurvesSelection.get()
            
# ... single - main title
            single_showMainTitle_checkbutton_status = self.varShowMainTitle_SingleCurvePerPlot.get()
            
# ... single - text main title
            single_textMainTitle_checkbutton_status = self.varEntryMainTitle_SingleCurvePerPlot.get()
            
# ... single - font main title
            single_fontMainTitle_combobox_value = self.comboboxFontMainTitle_SingleCurvePerPlot.get()

# ... single - color main title
            single_colorMainTitle_combobox_value = self.comboboxColorMainTitle_SingleCurvePerPlot.get()
            
# ... single - show plot titles
            single_showTitles_checkbutton_status = self.varShowTitles_SingleCurvePerPlot.get()
            
# ... single - font plot titles
            single_fontTitles_combobox_value = self.comboboxFontTitle_SingleCurvePerPlot.get()
            
# ... single - show grids
            single_showGrids_checkbutton_status = self.varShowGrid_SingleCurvePerPlot.get()
            
# ... single - labels font and color
            single_fontXYLabels_combobox_values = self.comboboxFontLabels_SingleCurvePerPlot.get()
            single_colorXYLabels_combobox_values = self.comboboxColorLabels_SingleCurvePerPlot.get()
            
# ... single - x-ticks font and color
            single_fontXTicks_combobox_value = self.comboboxFontXTicks_SingleCurvePerPlot.get()
            single_colorXTicks_combobox_value = self.comboboxColorXTicks_SingleCurvePerPlot.get()
            
# ... single - y-ticks font and color
            single_fontYTicks_combobox_value = self.comboboxFontYTicks_SingleCurvePerPlot.get()
            single_colorYTicks_combobox_value = self.comboboxColorYTicks_SingleCurvePerPlot.get()
            
# ... single - background color
            single_colorBackground_combobox_value = self.comboboxColorBackground_SingleCurvePerPlot.get()
            
# ... single - border color
            single_colorBorder_combobox_value = self.comboboxColorBorder_SingleCurvePerPlot.get()

# ... all - show titles
            all_showTitles_checkbutton_status = self.varCheckbuttonShowTitle_AllCurvesOnePlot.get()
            all_showTitles_entryfield_value = self.varEntryShowTitle_AllCurvesOnePlot.get()
            all_fontTitles_combobox_value = self.comboboxFontTitle_AllCurvesOnePlot.get()
            all_colorTitles_combobox_value = self.comboboxColorTitle_AllCurvesOnePlot.get()
            
# ... all - show y label
            all_showYLabel_checkbutton_status = self.varCheckbuttonShowLabelY_AllCurvesOnePlot.get()
            all_showYLabel_entryfield_value = self.varShowLabelY_AllCurvesOnePlot.get().strip()  
            
# ... all - show x label
            all_showXLabel_checkbutton_status = self.varCheckbuttonShowLabelX_AllCurvesOnePlot.get()
            
# ... all - x label entry
# ...       account for fact that self.headerNames_X[0] can be undefined if no table or buffer values 
# ...           have been selected
            try:
                all_showXLabel_entryfield_value = self.comboboxShowLabelX_AllCurvesOnePlot.get()
            except:
                all_showXLabel_entryfield_value = ''
                
# ... all xy-label font
            all_fontXYLabels_combobox_values = self.comboboxFontXYLabels_AllCurvesOnePlot.get()
            
# ... all xy-label color
            all_colorXYLabels_combobox_value = self.comboboxColorXYLabels_AllCurvesOnePlot.get()
            
# ... all - show legend
            all_showLegend_checkbutton_status = self.varCheckbuttonShowLegend_AllCurvesOnePlot.get()
            all_showLegend_combobox_value = self.comboboxShowLegendLocation_AllCurvesOnePlot.get()
            all_fontLegend_combobox_value = self.comboboxFontLegend_AllCurvesOnePlot.get()
            
# ... all - show grid
            all_showGrid_checkbutton_status = self.varCheckbuttonShowGrid_AllCurvesOnePlot.get()
            
# ... all - show reference curve
            all_showRefCurve_checkbutton_status = \
                self.varCheckbuttonShowReferenceCurve_AllCurvesOnePlot.get()
            all_showRefCurve_Multiplier_combobox_value = \
                self.comboboxShowReferenceCurveMultiplier_AllCurvesOnePlot.get()

# ... all = show sloped straight line reference curve
            all_showSlopedStraightLineRefCurve_checkbutton_status = \
                self.varCheckbuttonShowSlopedStraightReferenceCurve_AllCurvesOnePlot.get()
            all_showSlopedStraightLineRefCurve_x_initial = \
                self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xinitial.get()
            all_showSlopedStraightLineRefCurve_x_final = \
                self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xfinal.get()
            all_showSlopedStraightLineRefCurve_y_initial = \
                self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yinitial.get()
            all_showSlopedStraightLineRefCurve_y_final = \
                self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yfinal.get()
            all_showSlopedStraightLineRefCurve_UserLabel_checkbutton_status = \
                self.varCheckbuttonLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot.get()
            all_showSlopedStraightLineRefCurve_UserLabel = \
                self.entryfieldLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot.get()
            all_showSlopedStraightLineRefCurve_ShowSlope_checkbutton_status = \
                self.varCheckbuttonLabelSlopeDegreesSlopedStraightReferenceCurve_AllCurvesOnePlot.get()

# ... all - show horizontal straight line reference curve
            all_showHorizontalStraightLineRefCurve_checkbutton_status = \
                self.varCheckbuttonShowHorizontalStraightReferenceCurve_AllCurvesOnePlot.get()
            all_showHorizontalStraightLineRefCurve_x_initial = \
                self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xinitial.get()
            all_showHorizontalStraightLineRefCurve_x_final = \
                self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xfinal.get()
            all_showHorizontalStraightLineRefCurve_y = \
                self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Y.get()
            all_showHorizontalStraightLineRefCurve_UserLabel_checkbutton_status = \
                self.varCheckbuttonLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot.get()
            all_showHorizontalStraightLineRefCurve_UserLabel = \
                self.entryfieldLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot.get()
            all_showHorizontalStraightLineRefCurve_yValue_checkbutton_status = \
                self.varCheckbuttonLabelYMaxHorizontalStraightReferenceCurve_AllCurvesOnePlot.get()

# ... all - show vertical straight line reference curve
            all_showVerticalStraightLineRefCurve_checkbutton_status = \
                self.varCheckbuttonShowVerticalStraightReferenceCurve_AllCurvesOnePlot.get()
            all_showVerticalStraightLineRefCurve_y_initial = \
                self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yinitial.get()
            all_showVerticalStraightLineRefCurve_y_final = \
                self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yfinal.get()
            all_showVerticalStraightLineRefCurve_x = \
                self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_X.get()
            all_showVerticalStraightLineRefCurve_UserLabel_checkbutton_status = \
                self.varCheckbuttonLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot.get()
            all_showVerticalStraightLineRefCurve_UserLabel = \
                self.entryfieldLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot.get()
            all_showVerticalStraightLineRefCurve_XValue_checkbutton_status = \
                self.varCheckbuttonLabelXMaxVerticalStraightLineReferenceCurve_AllCurvesOnePlot.get()
                
# ... all - plot x-y data from file
            all_plotCsvFileData_checkbutton_status = self.varCheckbuttonPlotCsvFileData_AllCurvesOnePlot.get()
            all_plotCsvFileData_entry_value = self.varEntryPlotCsvFileData_AllCurvesOnePlot.get()
            all_plotCsvFileData_x_column_value = self.comboboxPlotCsvFileData_X_Column_AllCurvesOnePlot.get()
            all_plotCsvFileData_y_column_value = self.comboboxPlotCsvFileData_Y_Column_AllCurvesOnePlot.get()
            
# ... all - x-ticks size and color
            all_fontXTicks_combobox_value = self.comboboxFontXTicks_AllCurvesOnePlot.get()
            all_colorXTicks_combobox_value = self.comboboxColorXTicks_AllCurvesOnePlot.get()
            
# ... all - y-ticks size and color
            all_fontYTicks_combobox_value = self.comboboxFontYTicks_AllCurvesOnePlot.get()
            all_colorYTicks_combobox_value = self.comboboxColorYTicks_AllCurvesOnePlot.get()
            
# ... all - background color
            all_colorBackground_combobox_value = self.comboboxColorBackground_AllCurvesOnePlot.get()
            
# ... all - border color
            all_colorBorder_combobox_value = self.comboboxColorBorder_AllCurvesOnePlot.get()
            
# now destroy X-Y Plot Specs window; will regenerate below, then apply settings 
            self.plottingspecs_xWindowLocation_XY= self.toplevelXYPlotPreprocess.winfo_rootx() - self.offsetWindowX
            self.plottingspecs_yWindowLocation_XY= self.toplevelXYPlotPreprocess.winfo_rooty() - self.offsetWindowY
            self.toplevelXYPlotPreprocess.destroy()
            
        else:
            if DEBUG_XY:
                print(
                    'DEBUG: not saving state'
                    )
            self.previousWindow_XY = False
            

# open Toplevel frame for entering database name
        self.toplevelXYPlotPreprocess = Toplevel(
            self.toplevelTableValues,
            bg=colorbg,
            )
        self.toplevelXYPlotPreprocess.title(
            'Server: ' + self.comboServerMySQL.get() + '     ' +
            'Database: ' + self.varTableFunctionsSelectDatabase.get() + '     ' +
            'Table: ' + self.varEntryTableFunctionsSelectTable.get().strip()
            )

        self.toplevelXYPlotPreprocess.transient(self.toplevelTableValues)
        
# place the top window
        self.toplevelXYPlotPreprocess.geometry(
            '+%d+%d' % (
                        self.plottingspecs_xWindowLocation_XY,
                        self.plottingspecs_yWindowLocation_XY
                        )
            )        
            
# Row 0
        rowFrame = 0
# ... title frame
        frame_00 = Frame(
            self.toplevelXYPlotPreprocess,
            bg=colorbg,
#                            relief=RIDGE,
#                            borderwidth=2,
            )
        frame_00.grid(
            row=rowFrame,
            column=0,
            padx=2,
            pady=1,
            )
# ... number of curves
        rowFrame += 1
        frame_05 = Frame(
            self.toplevelXYPlotPreprocess,
            bg=colorbg,
            )
        frame_05.grid(
            row=rowFrame,
            column=0,
            padx=5,
            pady=1,
            sticky=E+W,
            )
# plots from storage buffer
        rowFrame += 1
        frame_12 = Frame(
            self.toplevelXYPlotPreprocess,
            bg=colorbg,
            )
        frame_12.grid(  
            row=rowFrame,
            column=0,
            padx=2,
            pady=1,
            sticky=E+W,
            )
        rowFrame += 1
        frame_14 = Frame(
            self.toplevelXYPlotPreprocess,
            bg=colorbg,
            )
        frame_14.grid(  
            row=rowFrame,
            column=0,
            padx=2,
            pady=1,
            sticky=E+W,
            )
        rowFrame += 1
        frame_15 = Frame(
            self.toplevelXYPlotPreprocess,
            bg=colorbg,
            )
        frame_15.grid(  
            row=rowFrame,
            column=0,
            padx=20,
            pady=1,
            sticky=E+W,
            )
            
# ... number of curves
        rowFrame += 1
        frame_10 = Frame(
            self.toplevelXYPlotPreprocess,
            bg=colorbg,
            )
        frame_10.grid(
            row=rowFrame,
            column=0,
            padx=2,
            pady=1,
            sticky=E+W,
            )
# ... plot style
        rowFrame += 1
        frame_11 = Frame(
            self.toplevelXYPlotPreprocess,
            bg=colorbg,
            )
        frame_11.grid(
            row=rowFrame,
            column=0,
            padx=2,
            pady=1,
            sticky=E+W
            )
# ... line width and marker size
        rowFrame += 1
        frame_11a = Frame(
            self.toplevelXYPlotPreprocess,
            bg=colorbg,
            )
        frame_11a.grid(
            row=rowFrame,
            column=0,
            columnspan=99,
            padx=2,
            pady=1,
#            sticky=E+W
            )     
# ...   for line width
        frame_11a_00 = Frame(
            frame_11a,
            bg=colorbg,
            )
        frame_11a_00.grid(
            row=0,
            column=0,
            padx=2,
            pady=0,
            )
# ...   for marker size
        frame_11a_01 = Frame(
            frame_11a,
            bg=colorbg,
            )
        frame_11a_01.grid(
            row=0,
            column=1,
            padx=2,
            pady=0,
            )

# for line separator
        rowFrame += 1
        frame_13 = Frame(
            self.toplevelXYPlotPreprocess,
            bg=colorbg,
            )
        frame_13.grid(  
            row=rowFrame,
            column=0,
            padx=2,
            pady=1,
            sticky=E+W,
            )

# ... radiobutton: single curve per plot
        rowFrame += 1
        frame_30 = Frame(
            self.toplevelXYPlotPreprocess,
            bg=colorbg,
            )
        frame_30.grid(
            row=rowFrame,
            column=0,
            padx=10,
            pady=1,
            sticky=W,
            )
# ... show main title over all plots
        rowFrame += 1
        self.frame_35 = Frame(
            self.toplevelXYPlotPreprocess,
            bg=colorbg,
            )
        self.frame_35.grid(
            row=rowFrame,
            column=0,
            padx=30,
            pady=1,
            sticky=W,
            )
# ... show individual plot titles and grid
        rowFrame += 1
        self.frame_40 = Frame(
            self.toplevelXYPlotPreprocess,
            bg=colorbg,
            )
        self.frame_40.grid(
            row=rowFrame,
            column=0,
            padx=30,
            pady=1,
            sticky=W,
            )
# single plot labels, x-y ticks size and color, background color
        rowFrame += 1
        self.frame_40b = Frame(
            self.toplevelXYPlotPreprocess,
            bg=colorbg,
            )
        self.frame_40b.grid(
            row=rowFrame,
            column=0,
            padx=30,
            pady=0,
            sticky=W,
            )
# ... radiobutton: all curves on one plot
        rowFrame += 1
        frame_50 = Frame(
            self.toplevelXYPlotPreprocess,
            bg=colorbg,
            )
        frame_50.grid(
            row=rowFrame,
            column=0,
            padx=10,
            pady=10,
            sticky=W,
            )
# ... show title, x label, y label, plot grid
        rowFrame += 1
        self.frame_60 = Frame(
            self.toplevelXYPlotPreprocess,
            bg=colorbg,
            )
        self.frame_60.grid(
            row=rowFrame,
            column=0,
            padx=30,
            pady=1,
            sticky=W,
            )
# ... <field> times curve labeled <field>
        rowFrame += 1
        self.frame_70 = Frame(
            self.toplevelXYPlotPreprocess,
            bg=colorbg,
            )
        self.frame_70.grid(
            row=rowFrame,
            column=0,
            padx=30,
            pady=1,
            sticky=W,
            )
# ... sloped straight line reference curve
        rowFrame += 1
        frame_71 = Frame(
            self.toplevelXYPlotPreprocess,
            bg=colorbg,
            )
        frame_71.grid(
            row=rowFrame,
            column=0,
            padx=30,
            pady=1,
            sticky=W,
            )
# ... label for sloped straight line reference curve
        rowFrame += 1
        frame_71a = Frame(
            self.toplevelXYPlotPreprocess,
            bg=colorbg,
            )
        frame_71a.grid(
            row=rowFrame,
            column=0,
            padx=60,
            pady=1,
            sticky=W,
            )
# ... horizontal straight line reference curve
        rowFrame += 1
        frame_72 = Frame(
            self.toplevelXYPlotPreprocess,
            bg=colorbg
            )
        frame_72.grid(
            row=rowFrame,
            column=0,
            padx=30,
            pady=1,
            sticky=W,
            )
# ... label for horizontal straight line reference curve
        rowFrame += 1
        frame_73 = Frame(
            self.toplevelXYPlotPreprocess,
            bg=colorbg
            )
        frame_73.grid(
            row=rowFrame,
            column=0,
            padx=60,
            pady=1,
            sticky=W,
            )

# ... vertical straight line reference curve
        rowFrame += 1
        frame_74 = Frame(
            self.toplevelXYPlotPreprocess,
            bg=colorbg
            )
        frame_74.grid(
            row=rowFrame,
            column=0,
            padx=30,
            pady=1,
            sticky=W,
            )
# ... label for vertical straight line reference curve
        rowFrame += 1
        frame_74a = Frame(
            self.toplevelXYPlotPreprocess,
            bg=colorbg
            )
        frame_74a.grid(
            row=rowFrame,
            column=0,
            padx=60,
            pady=1,
            sticky=W,
            )            

            
# ... include plot data from file...
        rowFrame += 1
        frame_75 = Frame(
            self.toplevelXYPlotPreprocess,
            bg=colorbg,
            )
        frame_75.grid(
            row=rowFrame,
            column=0,
            padx=30,
            pady=1,
            sticky=W,
            )
# ... x-y ticks, color, and chart background
        rowFrame += 1
        self.frame_80 = Frame(
            self.toplevelXYPlotPreprocess,
            bg=colorbg,
            )
        self.frame_80.grid(
            row=rowFrame,
            column=0,
            padx=10,
            pady=5,
#            sticky=W,
            )
# ... for x-y tick marks font size, color, etc.            
        self.frame_80a = Frame(
            self.frame_80,
            bg=colorbg,
            )
        self.frame_80a.grid(
            row=0,
            column=0,
            padx=5,
            pady=0,
            )
# ... for plot, close all plots, reset all, cancel
        frame_80b = Frame(
            self.frame_80,
            bg=colorbg,
            )
        frame_80b.grid(
            row=0,
            column=1,
            padx=5,
            pady=0,
            sticky=E
            )
            
# ... for bottom row, if needed
        '''
        frame_99 = Frame(
            self.toplevelXYPlotPreprocess,
            bg=colorbg,
            )
        frame_99.grid(
            row=99,
            column=0,
            padx=1,
            pady=1,
            )
        '''

# WIDGETS
                
# ... title
        labelTitle = Label(
            frame_00,
#            text='PLOTTING SPECS FOR\n' + 'TABLE: ' + self.myTable,
            text='X-Y PLOT SPECS',
            font=self.titleFontBig,
            justify=CENTER,
            bg=colorbg,
            )
        labelTitle.grid(
            row=0,
            column=0,
            )
            
# ... number of Table, Buffer, and Total curves
#...    table curves
        labelNumberOfTableCurves = Label(
            frame_05,
            text='Number of curves to plot from table:',
            justify=RIGHT,
            bg=colorbg,
            )
        labelNumberOfTableCurves.grid(
            row=0,
            column=0,
            padx=2,
            pady=0,
            sticky=E,
            )
# ... entry field
        self.varNumberOfTableCurves = IntVar()
        self.entryNumberOfTableCurves = Entry(
            frame_05,
            width=5,
            justify=LEFT,
            textvariable=self.varNumberOfTableCurves,
            disabledbackground='white',
            disabledforeground='black',
            )
        self.entryNumberOfTableCurves.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            sticky=W,
            )
#        self.entryNumberOfTableCurves.configure(state='normal')
        self.varNumberOfTableCurves.set(self.jcountTable)
        self.entryNumberOfTableCurves.configure(state='disabled')
        
# ...   buffer curves
        labelNumberOfBufferCurves = Label(
            frame_05,
            text='  from storage buffer:',
            justify=RIGHT,
            bg=colorbg,
            )
        labelNumberOfBufferCurves.grid(
            row=0,
            column=2,
            padx=2,
            pady=0,
            sticky=E,
            )
# ... entry field
        self.varNumberOfStorageBufferCurves = IntVar()
        self.varNumberOfStorageBufferCurves.set(self.jcountBuffer)
        self.entryNumberOfBufferCurves = Entry(
            frame_05,
            width=5,
            justify=LEFT,
            textvariable=self.varNumberOfStorageBufferCurves,
            state='disabled',
            disabledbackground='white',
            disabledforeground='black',
            )
        self.entryNumberOfBufferCurves.grid(
            row=0,
            column=3,
            padx=0,
            pady=0,
            sticky=W,
            )       

# add buffer names to self.headerNamesY_AllCurvesOnOnePlot
#        if self.varNumberOfOfBufferCurves.get().strip() <> 0:
        '''
        self.headerNames_Y_Buffer = []
        if self.varNumberOfStorageBufferCurves.get():
                for indexBufferRow in self.listWhichBufferRowsAreChecked:
                        index=indexBufferRow - 1
                        self.headerNames_Y_Buffer.append(
                            self.bufferRowStore[index][6] + ' (bufr row ' + str(indexBufferRow) + ')'
                            )
        '''

#        self.headerNames_Y_Table.extend(self.headerNames_Y_Buffer)
#        self.headerNames_Y = []
#        self.headerNames_Y.extend(self.headerNames_Y_Table)
#        self.headerNames_Y.extend(self.headerNames_Y_Buffer)

#        self.headerNames_X_Table.extend(self.headerNames_X_Buffer)
#        self.headerNames_X = []
#        self.headerNames_X.extend(self.headerNames_X_Table)
#        self.headerNames_X.extend(self.headerNames_X_Buffer)
        
# zero out the following
        '''
        self.headerNames_Y_Table = []
        self.headerNames_X_Table = []
        self.headerNames_Y_Buffer = []
        self.headerNames_X_Buffer = []
        '''

        
        if DEBUG_XY:
            print('-'*50 + '\n')
            print('\n** In ' + MODULE + '/' + 'handlerXYPlotPreprocess **')
            print('\nself.headerNames_Y_Table = %s' % self.headerNames_Y_Table)
            print('\nself.headerNames_Y_Buffer = %s' % self.headerNames_Y_Buffer)
            print('\nself.headerNames_X_Table = %s' % self.headerNames_X_Table)
            print('\nself.headerNames_X_Buffer = %s' % self.headerNames_X_Buffer)
#        print('\nself.headerNames_Y = %s' % self.headerNames_Y)
#        print('\nself.headerNames_X =%s' % self.headerNames_X)
            print('self.jcountTable = %s' % self.jcountTable)
            print('self.jcountBuffer = %s' % self.jcountBuffer)
            print('-'*50 + '\n')
        
# ...   total curves
        labelNumberOfTotalCurves = Label(
            frame_05,
            text='  Total plots (max displayed 25):',
            justify=RIGHT,
            bg=colorbg,
            )
        labelNumberOfTotalCurves.grid(
            row=0,
            column=4,
            padx=2,
            pady=0,
            sticky=E,
            )
# ... entry field
        self.varNumberOfTotalCurves = IntVar()
        self.entryNumberOfTotalCurves = Entry(
            frame_05,
            width=5,
            justify=LEFT,
            textvariable=self.varNumberOfTotalCurves,
            disabledbackground='white',
            disabledforeground='black',
            )
        self.entryNumberOfTotalCurves.grid(
            row=0,
            column=5,
            padx=0,
            pady=0,
            sticky=W,
            )
#        self.entryNumberOfTableCurves.configure(state='normal')
        self.varNumberOfTotalCurves.set(self.jcountTable + self.jcountBuffer)
        self.entryNumberOfTotalCurves.configure(state='disabled')
        
# FRAME 12

# Plot curves from Table 
        self.checkbuttonTableData = Checkbutton(
            frame_12,
            bg=colorbg,
            variable=self.varCheckbuttonTableData,
            command=self.handlerRefreshReferenceCurveList,
            )
        self.checkbuttonTableData.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            sticky=W,
            )       
        labelTableData = Label(
            frame_12,
            text='Plot curves from Table',
            justify=LEFT,
            bg=colorbg,
            )
        labelTableData.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            sticky=W,
            )
            
# filler label
        labelFiller = Label(
            frame_12,
            text='       ',
            justify=CENTER,
            bg=colorbg,
            )
        labelFiller.grid(
            row=0,
            column=2,
            padx=0,
            pady=0,
            )
            
# Plot curves from Storage Buffer
#        self.varCheckbuttonBufferData = IntVar()
        self.checkbuttonBufferData = Checkbutton(
            frame_12,
            bg=colorbg,
            variable=self.varCheckbuttonBufferData,
            command=self.handlerRefreshReferenceCurveList,
            )
        self.checkbuttonBufferData.grid(
            row=0,
            column=3,
            padx=0,
            pady=0,
            sticky=W,
            )
# ... label
        labelBufferData = Label(
            frame_12,
            text='Plot curves from Storage Buffer:',
            justify=LEFT,
            bg=colorbg,
            )
        labelBufferData.grid(
            row=0,
            column=4,
            padx=0,
            pady=0,
            sticky=W,
            )
            
 # ... show buffer details
        buttonDisplayBufferData = Button(
            frame_12,
            textvariable=self.countDisplayStorageBuffer,
            width=22,
            font=self.buttonFontSmallest,
            borderwidth=3,
            relief=RAISED,
            background='white',
            foreground='blue',
            command=self.handlerDisplayStorageBufferValues_Call,
            )
        buttonDisplayBufferData.grid(
            row=0,
            column=5,
            padx=5,
            pady=0,
            sticky=E,
            )
                    
# ... choice to re-plot in current plot window
        self.varReplotInCurrentWindow = IntVar()
        self.checkbuttonReplotInCurrentWindow = Checkbutton(
            frame_14,
            bg=colorbg,
            variable=self.varReplotInCurrentWindow,
            command=self.handlerReplotInCurrentWindow,
            )
        self.checkbuttonReplotInCurrentWindow.grid(
            row=0,
            column=0,
#            columnspan=99,
            padx=0,
            pady=0,
            sticky=W,
            )
        labelReplotInCurrentWindow = Label(
            frame_14,
            text=(
                'Plot subsequent plots in current plot window'
                ),
            justify=LEFT,
            bg=colorbg,
            )
        labelReplotInCurrentWindow.grid(
            row=0,
            column=1,
            columnspan=99,
            padx=0,
            pady=0,
            sticky=W,
            )
#        self.checkbuttonReplotInCurrentWindow.deselect()
# ... choice to erase previous plot before re-plotting
        self.varKeepPreviousPlotInCurrentWindow = IntVar()
        self.checkbuttonKeepPreviousPlotInCurrentWindow = Checkbutton(
            frame_14,
            text=(
                'Show current curve(s) on next plot ' +
                '(legend will not show current curves)'
                ),
            justify=LEFT,
            bg=colorbg,
            variable=self.varKeepPreviousPlotInCurrentWindow,
            )
        self.checkbuttonKeepPreviousPlotInCurrentWindow.grid(
            row=1,
            column=1,
            columnspan=99,
            padx=0,
            pady=0,
            sticky=W,
            )
            
# ... plot style: 1) cartesian, 2) semilog-X, 3) semilog-Y, 4) log-log, and base (for log plots)
# ...       cartesian
        self.var_radiobuttonPlotStyle = StringVar()
        self.radiobuttonPlotStyleCartesian = Radiobutton(
            frame_11,
            variable=self.var_radiobuttonPlotStyle,
            value='cartesian',
            text='Cartesian',
            bg=colorbg,
            command=self.handlerBaseForLogPlots_XY,
            )
        self.radiobuttonPlotStyleCartesian.grid(
            row=0,
            column=0,
            padx=5,
            pady=1,
            sticky=W,
            )
# ...       semilog-X
        self.radiobuttonPlotStyleSemiLogX = Radiobutton(
            frame_11,
            variable=self.var_radiobuttonPlotStyle,
            value='semilogx',
            text='SemiLog-X',
            bg=colorbg,
            command=self.handlerBaseForLogPlots_XY,
            )
        self.radiobuttonPlotStyleSemiLogX.grid(
            row=0,
            column=1,
            padx=5,
            pady=1,
            sticky=W,
            )
# ...       semilog-Y            
        self.radiobuttonPlotStyleSemiLogY = Radiobutton(
            frame_11,
            variable=self.var_radiobuttonPlotStyle,
            value='semilogy',
            text='SemiLog-Y',
            bg=colorbg,
            command=self.handlerBaseForLogPlots_XY,
            )
        self.radiobuttonPlotStyleSemiLogY.grid(
            row=0,
            column=2,
            padx=5,
            pady=1,
            sticky=W,
            )
# ...       Log-log            
        self.radiobuttonPlotStyleLogLog = Radiobutton(
            frame_11,
            variable=self.var_radiobuttonPlotStyle,
            value='loglog',
            text='Log-Log',
            bg=colorbg,
            command=self.handlerBaseForLogPlots_XY,
            )
        self.radiobuttonPlotStyleLogLog.grid(
            row=0,
            column=3,
            padx=5,
            pady=1,
            sticky=W,
            )
# ...       base for log plots along X axis
        self.comboboxBaseForLogPlotsX = Pmw.ComboBox(
            frame_11,
            scrolledlist_items=self.baseForLogPlots,
            listheight=140,
            entry_width=7,
            label_text='Base for log plots:  X ',
            labelpos='w',
            label_background=colorbg,
            scrolledlist_hull_width=500,
            )
        self.comboboxBaseForLogPlotsX.grid(
            row=0,
            column=4,
            padx=10,
            pady=1,
            sticky=W,
            )
# ...       base for log plots along Y axis
        self.comboboxBaseForLogPlotsY = Pmw.ComboBox(
            frame_11,
            scrolledlist_items=self.baseForLogPlots,
            listheight=140,
            entry_width=7,
            label_text='  Y ',
            labelpos='w',
            label_background=colorbg,
            scrolledlist_hull_width=500,
            )
        self.comboboxBaseForLogPlotsY.grid(
            row=0,
            column=5,
            padx=10,
            pady=1,
            sticky=W,
            )
            
# ...       line width for all plots
        self.comboboxLineWidthPlots_XY = Pmw.ComboBox(
            frame_11a_00,
            scrolledlist_items=self.lineWidth_Plots_XY,
            listheight=100,
            entry_width=3,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            label_text='Line width: ',
            labelpos='w',
            label_background=colorbg,
            scrolledlist_hull_width=500,
            ) 
        self.comboboxLineWidthPlots_XY.grid(
            row=0,
            column=0,
            padx=0,
            pady=1,
            sticky=E,
            )
            
# ...       marker size for data points
        self.comboboxMarkerSizePlots_XY = Pmw.ComboBox(
            frame_11a_01,
            scrolledlist_items=self.listDataMarkerSize,
            listheight=120,
            entry_width=4,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            label_text='Symbol size for data points: ',
            labelpos='w',
            label_background=colorbg,
            scrolledlist_hull_width=500,
            ) 
        self.comboboxMarkerSizePlots_XY.grid(
            row=0,
            column=0,
            padx=5,
            pady=1,
            sticky=W,
            )
            
# ...       separator line
        labelSeparatorLine = Label(
            frame_13,
            text='-'*100,
            bg=colorbg,
            justify=CENTER,
            )
        labelSeparatorLine.grid(
            row=0,
            column=0,
            padx=5,
            pady=1,
            )

            
# ... single curve per plot
        self.varCurvesSelection = StringVar()
        self.radiobuttonSingleCurvePerPlot = Radiobutton(
            frame_30,
            bg=colorbg,
            variable=self.varCurvesSelection,
            value='single',
            command=self.handlerSelectSingleOrMultiCurvePlots,
            )
        self.radiobuttonSingleCurvePerPlot.grid(
            row=0,
            column=0,
            padx=2,
            pady=1,
            )
#        self.radiobuttonSingleCurvePerPlot.select()
        
        labelSingleCurvePerPlot = Label(
            frame_30,
            bg=colorbg,
            text=(
                'Plot single curve per plot, all plots in one window\n' +
                '(each curve may have different "y" units; max ' + 
                str(plotsMaxNumber) + ' plots)'
                ),
            justify=LEFT,
            font=self.subtitleFont,
            )
        labelSingleCurvePerPlot.grid(
            row=0,
            column=1,
            padx=0,
            pady=1,
            )
            
# ... show main title over all plots
# ...   checkbutton
        self.varShowMainTitle_SingleCurvePerPlot = IntVar()
        self.checkbuttonShowMainTitle_SingleCurvePerPlot = Checkbutton(
            self.frame_35,
            bg=colorbg,
            variable=self.varShowMainTitle_SingleCurvePerPlot,
            command=self.handlerShowMainTitle_SingleCurvePerPlot,
            )
        self.checkbuttonShowMainTitle_SingleCurvePerPlot.grid(
            row=0,
            column=0,
            padx=2,
            pady=1,
            sticky=W,
            )  
        labelShowMainTitle_SingleCurvePerPlot = Label(
            self.frame_35,
            text='Show main title: ',
            bg=colorbg,
            )
        labelShowMainTitle_SingleCurvePerPlot.grid(
            row=0,
            column=1,
            padx=0,
            pady=1,
            sticky=E,
            )
            
# ...   main title entry widget
        self.varEntryMainTitle_SingleCurvePerPlot = StringVar()
        self.entryMainTitle_SingleCurvePerPlot = Entry(
            self.frame_35,
            width=40,
            textvariable=self.varEntryMainTitle_SingleCurvePerPlot,
            foreground='black',
            background='white',
            disabledforeground='#777777',   # darker gray
            disabledbackground='lightgray',
            )
        self.entryMainTitle_SingleCurvePerPlot.grid(
            row=0,
            column=2,
            padx=0,
            pady=1,
            )
            
# ...   main title font
        self.comboboxFontMainTitle_SingleCurvePerPlot = Pmw.ComboBox(
            self.frame_35,
            scrolledlist_items=self.fontsizesChartTitle,
            listheight=150,
            label_text='size:',
            label_background=colorbg,
            labelpos='w',
            entry_width=5,
            scrolledlist_hull_width=500,
            )
        self.comboboxFontMainTitle_SingleCurvePerPlot.grid(
            row=0,
            column=3,
            padx=5,
            pady=1,
            sticky=W,
            )
            
# ...   main title color
        self.comboboxColorMainTitle_SingleCurvePerPlot = Pmw.ComboBox(
            self.frame_35,
            scrolledlist_items=self.colorsChartLabels,
            listheight=150,
            label_text='color:',
            label_background=colorbg,
            labelpos='w',
            entry_width=10,
            scrolledlist_hull_width=500,
            )
        self.comboboxColorMainTitle_SingleCurvePerPlot.grid(
            row=0,
            column=4,
            padx=5,
            pady=1,
            sticky=W,
            )
            
# ... show title for individual plots
        self.varShowTitles_SingleCurvePerPlot = IntVar()
        self.checkbuttonShowTitles_SingleCurvePerPlot = Checkbutton(
            self.frame_40,
            bg=colorbg,
            variable=self.varShowTitles_SingleCurvePerPlot,
            command=self.handlerShowTitles_SingleCurvePerPlot,
            )
        self.checkbuttonShowTitles_SingleCurvePerPlot.grid(
            row=0,
            column=0,
            padx=2,
            pady=1,
            sticky=W,
            )
        labelShowTitles_SingleCurvePerPlot = Label(
            self.frame_40,
            text='Show Y-labels as individual plot titles',
            bg=colorbg,
            )
        labelShowTitles_SingleCurvePerPlot.grid(
            row=0,
            column=1,
            padx=0,
            pady=1,
            sticky=E
            )
#        self.checkbuttonShowTitles_SingleCurvePerPlot.deselect()
# ... plot title font
        self.comboboxFontTitle_SingleCurvePerPlot = Pmw.ComboBox(
            self.frame_40,
            scrolledlist_items=self.fontsizesChartTitle,
            listheight=150,
            label_text='size:',
            label_background=colorbg,
            labelpos='w',
            entry_width=5,
            scrolledlist_hull_width=500,
            )
        self.comboboxFontTitle_SingleCurvePerPlot.grid(
            row=0,
            column=2,
            padx=5,
            pady=1,
            sticky=W,
            )
            
# ... show grid
        self.varShowGrid_SingleCurvePerPlot = IntVar()
        self.checkbuttonShowGrid_SingleCurvePerPlot = Checkbutton(
            self.frame_40,
            bg=colorbg,
            variable=self.varShowGrid_SingleCurvePerPlot,
            )
        self.checkbuttonShowGrid_SingleCurvePerPlot.grid(
            row=1,
            column=0,
            padx=2,
            pady=1,
            sticky=E,
            )
        labelShowGrid_SingleCurvePerPlot = Label(
            self.frame_40,
            text='Show grids',
            bg=colorbg,
            )
        labelShowGrid_SingleCurvePerPlot.grid(
            row=1,
            column=1,
            padx=0,
            pady=1,
            sticky=W
            )
#        self.checkbuttonShowGrid_SingleCurvePerPlot.select()

# xy-label font sizes, single plots
        labelFontLabels = Label(
            self.frame_40b,
            text='Labels size:',
            bg=colorbg,
            )
        labelFontLabels.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            sticky=E,
            )
        self.comboboxFontLabels_SingleCurvePerPlot = Pmw.ComboBox(
            self.frame_40b,
            scrolledlist_items=self.fontsizesChartLabels,
            listheight=160,
            entry_width=5,
            scrolledlist_hull_width=500,
            )
        self.comboboxFontLabels_SingleCurvePerPlot.grid(
            row=0,
            column=1,
            padx=5,
            pady=0,
            sticky=E,
            )
# xy-label color, single plots
        self.comboboxColorLabels_SingleCurvePerPlot = Pmw.ComboBox(
            self.frame_40b,
            scrolledlist_items=self.colorsChartLabels,
            listheight=150,
            label_text='color:',
            label_background=colorbg,
            labelpos='w',
            entry_width=10,
            scrolledlist_hull_width=500,
            )
        self.comboboxColorLabels_SingleCurvePerPlot.grid(
            row=0,
            column=2,
            padx=5,
            pady=0,
            sticky=E,
            )
# x-tick size
        labelFontLabels = Label(
            self.frame_40b,
            text='X-Ticks size:',
            bg=colorbg,
            )
        labelFontLabels.grid(
            row=1,
            column=0,
            padx=0,
            pady=0,
            sticky=E,
            )
        self.comboboxFontXTicks_SingleCurvePerPlot = Pmw.ComboBox(
            self.frame_40b,
            scrolledlist_items=self.fontsizesTickX,
            listheight=160,
#            label_text='X-Ticks size:',
#            label_background=colorbg,
#            labelpos='w',
            entry_width=5,
            scrolledlist_hull_width=500,
            )
        self.comboboxFontXTicks_SingleCurvePerPlot.grid(
            row=1,
            column=1,
            padx=5,
            pady=0,
            sticky=E,
            )
# x-tick color
        self.comboboxColorXTicks_SingleCurvePerPlot = Pmw.ComboBox(
            self.frame_40b,
            scrolledlist_items=self.colorsTickX,
            listheight=150,
            label_text='color:',
            label_background=colorbg,
            labelpos='w',
            entry_width=10,
            scrolledlist_hull_width=500,
            )
        self.comboboxColorXTicks_SingleCurvePerPlot.grid(
            row=1,
            column=2,
            padx=5,
            pady=0,
            sticky=E,
            )
# y-tick size
        labelFontLabels = Label(
            self.frame_40b,
            text='Y-Ticks size:',
            bg=colorbg,
            )
        labelFontLabels.grid(
            row=2,
            column=0,
            padx=0,
            pady=0,
            sticky=E,
            )
        self.comboboxFontYTicks_SingleCurvePerPlot = Pmw.ComboBox(
            self.frame_40b,
            scrolledlist_items=self.fontsizesTickY,
            listheight=160,
            entry_width=5,
            scrolledlist_hull_width=500,
            )
        self.comboboxFontYTicks_SingleCurvePerPlot.grid(
            row=2,
            column=1,
            padx=5,
            pady=0,
            sticky=E,
            )
# y-tick color
        self.comboboxColorYTicks_SingleCurvePerPlot = Pmw.ComboBox(
            self.frame_40b,
            scrolledlist_items=self.colorsTickY,
            listheight=150,
            label_text='color:',
            label_background=colorbg,
            labelpos='w',
            entry_width=10,
            scrolledlist_hull_width=500,
            )
        self.comboboxColorYTicks_SingleCurvePerPlot.grid(
            row=2,
            column=2,
            padx=5,
            pady=0,
            sticky=E,
            )
# chart background color
        self.comboboxColorBackground_SingleCurvePerPlot = Pmw.ComboBox(
            self.frame_40b,
            scrolledlist_items=self.colorsChartBackground,
            listheight=150,
            label_text='Background color:',
            label_background=colorbg,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            labelpos='w',
            entry_width=10,
            scrolledlist_hull_width=500,
            )
        self.comboboxColorBackground_SingleCurvePerPlot.grid(
            row=0,
            column=3,
            columnspan=1,
            padx=5,
            pady=0,
            sticky=E,
            )
# chart border color
        self.comboboxColorBorder_SingleCurvePerPlot = Pmw.ComboBox(
            self.frame_40b,
            scrolledlist_items=self.colorsChartBackground,
            listheight=150,
            label_text='Border color:',
            label_background=colorbg,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            labelpos='w',
            entry_width=10,
            scrolledlist_hull_width=500,
            )
        self.comboboxColorBorder_SingleCurvePerPlot.grid(
            row=1,
            column=3,
            columnspan=1,
            padx=5,
            pady=0,
            sticky=E,
            )

# ... all curves on one plot
        self.radiobuttonAllCurvesOnePlot = Radiobutton(
            frame_50,
            bg=colorbg,
            variable=self.varCurvesSelection,
            value='all',
            command=self.handlerSelectSingleOrMultiCurvePlots,
            )
        self.radiobuttonAllCurvesOnePlot.grid(
            row=0,
            column=0,
            padx=2,
            pady=0,
            )
#        self.radiobuttonAllCurvesOnePlot.deselect()
        labelAllCurvesOnePlot = Label(
            frame_50,
            bg=colorbg,
            text=(
                'Plot all curves on one plot in one window\n' +
                '(all curves should have same units; max 25 curves)'
                ),
            justify=LEFT,
            font=self.subtitleFont,
            )
        labelAllCurvesOnePlot.grid(
            row=0,
            column=1,
            padx=2,
            pady=1,
            )
# ... show title, x label, y label, plot grid, show reference curve
#       row 0
        self.varCheckbuttonShowTitle_AllCurvesOnePlot = IntVar()
        self.checkbuttonShowTitle_AllCurvesOnePlot = Checkbutton(
            self.frame_60,
            bg=colorbg,
            variable=self.varCheckbuttonShowTitle_AllCurvesOnePlot,
            command=self.handlerShowTitle_AllCurvesOnePlot,
            )
        self.checkbuttonShowTitle_AllCurvesOnePlot.grid(
            row=0,
            column=0,
            padx=2,
            pady=1,
            sticky=W,
            )
#        self.checkbuttonShowTitle_AllCurvesOnePlot.configure(state='disabled')
        labelShowTitle_AllCurvesOnePlot = Label(
            self.frame_60,
            text='Show title: ',
            bg=colorbg,
            justify=LEFT,
            )
        labelShowTitle_AllCurvesOnePlot.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            sticky=W,
            )
        self.varEntryShowTitle_AllCurvesOnePlot = StringVar()
        self.entryShowTitle_AllCurvesOnePlot = Entry(
            self.frame_60,
            width=20,
            textvariable=self.varEntryShowTitle_AllCurvesOnePlot,
            disabledbackground='lightgray',
            )
        self.entryShowTitle_AllCurvesOnePlot.grid(
            row=0,
            column=2,
            padx=5,
            pady=0,
            sticky=W,
            )
# ...   title font
        self.comboboxFontTitle_AllCurvesOnePlot = Pmw.ComboBox(
            self.frame_60,
            scrolledlist_items=self.fontsizesChartTitle,
            listheight=150,
            label_text='size:',
            label_background=colorbg,
            labelpos='w',
            entry_width=5,
            scrolledlist_hull_width=500,
            )
        self.comboboxFontTitle_AllCurvesOnePlot.grid(
            row=0,
            column=3,
            padx=5,
            pady=0,
            sticky=W,
            )

# ...   title color
        self.comboboxColorTitle_AllCurvesOnePlot = Pmw.ComboBox(
            self.frame_60,
            scrolledlist_items=self.colorsChartLabels,
            listheight=150,
            label_text='color:',
            label_background=colorbg,
            labelpos='w',
            entry_width=10,
            scrolledlist_hull_width=500,
            )
        self.comboboxColorTitle_AllCurvesOnePlot.grid(
            row=0,
            column=4,
            padx=5,
            pady=0,
            sticky=W,
            )    
#       row 1
        self.varCheckbuttonShowLabelY_AllCurvesOnePlot = IntVar()
        self.checkbuttonShowLabelY_AllCurvesOnePlot = Checkbutton(
            self.frame_60,
            bg=colorbg,
            variable=self.varCheckbuttonShowLabelY_AllCurvesOnePlot,
            command=self.handlerShowLabelY_AllCurvesOnePlot,
            )
        self.checkbuttonShowLabelY_AllCurvesOnePlot.grid(
            row=1,
            column=0,
            padx=2,
            pady=0,
            sticky=W,
            )
#        self.checkbuttonShowLabelY_AllCurvesOnePlot.configure(state='disabled')
        labelShowLabelY_AllCurvesOnePlot = Label(
            self.frame_60,
            text='Show Y label (specify):',
            justify=LEFT,
            bg=colorbg,
            )
        labelShowLabelY_AllCurvesOnePlot.grid(
            row=1,
            column=1,
            padx=0,
            pady=0,
            sticky=W,
            )
        self.varShowLabelY_AllCurvesOnePlot = StringVar()
        self.entryShowLabelY_AllCurvesOnePlot = Entry(
            self.frame_60,
            width=20,
            textvariable=self.varShowLabelY_AllCurvesOnePlot,
            )
        self.entryShowLabelY_AllCurvesOnePlot.grid(
            row=1,
            column=2,
            padx=5,
            pady=0,
            sticky=W,
            )
#        self.entryShowLabelY_AllCurvesOnePlot.configure(state='normal')
#        self.varShowLabelY_AllCurvesOnePlot.set('')
#        self.entryShowLabelY_AllCurvesOnePlot.configure(state='disabled')
        
#       row 2
        self.varCheckbuttonShowLabelX_AllCurvesOnePlot = IntVar()
        self.checkbuttonShowLabelX_AllCurvesOnePlot = Checkbutton(
            self.frame_60,
            bg=colorbg,
            variable=self.varCheckbuttonShowLabelX_AllCurvesOnePlot,
            command=self.handlerShowLabelX_AllCurvesOnePlot,
            )
        self.checkbuttonShowLabelX_AllCurvesOnePlot.grid(
            row=2,
            column=0,
            padx=2,
            pady=0,
            sticky=W,
            )
#        self.checkbuttonShowLabelX_AllCurvesOnePlot.configure(state='normal')
#        self.checkbuttonShowLabelX_AllCurvesOnePlot.select()
#        self.checkbuttonShowLabelX_AllCurvesOnePlot.configure(state='disabled')
        labelShowLabelX_AllCurvesOnePlot = Label(
            self.frame_60,
            text='Show X label:',
            justify=LEFT,
            bg=colorbg,
            )
        labelShowLabelX_AllCurvesOnePlot.grid(
            row=2,
            column=1,
            padx=0,
            pady=0,
            sticky=W,
            )

        self.comboboxShowLabelX_AllCurvesOnePlot = Pmw.ComboBox(
            self.frame_60,
            scrolledlist_items=self.listitemsShowLabelX_AllCurvesOnePlot,
            dropdown=1,
#            entry_state='normal',
            listheight=150,
            entry_width=20,
            entry_justify=LEFT,
            scrolledlist_hull_width=500,
            )
        self.comboboxShowLabelX_AllCurvesOnePlot.grid(
            row=2,
            column=2,
            padx=5,
            pady=0,
            sticky=W,
            )
           
            
#        self.entryShowLabelX_AllCurvesOnePlot.configure(state='normal')
#        self.varShowLabelX_AllCurvesOnePlot.set(headerNameX)
#        self.entryShowLabelX_AllCurvesOnePlot.configure(state='disabled')
# ... x-y label font size
        self.comboboxFontXYLabels_AllCurvesOnePlot = Pmw.ComboBox(
            self.frame_60,
            scrolledlist_items=self.fontsizesChartLabels,
            listheight=160,
            label_text='size:',
            label_background=colorbg,
            labelpos='w',
            entry_width=5,
            scrolledlist_hull_width=500,
            )
        self.comboboxFontXYLabels_AllCurvesOnePlot.grid(
            row=1,
            rowspan=2,
            column=3,
            padx=5,
            pady=0,
            sticky=W,
            )
# ... x-y label color    
        self.comboboxColorXYLabels_AllCurvesOnePlot = Pmw.ComboBox(
            self.frame_60,
            scrolledlist_items=self.colorsChartLabels,
            listheight=150,
            label_text='color:',
            label_background=colorbg,
            labelpos='w',
            entry_width=10,
            scrolledlist_hull_width=500,
            )
        self.comboboxColorXYLabels_AllCurvesOnePlot.grid(
            row=1,
            rowspan=2,
            column=4,
            padx=0,
            pady=0,
            sticky=W,
            )
    
# ... show legend
# ...       checkbutton
        self.varCheckbuttonShowLegend_AllCurvesOnePlot = IntVar()
        self.checkbuttonShowLegend_AllCurvesOnePlot = Checkbutton(
            self.frame_60,
            bg=colorbg,
            variable=self.varCheckbuttonShowLegend_AllCurvesOnePlot,
            command=self.handlerShowLegend_AllCurvesOnePlot,
            )
        self.checkbuttonShowLegend_AllCurvesOnePlot.grid(
            row=3,
            column=0,
            padx=2,
            pady=0,
            sticky=W,
            )
#        self.checkbuttonShowLegend_AllCurvesOnePlot.configure(state='disabled')
# ...       text
        labelShowLegend_AllCurvesOnePlot = Label(
            self.frame_60,
            text='Show legend, located ',
            justify=LEFT,
            bg=colorbg,
            )
        labelShowLegend_AllCurvesOnePlot.grid(
            row=3,
            column=1,
            padx=0,
            pady=0,
            sticky=W
            )
# ...       legend location
        self.comboboxShowLegendLocation_AllCurvesOnePlot = Pmw.ComboBox(
            self.frame_60,
            scrolledlist_items=self.legendLocations,
            listheight=200,
            entry_width=20,
            scrolledlist_hull_width=500,
            )
        self.comboboxShowLegendLocation_AllCurvesOnePlot.grid(
            row=3,
            column=2,
            padx=5,
            pady=0,
            sticky=W,
            )
#        self.comboboxShowLegendLocation_AllCurvesOnePlot.selectitem(self.legendLocations[0]) 
#        self.comboboxShowLegendLocation_AllCurvesOnePlot.configure(entry_width=10)
#        self.comboboxShowReferenceCurveMultiplier_AllCurvesOnePlot.component('entryfield').component('entry').configure(state=DISABLED)
#        self.comboboxShowLegendLocation_AllCurvesOnePlot._entryWidget['state']=DISABLED
# ...       legend font
        self.comboboxFontLegend_AllCurvesOnePlot = Pmw.ComboBox(
            self.frame_60,
            scrolledlist_items=self.fontsizesChartTitle,
            listheight=120,
            label_text='size:',
            label_background=colorbg,
            labelpos='w',
            entry_width=5,
            scrolledlist_hull_width=500,
            )
        self.comboboxFontLegend_AllCurvesOnePlot.grid(
            row=3,
            column=3,
            padx=5,
            pady=0,
            sticky=W,
            )
      
#       row 4
        self.varCheckbuttonShowGrid_AllCurvesOnePlot = IntVar()
        self.checkbuttonShowGrid_AllCurvesOnePlot = Checkbutton(
            self.frame_60,
            bg=colorbg,
            variable=self.varCheckbuttonShowGrid_AllCurvesOnePlot,
            )
        self.checkbuttonShowGrid_AllCurvesOnePlot.grid(
            row=4,
            column=0,
            padx=2,
            pady=0,
            sticky=W,
            )
#        self.checkbuttonShowGrid_AllCurvesOnePlot.configure(state='normal')
#        self.checkbuttonShowGrid_AllCurvesOnePlot.select()
#        self.checkbuttonShowGrid_AllCurvesOnePlot.configure(state='disabled')
        labelShowGrid_AllCurvesOnePlot = Label(
            self.frame_60,
            text='Show grid',
            justify=LEFT,
            bg=colorbg,
            )
        labelShowGrid_AllCurvesOnePlot.grid(
            row=4,
            column=1,
            padx=0,
            pady=0,
            sticky=W
            )
            
# frame_70

# ... reference curve derived from existing curve

        self.varCheckbuttonShowReferenceCurve_AllCurvesOnePlot = IntVar()
        self.checkbuttonShowReferenceCurve_AllCurvesOnePlot = Checkbutton(
            self.frame_70,
            bg=colorbg,
            variable=self.varCheckbuttonShowReferenceCurve_AllCurvesOnePlot,
            command=self.handlerShowReferenceCurve_AllCurvesOnePlot,
            )
        self.checkbuttonShowReferenceCurve_AllCurvesOnePlot.grid(
            row=0,
            column=0,
            padx=2,
            pady=0,
            sticky=W,
            )
            
#        self.checkbuttonShowReferenceCurve_AllCurvesOnePlot.configure(state='disabled')
        labelShowReferenceCurve_AllCurvesOnePlot = Label(
            self.frame_70,
            text='Show reference curve:',
            justify=LEFT,
            bg=colorbg,
            )
        labelShowReferenceCurve_AllCurvesOnePlot.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            sticky=W
            )
            
# ... <field> times curve labeled <field>
        self.comboboxShowReferenceCurveMultiplier_AllCurvesOnePlot = Pmw.ComboBox(
            self.frame_70,
            scrolledlist_items=self.multipliersReferenceCurve,
            listheight=150,
            entry_width=6,
            scrolledlist_hull_width=500,
            )
        self.comboboxShowReferenceCurveMultiplier_AllCurvesOnePlot.grid(
            row=0,
            column=2,
            padx=2,
            pady=0,
            sticky=W,
            )
#        self.comboboxShowReferenceCurveMultiplier_AllCurvesOnePlot.selectitem(self.multipliersReferenceCurve[4])   
#        self.comboboxShowReferenceCurveMultiplier_AllCurvesOnePlot.configure(entry_width=6)
#        self.comboboxShowReferenceCurveMultiplier_AllCurvesOnePlot.component('entryfield').component('entry').configure(state=DISABLED)
# or
#        self.comboboxShowReferenceCurveMultiplier_AllCurvesOnePlot._entryWidget['state']=DISABLED
        
        labelShowReferenceCurveMultiply_AllCurvesOnePlot = Label(
            self.frame_70,
            text='times curve labeled',
            bg=colorbg,
            )
        labelShowReferenceCurveMultiply_AllCurvesOnePlot.grid(
            row=0,
            column=3,
            padx=2,
            pady=0,
            sticky=W,
            )
        # regraph Reference Curve widget with 'scrolledlist_items' based on checked widgets
        self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot = Pmw.ComboBox(
            self.frame_70,
# scrolledlist_items defined in method "handlerRefreshReferenceCurveList" after determining which table columns
#   have been selected
#            scrolledlist_items = self.legendNamesForCurveLabeled,
            listheight=100,
            entry_width=35,
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot.grid(
            row=0,
            column=4,
            padx=2,
            pady=0,
            sticky=W,
            )
                 

# frame 71

# ... sloped straight line reference curve

        self.varCheckbuttonShowSlopedStraightReferenceCurve_AllCurvesOnePlot = IntVar()
        self.checkbuttonShowSlopedStraightReferenceCurve_AllCurvesOnePlot = Checkbutton(
            frame_71,
            bg=colorbg,
            variable=self.varCheckbuttonShowSlopedStraightReferenceCurve_AllCurvesOnePlot,
            command=self.handlerShowSlopedStraightReferenceCurve_AllCurvesOnePlot,
            )
        self.checkbuttonShowSlopedStraightReferenceCurve_AllCurvesOnePlot.grid(
            row=0,
            column=0,
            padx=2,
            pady=0,
            sticky=W,
            )
            
        self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xinitial = Pmw.EntryField(
            frame_71,
            entry_width=10,
            label_bg=colorbg,
            labelpos='w',
            label_text='Show sloped reference line between X(initial) = ',
#            textvariable=self.varShowStraightReferenceCurve_AllCurvesOnePlot_Xinitial,
            entry_disabledbackground='lightgray',
            validate = {'validator' : 'real'},
#                        'min' : 10, 'max' : 99, 'minstrict' : 0},
#            entry_state='normal',
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            )
        self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xinitial.grid(
            row=0,
            column=2,
            padx=0,
            pady=0,
            sticky=W,
            )
        
        self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yinitial = Pmw.EntryField(
            frame_71,
            entry_width=10,
            label_bg=colorbg,
            labelpos='w',
            label_text=', Y(initial) = ',
#            textvariable=self.varShowStraightReferenceCurve_AllCurvesOnePlot_Xinitial,
            entry_disabledbackground='lightgray',
            validate = {'validator' : 'real'},
#                        'min' : 10, 'max' : 99, 'minstrict' : 0},
#            entry_state='normal',
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            )
        self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yinitial.grid(
            row=0,
            column=3,
            padx=0,
            pady=0,
            sticky=W,
            )

        self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xfinal = Pmw.EntryField(
            frame_71,
            entry_width=10,
            labelpos='w',
            label_bg=colorbg,
            label_text='and X(final) = ',
            entry_disabledbackground='lightgray',
            validate = {'validator' : 'real'},
#                        'min' : 10, 'max' : 99, 'minstrict' : 0},
#            entry_state='normal',
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            )
        self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xfinal.grid(
            row=1,
            column=2,
            padx=0,
            pady=0,
            sticky=E,
            )
        self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yfinal = Pmw.EntryField(
            frame_71,
            entry_width=10,
            label_bg=colorbg,
            labelpos='w',
            label_text=',   Y(final) = ',
#            textvariable=self.varShowStraightReferenceCurve_AllCurvesOnePlot_Xinitial,
            entry_disabledbackground='lightgray',
            validate = {'validator' : 'real'},
#                        'min' : 10, 'max' : 99, 'minstrict' : 0},
#            entry_state='normal',
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            )
        self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yfinal.grid(
            row=1,
            column=3,
            padx=0,
            pady=0,
            sticky=W,
            )

            
# FRAME 71a
# label for sloped straight line reference curve
# Row 0
# ... checkbutton and entry field for user-specified label
        labelText = Label(
            frame_71a,
            text='     using concatenated label: ',
            justify=LEFT,
            bg=colorbg,
            )
        labelText.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            sticky=W
            )
        self.varCheckbuttonLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot = IntVar()
        self.checkbuttonLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot = Checkbutton(
            frame_71a,
            bg=colorbg,
            borderwidth=0,
            variable=self.varCheckbuttonLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot,
#            command=??,
            )
        self.checkbuttonLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            sticky=E,
            )
        self.entryfieldLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot = Pmw.EntryField(
            frame_71a,
            entry_width=15,
            labelpos='w',
            label_bg=colorbg,
            label_text='user-specified ',
            entry_disabledbackground='lightgray',
#            validate = {'validator' : 'alphanumeric','max' : 20, 'min' : 0},
#            entry_state='normal',
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            )
        self.entryfieldLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot.grid(
            row=0,
            column=2,
            padx=0,
            pady=0,
            sticky=W,
            )
# ... add plus sign
        labelText = Label(
            frame_71a,
            text='  +  ',
            justify=CENTER,
            bg=colorbg,
            )
        labelText.grid(
            row=0,
            column=3,
            padx=0,
            pady=0,
#            sticky=W
            )
# ... checkbutton and entry field for using y value in label
        self.varCheckbuttonLabelSlopeDegreesSlopedStraightReferenceCurve_AllCurvesOnePlot = IntVar()
        self.checkbuttonLabelSlopeDegreesSlopedStraightReferenceCurve_AllCurvesOnePlot = Checkbutton(
            frame_71a,
            bg=colorbg,
            borderwidth=0,
            variable=self.varCheckbuttonLabelSlopeDegreesSlopedStraightReferenceCurve_AllCurvesOnePlot,
#            command=??,
            )
        self.checkbuttonLabelSlopeDegreesSlopedStraightReferenceCurve_AllCurvesOnePlot.grid(
            row=0,
            column=4,
            padx=0,
            pady=0,
            sticky=E,
            )
        labelText = Label(
            frame_71a,
            text='slope (degs)',
            justify=LEFT,
            bg=colorbg,
            )
        labelText.grid(
            row=0,
            column=5,
            padx=0,
            pady=0,
            sticky=W
            )

# ... label text showing "[ref]" will always be included in label
        labelText = Label(
            frame_71a,
            text=' +  [ref]',
            justify=LEFT,
            bg=colorbg,
            )
        labelText.grid(
            row=0,
            column=6,
            padx=0,
            pady=0,
#            sticky=W
            )           
                 

# frame 72

# ... horizontal straight line reference curve

        self.varCheckbuttonShowHorizontalStraightReferenceCurve_AllCurvesOnePlot = IntVar()
        self.checkbuttonShowHorizontalStraightReferenceCurve_AllCurvesOnePlot = Checkbutton(
            frame_72,
            bg=colorbg,
            variable=self.varCheckbuttonShowHorizontalStraightReferenceCurve_AllCurvesOnePlot,
            command=self.handlerShowHorizontalStraightReferenceCurve_AllCurvesOnePlot,
            )
        self.checkbuttonShowHorizontalStraightReferenceCurve_AllCurvesOnePlot.grid(
            row=0,
            column=0,
            padx=2,
            pady=0,
            sticky=W,
            )          
#        self.checkbuttonShowReferenceCurve_AllCurvesOnePlot.configure(state='disabled')

        self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xinitial = Pmw.EntryField(
            frame_72,
            entry_width=10,
            label_bg=colorbg,
            labelpos='w',
            label_text='Show horizontal reference line between X(initial) = ',
#            textvariable=self.varShowStraightReferenceCurve_AllCurvesOnePlot_Xinitial,
            entry_disabledbackground='lightgray',
            validate = {'validator' : 'real'},
#                        'min' : 10, 'max' : 99, 'minstrict' : 0},
#            entry_state='normal',
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            )
        self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xinitial.grid(
            row=0,
            column=2,
            padx=0,
            pady=0,
            sticky=W,
            )

        self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xfinal = Pmw.EntryField(
            frame_72,
            entry_width=10,
            labelpos='w',
            label_bg=colorbg,
            label_text=' and X(final) = ',
            entry_disabledbackground='lightgray',
            validate = {'validator' : 'real'},
#                        'min' : 10, 'max' : 99, 'minstrict' : 0},
#            entry_state='normal',
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            )
        self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xfinal.grid(
            row=0,
            column=4,
            padx=5,
            pady=0,
            sticky=W,
            )
        self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Y = Pmw.EntryField(
            frame_72,
            entry_width=10,
            labelpos='w',
            label_bg=colorbg,
            label_text=' at Y = ',
            entry_disabledbackground='lightgray',
            validate = {'validator' : 'real'},
#                        'min' : 10, 'max' : 99, 'minstrict' : 0},
#            entry_state='normal',
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            )
        self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Y.grid(
            row=0,
            column=6,
            padx=5,
            pady=0,
            sticky=W,
            )
            
# FRAME 73
# label for straight line reference curve
# Row 0
# ... checkbutton and entry field for user-specified label
        labelText = Label(
            frame_73,
            text='     using concatenated label: ',
            justify=LEFT,
            bg=colorbg,
            )
        labelText.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            sticky=W
            )
        self.varCheckbuttonLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot = IntVar()
        self.checkbuttonLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot = Checkbutton(
            frame_73,
            bg=colorbg,
            borderwidth=0,
            variable=self.varCheckbuttonLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot,
#            command=??,
            )
        self.checkbuttonLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            sticky=E,
            )
        self.entryfieldLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot = Pmw.EntryField(
            frame_73,
            entry_width=15,
            labelpos='w',
            label_bg=colorbg,
            label_text='user-specified ',
            entry_disabledbackground='lightgray',
#            validate = {'validator' : 'alphanumeric','max' : 20, 'min' : 0},
#            entry_state='normal',
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            )
        self.entryfieldLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot.grid(
            row=0,
            column=2,
            padx=0,
            pady=0,
            sticky=W,
            )
# ... add plus sign
        labelText = Label(
            frame_73,
            text='  +  ',
            justify=CENTER,
            bg=colorbg,
            )
        labelText.grid(
            row=0,
            column=3,
            padx=0,
            pady=0,
#            sticky=W
            )
# ... checkbutton and entry field for using y value in label
        self.varCheckbuttonLabelYMaxHorizontalStraightReferenceCurve_AllCurvesOnePlot = IntVar()
        self.checkbuttonLabelYMaxHorizontalStraightReferenceCurve_AllCurvesOnePlot = Checkbutton(
            frame_73,
            bg=colorbg,
            borderwidth=0,
            variable=self.varCheckbuttonLabelYMaxHorizontalStraightReferenceCurve_AllCurvesOnePlot,
#            command=??,
            )
        self.checkbuttonLabelYMaxHorizontalStraightReferenceCurve_AllCurvesOnePlot.grid(
            row=0,
            column=4,
            padx=0,
            pady=0,
            sticky=E,
            )
        labelText = Label(
            frame_73,
            text='Y value',
            justify=LEFT,
            bg=colorbg,
            )
        labelText.grid(
            row=0,
            column=5,
            padx=0,
            pady=0,
            sticky=W
            )

# ... label text showing "[ref]" will always be included in label
        labelText = Label(
            frame_73,
            text=' +  [ref]',
            justify=LEFT,
            bg=colorbg,
            )
        labelText.grid(
            row=0,
            column=6,
            padx=0,
            pady=0,
#            sticky=W
            )           
            
# frame 74

# ... vertical straight line reference curve

        self.varCheckbuttonShowVerticalStraightReferenceCurve_AllCurvesOnePlot = IntVar()
        self.checkbuttonShowVerticalStraightReferenceCurve_AllCurvesOnePlot = Checkbutton(
            frame_74,
            bg=colorbg,
            variable=self.varCheckbuttonShowVerticalStraightReferenceCurve_AllCurvesOnePlot,
            command=self.handlerShowVerticalStraightReferenceCurve_AllCurvesOnePlot,
            )
        self.checkbuttonShowVerticalStraightReferenceCurve_AllCurvesOnePlot.grid(
            row=0,
            column=0,
            padx=2,
            pady=0,
            sticky=W,
            )          
#        self.checkbuttonShowReferenceCurve_AllCurvesOnePlot.configure(state='disabled')

        self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yinitial = Pmw.EntryField(
            frame_74,
            entry_width=10,
            label_bg=colorbg,
            labelpos='w',
            label_text='Show vertical reference line between Y(initial) = ',
#            textvariable=self.varShowStraightReferenceCurve_AllCurvesOnePlot_Xinitial,
            entry_disabledbackground='lightgray',
            validate = {'validator' : 'real'},
#                        'min' : 10, 'max' : 99, 'minstrict' : 0},
#            entry_state='normal',
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            )
        self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yinitial.grid(
            row=0,
            column=2,
            padx=0,
            pady=0,
            sticky=W,
            )

        self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yfinal = Pmw.EntryField(
            frame_74,
            entry_width=10,
            labelpos='w',
            label_bg=colorbg,
            label_text=' and Y(final) = ',
            entry_disabledbackground='lightgray',
            validate = {'validator' : 'real'},
#                        'min' : 10, 'max' : 99, 'minstrict' : 0},
#            entry_state='normal',
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            )
        self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yfinal.grid(
            row=0,
            column=4,
            padx=5,
            pady=0,
            sticky=W,
            )
        self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_X = Pmw.EntryField(
            frame_74,
            entry_width=10,
            labelpos='w',
            label_bg=colorbg,
            label_text=' at X = ',
            entry_disabledbackground='lightgray',
            validate = {'validator' : 'real'},
#                        'min' : 10, 'max' : 99, 'minstrict' : 0},
#            entry_state='normal',
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            )
        self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_X.grid(
            row=0,
            column=6,
            padx=5,
            pady=0,
            sticky=W,
            )
            
# FRAME 74a
# label for vertical straight line reference curve
# Row 0
# ... checkbutton and entry field for user-specified label
        labelText = Label(
            frame_74a,
            text='     using concatenated label: ',
            justify=LEFT,
            bg=colorbg,
            )
        labelText.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            sticky=W
            )
        self.varCheckbuttonLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot = IntVar()
        self.checkbuttonLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot = Checkbutton(
            frame_74a,
            bg=colorbg,
            borderwidth=0,
            variable=self.varCheckbuttonLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot,
#            command=??,
            )
        self.checkbuttonLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            sticky=E,
            )
        self.entryfieldLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot = Pmw.EntryField(
            frame_74a,
            entry_width=15,
            labelpos='w',
            label_bg=colorbg,
            label_text='user-specified ',
            entry_disabledbackground='lightgray',
#            validate = {'validator' : 'alphanumeric','max' : 20, 'min' : 0},
#            entry_state='normal',
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            )
        self.entryfieldLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot.grid(
            row=0,
            column=2,
            padx=0,
            pady=0,
            sticky=W,
            )
# ... add plus sign
        labelText = Label(
            frame_74a,
            text='  +  ',
            justify=CENTER,
            bg=colorbg,
            )
        labelText.grid(
            row=0,
            column=3,
            padx=0,
            pady=0,
#            sticky=W
            )
# ... checkbutton and entry field for using x value in label
        self.varCheckbuttonLabelXMaxVerticalStraightLineReferenceCurve_AllCurvesOnePlot = IntVar()
        self.checkbuttonLabelXMaxVerticalStraightLineReferenceCurve_AllCurvesOnePlot = Checkbutton(
            frame_74a,
            bg=colorbg,
            borderwidth=0,
            variable=self.varCheckbuttonLabelXMaxVerticalStraightLineReferenceCurve_AllCurvesOnePlot,
#            command=??,
            )
        self.checkbuttonLabelXMaxVerticalStraightLineReferenceCurve_AllCurvesOnePlot.grid(
            row=0,
            column=4,
            padx=0,
            pady=0,
            sticky=E,
            )
        labelText = Label(
            frame_74a,
            text='X value',
            justify=LEFT,
            bg=colorbg,
            )
        labelText.grid(
            row=0,
            column=5,
            padx=0,
            pady=0,
            sticky=W
            )

# ... label text showing "[ref]" will always be included in label
        labelText = Label(
            frame_74a,
            text=' +  [ref]',
            justify=LEFT,
            bg=colorbg,
            )
        labelText.grid(
            row=0,
            column=6,
            padx=0,
            pady=0,
#            sticky=W
            )              

# FRAME 75
# include CSV-formatted plot data from a file
# Row 0
# ... checkbutton
        self.varCheckbuttonPlotCsvFileData_AllCurvesOnePlot = IntVar()
        self.checkbuttonPlotCsvFileData_AllCurvesOnePlot = Checkbutton(
            frame_75,
            bg=colorbg,
            variable=self.varCheckbuttonPlotCsvFileData_AllCurvesOnePlot,
            command=self.handlerCheckbuttonPlotCsvFileData_AllCurvesOnePlot,
            )
        self.checkbuttonPlotCsvFileData_AllCurvesOnePlot.grid(
            row=0,
            column=0,
            padx=2,
            pady=0,
            sticky=W,
            )
# ... label
        labelPlotCsvFileData_AllCurvesOnePlot = Label(
            frame_75,
            text='Plot x-y from CSV file:',
            justify=LEFT,
            bg=colorbg,
            )
        labelPlotCsvFileData_AllCurvesOnePlot.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            sticky=W
            )
# ... entry field for file
        self.varEntryPlotCsvFileData_AllCurvesOnePlot = StringVar()
        self.entryPlotCsvFileData_AllCurvesOnePlot = Entry(
            frame_75,
            width=20,
            textvariable=self.varEntryPlotCsvFileData_AllCurvesOnePlot,
            )
        self.entryPlotCsvFileData_AllCurvesOnePlot.grid(
            row=0,
            column=2,
            padx=2,
            pady=0,
            )
# ... label for x column
        labelPlotCsvFileData_X_Column_AllCurvesOnePlot = Label(
            frame_75,
            text='X col:',
            justify=RIGHT,
            bg=colorbg,
            )
        labelPlotCsvFileData_X_Column_AllCurvesOnePlot.grid(
            row=0,
            column=3,
            padx=2,
            pady=0,
            )
# ... combobox for x column
        self.comboboxPlotCsvFileData_X_Column_AllCurvesOnePlot = Pmw.ComboBox(
            frame_75,
            scrolledlist_items=self.headers_PlotFileData_X_Column,
            entry_width=10,
            listheight=100,
            scrolledlist_hull_width=500,
            )
        self.comboboxPlotCsvFileData_X_Column_AllCurvesOnePlot.grid(
            row=0,
            column=4,
            padx=0,
            pady=0,
            )
# ... label for y column
        labelPlotCsvFileData_Y_Column_AllCurvesOnePlot = Label(
            frame_75,
            text='Y col:',
            justify=RIGHT,
            bg=colorbg,
            )
        labelPlotCsvFileData_Y_Column_AllCurvesOnePlot.grid(
            row=0,
            column=5,
            padx=2,
            pady=0,
            )
# ... combobox for y column
        self.comboboxPlotCsvFileData_Y_Column_AllCurvesOnePlot = Pmw.ComboBox(
            frame_75,
            scrolledlist_items=self.headers_PlotFileData_Y_Column,
            entry_width=10,
            listheight=100,
            scrolledlist_hull_width=500,
            )
        self.comboboxPlotCsvFileData_Y_Column_AllCurvesOnePlot.grid(
            row=0,
            column=6,
            padx=0,
            pady=0,
            )
# Row 1
# ... browse for plot x-y file
        buttonBrowseForPlotCsvFileData_AllCurvesOnePlot = Button(
            frame_75,
            text='Browse',
            width=10,
            font=self.buttonFontSmallest,
            borderwidth=3,
            relief=RAISED,
            background='white',
            foreground='blue',
            command=self.handlerButtonBrowseForPlotCsvFileData_AllCurvesOnePlot,
            )
        buttonBrowseForPlotCsvFileData_AllCurvesOnePlot.grid(
            row=1,
            column=2,
            padx=0,
            pady=0,
            sticky=N,
            )

# frame_80
# x-tick size
        labelFontLabels = Label(
            self.frame_80a,
            text='X-Ticks size:',
            bg=colorbg,
            )
        labelFontLabels.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            sticky=E,
            )
        self.comboboxFontXTicks_AllCurvesOnePlot = Pmw.ComboBox(
            self.frame_80a,
            scrolledlist_items=self.fontsizesTickX,
            listheight=160,
            entry_width=5,
            scrolledlist_hull_width=500,
            )
        self.comboboxFontXTicks_AllCurvesOnePlot.grid(
            row=0,
            column=1,
            padx=5,
            pady=0,
            sticky=W,
            )
# x-tick color
        self.comboboxColorXTicks_AllCurvesOnePlot = Pmw.ComboBox(
            self.frame_80a,
            scrolledlist_items=self.colorsTickX,
            listheight=150,
            label_text='color:',
            label_background=colorbg,
            labelpos='w',
            entry_width=10,
            scrolledlist_hull_width=500,
            )
        self.comboboxColorXTicks_AllCurvesOnePlot.grid(
            row=0,
            column=2,
            padx=5,
            pady=0,
            sticky=W,
            )
# y-tick size
        labelFontLabels = Label(
            self.frame_80a,
            text='Y-Ticks size:',
            bg=colorbg,
            )
        labelFontLabels.grid(
            row=1,
            column=0,
            padx=0,
            pady=0,
            sticky=E,
            )
        self.comboboxFontYTicks_AllCurvesOnePlot = Pmw.ComboBox(
            self.frame_80a,
            scrolledlist_items=self.fontsizesTickY,
            listheight=160,
            entry_width=5,
            scrolledlist_hull_width=500,
            )
        self.comboboxFontYTicks_AllCurvesOnePlot.grid(
            row=1,
            column=1,
            padx=5,
            pady=0,
            sticky=W,
            )
# y-tick color
        self.comboboxColorYTicks_AllCurvesOnePlot = Pmw.ComboBox(
            self.frame_80a,
            scrolledlist_items=self.colorsTickY,
            listheight=150,
            label_text='color:',
            label_background=colorbg,
            labelpos='w',
            entry_width=10,
            scrolledlist_hull_width=500,
            )
        self.comboboxColorYTicks_AllCurvesOnePlot.grid(
            row=1,
            column=2,
            padx=5,
            pady=0,
            sticky=W,
            )
# chart background color 
        self.comboboxColorBackground_AllCurvesOnePlot = Pmw.ComboBox(
            self.frame_80a,
            scrolledlist_items=self.colorsChartBackground,
            listheight=150,
            label_text='Background color:',
            label_background=colorbg,
#            entry_state='disabled',
#            entry_disabledbackground='lightgray',
#            entry_disabledforeground='darkgray',
            labelpos='w',
            entry_width=10,
            scrolledlist_hull_width=500,
            )
        self.comboboxColorBackground_AllCurvesOnePlot.grid(
            row=0,
            column=3,
            columnspan=1,
            padx=5,
            pady=0,
            sticky=E,
            )
# chart border color 
        self.comboboxColorBorder_AllCurvesOnePlot = Pmw.ComboBox(
            self.frame_80a,
            scrolledlist_items=self.colorsChartBackground,
            listheight=150,
            label_text='Border color:',
            label_background=colorbg,
#            entry_state='disabled',
#            entry_disabledbackground='lightgray',
#            entry_disabledforeground='darkgray',
            labelpos='w',
            entry_width=10,
            scrolledlist_hull_width=500,
            )
        self.comboboxColorBorder_AllCurvesOnePlot.grid(
            row=1,
            column=3,
            columnspan=1,
            padx=5,
            pady=0,
            sticky=E,
            )
        
# frame_80b
# ... reset all
        buttonResetAllPlots = Button(
            frame_80b,
            text='Reset all',
            width=12,
            background='white',
            foreground='blue',
            font=self.buttonFontSmall,
            relief=RAISED,
            borderwidth=3,
            command=self.handlerResetAllPlotXYSelect,
            )
        buttonResetAllPlots.grid(
            row=0,
            column=0,
            padx=5,
            pady=1,
            )
# ... close all plots if plots are present
        buttonCloseAllPlots = Button(
            frame_80b,
            text='Close all plots',
            width=12,
            font=self.buttonFontSmall,
            relief=RAISED,
            borderwidth=3,
            command=self.handlerCloseAllXYPlots,
            )
        buttonCloseAllPlots.grid(
            row=0,
            column=1,
            padx=5,
            pady=1,
            )
            
# ... plot
        self.buttonXYPlottingSpecsPlot = Button(
            frame_80b,
            text='Plot',
            width=15,
            relief=RAISED,
            borderwidth=5,
            command=self.handlerPlotXYSelect,
            )
        self.buttonXYPlottingSpecsPlot.grid(
            row=1,
            column=0,
            padx=5,
            pady=2,
            )
# ... cancel
        buttonCancel = Button(
            frame_80b,
            text='Cancel',
            width=15,
            relief=RAISED,
            borderwidth=5,
            command=self.destroyPlotPreprocess_XY,
            )
        buttonCancel.grid(
            row=1,
            column=1,
            padx=1,
            pady=2,
            )

# set all variables, depending on whether there was a previous window
        if self.previousWindow_XY:
        
# XY Plot window exists; restore previous state of window
# ... replot
            self.varReplotInCurrentWindow.set(replot_checkbutton_status)
            if replot_checkbutton_status:
                self.checkbuttonReplotInCurrentWindow.select()
            else:
                self.checkbuttonReplotInCurrentWindow.deselect()
                
# ... erase previous plot
            self.varKeepPreviousPlotInCurrentWindow.set(keep_previous_plot_status)
            if keep_previous_plot_status:
                self.checkbuttonKeepPreviousPlotInCurrentWindow.select()
            else:
                self.checkbuttonKeepPreviousPlotInCurrentWindow.deselect()
                
# ... disable replot button if 'erase previous plot' button is not checked

            print ' **********   replot_checkbutton_status = ', replot_checkbutton_status
            if replot_checkbutton_status:
                self.checkbuttonKeepPreviousPlotInCurrentWindow.configure(state='normal')
            else:
                self.checkbuttonKeepPreviousPlotInCurrentWindow.configure(state='disabled')
                
# ... plot style radiobutton
            self.var_radiobuttonPlotStyle.set(plot_Style_XY)
            
# ... base for log plots
            self.comboboxBaseForLogPlotsX.setentry(plot_BaseForLogPlotsX)
            self.comboboxBaseForLogPlotsY.setentry(plot_BaseForLogPlotsY)
            
# ... line width
            lineWidthAllPlots = self.comboboxLineWidthPlots_XY.setentry(lineWidthAllPlots)
            
# ... marker size
            markerSizeAllPlots = self.comboboxMarkerSizePlots_XY.setentry(
                self.listDataMarkerSize[3]
                )
            
# ... show as disabled if 'cartesian' is selected; o/w, show as normal
            if self.var_radiobuttonPlotStyle.get().strip() == 'cartesian':
                self.comboboxBaseForLogPlotsX._entryWidget['state']=DISABLED
                self.comboboxBaseForLogPlotsY._entryWidget['state']=DISABLED
            elif self.var_radiobuttonPlotStyle.get().strip() == 'semilogx':
                self.comboboxBaseForLogPlotsX._entryWidget['state']=NORMAL
                self.comboboxBaseForLogPlotsY._entryWidget['state']=DISABLED
            elif self.var_radiobuttonPlotStyle.get().strip() == 'semilogy':
                self.comboboxBaseForLogPlotsX._entryWidget['state']=DISABLED
                self.comboboxBaseForLogPlotsY._entryWidget['state']=NORMAL
            else:
                self.comboboxBaseForLogPlotsX._entryWidget['state']=NORMAL
                self.comboboxBaseForLogPlotsY._entryWidget['state']=NORMAL
                
# ... include table data
            if (
                numberOfPreviousTableCurves == 0
                and
                self.varNumberOfTableCurves.get() <> 0
                ):
                self.varCheckbuttonTableData.set(1)
            elif (
                numberOfPreviousTableCurves <> 0
                and
                self.varNumberOfTableCurves.get() <> 0
                ):
                self.varCheckbuttonTableData.set(includeTableData_checkbutton_status)
            else:
                self.varCheckbuttonTableData.set(0)
                
# ... include buffer data
            if (
                numberOfPreviousStorageBufferCurves == 0
                and
                self.varNumberOfStorageBufferCurves.get() <> 0
                ):
                self.varCheckbuttonBufferData.set(1)
            elif (
                numberOfPreviousStorageBufferCurves <> 0
                and
                self.varNumberOfStorageBufferCurves.get() <> 0
                ):
                self.varCheckbuttonBufferData.set(includeBufferData_checkbutton_status)
            else:
                self.varCheckbuttonBufferData.set(0)
            '''
            if includeBufferData_checkbutton_status:
                self.checkbuttonBufferData.select()
            else:
                self.checkbuttonBufferData.deselect() 
            '''
            
# ... single or all radiobutton            
            if single_or_all_radiobutton == 'single':
                self.radiobuttonSingleCurvePerPlot.select()
            else:
                self.radiobuttonAllCurvesOnePlot.select()
# ... single - show main title
            self.varShowMainTitle_SingleCurvePerPlot.set(single_showMainTitle_checkbutton_status)
            
# ... single - text main title
            self.varEntryMainTitle_SingleCurvePerPlot.set(single_textMainTitle_checkbutton_status)
            
# ... single - font main title
            self.comboboxFontMainTitle_SingleCurvePerPlot.setentry(single_fontMainTitle_combobox_value)            

# ... single - color main title
            self.comboboxColorMainTitle_SingleCurvePerPlot.setentry(single_colorMainTitle_combobox_value)

# ... single - show titles
            self.varShowTitles_SingleCurvePerPlot.set(single_showTitles_checkbutton_status)
            
# ... single - font title
            self.comboboxFontTitle_SingleCurvePerPlot.setentry(single_fontTitles_combobox_value)

# ... single - show grids
            self.varShowGrid_SingleCurvePerPlot.set(single_showGrids_checkbutton_status)
            
# ... single - x-y labels size and color
            self.comboboxFontLabels_SingleCurvePerPlot.setentry(single_fontXYLabels_combobox_values)
            self.comboboxColorLabels_SingleCurvePerPlot.setentry(single_colorXYLabels_combobox_values)
            
# ... single - x-ticks size and color
            self.comboboxFontXTicks_SingleCurvePerPlot.setentry(single_fontXTicks_combobox_value)
            self.comboboxColorXTicks_SingleCurvePerPlot.setentry(single_colorXTicks_combobox_value)
            
# ... single - y-ticks size and color
            self.comboboxFontYTicks_SingleCurvePerPlot.setentry(single_fontYTicks_combobox_value)
            self.comboboxColorYTicks_SingleCurvePerPlot.setentry(single_colorYTicks_combobox_value)
            
# ... single - background color
            self.comboboxColorBackground_SingleCurvePerPlot.setentry(single_colorBackground_combobox_value)
            
# ... single - border color
            self.comboboxColorBorder_SingleCurvePerPlot.setentry(single_colorBorder_combobox_value)

# ... all - show titles
            self.varCheckbuttonShowTitle_AllCurvesOnePlot.set(all_showTitles_checkbutton_status)
            self.varEntryShowTitle_AllCurvesOnePlot.set(all_showTitles_entryfield_value)
            try:
                self.comboboxFontTitle_AllCurvesOnePlot.setentry(all_fontTitles_Combobox_value)
            except:
                self.comboboxFontTitle_AllCurvesOnePlot.selectitem(self.fontsizesChartTitle[6])
            self.comboboxColorTitle_AllCurvesOnePlot.setentry(all_colorTitles_combobox_value)

# ... all - show y label
            self.varCheckbuttonShowLabelY_AllCurvesOnePlot.set(all_showYLabel_checkbutton_status)
            self.varShowLabelY_AllCurvesOnePlot.set(all_showYLabel_entryfield_value)
            
# ... all - show x label
            self.varCheckbuttonShowLabelX_AllCurvesOnePlot.set(all_showXLabel_checkbutton_status)

# ... all - xy-label font
            try:
                self.comboboxFontXYLabels_AllCurvesOnePlot.setentry(all_fontXYLabels_combobox_value)
            except:
                self.comboboxFontXYLabels_AllCurvesOnePlot.selectitem(self.fontsizesChartLabels[4])
                self.comboboxFontXYLabels_AllCurvesOnePlot.configure(entry_width=5)
                
# ... all - xy-label color
            self.comboboxColorXYLabels_AllCurvesOnePlot.setentry(all_colorXYLabels_combobox_value)
            
# ... all - show legend
            self.varCheckbuttonShowLegend_AllCurvesOnePlot.set(all_showLegend_checkbutton_status)
            
# ... all - legend location
            try:
                self.comboboxShowLegendLocation_AllCurvesOnePlot.setentry(
                    all_showLegend_combobox_value
                    )
            except:
                self.comboboxShowLegendLocation_AllCurvesOnePlot.selectitem(self.legendLocations[0])
                
# ... all - font legend
            try:
                all_fontLegend_combobox_value = self.comboboxFontLegend_AllCurvesOnePlot.setentry(
                    all_fontLegend_combobox_value
                    )
            except:
                self.comboboxFontLegend_AllCurvesOnePlot.selectitem(self.fontsizesLegend[1])
            self.comboboxShowLegendLocation_AllCurvesOnePlot.configure(entry_width=10)
            self.comboboxFontLegend_AllCurvesOnePlot.configure(entry_width=5)
            
# ... all - show grid
            self.varCheckbuttonShowGrid_AllCurvesOnePlot.set(all_showGrid_checkbutton_status)
            
# ... all - show reference curve
            self.varCheckbuttonShowReferenceCurve_AllCurvesOnePlot.set(all_showRefCurve_checkbutton_status)
            if all_showRefCurve_checkbutton_status:
                self.checkbuttonShowReferenceCurve_AllCurvesOnePlot.select()
            else:
                self.checkbuttonShowReferenceCurve_AllCurvesOnePlot.deselect()
                
# ... all - reference curve multiplier
            try:
                self.comboboxShowReferenceCurveMultiplier_AllCurvesOnePlot.setentry(all_showRefCurve_Multiplier_combobox_value)
            except:
                self.comboboxShowReferenceCurveMultiplier_AllCurvesOnePlot.selectitem(self.multipliersReferenceCurve[4])
                self.comboboxShowReferenceCurveMultiplier_AllCurvesOnePlot.configure(entry_width=6)
# ... all - reference curve label   
# keep same label as before unless not available due to checking or unchecking table columns
# ... update scrolledlist_items first, since refreshed window may contain either table or buffer updates
#            self.handlerRefreshReferenceCurveList()
            '''
            nameMatch = 0
            for name in (self.headerNames_Y_Table + self.headerNames_Y_Buffer):
                if name == all_showRefCurve_Label_combobox_value:
                    self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot.setentry(
                        all_showRefCurve_Label_combobox_value
                        )
                    nameMatch=1
                    break
            if not nameMatch:
                try:
                    self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot.selectitem(
                        (self.headerNames_Y_Table + self.headerNames_Y_Buffer)[0]
                        )
                except:
                    self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot.setentry('')
            '''
#            try:
#                self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot.setentry(all_showRefCurve_Label_combobox_value)
#            except:
#                self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot.selectitem(self.headerNamesY_AllCurvesOnOnePlot[0])
#            self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot.configure(entry_width=35) 

# ... all - show sloped straight line reference curve
            self.varCheckbuttonShowSlopedStraightReferenceCurve_AllCurvesOnePlot.set(all_showSlopedStraightLineRefCurve_checkbutton_status)
            if all_showSlopedStraightLineRefCurve_checkbutton_status:
                self.checkbuttonShowSlopedStraightReferenceCurve_AllCurvesOnePlot.select()
            else:
                self.checkbuttonShowSlopedStraightReferenceCurve_AllCurvesOnePlot.deselect()
            self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xinitial.setvalue(
                all_showSlopedStraightLineRefCurve_x_initial
                )
            self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xfinal.setvalue(
                all_showSlopedStraightLineRefCurve_x_final
                )
            self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yinitial.setvalue(
                all_showSlopedStraightLineRefCurve_y_initial
                )
            self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yfinal.setvalue(
                all_showSlopedStraightLineRefCurve_y_final
                ) 
            self.varCheckbuttonLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot.set(
                all_showSlopedStraightLineRefCurve_UserLabel_checkbutton_status
                )
            self.entryfieldLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot.setvalue(all_showSlopedStraightLineRefCurve_UserLabel)
            self.varCheckbuttonLabelSlopeDegreesSlopedStraightReferenceCurve_AllCurvesOnePlot.set(
                all_showSlopedStraightLineRefCurve_ShowSlope_checkbutton_status
                )
            
# ... all - show horizontal straight line reference curve
            self.varCheckbuttonShowHorizontalStraightReferenceCurve_AllCurvesOnePlot.set(all_showHorizontalStraightLineRefCurve_checkbutton_status)
            if all_showHorizontalStraightLineRefCurve_checkbutton_status:
                self.checkbuttonShowHorizontalStraightReferenceCurve_AllCurvesOnePlot.select()
            else:
                self.checkbuttonShowHorizontalStraightReferenceCurve_AllCurvesOnePlot.deselect()
            self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xinitial.setvalue(
                all_showHorizontalStraightLineRefCurve_x_initial
                )
            self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xfinal.setvalue(
                all_showHorizontalStraightLineRefCurve_x_final
                )
            self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Y.setvalue(
                all_showHorizontalStraightLineRefCurve_y
                ) 
            self.varCheckbuttonLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot.set(
                all_showHorizontalStraightLineRefCurve_UserLabel_checkbutton_status
                )
            self.entryfieldLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot.setvalue(
                all_showHorizontalStraightLineRefCurve_UserLabel
                )
            self.varCheckbuttonLabelYMaxHorizontalStraightReferenceCurve_AllCurvesOnePlot.set(
                all_showHorizontalStraightLineRefCurve_yValue_checkbutton_status
                )
                
# ... all - show vertical straight line reference curve
            self.varCheckbuttonShowVerticalStraightReferenceCurve_AllCurvesOnePlot.set(
                all_showVerticalStraightLineRefCurve_checkbutton_status
                )
            if all_showVerticalStraightLineRefCurve_checkbutton_status:
                self.checkbuttonShowVerticalStraightReferenceCurve_AllCurvesOnePlot.select()
            else:
                self.checkbuttonShowVerticalStraightReferenceCurve_AllCurvesOnePlot.deselect()
            self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yinitial.setvalue(
                all_showVerticalStraightLineRefCurve_y_initial
                )
            self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yfinal.setvalue(
                all_showVerticalStraightLineRefCurve_y_final
                )
            self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_X.setvalue(
                all_showVerticalStraightLineRefCurve_x
                ) 
            self.varCheckbuttonLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot.set(
                all_showVerticalStraightLineRefCurve_UserLabel_checkbutton_status
                )
            self.entryfieldLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot.setvalue(
                all_showVerticalStraightLineRefCurve_UserLabel
                )
            self.varCheckbuttonLabelXMaxVerticalStraightLineReferenceCurve_AllCurvesOnePlot.set(
                all_showVerticalStraightLineRefCurve_XValue_checkbutton_status
                )
                
# ... all - plot x-y data from csv file
            self.varCheckbuttonPlotCsvFileData_AllCurvesOnePlot.set(all_plotCsvFileData_checkbutton_status)
            self.varEntryPlotCsvFileData_AllCurvesOnePlot.set(all_plotCsvFileData_entry_value)
            self.comboboxPlotCsvFileData_X_Column_AllCurvesOnePlot.setentry(all_plotCsvFileData_x_column_value)
            self.comboboxPlotCsvFileData_Y_Column_AllCurvesOnePlot.setentry(all_plotCsvFileData_y_column_value)
            
# ... x ticks size and color
            self.comboboxFontXTicks_AllCurvesOnePlot.setentry(all_fontXTicks_combobox_value)
            self.comboboxColorXTicks_AllCurvesOnePlot.setentry(all_colorXTicks_combobox_value)
            
# ... y ticks size and color
            self.comboboxFontYTicks_AllCurvesOnePlot.setentry(all_fontYTicks_combobox_value)
            self.comboboxColorYTicks_AllCurvesOnePlot.setentry(all_colorYTicks_combobox_value)
            
# ... background color
            self.comboboxColorBackground_AllCurvesOnePlot.setentry(all_colorBackground_combobox_value)
            
# ... border color
            self.comboboxColorBorder_AllCurvesOnePlot.setentry(all_colorBorder_combobox_value)
                     

# use 'disabled' or 'normal' for single or all section on Plotting Specs

            if single_or_all_radiobutton == 'single':
            
# enable the 'single' widgets
# ... single - show main title, font
                self.checkbuttonShowMainTitle_SingleCurvePerPlot.configure(state='normal')
                if self.varShowMainTitle_SingleCurvePerPlot.get():
                    self.entryMainTitle_SingleCurvePerPlot.configure(state='normal')
                    self.handlerRefreshMainTitleSize_SingleCurvePerPlot(1)
                else:
                    self.entryMainTitle_SingleCurvePerPlot.configure(state='disabled')
                    self.handlerRefreshMainTitleSize_SingleCurvePerPlot(0)
                    
# ... single - show title, font
                self.checkbuttonShowTitles_SingleCurvePerPlot.configure(state='normal')
                if self.varShowTitles_SingleCurvePerPlot.get():
#                    self.comboboxFontTitle_SingleCurvePerPlot._entryWidget['state']=NORMAL
                    self.handlerRefreshYLabelSize_SingleCurvePerPlot(1)
                else:
#                    self.comboboxFontTitle_SingleCurvePerPlot._entryWidget['state']=DISABLED
                    self.handlerRefreshYLabelSize_SingleCurvePerPlot(0)
                    
# ... single - show grids
                self.checkbuttonShowGrid_SingleCurvePerPlot.configure(state='normal')
                '''
# ... single - xy-labels font and color
                self.comboboxFontLabels_SingleCurvePerPlot._entryWidget['state']=NORMAL
                self.comboboxColorLabels_SingleCurvePerPlot._entryWidget['state']=NORMAL
# ... single - x-ticks font and color
                self.comboboxFontXTicks_SingleCurvePerPlot._entryWidget['state']=NORMAL
                self.comboboxColorXTicks_SingleCurvePerPlot._entryWidget['state']=NORMAL
# ... single - y-ticks font and color
                self.comboboxFontYTicks_SingleCurvePerPlot._entryWidget['state']=NORMAL
                self.comboboxColorYTicks_SingleCurvePerPlot._entryWidget['state']=NORMAL
# ... single - background
                self.comboboxColorBackground_SingleCurvePerPlot._entryWidget['state']=NORMAL
                '''
# ... single - xy-labels, x-ticks, y-ticks fonts and colors; background color
                self.handlerRefreshColors_SingleCurvePerPlot(1)
                
# disable the 'all' widgets
# ... all - show title
                self.checkbuttonShowTitle_AllCurvesOnePlot.configure(state='disabled')
                self.entryShowTitle_AllCurvesOnePlot.configure(state='disabled')
                self.comboboxFontTitle_AllCurvesOnePlot._entryWidget['state'] = DISABLED
                self.comboboxColorTitle_AllCurvesOnePlot._entryWidget['state'] = DISABLED
                
# ... all - show y label
                self.checkbuttonShowLabelY_AllCurvesOnePlot.configure(state='disabled')
                self.entryShowLabelY_AllCurvesOnePlot.configure(state='disabled')
                
# ... all - show x label
                self.checkbuttonShowLabelX_AllCurvesOnePlot.configure(state='disabled')
                self.comboboxShowLabelX_AllCurvesOnePlot._entryWidget['state']=DISABLED
                
# ... all - xy-label font
                self.comboboxFontXYLabels_AllCurvesOnePlot._entryWidget['state'] = DISABLED
# ... all - xy-label color
#                self.comboboxColorXYLabels_AllCurvesOnePlot._entryWidget['state'] = DISABLED
                self.handlerRefreshXYLabelsColor_AllCurvesOnOnePlot(0)
                
# ... all - show legend
                self.checkbuttonShowLegend_AllCurvesOnePlot.configure(state='disabled')
                self.comboboxShowLegendLocation_AllCurvesOnePlot._entryWidget['state'] = DISABLED
                self.comboboxFontLegend_AllCurvesOnePlot._entryWidget['state'] = DISABLED
                
# ... all - show grid
                self.checkbuttonShowGrid_AllCurvesOnePlot.configure(state='disabled')
                
# ... all - show reference curve
                self.checkbuttonShowReferenceCurve_AllCurvesOnePlot.configure(state='disabled')
                
# ... all - reference curve multiplier
                self.comboboxShowReferenceCurveMultiplier_AllCurvesOnePlot._entryWidget['state'] = DISABLED
                
# ... all - reference curve label
#                self.handlerRefreshReferenceCurveList(0, single_or_all_radiobutton)
                self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot._entryWidget['state'] = DISABLED

# ...       update reference curve list and X labels for 'all'             
                self.handlerRefreshReferenceCurveList()

# ... all - show sloped straight line reference curve
                self.checkbuttonShowSlopedStraightReferenceCurve_AllCurvesOnePlot.configure(state='disabled')
                self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xinitial.configure(entry_state='disabled')
                self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xfinal.configure(entry_state='disabled')
                self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yinitial.configure(entry_state='disabled')
                self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yfinal.configure(entry_state='disabled')
                self.checkbuttonLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot.configure(state='disabled')
                self.entryfieldLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot.configure(entry_state='disabled')
     #           self.checkbuttonLabelYMaxHorizontalStraightReferenceCurve_AllCurvesOnePlot.configure(state='disabled')
                self.checkbuttonLabelSlopeDegreesSlopedStraightReferenceCurve_AllCurvesOnePlot.configure(state='disabled')
                
# ... all - show horizontal straight line reference curve
                self.checkbuttonShowHorizontalStraightReferenceCurve_AllCurvesOnePlot.configure(state='disabled')
                self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xinitial.configure(entry_state='disabled')
                self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xfinal.configure(entry_state='disabled')
                self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Y.configure(entry_state='disabled')
                self.checkbuttonLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot.configure(state='disabled')
                self.entryfieldLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot.configure(entry_state='disabled')
                self.checkbuttonLabelYMaxHorizontalStraightReferenceCurve_AllCurvesOnePlot.configure(state='disabled')

# ... all - show vertical straight line reference curve
                self.checkbuttonShowVerticalStraightReferenceCurve_AllCurvesOnePlot.configure(state='disabled')
                self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yinitial.configure(entry_state='disabled')
                self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yfinal.configure(entry_state='disabled')
                self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_X.configure(entry_state='disabled')
                self.checkbuttonLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot.configure(state='disabled')
                self.entryfieldLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot.configure(entry_state='disabled')
                self.checkbuttonLabelXMaxVerticalStraightLineReferenceCurve_AllCurvesOnePlot.configure(state='disabled')

# ... all - plot x-y from file
                self.checkbuttonPlotCsvFileData_AllCurvesOnePlot.configure(state='disabled')
                self.entryPlotCsvFileData_AllCurvesOnePlot.configure(state='disabled')
                self.comboboxPlotCsvFileData_X_Column_AllCurvesOnePlot._entryWidget['state']=DISABLED
                self.comboboxPlotCsvFileData_Y_Column_AllCurvesOnePlot._entryWidget['state']=DISABLED
                
# ... all - x-ticks size and color
                self.comboboxFontXTicks_AllCurvesOnePlot._entryWidget['state'] = DISABLED
                '''
                self.comboboxColorXTicks_AllCurvesOnePlot._entryWidget['state'] = DISABLED
                '''
                
# ... all - y-ticks size and color
                self.comboboxFontYTicks_AllCurvesOnePlot._entryWidget['state'] = DISABLED
                '''
                self.comboboxColorYTicks_AllCurvesOnePlot._entryWidget['state'] = DISABLED
                '''
                
# ... all - background color
                '''
                self.comboboxColorBackground_AllCurvesOnePlot._entryWidget['disabledbackground'] = 'lightgray'
                self.comboboxColorBackground_AllCurvesOnePlot._entryWidget['disabledforeground'] = 'darkgray'
                self.comboboxColorBackground_AllCurvesOnePlot._entryWidget['state'] = DISABLED
                '''
                
# ... x-ticks color, y-ticks color, and background color
                self.handlerRefreshColors_AllCurvesOnOnePlot(0)
                
                
# ------------------------   
             
            elif single_or_all_radiobutton == 'all':
            
# ... 'single' entry fields

# ... single - main title - disable
                self.checkbuttonShowMainTitle_SingleCurvePerPlot.configure(state='disabled')
                
# ... single - main title entry - disable
                self.entryMainTitle_SingleCurvePerPlot.configure(state='disabled')
                
# ... single - main title font - disable
                self.handlerRefreshMainTitleSize_SingleCurvePerPlot(0)
                
# ... single - titles - disable
                self.checkbuttonShowTitles_SingleCurvePerPlot.configure(state='disabled')
                
# ... single - title font - disable
#                self.comboboxFontTitle_SingleCurvePerPlot._entryWidget['state']=DISABLED
                self.handlerRefreshYLabelSize_SingleCurvePerPlot(0)
# ... single - show grids - disable

                self.checkbuttonShowGrid_SingleCurvePerPlot.configure(state='disabled')
                
                '''
# ...  single - labels font and color - disable
                self.comboboxFontLabels_SingleCurvePerPlot._entryWidget['state']=DISABLED
                self.comboboxColorLabels_SingleCurvePerPlot._entryWidget['state']=DISABLED
# ... single - x-ticks size and color - disable
                self.comboboxFontXTicks_SingleCurvePerPlot._entryWidget['state']=DISABLED
                self.comboboxColorXTicks_SingleCurvePerPlot._entryWidget['state']=DISABLED
# ... single - y-ticks size and color - disable
                self.comboboxFontYTicks_SingleCurvePerPlot._entryWidget['state']=DISABLED
                self.comboboxColorYTicks_SingleCurvePerPlot._entryWidget['state']=DISABLED
# ... single - background color
                self.comboboxColorBackground_SingleCurvePerPlot._entryWidget['state'] = DISABLED 
                '''
                
# ... single - xy-labels, x-ticks, y-ticks fonts and colors; background color
                self.handlerRefreshColors_SingleCurvePerPlot(0)
                
# ... 'all' entry fields
# ... all - title
                self.checkbuttonShowTitle_AllCurvesOnePlot.configure(state='normal')
                if all_showTitles_checkbutton_status:
                    self.entryShowTitle_AllCurvesOnePlot.configure(state='normal')
                    self.comboboxFontTitle_AllCurvesOnePlot._entryWidget['state'] = NORMAL
                    self.comboboxColorTitle_AllCurvesOnePlot._entryWidget['state'] = NORMAL
                else:
                    self.entryShowTitle_AllCurvesOnePlot.configure(state='disabled')
                    self.comboboxFontTitle_AllCurvesOnePlot._entryWidget['state'] = DISABLED
                    self.comboboxColorTitle_AllCurvesOnePlot._entryWidget['state'] = DISABLED
                    
# ... all - y label
                self.checkbuttonShowLabelY_AllCurvesOnePlot.configure(state='normal')
                if all_showYLabel_checkbutton_status:
                    self.entryShowLabelY_AllCurvesOnePlot.configure(state='normal')
                else:
                    self.entryShowLabelY_AllCurvesOnePlot.configure(state='disabled')
                    
# ... all - x label
                self.checkbuttonShowLabelX_AllCurvesOnePlot.configure(state='normal')
                if all_showXLabel_checkbutton_status:
#                    self.entryShowLabelX_AllCurvesOnePlot.configure(state='normal') 
                    self.comboboxShowLabelX_AllCurvesOnePlot._entryWidget['state']=NORMAL
                else:
#                    self.entryShowLabelX_AllCurvesOnePlot.configure(state='disabled')
                    self.comboboxShowLabelX_AllCurvesOnePlot._entryWidget['state']=DISABLED
                    
# ... all - xy-label font and color
                if all_showYLabel_checkbutton_status or all_showXLabel_checkbutton_status:
                    self.comboboxFontXYLabels_AllCurvesOnePlot._entryWidget['state']=NORMAL
#                    self.comboboxColorXYLabels_AllCurvesOnePlot._entryWidget['state']=NORMAL
                    self.handlerRefreshXYLabelsColor_AllCurvesOnOnePlot(1)
                else:
                    self.comboboxFontXYLabels_AllCurvesOnePlot._entryWidget['state']=DISABLED
#                    self.comboboxColorXYLabels_AllCurvesOnePlot._entryWidget['state']=DISABLED
                    self.handlerRefreshXYLabelsColor_AllCurvesOnOnePlot(0)
                    
# ...  all - legend
                self.checkbuttonShowLegend_AllCurvesOnePlot.configure(state='normal')
                if all_showLegend_checkbutton_status:
                    self.comboboxShowLegendLocation_AllCurvesOnePlot._entryWidget['state']=NORMAL
                    self.comboboxFontLegend_AllCurvesOnePlot._entryWidget['state']=NORMAL
                else:
                    self.comboboxShowLegendLocation_AllCurvesOnePlot._entryWidget['state']=DISABLED
                    self.comboboxFontLegend_AllCurvesOnePlot._entryWidget['state']=DISABLED
                    
# ...  all - show grid
                self.checkbuttonShowGrid_AllCurvesOnePlot.configure(state='normal')
                
# ... all - reference curve and X labels
                self.checkbuttonShowReferenceCurve_AllCurvesOnePlot.configure(state='normal')
                if self.varCheckbuttonShowReferenceCurve_AllCurvesOnePlot.get():
                    self.comboboxShowReferenceCurveMultiplier_AllCurvesOnePlot._entryWidget['state'] = NORMAL
                    self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot._entryWidget['state'] = NORMAL
                else:
                    self.comboboxShowReferenceCurveMultiplier_AllCurvesOnePlot._entryWidget['state'] = DISABLED
                    self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot._entryWidget['state'] = DISABLED
                    
# ...       update reference curve list and X labels for 'all'
#                self.handlerRefreshReferenceCurveList(1, single_or_all_radiobutton)
                self.handlerRefreshReferenceCurveList()
                    
# ... all - show sloped straight line reference curve
                self.checkbuttonShowSlopedStraightReferenceCurve_AllCurvesOnePlot.configure(state='normal')
                if self.varCheckbuttonShowSlopedStraightReferenceCurve_AllCurvesOnePlot.get():
                    self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xinitial.configure(entry_state='normal')
                    self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xfinal.configure(entry_state='normal')
                    self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yinitial.configure(entry_state='normal')
                    self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yfinal.configure(entry_state='normal')
                    self.checkbuttonLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot.configure(state='normal')
                    self.entryfieldLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot.configure(entry_state='normal')
                    self.checkbuttonLabelSlopeDegreesSlopedStraightReferenceCurve_AllCurvesOnePlot.configure(state='normal')
                else:
                    self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xinitial.configure(entry_state='disabled')
                    self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xfinal.configure(entry_state='disabled')
                    self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yinitial.configure(entry_state='disabled')
                    self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yfinal.configure(entry_state='disabled')
                    self.checkbuttonLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot.configure(state='disabled')
                    self.entryfieldLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot.configure(entry_state='disabled')
                    self.checkbuttonLabelSlopeDegreesSlopedStraightReferenceCurve_AllCurvesOnePlot.configure(state='disabled')
                    
# ... all - show horizontal straight line reference curve
                self.checkbuttonShowHorizontalStraightReferenceCurve_AllCurvesOnePlot.configure(state='normal')
                if self.varCheckbuttonShowHorizontalStraightReferenceCurve_AllCurvesOnePlot.get():
                    self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xinitial.configure(entry_state='normal')
                    self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xfinal.configure(entry_state='normal')
                    self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Y.configure(entry_state='normal')
                    self.checkbuttonLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot.configure(state='normal')
                    self.entryfieldLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot.configure(entry_state='normal')
                    self.checkbuttonLabelYMaxHorizontalStraightReferenceCurve_AllCurvesOnePlot.configure(state='normal')
                else:
                    self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xinitial.configure(entry_state='disabled')
                    self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xfinal.configure(entry_state='disabled')
                    self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Y.configure(entry_state='disabled')
                    self.checkbuttonLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot.configure(state='disabled')
                    self.entryfieldLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot.configure(entry_state='disabled')
                    self.checkbuttonLabelYMaxHorizontalStraightReferenceCurve_AllCurvesOnePlot.configure(state='disabled')
                    
# ... all - show vertical straight line reference curve
                self.checkbuttonShowVerticalStraightReferenceCurve_AllCurvesOnePlot.configure(state='normal')
                if self.varCheckbuttonShowVerticalStraightReferenceCurve_AllCurvesOnePlot.get():
                    self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yinitial.configure(entry_state='normal')
                    self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yfinal.configure(entry_state='normal')
                    self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_X.configure(entry_state='normal')
                    self.checkbuttonLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot.configure(state='normal')
                    self.entryfieldLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot.configure(entry_state='normal')
                    self.checkbuttonLabelXMaxVerticalStraightLineReferenceCurve_AllCurvesOnePlot.configure(state='normal')
                else:
                    self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yinitial.configure(entry_state='disabled')
                    self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yfinal.configure(entry_state='disabled')
                    self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_X.configure(entry_state='disabled')
                    self.checkbuttonLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot.configure(state='disabled')
                    self.entryfieldLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot.configure(entry_state='disabled')
                    self.checkbuttonLabelXMaxVerticalStraightLineReferenceCurve_AllCurvesOnePlot.configure(state='disabled')
                    
# ... all - plot x-y from file               
                self.checkbuttonPlotCsvFileData_AllCurvesOnePlot.configure(state='normal')
                if self.varCheckbuttonPlotCsvFileData_AllCurvesOnePlot.get():
                    self.entryPlotCsvFileData_AllCurvesOnePlot.configure(state='normal')
                    self.comboboxPlotCsvFileData_X_Column_AllCurvesOnePlot._entryWidget['state']=NORMAL
                    self.comboboxPlotCsvFileData_Y_Column_AllCurvesOnePlot._entryWidget['state']=NORMAL
                else:
                    self.entryPlotCsvFileData_AllCurvesOnePlot.configure(state='disabled')
                    self.comboboxPlotCsvFileData_X_Column_AllCurvesOnePlot._entryWidget['state']=DISABLED
                    self.comboboxPlotCsvFileData_Y_Column_AllCurvesOnePlot._entryWidget['state']=DISABLED
                    
# ... all - x-ticks size and color
                self.comboboxFontXTicks_AllCurvesOnePlot._entryWidget['state'] = NORMAL
#                self.comboboxColorXTicks_AllCurvesOnePlot._entryWidget['state'] = NORMAL

# ... all - y-ticks size and color
                self.comboboxFontYTicks_AllCurvesOnePlot._entryWidget['state'] = NORMAL
#                self.comboboxColorYTicks_AllCurvesOnePlot._entryWidget['state'] = NORMAL  

# ... all - background color
                self.handlerRefreshColors_AllCurvesOnOnePlot(1)
                    
            else:
# error
                stringErrorSingleOrAll = (
                    'Variable "single_or_all_radiobutton" in ' + MODULE + ' must' + '\n' +
                    '  take on the value of either "single" or "all". ' + '\n' +
                    'Current value: single_or_all_radiobutton = %s' + '\n\n' +
                    'Current operation is canceled.' + '\n'
                    ) % single_or_all_radiobutton
                print stringErrorSingleOrAll
                self.MySQL_Output(
                    1,
                    stringErrorSingleOrAll
                    )
                showerror(
                    'Error: invalid value',
                    '\n' + stringErrorSingleOrAll + '\n'
                    )
                return
                
        else:
# plot window did not exist
# DEFAULT SETTINGS
# ... replot
            self.checkbuttonReplotInCurrentWindow.deselect()
            
# ...  erase previous plot
            self.checkbuttonKeepPreviousPlotInCurrentWindow.deselect()
            
# ...  disable replot button if 'erase previous plot' button is not checked
            if self.varReplotInCurrentWindow.get():
                self.checkbuttonKeepPreviousPlotInCurrentWindow.configure(state='normal')
            else:
                self.checkbuttonKeepPreviousPlotInCurrentWindow.configure(state='disabled')
                
# ... if number of table curves is non-zero, check the 'Plot curves from Table' checkbutton
            if self.varNumberOfTableCurves.get() <> 0:
                self.varCheckbuttonTableData.set(1)
            else:
                self.varCheckbuttonTableData.set(0)
                
# ... if number of buffer curves is non-zero, check the 'Plot curves from Storage Buffer' checkbutton
            if self.varNumberOfStorageBufferCurves.get() <> 0:
                self.varCheckbuttonBufferData.set(1)
            else:
                self.varCheckbuttonBufferData.set(0)
                
# ... line width
            self.comboboxLineWidthPlots_XY.setentry(
                self.lineWidth_Plots_XY[1]
                )
                
# ... marker size
            self.comboboxMarkerSizePlots_XY.setentry(
                self.listDataMarkerSize[3]
                )
                
# ------------  single -------------
            self.dictSingleCurvePerChartPlotParams = \
                copy.deepcopy(self.dictSingleCurvePerChartPlotParams_Defaults)
            
# ... plot style radiobutton
            self.var_radiobuttonPlotStyle.set('cartesian')
            
# ... base for log plots
            self.comboboxBaseForLogPlotsX.setentry(
                self.baseForLogPlots[6]
                )
            self.comboboxBaseForLogPlotsY.setentry(
                self.baseForLogPlots[6]
                )
            self.comboboxBaseForLogPlotsX._entryWidget['state']=DISABLED
            self.comboboxBaseForLogPlotsY._entryWidget['state']=DISABLED
            
# ... single or all radiobutton
            self.radiobuttonSingleCurvePerPlot.select()
            
# ... single - show main title
            if self.dictSingleCurvePerChartPlotParams['showMainTitle']:
                self.checkbuttonShowMainTitle_SingleCurvePerPlot.select()
                self.handlerRefreshMainTitleSize_SingleCurvePerPlot(1)
                self.entryMainTitle_SingleCurvePerPlot.configure(state='normal')
            else:
                self.checkbuttonShowMainTitle_SingleCurvePerPlot.deselect()
                self.handlerRefreshMainTitleSize_SingleCurvePerPlot(0)
                self.entryMainTitle_SingleCurvePerPlot.configure(state='disabled')
                
# ... single - main title text
            self.varEntryMainTitle_SingleCurvePerPlot.set(
                self.dictSingleCurvePerChartPlotParams['textMainTitle']
                )
                
# ... single - main title font
            self.comboboxFontMainTitle_SingleCurvePerPlot.setentry(
                self.dictSingleCurvePerChartPlotParams['fontsizeMainTitle']
                )
                
# ... single - main title color
            self.comboboxColorMainTitle_SingleCurvePerPlot.setentry(
                self.dictSingleCurvePerChartPlotParams['colorMainTitle']
                )
            
# ... single - show individual plot titles
            if self.dictSingleCurvePerChartPlotParams['showTitles']:
                self.checkbuttonShowTitles_SingleCurvePerPlot.select()
#                self.comboboxFontTitle_SingleCurvePerPlot._entryWidget['state']=NORMAL
                self.handlerRefreshYLabelSize_SingleCurvePerPlot(1)
            else:
                self.checkbuttonShowTitles_SingleCurvePerPlot.deselect()
#                self.comboboxFontTitle_SingleCurvePerPlot._entryWidget['state']=DISABLED
                self.handlerRefreshYLabelSize_SingleCurvePerPlot(0)
                
# ... single - individual plot titles font
            self.comboboxFontTitle_SingleCurvePerPlot.setentry(
                self.dictSingleCurvePerChartPlotParams['fontsizeTitle']
                )
                
# ... single - show grids
            if self.dictSingleCurvePerChartPlotParams['showGrids']:
                self.checkbuttonShowGrid_SingleCurvePerPlot.select()
            else:
                self.checkbuttonShowGrid_SingleCurvePerPlot.deselect()
                
# ...  single - x-y labels
#            self.comboboxFontLabels_SingleCurvePerPlot._entryWidget['state'] = NORMAL
            self.comboboxFontLabels_SingleCurvePerPlot.setentry(
                self.dictSingleCurvePerChartPlotParams['fontsizeXYLabels']
                )
#            self.comboboxColorLabels_SingleCurvePerPlot._entryWidget['state'] = NORMAL
            self.comboboxColorLabels_SingleCurvePerPlot.setentry(
                self.dictSingleCurvePerChartPlotParams['colorXYLabels']
                )
                
# ... single - x-ticks size and color - disable
#            self.comboboxFontXTicks_SingleCurvePerPlot._entryWidget['state'] = NORMAL
            self.comboboxFontXTicks_SingleCurvePerPlot.setentry(
                self.dictSingleCurvePerChartPlotParams['fontsizeXTicks']
                )
#            self.comboboxColorXTicks_SingleCurvePerPlot._entryWidget['state'] = NORMAL
            self.comboboxColorXTicks_SingleCurvePerPlot.setentry(
                self.dictSingleCurvePerChartPlotParams['colorXTicks']
                )
                
# ... single - y-ticks size and color - disable
#            self.comboboxFontYTicks_SingleCurvePerPlot._entryWidget['state'] = NORMAL
            self.comboboxFontYTicks_SingleCurvePerPlot.setentry(
                self.dictSingleCurvePerChartPlotParams['fontsizeYTicks']
                )
#            self.comboboxColorYTicks_SingleCurvePerPlot._entryWidget['state'] = NORMAL
            self.comboboxColorYTicks_SingleCurvePerPlot.setentry(
                self.dictSingleCurvePerChartPlotParams['colorYTicks']
                )
                
# ...  single - background color
            self.comboboxColorBackground_SingleCurvePerPlot.setentry(
                self.dictSingleCurvePerChartPlotParams['colorChartBackground']
                )
                
# ... single - border color
            self.comboboxColorBorder_SingleCurvePerPlot.setentry(
                self.dictSingleCurvePerChartPlotParams['colorPlotBorder']
                )
                
# ... single - xy-labels, x-ticks, y-ticks fonts and colors; background color
            self.handlerRefreshColors_SingleCurvePerPlot(1)
          
# ------------  all -------------
            self.dictMultiCurvePerChartPlotParams = \
                copy.deepcopy(self.dictMultiCurvePerChartPlotParams_Defaults)
            
# ... all - show titles
            self.checkbuttonShowTitle_AllCurvesOnePlot.configure(state='disabled')
            if self.dictMultiCurvePerChartPlotParams['showTitle']:
                self.checkbuttonShowTitle_AllCurvesOnePlot.select()
            else:
                self.checkbuttonShowTitle_AllCurvesOnePlot.deselect()

# ... all - show title
            self.varEntryShowTitle_AllCurvesOnePlot.set('')
            self.entryShowTitle_AllCurvesOnePlot.configure(state='disabled')
            
# ... all - title font
            self.comboboxFontTitle_AllCurvesOnePlot.setentry(
                self.dictMultiCurvePerChartPlotParams['fontsizeTitle']
                )
            self.comboboxFontTitle_AllCurvesOnePlot._entryWidget['state'] = DISABLED
            
# ... all - title color
            self.comboboxColorTitle_AllCurvesOnePlot.setentry(
                self.dictMultiCurvePerChartPlotParams['colorTitle']
                )
            self.comboboxColorTitle_AllCurvesOnePlot._entryWidget['state'] = DISABLED
            
# ... all - show y label
            self.checkbuttonShowLabelY_AllCurvesOnePlot.deselect()
            self.checkbuttonShowLabelY_AllCurvesOnePlot.configure(state='disabled')
            self.varShowLabelY_AllCurvesOnePlot.set('')
            self.entryShowLabelY_AllCurvesOnePlot.configure(state='disabled')
            
# ... all - show x label
            self.checkbuttonShowLabelX_AllCurvesOnePlot.select()
            self.checkbuttonShowLabelX_AllCurvesOnePlot.configure(state='disabled')
            
# ...   account for fact that self.headerNames_X[0] may not be defined if no values have been selected in Table or Buffer
            '''
            try:
                self.varShowLabelX_AllCurvesOnePlot.set(self.headerNames_X[0])
            except:
                self.varShowLabelX_AllCurvesOnePlot.set('')
            '''
#            self.entryShowLabelX_AllCurvesOnePlot.configure(state='disabled')
            
# ... all - xy-labels font size
            self.comboboxFontXYLabels_AllCurvesOnePlot.setentry(
                self.dictMultiCurvePerChartPlotParams['fontsizeXYLabels']
                )
            self.comboboxFontXYLabels_AllCurvesOnePlot._entryWidget['state'] = DISABLED
            
# ... all - xy-labels color
#            self.comboboxColorXYLabels_AllCurvesOnePlot.setvalue('black')
#            self.comboboxColorXYLabels_AllCurvesOnePlot._entryWidget['state'] = DISABLED
            self.handlerRefreshXYLabelsColor_AllCurvesOnOnePlot(0)
            self.comboboxColorXYLabels_AllCurvesOnePlot.setentry(
                self.dictMultiCurvePerChartPlotParams['colorXYLabels']
                )
                
# ... all - show legend
            self.checkbuttonShowLegend_AllCurvesOnePlot.configure(state='disabled')  
            if self.dictMultiCurvePerChartPlotParams['showLegend']:
                self.checkbuttonShowLegend_AllCurvesOnePlot.select()
            else:
                self.checkbuttonShowLegend_AllCurvesOnePlot.deselect()
            self.comboboxShowLegendLocation_AllCurvesOnePlot.selectitem(self.legendLocations[0]) 
            self.comboboxShowLegendLocation_AllCurvesOnePlot._entryWidget['state']=DISABLED
            self.comboboxFontLegend_AllCurvesOnePlot.setentry(
                self.dictMultiCurvePerChartPlotParams['fontsizeLegend']
                )
            self.comboboxFontLegend_AllCurvesOnePlot._entryWidget['state']=DISABLED
            
# ... all - show grid
            self.checkbuttonShowGrid_AllCurvesOnePlot.configure(state='disabled')
            if self.dictMultiCurvePerChartPlotParams['showGrid']:
                self.checkbuttonShowGrid_AllCurvesOnePlot.select()
            else:
                self.checkbuttonShowGrid_AllCurvesOnePlot.deselect()
                
# ... all - show reference curve
            self.checkbuttonShowReferenceCurve_AllCurvesOnePlot.configure(state='disabled')
            
# ...       to initialize...
            if self.dictMultiCurvePerChartPlotParams['showReferenceCurve']:   
                self.checkbuttonShowReferenceCurve_AllCurvesOnePlot.select()
            else:
                self.checkbuttonShowReferenceCurve_AllCurvesOnePlot.deselect()
            self.comboboxShowReferenceCurveMultiplier_AllCurvesOnePlot.selectitem(self.multipliersReferenceCurve[4])   
            self.comboboxShowReferenceCurveMultiplier_AllCurvesOnePlot._entryWidget['state']=DISABLED
            
# ... set x value
            try:
                self.comboboxShowLabelX_AllCurvesOnePlot.setentry(
                    (self.headerNames_X_Table + self.headerNames_X_Buffer)[0]
                    )
            except:
                self.comboboxShowLabelX_AllCurvesOnePlot.setentry('')
                
# ... set y value
            try:
                self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot.setentry(
                    (self.headerNames_Y_Table + self.headerNames_Y_Buffer)[0]
                    )
            except:
                self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot.setentry('')
            self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot._entryWidget['state']=DISABLED
            
# ...       update reference curve list and X labels
#           self.handlerRefreshReferenceCurveList(0, 'single')
            self.handlerRefreshReferenceCurveList()         
            
# ... all - show sloped straight line reference curve
            self.checkbuttonShowSlopedStraightReferenceCurve_AllCurvesOnePlot.configure(state='disabled')
            self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xinitial.configure(entry_state='disabled')
            self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xfinal.configure(entry_state='disabled')
            self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yinitial.configure(entry_state='disabled')
            self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yfinal.configure(entry_state='disabled')
            self.checkbuttonLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot.configure(state='disabled')
            self.entryfieldLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot.configure(entry_state='disabled')
            self.checkbuttonLabelSlopeDegreesSlopedStraightReferenceCurve_AllCurvesOnePlot.configure(state='disabled')
# ...     set values
            self.varCheckbuttonLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot.set(1)
            self.entryfieldLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot.setentry('s-ref line')
            
# ... all - show horizontal straight line reference curve
            self.checkbuttonShowHorizontalStraightReferenceCurve_AllCurvesOnePlot.configure(state='disabled')
            self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xinitial.configure(entry_state='disabled')
            self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xfinal.configure(entry_state='disabled')
            self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Y.configure(entry_state='disabled')
            self.checkbuttonLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot.configure(state='disabled')
            self.entryfieldLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot.configure(entry_state='disabled')
            self.checkbuttonLabelYMaxHorizontalStraightReferenceCurve_AllCurvesOnePlot.configure(state='disabled')
# ...     set values
            self.varCheckbuttonLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot.set(1)
            self.entryfieldLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot.setentry('h-ref line')

# ... all - show vertical straight line reference curve
            self.checkbuttonShowVerticalStraightReferenceCurve_AllCurvesOnePlot.configure(state='disabled')
            self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yinitial.configure(entry_state='disabled')
            self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yfinal.configure(entry_state='disabled')
            self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_X.configure(entry_state='disabled')
            self.checkbuttonLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot.configure(state='disabled')
            self.entryfieldLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot.configure(entry_state='disabled')
            self.checkbuttonLabelXMaxVerticalStraightLineReferenceCurve_AllCurvesOnePlot.configure(state='disabled')
# ...     set values
            self.varCheckbuttonLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot.set(1)
            self.entryfieldLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot.setentry('v-ref line')

# ... plot x-y from file
            self.checkbuttonPlotCsvFileData_AllCurvesOnePlot.configure(state='disabled')
            self.entryPlotCsvFileData_AllCurvesOnePlot.configure(state='disabled')
            self.comboboxPlotCsvFileData_X_Column_AllCurvesOnePlot._entryWidget['state']=DISABLED
            self.comboboxPlotCsvFileData_Y_Column_AllCurvesOnePlot._entryWidget['state']=DISABLED
            
# ... x-ticks size and color
            self.comboboxFontXTicks_AllCurvesOnePlot._entryWidget['state'] = DISABLED
            self.comboboxFontXTicks_AllCurvesOnePlot.setentry(
                self.dictMultiCurvePerChartPlotParams['fontsizeXTicks']
                )
#            self.comboboxColorXTicks_AllCurvesOnePlot._entryWidget['state'] = DISABLED
#            self.comboboxColorXTicks_AllCurvesOnePlot.setentry(
#                self.dictMultiCurvePerChartPlotParams['colorXTicks']
#                )

# ... y-ticks size and color
            self.comboboxFontYTicks_AllCurvesOnePlot._entryWidget['state'] = DISABLED
            self.comboboxFontYTicks_AllCurvesOnePlot.setentry(
                self.dictMultiCurvePerChartPlotParams['fontsizeYTicks']
                )
#            self.comboboxColorYTicks_AllCurvesOnePlot._entryWidget['state'] = DISABLED
#            self.comboboxColorYTicks_AllCurvesOnePlot.setentry(
#                self.dictMultiCurvePerChartPlotParams['colorYTicks']
#                )

# x-ticks color, y-ticks color, and chart background color
            self.handlerRefreshColors_AllCurvesOnOnePlot(0)
#            self.comboboxColorBackground_AllCurvesOnePlot._entryWidget['state'] = DISABLED
            self.comboboxColorBackground_AllCurvesOnePlot.setentry(
                self.dictMultiCurvePerChartPlotParams['colorBackground']
                )
            self.comboboxColorBorder_AllCurvesOnePlot.setentry(
                self.dictMultiCurvePerChartPlotParams['colorPlotBorder']
                )
            self.comboboxColorXTicks_AllCurvesOnePlot.setentry(
                self.dictMultiCurvePerChartPlotParams['colorXTicks']
                )
            self.comboboxColorYTicks_AllCurvesOnePlot.setentry(
                self.dictMultiCurvePerChartPlotParams['colorYTicks']
                )
                
#------------------------------
                
# Now call plot labeling methods
# ... if 'Plot single curve per plot' is selected
        if self.varCurvesSelection.get().strip() == 'single':
            self.labels_SingleCurvePerPlot(
                self.labels_xWindowLocationSingle,
                self.labels_yWindowLocationSingle
                )
                
# ... if 'Plot all curves on one plot' is selected
        elif self.varCurvesSelection.get().strip() == 'all':
            self.labels_AllCurvesOnePlot(
                self.labels_xWindowLocationAll,
                self.labels_yWindowLocationAll
                )
                
        else:
            stringErrorCurvesSelection = (
                'Variable undefined for curve selection:\n\n' +
                '     self.varCurvesSelection = ' + self.varCurvesSelection.get().strip() + '\n\n' +
                'in\n\n' +
                MODULE + '/' + 'handlerXYPlotPreprocess\n\n' +
                'Pls correct this code error. Stopping...'
                )
            showerror(
                'Error: undefined value',
                stringErrorCurvesSelection
                )
            sys.exit()
        
        return
        
        
    def handlerRefreshMainTitleSize_SingleCurvePerPlot(self,active):
        '''
        Purpose:
            active=0: Makes widget look grayed out
            active=1: Makes widget look black on white
            
        Notes:
            This widget is always disabled from user input. User cannot
            put just any size in the column since error handling for invalid
            sizes is difficult in matplotlib
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerRefreshMainTitleSize_SingleCurvePerPlot')
            
# set widget label color to match window background color   
        color_bg_label = 'lightblue'
# gather current size; reinstate before leaving this method     
        size_mainTitle = self.comboboxFontMainTitle_SingleCurvePerPlot.get()
        color_mainTitle = self.comboboxColorMainTitle_SingleCurvePerPlot.get()
        
        if active == 0:
# active = 0: make widget look grayed out
# ... title font
            self.comboboxFontMainTitle_SingleCurvePerPlot = Pmw.ComboBox(
                self.frame_35,
                scrolledlist_items=self.fontsizesChartTitle,
                listheight=150,
                label_text='size:',
                label_background=color_bg_label,
                labelpos='w',
                entry_width=5,
                entry_state='disabled',
                scrolledlist_hull_width=500,
                )
            self.comboboxFontMainTitle_SingleCurvePerPlot.grid(
                row=0,
                column=3,
                padx=5,
                pady=1,
                sticky=W,
                )        
                
# ...   main title color
            self.comboboxColorMainTitle_SingleCurvePerPlot = Pmw.ComboBox(
                self.frame_35,
                scrolledlist_items=self.colorsChartLabels,
                listheight=150,
                label_text='color:',
                label_background=color_bg_label,
                labelpos='w',
                entry_width=10,
                entry_state='disabled',
                scrolledlist_hull_width=500,
                )
            self.comboboxColorMainTitle_SingleCurvePerPlot.grid(
                row=0,
                column=4,
                padx=5,
                pady=1,
                sticky=W,
                )
        
        elif active == 1:
# active = 1: make widgets look black on white
            color_bg = 'white'
            color_fg = 'black'
            
            self.comboboxFontMainTitle_SingleCurvePerPlot = Pmw.ComboBox(
                self.frame_35,
                scrolledlist_items=self.fontsizesChartTitle,
                listheight=150,
                label_text='size:',
                label_background=color_bg_label,
                labelpos='w',
                entry_width=5,
                entry_state='disabled',
                entry_disabledbackground=color_bg,
                entry_disabledforeground=color_fg,
                scrolledlist_hull_width=500,
                )
            self.comboboxFontMainTitle_SingleCurvePerPlot.grid(
                row=0,
                column=3,
                padx=5,
                pady=1,
                sticky=W,
                )  

# ...   main title color
            self.comboboxColorMainTitle_SingleCurvePerPlot = Pmw.ComboBox(
                self.frame_35,
                scrolledlist_items=self.colorsChartLabels,
                listheight=150,
                label_text='color:',
                label_background=color_bg_label,
                labelpos='w',
                entry_width=10,
                entry_state='disabled',
                entry_disabledbackground=color_bg,
                entry_disabledforeground=color_fg,
                scrolledlist_hull_width=500,
                )
            self.comboboxColorMainTitle_SingleCurvePerPlot.grid(
                row=0,
                column=4,
                padx=5,
                pady=1,
                sticky=W,
                )                
        
        else:
# wrong value for active
            stringErrorActive = (
                'Invalid value for the paramenter "active" in\n' +
                'method handlerRefreshMainTitleSize_SingleCurvePerPlot.\n\n' +
                '     active = %s\n\n' +
                'where "active" should be either 0 or 1\n\n' +
                'This is a coding error. Contact code administrator\n' +
                'to get this corrected.\n\n'
                )
            print stringErrorActive
            self.MySQL_Output(
                0,
                stringErrorActive
                )
            showerror(
                'Error: invalid value',
                stringErrorActive
                )
            return  

# reinstate sizes and colors before leaving this method     
        self.comboboxFontMainTitle_SingleCurvePerPlot.setentry(size_mainTitle)
        self.comboboxColorMainTitle_SingleCurvePerPlot.setentry(color_mainTitle)
        
        return
        
        
        
    def handlerRefreshYLabelSize_SingleCurvePerPlot(self,active):
        '''
        Purpose:
            active=0: Makes widget look grayed out
            active=1: Makes widget look black on white
            
        Notes:
            This widget is always disabled from user input. User cannot
            put just any size in the column since error handling for invalid
            sizes is difficult in matplotlib
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerRefreshYLabelSize_SingleCurvePerPlot')
            
# set widget label color to match window background color   
        color_bg_label = 'lightblue'
# gather current size; reinstate before leaving this method     
        size_ylabel = self.comboboxFontTitle_SingleCurvePerPlot.get()
        
        if active == 0:
# active = 0: make widget look grayed out
# ... title font
            self.comboboxFontTitle_SingleCurvePerPlot = Pmw.ComboBox(
                self.frame_40,
                scrolledlist_items=self.fontsizesChartTitle,
                listheight=150,
                label_text='size:',
                label_background=color_bg_label,
                labelpos='w',
                entry_width=5,
                entry_state='disabled',
                scrolledlist_hull_width=500,
                )
            self.comboboxFontTitle_SingleCurvePerPlot.grid(
                row=0,
                column=2,
                padx=5,
                pady=1,
                sticky=W,
                )        
        
        elif active == 1:
# active = 1: make widgets look black on white
            color_bg = 'white'
            color_fg = 'black'
            
            self.comboboxFontTitle_SingleCurvePerPlot = Pmw.ComboBox(
                self.frame_40,
                scrolledlist_items=self.fontsizesChartTitle,
                listheight=150,
                label_text='size:',
                label_background=color_bg_label,
                labelpos='w',
                entry_width=5,
                entry_state='disabled',
                entry_disabledbackground=color_bg,
                entry_disabledforeground=color_fg,
                scrolledlist_hull_width=500,
                )
            self.comboboxFontTitle_SingleCurvePerPlot.grid(
                row=0,
                column=2,
                padx=5,
                pady=1,
                sticky=W,
                )                
        
        else:
# wrong value for active
            stringErrorActive = (
                'Invalid value for the paramenter "active" in\n' +
                'method handlerRefreshXYLabelsColor_AllCurvesOnOnePlot.\n\n' +
                '     active = %s\n\n' +
                'where "active" should be either 0 or 1\n\n' +
                'This is a coding error. Contact code administrator\n' +
                'to get this corrected.\n\n'
                )
            print stringErrorActive
            self.MySQL_Output(
                0,
                stringErrorActive
                )
            showerror(
                'Error: invalid value',
                stringErrorActive
                )
            return  

# reinstate sizes and colors before leaving this method     
        self.comboboxFontTitle_SingleCurvePerPlot.setentry(size_ylabel)
        
        return
        
        
    def handlerRefreshColors_SingleCurvePerPlot(self,active):
        '''
        Purpose:
            active=0: Makes widget look grayed out
            active=1: Makes widget look black on white
            
        Notes:
            These widgets are always disabled from user input. User cannot
            put just any color in the column since error handling for invalid
            colors is difficult in matplotlib
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerRefreshColors_SingleCurvePerPlot\n')
            
# set widget label color to match window background color   
        color_bg_label = 'lightblue'
# gather current sizes and colors; reinstate before leaving this method
        size_labels = self.comboboxFontLabels_SingleCurvePerPlot.get()
        size_xticks = self.comboboxFontXTicks_SingleCurvePerPlot.get()
        size_yticks = self.comboboxFontYTicks_SingleCurvePerPlot.get()
        color_labels = self.comboboxColorLabels_SingleCurvePerPlot.get()
        color_xticks = self.comboboxColorXTicks_SingleCurvePerPlot.get()
        color_yticks = self.comboboxColorYTicks_SingleCurvePerPlot.get()
        color_background = self.comboboxColorBackground_SingleCurvePerPlot.get()
        color_border = self.comboboxColorBorder_SingleCurvePerPlot.get()
        
        
        if active == 0:
# active = 0: make widget look grayed out
# xy-label font sizes, single plots
            self.comboboxFontLabels_SingleCurvePerPlot = Pmw.ComboBox(
                self.frame_40b,
                scrolledlist_items=self.fontsizesChartLabels,
                listheight=160,
                entry_width=5,
                entry_state='disabled',
                scrolledlist_hull_width=500,
                )
            self.comboboxFontLabels_SingleCurvePerPlot.grid(
                row=0,
                column=1,
                padx=5,
                pady=0,
                sticky=E,
                )
# xy-label color, single plots
            self.comboboxColorLabels_SingleCurvePerPlot = Pmw.ComboBox(
                self.frame_40b,
                scrolledlist_items=self.colorsChartLabels,
                listheight=150,
                label_text='color:',
                label_background=color_bg_label,
                labelpos='w',
                entry_width=10,
                entry_state='disabled',
                scrolledlist_hull_width=500,
                )
            self.comboboxColorLabels_SingleCurvePerPlot.grid(
                row=0,
                column=2,
                padx=5,
                pady=0,
                sticky=E,
                )
# x-tick size
            self.comboboxFontXTicks_SingleCurvePerPlot = Pmw.ComboBox(
                self.frame_40b,
                scrolledlist_items=self.fontsizesTickX,
                listheight=160,
#            label_text='X-Ticks size:',
#            label_background=colorbg,
#            labelpos='w',
                entry_width=5,
                entry_state='disabled',
                scrolledlist_hull_width=500,
                )
            self.comboboxFontXTicks_SingleCurvePerPlot.grid(
                row=1,
                column=1,
                padx=5,
                pady=0,
                sticky=E,
                )
# x-tick color
            self.comboboxColorXTicks_SingleCurvePerPlot = Pmw.ComboBox(
                self.frame_40b,
                scrolledlist_items=self.colorsTickX,
                listheight=150,
                label_text='color:',
                label_background=color_bg_label,
                labelpos='w',
                entry_width=10,
                entry_state='disabled',
                scrolledlist_hull_width=500,
                )
            self.comboboxColorXTicks_SingleCurvePerPlot.grid(
                row=1,
                column=2,
                padx=5,
                pady=0,
                sticky=E,
                )
# y-tick size
            self.comboboxFontYTicks_SingleCurvePerPlot = Pmw.ComboBox(
                self.frame_40b,
                scrolledlist_items=self.fontsizesTickY,
                listheight=160,
                entry_width=5,
                entry_state='disabled',
                scrolledlist_hull_width=500,
                )
            self.comboboxFontYTicks_SingleCurvePerPlot.grid(
                row=2,
                column=1,
                padx=5,
                pady=0,
                sticky=E,
                )
# y-tick color
            self.comboboxColorYTicks_SingleCurvePerPlot = Pmw.ComboBox(
                self.frame_40b,
                scrolledlist_items=self.colorsTickY,
                listheight=150,
                label_text='color:',
                label_background=color_bg_label,
                labelpos='w',
                entry_width=10,
                entry_state='disabled',
                scrolledlist_hull_width=500,
                )
            self.comboboxColorYTicks_SingleCurvePerPlot.grid(
                row=2,
                column=2,
                padx=5,
                pady=0,
                sticky=E,
                )
# chart background color
            self.comboboxColorBackground_SingleCurvePerPlot = Pmw.ComboBox(
                self.frame_40b,
                scrolledlist_items=self.colorsChartBackground,
                listheight=150,
                label_text='Background color:',
                label_background=color_bg_label,
                entry_state='disabled',
                labelpos='w',
                entry_width=10,
                scrolledlist_hull_width=500,
                )
            self.comboboxColorBackground_SingleCurvePerPlot.grid(
                row=0,
                column=3,
                columnspan=1,
                padx=5,
                pady=0,
                sticky=E,
                )
# chart border color
            self.comboboxColorBorder_SingleCurvePerPlot = Pmw.ComboBox(
                self.frame_40b,
                scrolledlist_items=self.colorsChartBackground,
                listheight=150,
                label_text='Border color:',
                label_background=color_bg_label,
                entry_state='disabled',
                labelpos='w',
                entry_width=10,
                scrolledlist_hull_width=500,
                )
            self.comboboxColorBorder_SingleCurvePerPlot.grid(
                row=1,
                column=3,
                columnspan=1,
                padx=5,
                pady=0,
                sticky=E,
                )
        
        elif active == 1:
# active = 1: make widgets look black on white
            color_bg = 'white'
            color_fg = 'black'   

# xy-label font sizes, single plots
            self.comboboxFontLabels_SingleCurvePerPlot = Pmw.ComboBox(
                self.frame_40b,
                scrolledlist_items=self.fontsizesChartLabels,
                listheight=160,
                entry_width=5,
                entry_state='disabled',
                entry_disabledbackground=color_bg,
                entry_disabledforeground=color_fg,
                scrolledlist_hull_width=500,
                )
            self.comboboxFontLabels_SingleCurvePerPlot.grid(
                row=0,
                column=1,
                padx=5,
                pady=0,
                sticky=E,
                )
# xy-label color, single plots
            self.comboboxColorLabels_SingleCurvePerPlot = Pmw.ComboBox(
                self.frame_40b,
                scrolledlist_items=self.colorsChartLabels,
                listheight=150,
                label_text='color:',
                label_background=color_bg_label,
                labelpos='w',
                entry_width=10,
                entry_state='disabled',
                entry_disabledbackground=color_bg,
                entry_disabledforeground=color_fg,
                scrolledlist_hull_width=500,
                )
            self.comboboxColorLabels_SingleCurvePerPlot.grid(
                row=0,
                column=2,
                padx=5,
                pady=0,
                sticky=E,
                )
# x-tick size
            self.comboboxFontXTicks_SingleCurvePerPlot = Pmw.ComboBox(
                self.frame_40b,
                scrolledlist_items=self.fontsizesTickX,
                listheight=160,
#            label_text='X-Ticks size:',
#            label_background=colorbg,
#            labelpos='w',
                entry_width=5,
                entry_state='disabled',
                entry_disabledbackground=color_bg,
                entry_disabledforeground=color_fg,
                scrolledlist_hull_width=500,
                )
            self.comboboxFontXTicks_SingleCurvePerPlot.grid(
                row=1,
                column=1,
                padx=5,
                pady=0,
                sticky=E,
                )
# x-tick color
            self.comboboxColorXTicks_SingleCurvePerPlot = Pmw.ComboBox(
                self.frame_40b,
                scrolledlist_items=self.colorsTickX,
                listheight=150,
                label_text='color:',
                label_background=color_bg_label,
                labelpos='w',
                entry_width=10,
                entry_state='disabled',
                entry_disabledbackground=color_bg,
                entry_disabledforeground=color_fg,
                scrolledlist_hull_width=500,
                )
            self.comboboxColorXTicks_SingleCurvePerPlot.grid(
                row=1,
                column=2,
                padx=5,
                pady=0,
                sticky=E,
                )
# y-tick size
            self.comboboxFontYTicks_SingleCurvePerPlot = Pmw.ComboBox(
                self.frame_40b,
                scrolledlist_items=self.fontsizesTickY,
                listheight=160,
                entry_width=5,
                entry_state='disabled',
                entry_disabledbackground=color_bg,
                entry_disabledforeground=color_fg,
                scrolledlist_hull_width=500,
                )
            self.comboboxFontYTicks_SingleCurvePerPlot.grid(
                row=2,
                column=1,
                padx=5,
                pady=0,
                sticky=E,
                )
# y-tick color
            self.comboboxColorYTicks_SingleCurvePerPlot = Pmw.ComboBox(
                self.frame_40b,
                scrolledlist_items=self.colorsTickY,
                listheight=150,
                label_text='color:',
                label_background=color_bg_label,
                labelpos='w',
                entry_width=10,
                entry_state='disabled',
                entry_disabledbackground=color_bg,
                entry_disabledforeground=color_fg,
                scrolledlist_hull_width=500,
                )
            self.comboboxColorYTicks_SingleCurvePerPlot.grid(
                row=2,
                column=2,
                padx=5,
                pady=0,
                sticky=E,
                )
# chart background color
            self.comboboxColorBackground_SingleCurvePerPlot = Pmw.ComboBox(
                self.frame_40b,
                scrolledlist_items=self.colorsChartBackground,
                listheight=150,
                label_text='Background color:',
                label_background=color_bg_label,
                entry_state='disabled',
                entry_disabledbackground=color_bg,
                entry_disabledforeground=color_fg,
                labelpos='w',
                entry_width=10,
                scrolledlist_hull_width=500,
                )
            self.comboboxColorBackground_SingleCurvePerPlot.grid(
                row=0,
                column=3,
                columnspan=1,
                padx=5,
                pady=0,
                sticky=E,
                )    
# chart border color
            self.comboboxColorBorder_SingleCurvePerPlot = Pmw.ComboBox(
                self.frame_40b,
                scrolledlist_items=self.colorsChartBackground,
                listheight=150,
                label_text='Border color:',
                label_background=color_bg_label,
                entry_state='disabled',
                entry_disabledbackground=color_bg,
                entry_disabledforeground=color_fg,
                labelpos='w',
                entry_width=10,
                scrolledlist_hull_width=500,
                )
            self.comboboxColorBorder_SingleCurvePerPlot.grid(
                row=1,
                column=3,
                columnspan=1,
                padx=5,
                pady=0,
                sticky=E,
                )                 
        
        else:
# wrong value for active
            stringErrorActive = (
                'Invalid value for the paramenter "active" in\n' +
                'method handlerRefreshXYLabelsColor_AllCurvesOnOnePlot.\n\n' +
                '     active = %s\n\n' +
                'where "active" should be either 0 or 1\n\n' +
                'This is a coding error. Contact code administrator\n' +
                'to get this corrected.\n\n'
                )
            print stringErrorActive
            self.MySQL_Output(
                0,
                stringErrorActive
                )
            showerror(
                'Error: invalid value',
                stringErrorActive
                )
            return  

# reinstate sizes and colors before leaving this method
        self.comboboxFontLabels_SingleCurvePerPlot.setentry(size_labels)
        self.comboboxFontXTicks_SingleCurvePerPlot.setentry(size_xticks)
        self.comboboxFontYTicks_SingleCurvePerPlot.setentry(size_yticks)
        self.comboboxColorLabels_SingleCurvePerPlot.setentry(color_labels)
        self.comboboxColorXTicks_SingleCurvePerPlot.setentry(color_xticks)
        self.comboboxColorYTicks_SingleCurvePerPlot.setentry(color_yticks)
        self.comboboxColorBackground_SingleCurvePerPlot.setentry(color_background)            
        self.comboboxColorBorder_SingleCurvePerPlot.setentry(color_border)            
        
        return

      
    def handlerRefreshXYLabelsColor_AllCurvesOnOnePlot(self,active):
        '''
        Purpose:
            active=0: Makes widget look grayed out
            active=1: Makes widget look black on white
            
        Notes:
            These widgets are always disabled from user input. User cannot
            put just any color in the column since error handling for invalid
            colors is difficult in matplotlib
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerRefreshXYLabelsColor_AllCurvesOnOnePlot\n')
            
# set widget label color to match window background color        
        color_bg_label = 'lightblue'
# gather current color; reinstate before leaving this method
        color_xylabels = self.comboboxColorXYLabels_AllCurvesOnePlot.get()
        
        if active == 0:
# active = 0: make widget look grayed out
# ... x-y label color    
            self.comboboxColorXYLabels_AllCurvesOnePlot = Pmw.ComboBox(
                self.frame_60,
                scrolledlist_items=self.colorsChartLabels,
                listheight=150,
                label_text='color:',
                label_background=color_bg_label,
                labelpos='w',
                entry_width=10,
                entry_state='disabled',
#                entry_disabledbackground=color_bg,
#                entry_disabledforeground=color_fg,
                scrolledlist_hull_width=500,
                )
            self.comboboxColorXYLabels_AllCurvesOnePlot.grid(
                row=1,
                rowspan=2,
                column=4,
                padx=0,
                pady=0,
                sticky=W,
                )
        
        elif active == 1:
# active = 1: make widget black on white to look active
#            print('     - blacking/whiting out widgets')
            color_bg = 'white'
            color_fg = 'black'
            
# ... x-y label color    
            self.comboboxColorXYLabels_AllCurvesOnePlot = Pmw.ComboBox(
                self.frame_60,
                scrolledlist_items=self.colorsChartLabels,
                listheight=150,
                label_text='color:',
                label_background=color_bg_label,
                labelpos='w',
                entry_width=10,
                entry_state='disabled',
                entry_disabledbackground=color_bg,
                entry_disabledforeground=color_fg,
                scrolledlist_hull_width=500,
                )
            self.comboboxColorXYLabels_AllCurvesOnePlot.grid(
                row=1,
                rowspan=2,
                column=4,
                padx=0,
                pady=0,
                sticky=W,
                )
        
        else:
# wrong value for active
            stringErrorActive = (
                'Invalid value for the paramenter "active" in\n' +
                'method handlerRefreshXYLabelsColor_AllCurvesOnOnePlot.\n\n' +
                '     active = %s\n\n' +
                'where "active" should be either 0 or 1\n\n' +
                'This is a coding error. Contact code administrator\n' +
                'to get this corrected.\n\n'
                )
            print stringErrorActive
            self.MySQL_Output(
                0,
                stringErrorActive
                )
            showerror(
                'Error: invalid value',
                stringErrorActive
                )
            return

# restore color value in widget            
        self.comboboxColorXYLabels_AllCurvesOnePlot.setentry(color_xylabels)
        
        return
        
        
    def handlerRefreshXYLabelsColor_AllCurvesOnOnePlot_Scatter(self):
        '''
        Purpose:
            make widget for label color for scatter plots look normal or disabled, depending
            on labelX and labelY checkbuttons
            
        Notes:
            These widgets are always disabled from user input. User cannot
            put just any color in the column since error handling for invalid
            colors is difficult in matplotlib
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerRefreshXYLabelsColor_AllCurvesOnOnePlot_Scatter\n')
        
        if (self.varCheckbuttonShowLabelY_AllCurvesOnePlot_Scatter.get() 
            or 
            self.varCheckbuttonShowLabelX_AllCurvesOnePlot_Scatter.get() 
            ):
            self.comboboxFontXYLabels_AllCurvesOnePlot_Scatter._entryWidget['state'] = NORMAL
            self.comboboxColorXYLabels_AllCurvesOnePlot_Scatter._entryWidget['disabledbackground'] = 'white'
            self.comboboxColorXYLabels_AllCurvesOnePlot_Scatter._entryWidget['disabledforeground'] = 'black'
        else:
            self.comboboxFontXYLabels_AllCurvesOnePlot_Scatter._entryWidget['state'] = DISABLED
            self.comboboxColorXYLabels_AllCurvesOnePlot_Scatter._entryWidget['disabledbackground'] = 'lightgray'
            self.comboboxColorXYLabels_AllCurvesOnePlot_Scatter._entryWidget['disabledforeground'] = '#777777'  # dark gray
        
        return
        
        
    def handlerRefreshColors_AllCurvesOnOnePlot(self,active):
        '''
        Purpose:
            active=0: Makes widget look grayed out
            active=1: Makes widget look black on white
            
        Notes:
            These widgets are always disabled from user input. User cannot
            put just any color in the column since error handling for invalid
            colors is difficult in matplotlib
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerRefreshColors_AllCurvesOnOnePlot\n')
            
# set widget label color to match window background color       
        color_bg_label = 'lightblue'
# gather current colors; reinstate before leaving this method
        color_xtick = self.comboboxColorXTicks_AllCurvesOnePlot.get()
        color_ytick = self.comboboxColorYTicks_AllCurvesOnePlot.get()
        color_background = self.comboboxColorBackground_AllCurvesOnePlot.get()
        color_border = self.comboboxColorBorder_AllCurvesOnePlot.get()
        
# active = 0: make widgets look grayed out
        if active == 0:
            color_bg = 'lightgray'
            color_fg = 'darkgray'
# x-tick color
            self.comboboxColorXTicks_AllCurvesOnePlot = Pmw.ComboBox(
                self.frame_80a,
                scrolledlist_items=self.colorsTickX,
                listheight=150,
                label_text='color:',
                label_background=color_bg_label,
                labelpos='w',
                entry_width=10,
                entry_state='disabled',
#                entry_disabledbackground=color_bg,
#                entry_disabledforeground=color_fg,
                scrolledlist_hull_width=500,
                )
            self.comboboxColorXTicks_AllCurvesOnePlot.grid(
                row=0,
                column=2,
                padx=5,
                pady=0,
                sticky=E,
                )

# y-tick color
            self.comboboxColorYTicks_AllCurvesOnePlot = Pmw.ComboBox(
                self.frame_80a,
                scrolledlist_items=self.colorsTickY,
                listheight=150,
                label_text='color:',
                label_background=color_bg_label,
                labelpos='w',
                entry_width=10,
                entry_state='disabled',
#                entry_disabledbackground=color_bg,
#                entry_disabledforeground=color_fg,
                scrolledlist_hull_width=500,
                )
            self.comboboxColorYTicks_AllCurvesOnePlot.grid(
                row=1,
                column=2,
                padx=5,
                pady=0,
                sticky=E,
                )

# chart background color
            self.comboboxColorBackground_AllCurvesOnePlot = Pmw.ComboBox(
                self.frame_80a,
                scrolledlist_items=self.colorsChartBackground,
                listheight=150,
                label_text='Background color:',
                label_background=color_bg_label,
                entry_state='disabled',
#                entry_disabledbackground=color_bg,
#                entry_disabledforeground=color_fg,
                labelpos='w',
                entry_width=10,
                scrolledlist_hull_width=500,
                )
            self.comboboxColorBackground_AllCurvesOnePlot.grid(
                row=0,
                column=3,
                columnspan=1,
                padx=5,
                pady=0,
                sticky=E,
                )
# chart border color
            self.comboboxColorBorder_AllCurvesOnePlot = Pmw.ComboBox(
                self.frame_80a,
                scrolledlist_items=self.colorsChartBackground,
                listheight=150,
                label_text='Border color:',
                label_background=color_bg_label,
                entry_state='disabled',
#                entry_disabledbackground=color_bg,
#                entry_disabledforeground=color_fg,
                labelpos='w',
                entry_width=10,
                scrolledlist_hull_width=500,
                )
            self.comboboxColorBorder_AllCurvesOnePlot.grid(
                row=1,
                column=3,
                columnspan=1,
                padx=5,
                pady=0,
                sticky=E,
                )

        elif active == 1:
# active = 1: make widgets look black on white
            color_bg = 'white'
            color_fg = 'black'
# x-tick color
            self.comboboxColorXTicks_AllCurvesOnePlot = Pmw.ComboBox(
                self.frame_80a,
                scrolledlist_items=self.colorsTickX,
                listheight=150,
                label_text='color:',
                label_background=color_bg_label,
                labelpos='w',
                entry_width=10,
                entry_state='disabled',
                entry_disabledbackground=color_bg,
                entry_disabledforeground=color_fg,
                scrolledlist_hull_width=500,
                )
            self.comboboxColorXTicks_AllCurvesOnePlot.grid(
                row=0,
                column=2,
                padx=5,
                pady=0,
                sticky=E,
                )

# y-tick color
            self.comboboxColorYTicks_AllCurvesOnePlot = Pmw.ComboBox(
                self.frame_80a,
                scrolledlist_items=self.colorsTickY,
                listheight=150,
                label_text='color:',
                label_background=color_bg_label,
                labelpos='w',
                entry_width=10,
                entry_state='disabled',
                entry_disabledbackground=color_bg,
                entry_disabledforeground=color_fg,
                scrolledlist_hull_width=500,
                )
            self.comboboxColorYTicks_AllCurvesOnePlot.grid(
                row=1,
                column=2,
                padx=5,
                pady=0,
                sticky=E,
                )

# chart background color
            self.comboboxColorBackground_AllCurvesOnePlot = Pmw.ComboBox(
                self.frame_80a,
                scrolledlist_items=self.colorsChartBackground,
                listheight=150,
                label_text='Background color:',
                label_background=color_bg_label,
                entry_state='disabled',
                entry_disabledbackground=color_bg,
                entry_disabledforeground=color_fg,
                labelpos='w',
                entry_width=10,
                scrolledlist_hull_width=500,
                )
            self.comboboxColorBackground_AllCurvesOnePlot.grid(
                row=0,
                column=3,
                columnspan=1,
                padx=5,
                pady=0,
                sticky=E,
                )
                
# chart border color
            self.comboboxColorBorder_AllCurvesOnePlot = Pmw.ComboBox(
                self.frame_80a,
                scrolledlist_items=self.colorsChartBackground,
                listheight=150,
                label_text='Border color:',
                label_background=color_bg_label,
                entry_state='disabled',
                entry_disabledbackground=color_bg,
                entry_disabledforeground=color_fg,
                labelpos='w',
                entry_width=10,
                scrolledlist_hull_width=500,
                )
            self.comboboxColorBorder_AllCurvesOnePlot.grid(
                row=1,
                column=3,
                columnspan=1,
                padx=5,
                pady=0,
                sticky=E,
                )


        else:
# wrong value for active
            stringErrorActive = (
                'Invalid value for the paramenter "active" in\n' +
                'method handlerRefreshColors_AllCurvesOnOnePlot.\n\n' +
                '     active = %s\n\n' +
                'where "active" should be either 0 or 1\n\n' +
                'This is a coding error. Contact code administrator\n' +
                'to get this corrected.\n\n'
                )
            print stringErrorActive
            self.MySQL_Output(
                0,
                stringErrorActive
                )
            showerror(
                'Error: invalid value',
                stringErrorActive
                )
            return
            
# restore color values in widgets            
        self.comboboxColorXTicks_AllCurvesOnePlot.setentry(color_xtick)
        self.comboboxColorYTicks_AllCurvesOnePlot.setentry(color_ytick)
        self.comboboxColorBackground_AllCurvesOnePlot.setentry(color_background)
        self.comboboxColorBorder_AllCurvesOnePlot.setentry(color_border)
        
        return
       
        
    def handlerRefreshReferenceCurveList(self):
        '''
        Purpose:
            Refresh the items list for the reference curve ComboBox widget
            
        Called by:
            handlerXYPlotPreprocess
            
        Parameters:
            existPreviously = 0 or 1
                if 1, X-Y Plot Specs window existed previously; 
                if 0, X-Y Plot Specs window did NOT exist previously
        '''        
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerRefreshReferenceCurveList\n')
        
#        print 'single_or_all, type(single_or_all) = %s, %s' % (single_or_all, type(single_or_all))

# determine if X-Y Plot Specs window exists            
        existPreviously = self.previousWindow_XY
        
        if existPreviously:
            if DEBUG_XY:
                print '\n X-Y Plot Specs window exists\n'
        else:
            if DEBUG_XY:
                print '\n X-Y Plot Specs window does not exist\n'
            
        single_or_all = self.varCurvesSelection.get()
            
        if (single_or_all <> 'single') and (single_or_all <> 'all'):
# existPreviously has the wrong value
            stringErrorSingleOrAll = (
                (
                'An error has occurred in the value indicating whether\n' +
                'the plotting "single" or "all" is checked in Plotting Specs:\n\n' +
                '    single_or_all = %s \n\n' +
                'Method: handlerRefreshReferenceCurveList'
                )
                % single_or_all
                )
            print '\n' + stringErrorSingleOrAll
            self.MySQL_Output(
                0,
                stringErrorSingleOrAll
                )
            showerror(
                'Error: invalid value',
                stringErrorSingleOrAll
                )
            return


        self.legendNamesForCurveLabeled = []
        self.listitemsShowLabelX_AllCurvesOnePlot = []
        
# get current curve name 
        if DEBUG_XY:
            print('\n\n...CurveLabeled = %s' % 
                self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot.get()
                )

        try:
            currentYCurveNameLabel = self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot.get()
        except:
            currentYCurveNameLabel = ''
            
        try:
            currentXCurveNameLabel = self.comboboxShowLabelX_AllCurvesOnePlot.get()
        except:
            currentXCurveNameLabel = ''
        
# check which widgets are checked
        if (self.varCheckbuttonTableData.get() and self.varCheckbuttonBufferData.get()):
            self.legendNamesForCurveLabeled = self.headerNames_Y_Table + self.headerNames_Y_Buffer
            self.listitemsShowLabelX_AllCurvesOnePlot = self.headerNames_X_Table + self.headerNames_X_Buffer
        elif (not self.varCheckbuttonTableData.get() and self.varCheckbuttonBufferData.get()):
            self.legendNamesForCurveLabeled = self.headerNames_Y_Buffer
            self.listitemsShowLabelX_AllCurvesOnePlot = self.headerNames_X_Buffer
        elif (self.varCheckbuttonTableData.get() and not self.varCheckbuttonBufferData.get()):
            self.legendNamesForCurveLabeled = self.headerNames_Y_Table
            self.listitemsShowLabelX_AllCurvesOnePlot = self.headerNames_X_Table
        else:
            self.legendNamesForCurveLabeled = []
            self.listitemsShowLabelX_AllCurvesOnePlot = []
            
# filter out duplicates in X list and sort, for drop-down menu in X-Y Plot Specs window
# ... assign list to dictionary (fastest way to sort in Python)
        tempDict={}
        for key in self.listitemsShowLabelX_AllCurvesOnePlot:
            tempDict[key] = None
# ... re-assign to original list
        self.listitemsShowLabelX_AllCurvesOnePlot = tempDict.keys()
# ... and sort
        self.listitemsShowLabelX_AllCurvesOnePlot.sort()
            
        if DEBUG_XY:
            print(
                'self.legendNamesForCurveLabeled for scrolledlist_items = %s' % self.legendNamesForCurveLabeled
                )
            print (
                'self.listitemsShowLabelX_AllCurvesOnePlot = %s' % self.listitemsShowLabelX_AllCurvesOnePlot
                )
            

            
# regraph Reference Curve widget with 'scrolledlist_items' based on checked widgets
        self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot = Pmw.ComboBox(
            self.frame_70,
            scrolledlist_items = self.legendNamesForCurveLabeled,
            listheight=100,
            entry_width=35,
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot.grid(
            row=0,
            column=4,
            padx=2,
            pady=0,
            sticky=W,
            )
            
# regraph Show X Label widget with 'scrolledlist_items' based on checked widgets
        self.comboboxShowLabelX_AllCurvesOnePlot = Pmw.ComboBox(
            self.frame_60,
            scrolledlist_items=self.listitemsShowLabelX_AllCurvesOnePlot,
            dropdown=1,
#            entry_state='normal',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            listheight=150,
            entry_width=20,
            entry_justify=LEFT,
            scrolledlist_hull_width=500,
            )
        self.comboboxShowLabelX_AllCurvesOnePlot.grid(
            row=2,
            column=2,
            padx=5,
            pady=0,
            sticky=W,
            ) 
# determine status of widgets:
             
        if existPreviously:
# if single, both widgets are disabled
            if single_or_all == 'single':
                self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot._entryWidget['state'] = DISABLED
                self.comboboxShowLabelX_AllCurvesOnePlot._entryWidget['state'] = DISABLED
            elif single_or_all == 'all':
# if 'Show X label' is not checked, widget is disabled
                if self.varCheckbuttonShowLabelX_AllCurvesOnePlot.get():
# ... enabled
                    self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot._entryWidget['state'] = NORMAL
                else:
# ... disabled
                    self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot._entryWidget['state'] = DISABLED
                    
                if self.varCheckbuttonShowReferenceCurve_AllCurvesOnePlot.get():
# ... enabled
                    self.comboboxShowLabelX_AllCurvesOnePlot._entryWidget['state'] = NORMAL
                else:
                    self.comboboxShowLabelX_AllCurvesOnePlot._entryWidget['state'] = DISABLED        
        
        elif not existPreviously:
# default values, both widgets are disabled
            self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot._entryWidget['state'] = DISABLED
            self.comboboxShowLabelX_AllCurvesOnePlot._entryWidget['state'] = DISABLED

# y label       
        matchYLabel = False
        for name in self.legendNamesForCurveLabeled:
            if DEBUG_XY:
                print('name = %s, currentYCurveNameLabel = %s' % (name, currentYCurveNameLabel))
            if name == currentYCurveNameLabel:
                try:
                    self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot.selectitem(name)
                    matchYLabel = True
                    break
                except:
                    pass
        
        if not matchYLabel:
            try:
                self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot.selectitem(
                    self.legendNamesForCurveLabeled[0]
                    )
            except:
                self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot.setentry('')
                
# x label               
        matchXLabel = False
        for name in self.listitemsShowLabelX_AllCurvesOnePlot:
            if DEBUG_XY:
                print('name = %s, currentXCurveNameLabel = %s' % (name, currentXCurveNameLabel))
            if name == currentXCurveNameLabel:
                try:
                    self.comboboxShowLabelX_AllCurvesOnePlot.selectitem(name)
                    matchXLabel = True
                    break
                except:
                    pass
                    
        if not matchXLabel:
            try:
                self.comboboxShowLabelX_AllCurvesOnePlot.selectitem(
                    self.listitemsShowLabelX_AllCurvesOnePlot[0]
                    )
            except:
                self.comboboxShowLabelX_AllCurvesOnePlot.setentry('')

 
        if DEBUG_XY:
            print '\n----------------\n'
        
        return
        
        
    def handlerRefreshReferenceCurveList_Scatter(self):
        '''
        Purpose:
            Refresh the items list for the reference curve ComboBox widget
            
        Called by:
            handlerScatterPlotPreprocess

        '''        
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerRefreshReferenceCurveList_Scatter\n')
        
        existPreviously = self.previousWindow_Scatter
        
        if DEBUG_REFRESHREFERENCECURVELIST_SCATTER:
            if existPreviously:
                print '\n Scatter Plot Specs window exists\n'
            else:
                print '\n Scatter Plot Specs window does not exist\n'

        self.legendNamesForCurveLabeled_Scatter = []
        self.listitemsShowLabelX_AllCurvesOnePlot_Scatter = []
        
# get current curve name      
        try:
            currentYCurveNameLabel = self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot_Scatter.get()
        except:
            currentYCurveNameLabel = ''
            
        try:
            currentXCurveNameLabel = self.comboboxShowLabelX_AllCurvesOnePlot_Scatter.get()
        except:
            currentXCurveNameLabel = ''
        
# check which widgets are checked
        if (self.varCheckbuttonTableData_Scatter.get() and self.varCheckbuttonBufferData_Scatter.get()):
            self.legendNamesForCurveLabeled_Scatter = self.headerNames_Y_Table_Scatter + self.headerNames_Y_Buffer_Scatter
            self.listitemsShowLabelX_AllCurvesOnePlot_Scatter = self.headerNames_X_Table_Scatter + self.headerNames_X_Buffer_Scatter
        elif (not self.varCheckbuttonTableData_Scatter.get() and self.varCheckbuttonBufferData_Scatter.get()):
            self.legendNamesForCurveLabeled_Scatter = self.headerNames_Y_Buffer_Scatter
            self.listitemsShowLabelX_AllCurvesOnePlot_Scatter = self.headerNames_X_Buffer_Scatter
        elif (self.varCheckbuttonTableData_Scatter.get() and not self.varCheckbuttonBufferData_Scatter.get()):
            self.legendNamesForCurveLabeled_Scatter = self.headerNames_Y_Table_Scatter
            self.listitemsShowLabelX_AllCurvesOnePlot_Scatter = self.headerNames_X_Table_Scatter
        else:
            self.legendNamesForCurveLabeled_Scatter = []
            self.listitemsShowLabelX_AllCurvesOnePlot_Scatter = []
            
# filter out duplicates in X list and sort, for drop-down menu in X-Y Plot Specs window
# ... assign list to dictionary (fastest way to sort in Python)
        tempDict={}
        for key in self.listitemsShowLabelX_AllCurvesOnePlot_Scatter:
            tempDict[key] = None
# ... re-assign to original list
        self.listitemsShowLabelX_AllCurvesOnePlot_Scatter = tempDict.keys()
# ... and sort
        self.listitemsShowLabelX_AllCurvesOnePlot_Scatter.sort()
            
        if DEBUG_REFRESHREFERENCECURVELIST_SCATTER:
            print(
                '\nself.legendNamesForCurveLabeled_Scatter for scrolledlist_items_Scatter = %s' 
                    % self.legendNamesForCurveLabeled_Scatter
                )
            print (
                '\nself.listitemsShowLabelX_AllCurvesOnePlot_Scatter = %s' 
                    % self.listitemsShowLabelX_AllCurvesOnePlot_Scatter
                )
            
# regraph Show X Label widget with 'scrolledlist_items' based on checked widgets
        self.comboboxShowLabelX_AllCurvesOnePlot_Scatter = Pmw.ComboBox(
            self.frame_60_Scatter,
            scrolledlist_items=self.listitemsShowLabelX_AllCurvesOnePlot_Scatter,
            dropdown=1,
#            entry_state='normal',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            listheight=150,
            entry_width=20,
            entry_justify=LEFT,
            scrolledlist_hull_width=500,
            )
        self.comboboxShowLabelX_AllCurvesOnePlot_Scatter.grid(
            row=2,
            column=2,
            padx=5,
            pady=0,
            sticky=W,
            ) 
       
# regraph Reference Curve widget with 'scrolledlist_items' based on checked widgets
        self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot_Scatter = Pmw.ComboBox(
            self.frame_70_Scatter,
            scrolledlist_items = self.legendNamesForCurveLabeled_Scatter,
            listheight=100,
            entry_width=35,
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot_Scatter.grid(
            row=0,
            column=4,
            padx=2,
            pady=0,
            sticky=W,
            )
            
# determine status of widgets:

# ... X label
        self.handlerShowLabelX_AllCurvesOnePlot_Scatter()
# ... reference curve
        self.handlerShowReferenceCurve_AllCurvesOnePlot_Scatter()
        
        
        '''
        if existPreviously:
# if 'Show X label' is not checked, widget is disabled
            if self.varCheckbuttonShowLabelX_AllCurvesOnePlot_Scatter.get():
# ... enabled
                self.comboboxShowLabelX_AllCurvesOnePlot_Scatter._entryWidget['state'] = NORMAL
            else:
# ... disabled
                self.comboboxShowLabelX_AllCurvesOnePlot_Scatter._entryWidget['state'] = DISABLED
                    
            if self.varCheckbuttonShowReferenceCurve_AllCurvesOnePlot_Scatter.get():
# ... enabled
                self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot_Scatter._entryWidget['state'] = NORMAL
            else:
# ... disabled
                self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot_Scatter._entryWidget['state'] = DISABLED
                
        
        elif not existPreviously:
        
            if self.varCheckbuttonShowLabelX_AllCurvesOnePlot_Scatter.get():
# ... enabled
                self.comboboxShowLabelX_AllCurvesOnePlot_Scatter._entryWidget['state'] = NORMAL
            else:
# ... disabled
                self.comboboxShowLabelX_AllCurvesOnePlot_Scatter._entryWidget['state'] = DISABLED
# ... enable or disable XY-label font size and color
            self.handlerShowLabelX_AllCurvesOnePlot_Scatter()
            
            if self.varCheckbuttonShowReferenceCurve_AllCurvesOnePlot_Scatter.get():
# ... enabled
                self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot_Scatter._entryWidget['state'] = NORMAL
            else:
# ... disabled
                self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot_Scatter._entryWidget['state'] = DISABLED
            '''
                
# y label       
        matchYLabel = False
        for name in self.legendNamesForCurveLabeled_Scatter:
            if DEBUG_REFRESHREFERENCECURVELIST_SCATTER:
                print '\nname = %s, currentYCurveNameLabel = %s' % (name, currentYCurveNameLabel)
            if name == currentYCurveNameLabel:
                try:
                    self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot_Scatter.selectitem(name)
                    matchYLabel = True
                    break
                except:
                    pass
        
        if not matchYLabel:
            try:
                self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot_Scatter.selectitem(
                    self.legendNamesForCurveLabeled_Scatter[0]
                    )
            except:
                self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot_Scatter.setentry('')
                
# x label               
        matchXLabel = False
        for name in self.listitemsShowLabelX_AllCurvesOnePlot_Scatter:
            if DEBUG_REFRESHREFERENCECURVELIST_SCATTER:
                print '\nname = %s, currentXCurveNameLabel = %s' % (name, currentXCurveNameLabel)
            if name == currentXCurveNameLabel:
                try:
                    self.comboboxShowLabelX_AllCurvesOnePlot_Scatter.selectitem(name)
                    matchXLabel = True
                    break
                except:
                    pass
                    
        if not matchXLabel:
            try:
                self.comboboxShowLabelX_AllCurvesOnePlot_Scatter.selectitem(
                    self.listitemsShowLabelX_AllCurvesOnePlot_Scatter[0]
                    )
            except:
                self.comboboxShowLabelX_AllCurvesOnePlot_Scatter.setentry('')

 
        if DEBUG_REFRESHREFERENCECURVELIST_SCATTER:
            print '\n----------------\n'
        
        return
        
        
    def destroyPlotPreprocess_XY(self):
        '''
        Purpose:
            close X-Y Plot Specs window and all related child windows
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'destroyPlotPreprocess_XY')
            
# kill main window
# ... but get location first
        try:
            self.plottingspecs_xWindowLocation_XY= self.toplevelXYPlotPreprocess.winfo_rootx() - self.offsetWindowX
            self.plottingspecs_yWindowLocation_XY= self.toplevelXYPlotPreprocess.winfo_rooty() - self.offsetWindowY
            self.toplevelXYPlotPreprocess.destroy()
        except:
            pass
            
# kill label window 
# ... but get location first        
        try:
            self.labels_xWindowLocationSingle = self.toplevelLabelsSinglePlotPerCurve.winfo_rootx() - self.offsetWindowX
            self.labels_yWindowLocationSingle = self.toplevelLabelsSinglePlotPerCurve.winfo_rooty() - self.offsetWindowY
            self.toplevelLabelsSinglePlotPerCurve.destroy()
        except:
            pass
            
# kill legend window 
# ... but get location first          
        try:
            self.labels_xWindowLocationAll = self.toplevelLegendLabelsAllCurvesOnePlot.winfo_rootx() - self.offsetWindowX
            self.labels_yWindowLocationAll = self.toplevelLegendLabelsAllCurvesOnePlot.winfo_rooty() - self.offsetWindowY
            self.toplevelLegendLabelsAllCurvesOnePlot.destroy()
        except:
            pass
            
        return
        
        
    def destroyPlotPreprocess_Scatter(self):
        '''
        Purpose:
            close Scatter Plot Specs window and all related child windows
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'destroyPlotPreprocess_Scatter')
            
# kill main window
# ... but get location first
        self.plottingspecs_xWindowLocation_Scatter= self.toplevelScatterPlotPreprocess.winfo_rootx() - self.offsetWindowX
        self.plottingspecs_yWindowLocation_Scatter= self.toplevelScatterPlotPreprocess.winfo_rooty() - self.offsetWindowY
        self.toplevelScatterPlotPreprocess.destroy()
        '''
        try:
            self.plottingspecs_xWindowLocation_Scatter= self.toplevelScatterPlotPreprocess.winfo_rootx() - self.offsetWindowX
            self.plottingspecs_yWindowLocation_Scatter= self.toplevelScatterPlotPreprocess.winfo_rooty() - self.offsetWindowY
            self.toplevelScatterPlotPreprocess.destroy()
        except:
            pass
        '''
            
# kill label window 
# ... but get location first        
#        try:
#            self.labels_xWindowLocationSingle_Scatter = self.toplevelLabelsSinglePlotPerCurve_Scatter.winfo_rootx() - self.offsetWindowX
#            self.labels_yWindowLocationSingle_Scatter = self.toplevelLabelsSinglePlotPerCurve_Scatter.winfo_rooty() - self.offsetWindowY
#            self.toplevelLabelsSinglePlotPerCurve_Scatter.destroy()
#        except:
#            pass
            
# kill legend window 
# ... but get location first          
        try:
            self.labels_xWindowLocationAll_Scatter = self.toplevelLegendLabelsAllCurvesOnePlot_Scatter.winfo_rootx() - self.offsetWindowX
            self.labels_yWindowLocationAll_Scatter = self.toplevelLegendLabelsAllCurvesOnePlot_Scatter.winfo_rooty() - self.offsetWindowY
            self.toplevelLegendLabelsAllCurvesOnePlot_Scatter.destroy()
        except:
            pass
            
        return
        
        
    def destroyPlotPreprocess_Kiviat(self):
        '''
        Purpose:
            close Kiviat Plotting Specs window and all related child windows
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'destroyPlotPreprocess_Kiviat')
            
# kill main window
# ... but get location first
        try:
            self.plottingspecs_xWindowLocation_Kiviat = self.toplevelKiviatPlotPreprocess.winfo_rootx() - self.offsetWindowX
            self.plottingspecs_yWindowLocation_Kiviat = self.toplevelKiviatPlotPreprocess.winfo_rooty() - self.offsetWindowY
            self.toplevelKiviatPlotPreprocess.destroy()
        except:
            pass
            
        return
        
        
    def labels_SingleCurvePerPlot(self,xwin,ywin):
        '''
        Purpose:
            Generate labels for 'Single Plot Per Curve' mode
            
        Plot label separators:
            '  (space)',
            '\ (back slash)',
            '/ (forward slash)',
            ', (comma+space)',
            '- (dash)',
            '_ (underscore)',
            '+ (plus)',
            '* (asterisk)',
            '> (greater than)',
            '< (less than)'
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'labels_SingleCurvePerPlot')

# define background color            
        colorbg = 'lightblue'  
        
# open Toplevel frame for entering database name
        self.toplevelLabelsSinglePlotPerCurve = Toplevel(
            self.toplevelXYPlotPreprocess,
            bg=colorbg,
            )
        self.toplevelLabelsSinglePlotPerCurve.title(
            'PLOT LABELS - SINGLE CURVE PER PLOT'
            )
#        self.toplevelLabelsSinglePlotPerCurve.transient(self.toplevelTableValues)
        self.toplevelLabelsSinglePlotPerCurve.transient(self.toplevelXYPlotPreprocess)
# place the top window
        x_Windows=xwin
        y_Windows=ywin
        self.toplevelLabelsSinglePlotPerCurve.geometry(
            '+%d+%d' % (x_Windows, y_Windows)
            )
            
# determine list of text fields in current table
        listOfTextFields = []
        for row in range(len(self.tableStructure)):
#            fieldType = self.tableStructure[row][1]
            myField, myDatatype, myNull, myKey, myDefault, myExtra = \
                self.tableStructure[row]
            varfirst2 = myDatatype[0:2]
# check if text
            fieldNameIsText = self.checkIsFieldText(varfirst2)
            if fieldNameIsText:
                listOfTextFields.append(myField)  

            
# FRAMES 
# ... title
        Row = 0
        frame_00 = Frame(
            self.toplevelLabelsSinglePlotPerCurve,
            bg=colorbg,
            )
        frame_00.grid(
            row=Row,
            column=0,
            padx=2,
            pady=2,
            )
# ... plot label separator
        Row += 1
        frame_10 = Frame(
            self.toplevelLabelsSinglePlotPerCurve,
            bg=colorbg,
            )
        frame_10.grid(
            row=Row,
            column=0,
            padx=2,
            pady=2,
            )
# ... frame for TABLE data
        Row += 1
        frameTable = Frame(
            self.toplevelLabelsSinglePlotPerCurve,
            bg=colorbg,
            relief=RIDGE,
            borderwidth=2,
            )
        frameTable.grid(
            row=Row,
            column=0,
            padx=2,
            pady=5,
            )
# ... frame for Buffer data
        Row += 1
        frameBuffer = Frame(
            self.toplevelLabelsSinglePlotPerCurve,
            bg=colorbg,
            relief=RIDGE,
            borderwidth=2,
            )
        frameBuffer.grid(
            row=Row,
            column=0,
            padx=2,
            pady=5
            )
         
# frames for TABLE frame     
        refFrame = frameTable
# ... sub-title
        Row = 0
        frame_00_Table = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_00_Table.grid(
            row=Row,
            column=0,
            padx=2,
            pady=2,
            )
# ... x-label
        Row += 1
        frame_10_Table = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_10_Table.grid(
            row=Row,
            column=0,
            padx=2,
            pady=2,
            sticky=W,
            )
# ...       x-label defined
        Row += 1
        frame_20_Table = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_20_Table.grid(
            row=Row,
            column=0,
            padx=10,
            pady=2,
            )
# ... y-label
        Row += 1
        frame_30_Table = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_30_Table.grid(
            row=Row,
            column=0,
            padx=2,
            pady=2,
            sticky=W,
            )
# ...       y-label defined
        Row += 1
        frame_40_Table = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_40_Table.grid(
            row=Row,
            column=0,
            padx=10,
            pady=2,
            )
# ... show labels
        '''
        Row += 1
        frame_50_Table = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_50_Table.grid(
            row=Row,
            column=0,
            padx=2,
            pady=10,
            sticky=W,
            )
        '''
# ...       show labels widgets
        Row += 1
        frame_60_Table = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_60_Table.grid(
            row=Row,
            column=0,
            padx=10,
            pady=5,
            )
# ... reset all
        Row += 1
        frame_70_Table = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_70_Table.grid(
            row=Row,
            column=0,
            padx=2,
            pady=10,
            )
        
# ... frames for BUFFER frame
        refFrame = frameBuffer
# ... sub-title
        Row = 0
        frame_00_Buffer = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_00_Buffer.grid(
            row=Row,
            column=0,
            padx=2,
            pady=2,
            )
# ... x-label
        Row += 1
        frame_10_Buffer = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_10_Buffer.grid(
            row=Row,
            column=0,
            padx=2,
            pady=2,
            sticky=W,
            )
# ...       x-label defined
        Row += 1
        frame_20_Buffer = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_20_Buffer.grid(
            row=Row,
            column=0,
            padx=10,
            pady=2,
            )
# ... y-label
        Row += 1
        frame_30_Buffer = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_30_Buffer.grid(
            row=Row,
            column=0,
            padx=2,
            pady=2,
            sticky=W,
            )
# ...       y-label defined
        Row += 1
        frame_40_Buffer = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_40_Buffer.grid(
            row=Row,
            column=0,
            padx=10,
            pady=2,
            )
# ... show labels
        '''
        Row += 1
        frame_50_Buffer = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_50_Buffer.grid(
            row=Row,
            column=0,
            padx=2,
            pady=10,
            sticky=W,
            )
        '''
# ...       show labels widgets
        Row += 1
        frame_60_Buffer = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_60_Buffer.grid(
            row=Row,
            column=0,
            padx=10,
            pady=5,
            )
# ... reset all
        Row += 1
        frame_70_Buffer = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_70_Buffer.grid(
            row=Row,
            column=0,
            padx=2,
            pady=10,
            )

      
# WIDGETS
# ... title
        label = Label(
            frame_00,
            text=(
                'X-Y PLOT LABELS\n' +
                'For Single Curve per Plot\n'
                ),
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=0,
            padx=2,
            pady=2,
            )
# ... plot label separator
        label = Label(
            frame_10,
            text=(
                'Plot label separator: '
                ),
            bg=colorbg,
            justify=RIGHT,
            )
        label.grid(
            row=0,
            column=0,
            padx=5,
            pady=0,
            )
        self.comboboxPlotLabelSeparatorSingle = Pmw.ComboBox(
            frame_10,
            scrolledlist_items=self.separatorsPlotLabelsAndLegends,
            listheight=190,
            entry_width=20,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxPlotLabelSeparatorSingle.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            sticky=W,
            )
        self.comboboxPlotLabelSeparatorSingle.selectitem(
           self.separatorsPlotLabelsAndLegends[0]
           )
           
# WIDGETS FOR TABLE DATA          
# ... sub-title for TABLE data
        label = Label(
            frame_00_Table,
            text=(
                'LABELS FOR DATA FROM CURRENT TABLE'
                ),
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
# ... x-label
        label = Label(
            frame_10_Table,
            text=(
                'X LABEL\n' +
                ' '*5 + 'Table X-select header' +
                ' + user text'
                ),
            bg=colorbg,
            justify=LEFT,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
# ...       x-label defined
        '''
        label = Label( 
            frame_20_Table,
            text=(
                'X header + '
                ),
            bg=colorbg,
            justify=RIGHT,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
        '''
        
        self.varCheckbuttonXHeaderLabelSingleCurvePerPlotTable = IntVar()
        self.checkbuttonXHeaderLabelSingleCurvePerPlotTable = Checkbutton(
            frame_20_Table,
            text=' X header + ',
            variable=self.varCheckbuttonXHeaderLabelSingleCurvePerPlotTable,
            bg=colorbg,
            relief=FLAT,
            )
        self.checkbuttonXHeaderLabelSingleCurvePerPlotTable.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
        self.varCheckbuttonXHeaderLabelSingleCurvePerPlotTable.set(1)
 
        self.entryfieldXUserLabelSingleCurvePerPlotTable = Pmw.EntryField(
            frame_20_Table,
            entry_width=30,
            value='',
            )
        self.entryfieldXUserLabelSingleCurvePerPlotTable.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            )
        self.entryfieldXUserLabelSingleCurvePerPlotTable.setvalue('')

# ... y-label
        label = Label(
            frame_30_Table,
            text=(
                'Y LABEL\n' +
                ' '*5 + 'Table Y-select header' +
                ' + first values from Table text fields' +
                ' + user text'
                ),
            bg=colorbg,
            justify=LEFT,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )

# ...       y-label defined
        '''
        label = Label( 
            frame_40_Table,
            text=(
                'Y header'
                ),
            bg=colorbg,
            justify=RIGHT,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
        '''
        self.varCheckbuttonYHeaderLabelSingleCurvePerPlotTable = IntVar()
        self.checkbuttonYHeaderLabelSingleCurvePerPlotTable = Checkbutton(
            frame_40_Table,
            text=' Y header + ',
            variable=self.varCheckbuttonYHeaderLabelSingleCurvePerPlotTable,
            bg=colorbg,
            relief=FLAT,
            )
        self.checkbuttonYHeaderLabelSingleCurvePerPlotTable.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
        self.varCheckbuttonYHeaderLabelSingleCurvePerPlotTable.set(1)
        '''
        label = Label(
            frame_40_Table,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            )
        '''
        
        tempListOfAllFields = []
        for number,field in enumerate(self.myDatabaseFields):
            tempListOfAllFields.append(str(number + 1) + '. ' + field)
            
        self.comboboxY1LabelSingleCurvePerPlotTable = Pmw.ComboBox(
            frame_40_Table,
#            scrolledlist_items=listOfTextFields,
            scrolledlist_items=tempListOfAllFields,
            listheight=150,
            entry_width=15,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxY1LabelSingleCurvePerPlotTable.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            )
        self.comboboxY1LabelSingleCurvePerPlotTable.setentry('')        
        
        label = Label(
            frame_40_Table,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=2,
            padx=0,
            pady=0,
            )
            
        self.comboboxY2LabelSingleCurvePerPlotTable = Pmw.ComboBox(
            frame_40_Table,
#            scrolledlist_items=listOfTextFields,
            scrolledlist_items=tempListOfAllFields,
            listheight=150,
            entry_width=15,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxY2LabelSingleCurvePerPlotTable.grid(
            row=0,
            column=3,
            padx=0,
            pady=0,
            )
        self.comboboxY2LabelSingleCurvePerPlotTable.setentry('')
        
        label = Label(
            frame_40_Table,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=4,
            padx=0,
            pady=0,
            )
            
        self.comboboxY3LabelSingleCurvePerPlotTable = Pmw.ComboBox(
            frame_40_Table,
#            scrolledlist_items=listOfTextFields,
            scrolledlist_items=tempListOfAllFields,
            listheight=150,
            entry_width=15,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxY3LabelSingleCurvePerPlotTable.grid(
            row=0,
            column=5,
            padx=0,
            pady=0,
            )
        self.comboboxY3LabelSingleCurvePerPlotTable.setentry('')
        
        label = Label(
            frame_40_Table,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=1,
            column=1,
            padx=0,
            pady=0,
            sticky=E,
            )
            
        self.entryfieldYUserLabelSingleCurvePerPlotTable = Pmw.EntryField(
            frame_40_Table,
            entry_width=30,
            value='',
            )
        self.entryfieldYUserLabelSingleCurvePerPlotTable.grid(
            row=1,
            column=2,
            columnspan=3,
            padx=0,
            pady=2,
            sticky=W,
            )
        self.entryfieldYUserLabelSingleCurvePerPlotTable.setvalue('')
        
# ...       show labels widgets
        label = Label(
            frame_60_Table,
            text='X LABEL: ',
            bg=colorbg,
            justify=RIGHT,
            )
        label.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            )
        self.entryfieldXLabelShowTable = Pmw.EntryField(
            frame_60_Table,
            entry_width=50,
            value='',
            entry_state='normal',
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            )
        self.entryfieldXLabelShowTable.grid(
            row=0,
            column=2,
            padx=0,
            pady=0,
            )
        self.entryfieldXLabelShowTable.setvalue('')
        label = Label(
            frame_60_Table,
            text='Y LABEL: ',
            bg=colorbg,
            justify=RIGHT,
            )
        label.grid(
            row=1,
            column=1,
            padx=0,
            pady=2,
            )
        self.entryfieldYLabelShowTable = Pmw.EntryField(
            frame_60_Table,
            entry_width=50,
            value='',
            entry_state='normal',
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            )
        self.entryfieldYLabelShowTable.grid(
            row=1,
            column=2,
            padx=0,
            pady=2,
            ) 
        self.entryfieldYLabelShowTable.setvalue('')
        
        buttonShowXYLabelsTable = Button(
            frame_60_Table,
            text='Preview first labels',
            width=18,
            font=self.buttonFontSmall,
            relief=RAISED,
            borderwidth=3,
            justify=CENTER,
            command=self.handlerShowXYLabelsTable,
            )
        buttonShowXYLabelsTable.grid(
            row=0,
            column=0,
            rowspan=2,
            padx=5,
            pady=2,
            )
            
# ... reset all
        self.buttonResetAllSingleCurvePerPlotTable = Button(
            frame_70_Table,
            text='Clear all',
            width=12,
            bg='white',
            fg='blue',
            font=self.buttonFontSmall,
            relief=RAISED,
            borderwidth=3,
            justify=CENTER,
            command=self.handlerResetAllSingleCurvePerPlotTable,
            )
        self.buttonResetAllSingleCurvePerPlotTable.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
            
# WIDGETS FOR BUFFER DATA          
# ... sub-title for BUFFER data
        label = Label(
            frame_00_Buffer,
            text=(
                'LABELS FOR DATA FROM STORAGE BUFFER'
                ),
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
# ... x-label
        label = Label(
            frame_10_Buffer,
            text=(
                'X LABEL\n' +
                ' '*5 + 'Buffer X-select header' +
                ' + user text'
                ),
            bg=colorbg,
            justify=LEFT,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
# ...       x-label defined
        '''
        label = Label( 
            frame_20_Buffer,
            text=(
                'X header + '
                ),
            bg=colorbg,
            justify=RIGHT,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
        '''
        self.varCheckbuttonXHeaderLabelSingleCurvePerPlotBuffer = IntVar()
        self.checkbuttonXHeaderLabelSingleCurvePerPlotBuffer = Checkbutton(
            frame_20_Buffer,
            text=' X header + ',
            variable=self.varCheckbuttonXHeaderLabelSingleCurvePerPlotBuffer,
            bg=colorbg,
            relief=FLAT,
            )
        self.checkbuttonXHeaderLabelSingleCurvePerPlotBuffer.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
        self.varCheckbuttonXHeaderLabelSingleCurvePerPlotBuffer.set(1)
        
        self.entryfieldXUserLabelSingleCurvePerPlotBuffer = Pmw.EntryField(
            frame_20_Buffer,
            entry_width=30,
            value='',
            )
        self.entryfieldXUserLabelSingleCurvePerPlotBuffer.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            )
        self.entryfieldXUserLabelSingleCurvePerPlotBuffer.setvalue('')

# ... y-label
        label = Label(
            frame_30_Buffer,
            text=(
                'Y LABEL\n' +
                ' '*5 + 'Buffer Y-select header' +
                ' + first values from Buffer text fields' +
                ' + user text'
                ),
            bg=colorbg,
            justify=LEFT,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )

# ...       y-label defined
        '''
        label = Label( 
            frame_40_Buffer,
            text=(
                'Y header +'
                ),
            bg=colorbg,
            justify=RIGHT,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
        label = Label(
            frame_40_Buffer,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            )
        '''    
        self.varCheckbuttonYHeaderLabelSingleCurvePerPlotBuffer = IntVar()
        self.checkbuttonYHeaderLabelSingleCurvePerPlotBuffer = Checkbutton(
            frame_40_Buffer,
            text=' Y header + ',
            variable=self.varCheckbuttonYHeaderLabelSingleCurvePerPlotBuffer,
            bg=colorbg,
            relief=FLAT,
            )
        self.checkbuttonYHeaderLabelSingleCurvePerPlotBuffer.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
        self.varCheckbuttonYHeaderLabelSingleCurvePerPlotBuffer.set(1)
        
        self.comboboxY1LabelSingleCurvePerPlotBuffer = Pmw.ComboBox(
            frame_40_Buffer,
            scrolledlist_items=self.labelNamesBufferStorage,
            listheight=130,
            entry_width=15,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxY1LabelSingleCurvePerPlotBuffer.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            )
        self.comboboxY1LabelSingleCurvePerPlotBuffer.setentry('')
        
        label = Label(
            frame_40_Buffer,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=2,
            padx=0,
            pady=0,
            )
        self.comboboxY2LabelSingleCurvePerPlotBuffer = Pmw.ComboBox(
            frame_40_Buffer,
            scrolledlist_items=self.labelNamesBufferStorage,
            listheight=130,
            entry_width=15,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxY2LabelSingleCurvePerPlotBuffer.grid(
            row=0,
            column=3,
            padx=0,
            pady=0,
            )
        self.comboboxY2LabelSingleCurvePerPlotBuffer.setentry('')
        label = Label(
            frame_40_Buffer,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=4,
            padx=0,
            pady=0,
            )
        self.comboboxY3LabelSingleCurvePerPlotBuffer = Pmw.ComboBox(
            frame_40_Buffer,
            scrolledlist_items=self.labelNamesBufferStorage,
            listheight=130,
            entry_width=15,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxY3LabelSingleCurvePerPlotBuffer.grid(
            row=0,
            column=5,
            padx=0,
            pady=0,
            )
        self.comboboxY3LabelSingleCurvePerPlotBuffer.setentry('')
        
        label = Label(
            frame_40_Buffer,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=1,
            column=1,
            padx=0,
            pady=0,
            sticky=E,
            )
        self.entryfieldYUserLabelSingleCurvePerPlotBuffer = Pmw.EntryField(
            frame_40_Buffer,
            entry_width=30,
            value='',
            )
        self.entryfieldYUserLabelSingleCurvePerPlotBuffer.grid(
            row=1,
            column=2,
            columnspan=3,
            padx=0,
            pady=2,
            sticky=W,
            )
        self.entryfieldYUserLabelSingleCurvePerPlotBuffer.setvalue('')

# ... show labels
        '''
        label = Label(
            frame_50_Buffer,
            text=(
                'SHOW FIRST X-Y LABEL AS EXAMPLE:'
                ),
            bg=colorbg,
            justify=LEFT,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
        '''
# ...       show labels widgets
        label = Label(
            frame_60_Buffer,
            text='X LABEL: ',
            bg=colorbg,
            justify=RIGHT,
            )
        label.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            )
        self.entryfieldXLabelShowBuffer = Pmw.EntryField(
            frame_60_Buffer,
            entry_width=50,
            value='',
            entry_state='normal',
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            )
        self.entryfieldXLabelShowBuffer.grid(
            row=0,
            column=2,
            padx=0,
            pady=0,
            )
        self.entryfieldXLabelShowBuffer.setvalue('')
        label = Label(
            frame_60_Buffer,
            text='Y LABEL: ',
            bg=colorbg,
            justify=RIGHT,
            )
        label.grid(
            row=1,
            column=1,
            padx=0,
            pady=2,
            )
        self.entryfieldYLabelShowBuffer = Pmw.EntryField(
            frame_60_Buffer,
            entry_width=50,
            value='',
            entry_state='normal',
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            )
        self.entryfieldYLabelShowBuffer.grid(
            row=1,
            column=2,
            padx=0,
            pady=2,
            ) 
        self.entryfieldYLabelShowBuffer.setvalue('')
        buttonShowXYLabelsBuffer = Button(
            frame_60_Buffer,
            text='Preview first labels',
            width=18,
            font=self.buttonFontSmall,
            relief=RAISED,
            borderwidth=3,
            justify=CENTER,
            command=self.handlerShowXYLabelsBuffer,
            )
        buttonShowXYLabelsBuffer.grid(
#            row=2,
#            column=1,
            row=0,
            column=0,
            rowspan=2,
            padx=5,
            pady=2,
            )
# ... reset all
        self.buttonResetAllSingleCurvePerPlotBuffer = Button(
            frame_70_Buffer,
            text='Clear all',
            width=12,
            bg='white',
            fg='blue',
            font=self.buttonFontSmall,
            relief=RAISED,
            borderwidth=3,
            justify=CENTER,
            command=self.handlerResetAllSingleCurvePerPlotBuffer,
            )
        self.buttonResetAllSingleCurvePerPlotBuffer.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
            
# call 'Preview' handlers to show default labels
        self.handlerShowXYLabelsTable_NoErrMsg()
        self.handlerShowXYLabelsBuffer_NoErrMsg()

        return
        
        
    def handlerShowXYLabelsTable(self):
        '''
        Purpose:
            - For single curve per plot, all plots in one window
            take user input from designated widgets and display
            X and Y Labels for plots in respective display fields,
            and display error msg if no data to choose from
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerShowXYLabelsTable')
            
        if (
         self.varNumberOfTableCurves.get() == 0
           and
         self.varNumberOfStorageBufferCurves.get() == 0
         ):
            stringNoTableRowsSelected = (
                'No data have been selected from the current table\n' +
                'or the buffer for plotting.\n\n' +
                'Please select at least one data pair and try again.'
                )
            print stringNoTableRowsSelected
            self.MySQL_Output(
                0,
                stringNoTableRowsSelected
                )
            try:
                showerror(
                    'Error: no data',
                    stringNoTableRowsSelected,
                    parent=self.toplevelLabelsSinglePlotPerCurve,
                    )
            except:
                showerror(
                    'Error: no data',
                    stringNoTableRowsSelected
                    )
            return
 
# determine y index and header; only need the first one here 

        yHeaders = []
        yHeaders.extend(self.headerNames_Y_Table)
        
        if DEBUG_XY_LABELS:
            print(' yHeaders =\n')
            print(yHeaders)        

# determine plot label separator
        separator = self.determinePlotLabelSeparator(
            self.comboboxPlotLabelSeparatorSingle.get()
            )
        
        if DEBUG_XY_LABELS:
            print('-'*80)
            print('\n\n*** In ' + MODULE + '/' + 'handlerShowXYLabelsTable ***')
            print('self.headerNames_X_Table =\n%s' % self.headerNames_X_Table)
            print('self.headerNames_Y_Table =\n%s' % self.headerNames_Y_Table)
            print '-'*80

# concatenate X-label string
        self.xLabelStringTable = []
        xLabelString = ''
        if self.varCheckbuttonXHeaderLabelSingleCurvePerPlotTable.get():
            try:
                xLabelString = self.headerNames_X_Table[0]
            except:
                stringNoXHeaderNames = (
                    'There are no field header names for X\n\n' +
                    'It appears the X-Select value needs to be made.\n\n' +
                    'Select an X-Select value and try again.'
                    )
                print(stringNoXHeaderNames)
                self.MySQL_Output(
                    0,
                    stringNoXHeaderNames
                    )
                showinfo(
                    'Info: no header name for X',
                    stringNoXHeaderNames
                    )
                return   
                
#            self.xLabelStringTable.append(self.headerNames_X_Table[0])
        if self.entryfieldXUserLabelSingleCurvePerPlotTable.get().strip() <> '':
            if xLabelString <> '':
#                self.xLabelStringTable += separator + self.entryfieldXUserLabelSingleCurvePerPlotTable.get()
                xLabelString += separator + self.entryfieldXUserLabelSingleCurvePerPlotTable.get()
            else:
#                self.xLabelStringTable = self.entryfieldXUserLabelSingleCurvePerPlotTable.get()
                xLabelString = self.entryfieldXUserLabelSingleCurvePerPlotTable.get()
        self.xLabelStringTable.append(xLabelString)
            
# concatenate Y-label strings
        self.yLabelStringTable = []
        for header in yHeaders:
            yLabelString = ''
            if self.varCheckbuttonYHeaderLabelSingleCurvePerPlotTable.get():
                yLabelString = header
            if self.comboboxY1LabelSingleCurvePerPlotTable.get().strip() <> '':                    
                field1 = self.comboboxY1LabelSingleCurvePerPlotTable.get().split('.')[1].strip()
                for key,value in self.dictColumnHeaders.iteritems():
                    if key == field1:
                        if(
                        self.tableValues[0][value-1] <> None
                        and
                        self.tableValues[0][value-1] <> ''
                        ):
                            if yLabelString <> '':
                                yLabelString += separator + str(self.tableValues[0][value-1])
                            else:
                                yLabelString = str(self.tableValues[0][value-1])
                            break
                        else:
                            stringNoValue = (
                                'No value associated with field\n' +
                                '  - %s\n\n' +
                                'Select another field.'
                                ) % (
                                key
                                )
                            print('\n' + stringNoValue)
                            self.MySQL_Output(
                                0,
                                stringNoValue
                                )
                            try:
                                showerror(
                                    'Error: no value',
                                    stringNoValue,
                                    parent=self.toplevelXYPlotPreprocess
                                    )
                            except:
                                showerror(
                                    'Error: no value',
                                    stringNoValue
                                    )
                            return
            if self.comboboxY2LabelSingleCurvePerPlotTable.get().strip() <> '':
                field2 = self.comboboxY2LabelSingleCurvePerPlotTable.get().split('.')[1].strip()
                for key,value in self.dictColumnHeaders.iteritems():
                    if key == field2:
                        if(
                        self.tableValues[0][value-1] <> None
                        and
                        self.tableValues[0][value-1] <> ''
                        ):
                            if yLabelString <> '':
                                yLabelString += separator + str(self.tableValues[0][value-1])
                            else:
                                yLabelString = str(self.tableValues[0][value-1])
                            break
                        else:
                            stringNoValue = (
                                'No value associated with field\n' +
                                '  - %s\n\n' +
                                'Select another field.'
                                ) % (
                                key
                                )
                            print('\n' + stringNoValue)
                            self.MySQL_Output(
                                0,
                                stringNoValue
                                )
                            try:
                                showerror(
                                    'Error: no value',
                                    stringNoValue,
                                    parent=self.toplevelXYPlotPreprocess
                                    )
                            except:
                                showerror(
                                    'Error: no value',
                                    stringNoValue
                                    )
                            return
            if self.comboboxY3LabelSingleCurvePerPlotTable.get().strip() <> '':
                field3 = self.comboboxY3LabelSingleCurvePerPlotTable.get().split('.')[1].strip()
                for key,value in self.dictColumnHeaders.iteritems():
                    if key == field3:
                        if(
                        self.tableValues[0][value-1] <> None
                        and
                        self.tableValues[0][value-1] <> ''
                        ):
                            if yLabelString <> '':
                                yLabelString += separator + str(self.tableValues[0][value-1])
                            else:
                                yLabelString = str(self.tableValues[0][value-1])
                            break
                        else:
                            stringNoValue = (
                                'No value associated with field\n' +
                                '  - %s\n\n' +
                                'Select another field.'
                                ) % (
                                key
                                )
                            print('\n' + stringNoValue)
                            self.MySQL_Output(
                                0,
                                stringNoValue
                                )
                            try:
                                showerror(
                                    'Error: no value',
                                    stringNoValue,
                                    parent=self.toplevelXYPlotPreprocess
                                    )
                            except:
                                showerror(
                                    'Error: no value',
                                    stringNoValue
                                    )
                            return
            if self.entryfieldYUserLabelSingleCurvePerPlotTable.get().strip() <> '':
                if yLabelString <> '':
                    yLabelString += separator + self.entryfieldYUserLabelSingleCurvePerPlotTable.get()
                else:
                    yLabelString = self.entryfieldYUserLabelSingleCurvePerPlotTable.get()
            self.yLabelStringTable.append(yLabelString)
            
# show strings in respective fields
        self.entryfieldXLabelShowTable.setvalue(self.xLabelStringTable[0])
        self.entryfieldYLabelShowTable.setvalue(self.yLabelStringTable[0])
                 
        return
        
        
    def handlerShowXYLabelsTable_NoErrMsg(self):
        '''
        Purpose:
            take user input from designated widgets and display
            X and Y Labels for plots in respective display fields,
            but do not display error msg if no data to choose from
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerShowXYLabelsTable_NoErrMsg')
        
        if self.varNumberOfTableCurves.get() == 0:
            return
            
# determine x index and header

        try:
            xHeader = self.headerNames_X_Table[0]
        except:
            stringNoXHeaderNames = (
                'There are no field header names for X\n\n' +
                'It appears the X-Select value needs to be made.\n\n' +
                'Select an X-Select value and try again.'
                )
            print(stringNoXHeaderNames)
            self.MySQL_Output(
                0,
                stringNoXHeaderNames
                )
            showinfo(
                'Info: no header name for X',
                stringNoXHeaderNames
                )
            return
            
        if DEBUG_XY_LABELS:
            print('\nxHeader = %s' % xHeader)
 
# determine y index and header
        
        yHeaders = self.headerNames_Y_Table
        
        if DEBUG_XY_LABELS:
            print('\nyHeaders for X-Y plots =\n')
            print(yHeaders)
            print('')

# determine plot label separator
        separator = self.determinePlotLabelSeparator(
            self.comboboxPlotLabelSeparatorSingle.get()
            )
        
# concatenate X-label string
        self.xLabelStringTable = []
        xLabelString = ''
        if self.varCheckbuttonXHeaderLabelSingleCurvePerPlotTable.get():
            xLabelString = self.headerNames_X_Table[0]
#            self.xLabelStringTable.append(self.headerNames_X_Table[0])
        if self.entryfieldXUserLabelSingleCurvePerPlotTable.get().strip() <> '':
            if xLabelString <> '':
#                self.xLabelStringTable += separator + self.entryfieldXUserLabelSingleCurvePerPlotTable.get()
                xLabelString += separator + self.entryfieldXUserLabelSingleCurvePerPlotTable.get()
            else:
#                self.xLabelStringTable = self.entryfieldXUserLabelSingleCurvePerPlotTable.get()
                xLabelString = self.entryfieldXUserLabelSingleCurvePerPlotTable.get()
        self.xLabelStringTable.append(xLabelString)
            
# concatenate Y-label strings
        self.yLabelStringTable = []
        for header in yHeaders:
            yLabelString = ''
            if self.varCheckbuttonYHeaderLabelSingleCurvePerPlotTable.get():
                yLabelString = header
            if self.comboboxY1LabelSingleCurvePerPlotTable.get().strip() <> '':
                field1 = self.comboboxY1LabelSingleCurvePerPlotTable.get()
                for key,value in self.dictColumnHeaders.iteritems():
                    if key == field1:                        
                        if(
                        self.tableValues[0][value-1] <> None
                        and
                        self.tableValues[0][value-1] <> ''
                        ):
                            if yLabelString <> '':
                                yLabelString += separator + self.tableValues[0][value-1]
                            else:
                                yLabelString = self.tableValues[0][value-1]
                            break
                        else:
                            stringNoValue = (
                                'No value associated with field\n' +
                                '  - %s\n\n' +
                                'Select another field.'
                                ) % (
                                key
                                )
                            print('\n' + stringNoValue)
                            self.MySQL_Output(
                                0,
                                stringNoValue
                                )
                            try:
                                showerror(
                                    'Error: no value',
                                    stringNoValue,
                                    parent=self.toplevelXYPlotPreprocess
                                    )
                            except:
                                showerror(
                                    'Error: no value',
                                    stringNoValue
                                    )
                            return
            if self.comboboxY2LabelSingleCurvePerPlotTable.get().strip() <> '':
                field2 = self.comboboxY2LabelSingleCurvePerPlotTable.get()
                for key,value in self.dictColumnHeaders.iteritems():
                    if key == field2:
                        if(
                        self.tableValues[0][value-1] <> None
                        and
                        self.tableValues[0][value-1] <> ''
                        ):
                            if yLabelString <> '':
                                yLabelString += separator + self.tableValues[0][value-1]
                            else:
                                yLabelString = self.tableValues[0][value-1]
                            break
                        else:
                            stringNoValue = (
                                'No value associated with field\n' +
                                '  - %s\n\n' +
                                'Select another field.'
                                ) % (
                                key
                                )
                            print('\n' + stringNoValue)
                            self.MySQL_Output(
                                0,
                                stringNoValue
                                )
                            try:
                                showerror(
                                    'Error: no value',
                                    stringNoValue,
                                    parent=self.toplevelXYPlotPreprocess
                                    )
                            except:
                                showerror(
                                    'Error: no value',
                                    stringNoValue
                                    )
                            return
            if self.comboboxY3LabelSingleCurvePerPlotTable.get().strip() <> '':
                field3 = self.comboboxY3LabelSingleCurvePerPlotTable.get()
                for key,value in self.dictColumnHeaders.iteritems():
                    if key == field3:
                        if(
                        self.tableValues[0][value-1] <> None
                        and
                        self.tableValues[0][value-1] <> ''
                        ):
                            if yLabelString <> '':
                                yLabelString += separator + self.tableValues[0][value-1]
                            else:
                                yLabelString = self.tableValues[0][value-1]
                            break
                        else:
                            stringNoValue = (
                                'No value associated with field\n' +
                                '  - %s\n\n' +
                                'Select another field.'
                                ) % (
                                key
                                )
                            print('\n' + stringNoValue)
                            self.MySQL_Output(
                                0,
                                stringNoValue
                                )
                            try:
                                showerror(
                                    'Error: no value',
                                    stringNoValue,
                                    parent=self.toplevelXYPlotPreprocess
                                    )
                            except:
                                showerror(
                                    'Error: no value',
                                    stringNoValue
                                    )
                            return
            if self.entryfieldYUserLabelSingleCurvePerPlotTable.get().strip() <> '':
                if yLabelString <> '':
                    yLabelString += separator + self.entryfieldYUserLabelSingleCurvePerPlotTable.get()
                else:
                    yLabelString = self.entryfieldYUserLabelSingleCurvePerPlotTable.get()
            self.yLabelStringTable.append(yLabelString)
            
# show strings in respective fields
        self.entryfieldXLabelShowTable.setvalue(self.xLabelStringTable[0])
        self.entryfieldYLabelShowTable.setvalue(self.yLabelStringTable[0])
                 
        return
        
        
    def handlerResetAllSingleCurvePerPlotTable(self):
        '''
        Purpose:27848
        
            Reset all values to default in the 
            'PLOT LABELS \n For Single Curve per Plot' window
        '''
        '''
        self.comboboxPlotLabelSeparatorSingle.selectitem(
           self.separatorsPlotLabelsAndLegends[0]
           )
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerResetAllSingleCurvePerPlotTable')
            
        if self.entryfieldXUserLabelSingleCurvePerPlotTable.get().strip() <> '':
            self.entryfieldXUserLabelSingleCurvePerPlotTable.setvalue('')
        if self.comboboxY1LabelSingleCurvePerPlotTable.get().strip() <> '':
            self.comboboxY1LabelSingleCurvePerPlotTable.setentry('')
        if self.comboboxY2LabelSingleCurvePerPlotTable.get().strip() <> '':
            self.comboboxY2LabelSingleCurvePerPlotTable.setentry('')
        if self.comboboxY3LabelSingleCurvePerPlotTable.get().strip() <> '':
            self.comboboxY3LabelSingleCurvePerPlotTable.setentry('')
        if self.entryfieldYUserLabelSingleCurvePerPlotTable.get().strip() <> '':
            self.entryfieldYUserLabelSingleCurvePerPlotTable.setvalue('')
        
        self.entryfieldXLabelShowTable.setvalue('')
        self.entryfieldYLabelShowTable.setvalue('')
       
        return
        
        
    def handlerShowXYLabelsBuffer(self):
        '''
        Purpose:
            take user input from designated widgets and display
            X and Y Labels for plots in respective display fields.
            
            All X and Y plot labels for Storage Buffer data is determined here.
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerShowXYLabelsBuffer')
            
# set to 1 to print
        DEBUG_SHOWXYLABELSBUFFER = 0
            
#        if self.varNumberOfStorageBufferCurves.get() == 0:
#            return

# ... determine first row checked in Storage Buffer
#   (number of Storage Buffer curves total: len(self.varSelectAnyRow_Buffer)
# ... if no Buffer Rows are checked, return
        if len(self.listWhichBufferRowsAreChecked) == 0:
            stringNoBufferRowsSelected = (
                'No data rows have been selected from the Storage Buffer\n' +
                'for plotting.\n' 
                )
            print stringNoBufferRowsSelected
            self.MySQL_Output(
                0,
                stringNoBufferRowsSelected
                )
            try:
                showerror(
                    'Error: no data',
                    stringNoBufferRowsSelected,
                    parent=self.toplevelLabelsSinglePlotPerCurve,
                    )
            except:
                showerror(
                    'Error: no data',
                    stringNoBufferRowsSelected
                    )
            return
# determine row index and x-y headers       
        indexBufferRow = self.listWhichBufferRowsAreChecked
        if DEBUG_SHOWXYLABELSBUFFER:
            print '\n*** self.listWhichBufferRowsAreChecked =',self.listWhichBufferRowsAreChecked
            print '\n*** self.bufferRowStore =\n',self.bufferRowStore
            print
        
        # determine plot label separator
        separator = self.determinePlotLabelSeparator(
            self.comboboxPlotLabelSeparatorSingle.get()
            )
        
        self.xLabelStringBuffer = []        
        self.yLabelStringBuffer = []
        
        icount = 0
        for indexBufferRow in self.listWhichBufferRowsAreChecked:
            index=indexBufferRow - 1
# x labels
            xLabelString = ''
            if self.varCheckbuttonXHeaderLabelSingleCurvePerPlotBuffer.get():
#                self.xLabelStringBuffer.append(self.bufferRowStore[index][5])
                xLabelString = self.bufferRowStore[index][5]
            if self.entryfieldXUserLabelSingleCurvePerPlotBuffer.get().strip() <> '':
                if xLabelString <> '':
                    xLabelString += separator + (
                    self.entryfieldXUserLabelSingleCurvePerPlotBuffer.get()
                    )
                else:
                    xLabelString = (
                    self.entryfieldXUserLabelSingleCurvePerPlotBuffer.get()
                    )
            self.xLabelStringBuffer.append(xLabelString)
# y labels
            yLabelString = ''
            if self.varCheckbuttonYHeaderLabelSingleCurvePerPlotBuffer.get():
                yLabelString = self.bufferRowStore[index][6]
#                self.yLabelStringBuffer.append(self.bufferRowStore[index][6])                           
# concatenate Y-label strings
#            yLabelString = ''
            if self.comboboxY1LabelSingleCurvePerPlotBuffer.get().strip() <> '':
                field1 = self.comboboxY1LabelSingleCurvePerPlotBuffer.get()
                for key,value in self.dictNamesBufferStorage.iteritems():
                    if key == field1:
                        if(
                        self.bufferRowStore[index][value] <> None
                        and
                        self.bufferRowStore[index][value] <> ''
                        ):
                            if yLabelString <> '':
                                yLabelString += separator + self.bufferRowStore[index][value]
                            else:
                                yLabelString = self.bufferRowStore[index][value]
                            break
                        else:
                            stringNoValue = (
                                'No value associated with field\n' +
                                '  - %s\n\n' +
                                'Select another field.'
                                ) % (
                                key
                                )
                            print('\n' + stringNoValue)
                            self.MySQL_Output(
                                0,
                                stringNoValue
                                )
                            try:
                                showerror(
                                    'Error: no value',
                                    stringNoValue,
                                    parent=self.toplevelXYPlotPreprocess
                                    )
                            except:
                                showerror(
                                    'Error: no value',
                                    stringNoValue
                                    )
                            return
            if self.comboboxY2LabelSingleCurvePerPlotBuffer.get().strip() <> '':
                field2 = self.comboboxY2LabelSingleCurvePerPlotBuffer.get()
                for key,value in self.dictNamesBufferStorage.iteritems():
                    if key == field2:
                        if(
                        self.bufferRowStore[index][value] <> None
                        and
                        self.bufferRowStore[index][value] <> ''
                        ):
                            if yLabelString <> '':
                                yLabelString += separator + self.bufferRowStore[index][value]
                            else:
                                yLabelString = self.bufferRowStore[index][value]
                            break
                        else:
                            stringNoValue = (
                                'No value associated with field\n' +
                                '  - %s\n\n' +
                                'Select another field.'
                                ) % (
                                key
                                )
                            print('\n' + stringNoValue)
                            self.MySQL_Output(
                                0,
                                stringNoValue
                                )
                            try:
                                showerror(
                                    'Error: no value',
                                    stringNoValue,
                                    parent=self.toplevelXYPlotPreprocess
                                    )
                            except:
                                showerror(
                                    'Error: no value',
                                    stringNoValue
                                    )
                            return
            if self.comboboxY3LabelSingleCurvePerPlotBuffer.get().strip() <> '':
                field3 = self.comboboxY3LabelSingleCurvePerPlotBuffer.get()
                for key,value in self.dictNamesBufferStorage.iteritems():
                    if key == field3:
                        if(
                        self.bufferRowStore[index][value] <> None
                        and
                        self.bufferRowStore[index][value] <> ''
                        ):
                            if yLabelString <> '':
                                yLabelString += separator + self.bufferRowStore[index][value]
                            else:
                                yLabelString = self.bufferRowStore[index][value]
                            break
                        else:
                            stringNoValue = (
                                'No value associated with field\n' +
                                '  - %s\n\n' +
                                'Select another field.'
                                ) % (
                                key
                                )
                            print('\n' + stringNoValue)
                            self.MySQL_Output(
                                0,
                                stringNoValue
                                )
                            try:
                                showerror(
                                    'Error: no value',
                                    stringNoValue,
                                    parent=self.toplevelXYPlotPreprocess
                                    )
                            except:
                                showerror(
                                    'Error: no value',
                                    stringNoValue
                                    )
                            return
            if self.entryfieldYUserLabelSingleCurvePerPlotBuffer.get().strip() <> '':
                if yLabelString <> '':
                    yLabelString += separator + self.entryfieldYUserLabelSingleCurvePerPlotBuffer.get()
                else:
                    yLabelString = self.entryfieldYUserLabelSingleCurvePerPlotBuffer.get()
                    
            self.yLabelStringBuffer.append(yLabelString)
            
# show strings in respective fields
        self.entryfieldXLabelShowBuffer.setvalue(self.xLabelStringBuffer[0])
        self.entryfieldYLabelShowBuffer.setvalue(self.yLabelStringBuffer[0])
                 
        return
        
        
    def handlerShowXYLabelsBuffer_NoErrMsg(self):
        '''
        Purpose:
            take user input from designated widgets and display
            X and Y Labels for plots in respective display fields,
            but do not display error msg if no data to choose from
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerShowXYLabelsBuffer_NoErrMsg')
            
# set to 1 to print
        DEBUG_SHOWXYLABELSBUFFER_NOERRMSG = 0
            
# ... determine first row checked in Storage Buffer
#   (number of Storage Buffer curves total: len(self.varSelectAnyRow_Buffer)
# ... if no Buffer Rows are checked, return
        if len(self.listWhichBufferRowsAreChecked) == 0:
            return
# determine row index and x-y headers       
        indexBufferRow = self.listWhichBufferRowsAreChecked
        if DEBUG_SHOWXYLABELSBUFFER_NOERRMSG:
            print '\n*** self.listWhichBufferRowsAreChecked =',self.listWhichBufferRowsAreChecked
            print '\n*** self.bufferRowStore =\n',self.bufferRowStore
            print
        
        # determine plot label separator
        separator = self.determinePlotLabelSeparator(
            self.comboboxPlotLabelSeparatorSingle.get()
            )
        
        self.xLabelStringBuffer = []
        self.yLabelStringBuffer = []
        
        '''
        icount = 0
        for indexBufferRow in self.listWhichBufferRowsAreChecked:
            index=indexBufferRow - 1
            self.xLabelStringBuffer.append(self.bufferRowStore[index][5])
            self.yLabelStringBuffer.append(self.bufferRowStore[index][6])      
# concatenate X-label string with user text
            if self.entryfieldXUserLabelSingleCurvePerPlotBuffer.get().strip() <> '':
                self.xLabelStringBuffer[icount] += separator + (
                    self.entryfieldXUserLabelSingleCurvePerPlotBuffer.get()
                    )            
# concatenate Y-label strings
            yLabelString = ''
            if self.comboboxY1LabelSingleCurvePerPlotBuffer.get().strip() <> '':
                field1 = self.comboboxY1LabelSingleCurvePerPlotBuffer.get()
                for key,value in self.dictNamesBufferStorage.iteritems():
                    if key == field1:
                        yLabelString += separator + self.bufferRowStore[index][value]
                        break
            if self.comboboxY2LabelSingleCurvePerPlotBuffer.get().strip() <> '':
                field2 = self.comboboxY2LabelSingleCurvePerPlotBuffer.get()
                for key,value in self.dictNamesBufferStorage.iteritems():
                    if key == field2:
                        yLabelString += separator + self.bufferRowStore[index][value]
                        break
            if self.comboboxY3LabelSingleCurvePerPlotBuffer.get().strip() <> '':
                field3 = self.comboboxY3LabelSingleCurvePerPlotBuffer.get()
                for key,value in self.dictNamesBufferStorage.iteritems():
                    if key == field3:
                        yLabelString += separator + self.bufferRowStore[index][value]
                        break
            if self.entryfieldYUserLabelSingleCurvePerPlotBuffer.get().strip() <> '':
                yLabelString += separator + self.entryfieldYUserLabelSingleCurvePerPlotBuffer.get()
            self.yLabelStringBuffer[icount] += yLabelString
            
            icount += 1
        '''
            
        icount = 0
        for indexBufferRow in self.listWhichBufferRowsAreChecked:
            index=indexBufferRow - 1
# x labels
            xLabelString = ''
            if self.varCheckbuttonXHeaderLabelSingleCurvePerPlotBuffer.get():
#                self.xLabelStringBuffer.append(self.bufferRowStore[index][5])
                xLabelString = self.bufferRowStore[index][5]
            if self.entryfieldXUserLabelSingleCurvePerPlotBuffer.get().strip() <> '':
                if xLabelString <> '':
                    xLabelString += separator + (
                    self.entryfieldXUserLabelSingleCurvePerPlotBuffer.get()
                    )
                else:
                    xLabelString = (
                    self.entryfieldXUserLabelSingleCurvePerPlotBuffer.get()
                    )
            self.xLabelStringBuffer.append(xLabelString)
# y labels
            yLabelString = ''
            if self.varCheckbuttonYHeaderLabelSingleCurvePerPlotBuffer.get():
                yLabelString = self.bufferRowStore[index][6]
#                self.yLabelStringBuffer.append(self.bufferRowStore[index][6])                           
# concatenate Y-label strings
#            yLabelString = ''
            if self.comboboxY1LabelSingleCurvePerPlotBuffer.get().strip() <> '':
                field1 = self.comboboxY1LabelSingleCurvePerPlotBuffer.get()
                for key,value in self.dictNamesBufferStorage.iteritems():
                    if key == field1:
                        if(
                        self.bufferRowStore[index][value] <> None
                        and
                        self.bufferRowStore[index][value] <> ''
                        ):
                            if yLabelString <> '':
                                yLabelString += separator + self.bufferRowStore[index][value]
                            else:
                                yLabelString = self.bufferRowStore[index][value]
                            break
                        else:
                            stringNoValue = (
                                'No value associated with field\n' +
                                '  - %s\n\n' +
                                'Select another field.'
                                ) % (
                                key
                                )
                            print('\n' + stringNoValue)
                            self.MySQL_Output(
                                0,
                                stringNoValue
                                )
                            try:
                                showerror(
                                    'Error: no value',
                                    stringNoValue,
                                    parent=self.toplevelXYPlotPreprocess
                                    )
                            except:
                                showerror(
                                    'Error: no value',
                                    stringNoValue
                                    )
                            return
            if self.comboboxY2LabelSingleCurvePerPlotBuffer.get().strip() <> '':
                field2 = self.comboboxY2LabelSingleCurvePerPlotBuffer.get()
                for key,value in self.dictNamesBufferStorage.iteritems():
                    if key == field2:
                        if(
                        self.bufferRowStore[index][value] <> None
                        and
                        self.bufferRowStore[index][value] <> ''
                        ):
                            if yLabelString <> '':
                                yLabelString += separator + self.bufferRowStore[index][value]
                            else:
                                yLabelString = self.bufferRowStore[index][value]
                            break
                        else:
                            stringNoValue = (
                                'No value associated with field\n' +
                                '  - %s\n\n' +
                                'Select another field.'
                                ) % (
                                key
                                )
                            print('\n' + stringNoValue)
                            self.MySQL_Output(
                                0,
                                stringNoValue
                                )
                            try:
                                showerror(
                                    'Error: no value',
                                    stringNoValue,
                                    parent=self.toplevelXYPlotPreprocess
                                    )
                            except:
                                showerror(
                                    'Error: no value',
                                    stringNoValue
                                    )
                            return
            if self.comboboxY3LabelSingleCurvePerPlotBuffer.get().strip() <> '':
                field3 = self.comboboxY3LabelSingleCurvePerPlotBuffer.get()
                for key,value in self.dictNamesBufferStorage.iteritems():
                    if key == field3:
                        if(
                        self.bufferRowStore[index][value] <> None
                        and
                        self.bufferRowStore[index][value] <> ''
                        ):
                            if yLabelString <> '':
                                yLabelString += separator + self.bufferRowStore[index][value]
                            else:
                                yLabelString = self.bufferRowStore[index][value]
                            break
                        else:
                            stringNoValue = (
                                'No value associated with field\n' +
                                '  - %s\n\n' +
                                'Select another field.'
                                ) % (
                                key
                                )
                            print('\n' + stringNoValue)
                            self.MySQL_Output(
                                0,
                                stringNoValue
                                )
                            try:
                                showerror(
                                    'Error: no value',
                                    stringNoValue,
                                    parent=self.toplevelXYPlotPreprocess
                                    )
                            except:
                                showerror(
                                    'Error: no value',
                                    stringNoValue
                                    )
                            return
            if self.entryfieldYUserLabelSingleCurvePerPlotBuffer.get().strip() <> '':
                if yLabelString <> '':
                    yLabelString += separator + self.entryfieldYUserLabelSingleCurvePerPlotBuffer.get()
                else:
                    yLabelString = self.entryfieldYUserLabelSingleCurvePerPlotBuffer.get()
                    
#            self.yLabelStringBuffer[icount] += yLabelString
            self.yLabelStringBuffer.append(yLabelString)
            
            icount += 1
            
# show strings in respective fields
        self.entryfieldXLabelShowBuffer.setvalue(self.xLabelStringBuffer[0])
        self.entryfieldYLabelShowBuffer.setvalue(self.yLabelStringBuffer[0])
                 
        return

        
    def determinePlotLabelSeparator(self,plotLabelSeparator):
        '''
        Purpose:
            define plot label separator depending on what was 
            selected in Plot Labels window
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'determinePlotLabelSeparator')
            
        if plotLabelSeparator == ', (comma+space)':
            separator = ', '
        elif plotLabelSeparator == '  (space)':
            separator = ' '
        elif plotLabelSeparator == '\ (backward slash)':
            separator = ' \\ '
        elif plotLabelSeparator == '/ (forward slash)':
            separator = ' / '
        elif plotLabelSeparator == '- (dash)':
            separator = ' - '
        elif plotLabelSeparator == '_ (underscore)':
            separator = ' _ '
        elif plotLabelSeparator == '+ (plus)':
            separator = ' + '
        elif plotLabelSeparator == '* (asterisk)':
            separator = ' * '
        elif plotLabelSeparator == '> (greater than)':
            separator = ' > '
        elif plotLabelSeparator == '< (less than)':
            separator = ' < '
        else:
            stringErrorSeparator = (
                'No plot label separator match found!\n\n' +
                '  string to match: ' + plotLabelSeparator + '\n\n' +
                'This is a coding error. Contact code administrator.'
                )
            print stringErrorSeparator
            self.MySQL_Output(
                0,
                stringErrorSeparator
                )
            showerror(
                'Error: no match',
                stringErrorSeparator
                )
            return
        
        return separator
        
        
    def handlerResetAllSingleCurvePerPlotBuffer(self):
        '''
        Purpose:
            Reset all values to default in the 
            'PLOT LABELS \n For Single Curve per Plot' window
            for Storage Buffer data
        '''
        '''
        self.comboboxPlotLabelSeparatorSingle.selectitem(
           self.separatorsPlotLabelsAndLegends[0]
           )
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerShowXYLabelsBuffer')
            
        if self.entryfieldXUserLabelSingleCurvePerPlotBuffer.get().strip() <> '':
            self.entryfieldXUserLabelSingleCurvePerPlotBuffer.setvalue('')
        if self.comboboxY1LabelSingleCurvePerPlotBuffer.get().strip() <> '':
            self.comboboxY1LabelSingleCurvePerPlotBuffer.setentry('')
        if self.comboboxY2LabelSingleCurvePerPlotBuffer.get().strip() <> '':
            self.comboboxY2LabelSingleCurvePerPlotBuffer.setentry('')
        if self.comboboxY3LabelSingleCurvePerPlotBuffer.get().strip() <> '':
            self.comboboxY3LabelSingleCurvePerPlotBuffer.setentry('')
        if self.entryfieldYUserLabelSingleCurvePerPlotBuffer.get().strip() <> '':
            self.entryfieldYUserLabelSingleCurvePerPlotBuffer.setvalue('')
        
        self.entryfieldXLabelShowBuffer.setvalue('')
        self.entryfieldYLabelShowBuffer.setvalue('')
       
        return

        
    def labels_AllCurvesOnePlot(self,xwin,ywin):
        '''
        Purpose:
            Generate legend labels for 'All Curves On One Plot' mode
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'labels_AllCurvesOnePlot')
            
        colorbg='lightblue'  
# open Toplevel frame for entering database name
        self.toplevelLegendLabelsAllCurvesOnePlot = Toplevel(
            self.toplevelXYPlotPreprocess,
            bg=colorbg,
            )
        self.toplevelLegendLabelsAllCurvesOnePlot.title(
            'LEGEND LABELS'
            )
#        self.toplevelLegendLabelsAllCurvesOnePlot.transient(self.toplevelTableValues)
        self.toplevelLegendLabelsAllCurvesOnePlot.transient(self.toplevelXYPlotPreprocess)
# place the top window
        x_Windows=xwin
        y_Windows=ywin
        self.toplevelLegendLabelsAllCurvesOnePlot.geometry(
            '+%d+%d' % (x_Windows, y_Windows)
            )  
            
# determine list of text fields in current table
        listOfTextFields = []
        for row in range(len(self.tableStructure)):
#            fieldType = self.tableStructure[row][1]
            myField, myDatatype, myNull, myKey, myDefault, myExtra = \
                self.tableStructure[row]
            varfirst2 = myDatatype[0:2]
# check if text
            fieldNameIsText = self.checkIsFieldText(varfirst2)
            if fieldNameIsText:
                listOfTextFields.append(myField)  


# FRAMES
# ... title
        Row = 0
        frame_00 = Frame(
            self.toplevelLegendLabelsAllCurvesOnePlot,
            bg='lightblue',
            )
        frame_00.grid(
            row=Row,
            column=0,
            padx=2,
            pady=2,
            )
# ... plot label separator
        Row += 1
        frame_10 = Frame(
            self.toplevelLegendLabelsAllCurvesOnePlot,
            bg='lightblue',
            )
        frame_10.grid(
            row=Row,
            column=0,
            padx=2,
            pady=2,
            )
# ... frame for TABLE data
        Row += 1
        frameTable = Frame(
            self.toplevelLegendLabelsAllCurvesOnePlot,
            bg='lightblue',
            relief=RIDGE,
            borderwidth=2,
            )
        frameTable.grid(
            row=Row,
            column=0,
            padx=2,
            pady=5,
            )
# ... frame for Buffer data
        Row += 1
        frameBuffer = Frame(
            self.toplevelLegendLabelsAllCurvesOnePlot,
            bg='lightblue',
            relief=RIDGE,
            borderwidth=2,
            )
        frameBuffer.grid(
            row=Row,
            column=0,
            padx=2,
            pady=5
            )
         
# frames for TABLE frame     
        refFrame = frameTable
# ... sub-title and legend defined
        Row = 0
        frame_00_Table = Frame(
            refFrame,
            bg='lightblue',
            )
        frame_00_Table.grid(
            row=Row,
            column=0,
            padx=2,
            pady=2,
            sticky=W,
            )
# ... legend label specified
        Row += 1
        frame_10_Table = Frame(
            refFrame,
            bg='lightblue',
            )
        frame_10_Table.grid(
            row=Row,
            column=0,
            padx=2,
            pady=2,
            )
# ...      preview first legend label 
        Row += 1
        frame_20_Table = Frame(
            refFrame,
            bg='lightblue',
            )
        frame_20_Table.grid(
            row=Row,
            column=0,
            padx=10,
            pady=2,
            sticky=W,
            )
# ... clear all
        Row += 1
        frame_30_Table = Frame(
            refFrame,
            bg='lightblue',
            )
        frame_30_Table.grid(
            row=Row,
            column=0,
            padx=2,
            pady=2,
            )

# ... frames for BUFFER frame
        refFrame = frameBuffer
# ... sub-title
        Row = 0
        frame_00_Buffer = Frame(
            refFrame,
            bg='lightblue',
            )
        frame_00_Buffer.grid(
            row=Row,
            column=0,
            padx=2,
            pady=2,
            sticky=W,
            )
# ... x-label
        Row += 1
        frame_10_Buffer = Frame(
            refFrame,
            bg='lightblue',
            )
        frame_10_Buffer.grid(
            row=Row,
            column=0,
            padx=2,
            pady=2,
            sticky=W,
            )
# ...       x-label defined
        Row += 1
        frame_20_Buffer = Frame(
            refFrame,
            bg='lightblue',
            )
        frame_20_Buffer.grid(
            row=Row,
            column=0,
            padx=10,
            pady=2,
            )
# ... y-label
        Row += 1
        frame_30_Buffer = Frame(
            refFrame,
            bg='lightblue',
            )
        frame_30_Buffer.grid(
            row=Row,
            column=0,
            padx=2,
            pady=2,
            )

# WIDGETS
# ... title
        label = Label(
            frame_00,
            text=(
                'LEGEND LABELS\n' +
                'For All Curves on One Plot\n'
                ),
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=0,
            padx=2,
            pady=2,
            )
# ... plot label separator
        label = Label(
            frame_10,
            text=(
                'Plot label separator: '
                ),
            bg=colorbg,
            justify=RIGHT,
            )
        label.grid(
            row=0,
            column=0,
            padx=5,
            pady=0,
            )
        self.comboboxLegendLabelSeparatorAll = Pmw.ComboBox(
            frame_10,
            scrolledlist_items=self.separatorsPlotLabelsAndLegends,
            listheight=190,
            entry_width=20,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxLegendLabelSeparatorAll.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            sticky=W,
            )
        self.comboboxLegendLabelSeparatorAll.selectitem(
           self.separatorsPlotLabelsAndLegends[0]
           )
           
# for Data from Table
# ... legend label defined
        label = Label(
            frame_00_Table,
            text=(
                'LEGEND LABELS FROM TABLE DATA\n\n' +
                ' '*5 + 'Table Y-select header' +
                ' + first values from Table text fields' +
                ' + user text'
                ),
            bg=colorbg,
            justify=LEFT,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )

# ...       legend label specified
        '''
        label = Label( 
            frame_10_Table,
            text=(
                'Y header'
                ),
            bg=colorbg,
            justify=RIGHT,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
        label = Label(
            frame_10_Table,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            )
        '''  
        self.varCheckbuttonYHeaderLabelAllCurvesOnOnePlotTable = IntVar()
        self.checkbuttonYHeaderLabelAllCurvesOnOnePlotTable = Checkbutton(
            frame_10_Table,
            text=' Y header + ',
            variable=self.varCheckbuttonYHeaderLabelAllCurvesOnOnePlotTable,
            bg=colorbg,
            relief=FLAT,
            )
        self.checkbuttonYHeaderLabelAllCurvesOnOnePlotTable.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
        self.varCheckbuttonYHeaderLabelAllCurvesOnOnePlotTable.set(1)
        
        tempListOfAllFields = []
        for number,field in enumerate(self.myDatabaseFields):
            tempListOfAllFields.append(str(number + 1) + '. ' + field)
            
        self.comboboxLegend1LabelAllCurvesOnOnePlotTable = Pmw.ComboBox(
            frame_10_Table,
#            scrolledlist_items=listOfTextFields,
            scrolledlist_items=tempListOfAllFields,
            listheight=150,
            entry_width=15,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxLegend1LabelAllCurvesOnOnePlotTable.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            )
        self.comboboxLegend1LabelAllCurvesOnOnePlotTable.setentry('')
        
        label = Label(
            frame_10_Table,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=2,
            padx=0,
            pady=0,
            )
            
        self.comboboxLegend2LabelAllCurvesOnOnePlotTable = Pmw.ComboBox(
            frame_10_Table,
#            scrolledlist_items=listOfTextFields,
            scrolledlist_items=tempListOfAllFields,
            listheight=150,
            entry_width=15,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxLegend2LabelAllCurvesOnOnePlotTable.grid(
            row=0,
            column=3,
            padx=0,
            pady=0,
            )
        self.comboboxLegend2LabelAllCurvesOnOnePlotTable.setentry('')
        
        label = Label(
            frame_10_Table,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=4,
            padx=0,
            pady=0,
            )
            
        self.comboboxLegend3LabelAllCurvesOnOnePlotTable = Pmw.ComboBox(
            frame_10_Table,
#            scrolledlist_items=listOfTextFields,
            scrolledlist_items=tempListOfAllFields,
            listheight=150,
            entry_width=15,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxLegend3LabelAllCurvesOnOnePlotTable.grid(
            row=0,
            column=5,
            padx=0,
            pady=0,
            )
        self.comboboxLegend3LabelAllCurvesOnOnePlotTable.setentry('')
        
        label = Label(
            frame_10_Table,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=1,
            column=1,
            padx=0,
            pady=0,
            sticky=E,
            )
            
        self.entryfieldLegendUserLabelAllCurvesOnOnePlotTable = Pmw.EntryField(
            frame_10_Table,
            entry_width=30,
            value='',
            )
        self.entryfieldLegendUserLabelAllCurvesOnOnePlotTable.grid(
            row=1,
            column=2,
            columnspan=3,
            padx=0,
            pady=2,
            sticky=W,
            )
        self.entryfieldLegendUserLabelAllCurvesOnOnePlotTable.setvalue('')
        
# ... show labels
# ...       show labels widgets
        label = Label(
            frame_20_Table,
            text='LEGEND LABEL: ',
            bg=colorbg,
            justify=RIGHT,
            )
        label.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            )
        self.entryfieldLegendLabelShowTable = Pmw.EntryField(
            frame_20_Table,
            entry_width=35,
            value='',
            entry_state='normal',
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            )
        self.entryfieldLegendLabelShowTable.grid(
            row=0,
            column=2,
            padx=0,
            pady=0,
            )
        self.entryfieldLegendLabelShowTable.setvalue('')
        
        buttonShowLegendLabelsTable = Button(
            frame_20_Table,
            text='Preview first legend label',
            width=22,
            font=self.buttonFontSmall,
            relief=RAISED,
            borderwidth=3,
            justify=CENTER,
            command=self.handlerShowLegendLabelsTable,
            )
        buttonShowLegendLabelsTable.grid(
            row=0,
            column=0,
            padx=5,
            pady=2,
            )
            
# ... reset all
        self.buttonResetAllLegendLabelsTable = Button(
            frame_30_Table,
            text='Clear all',
            width=12,
            bg='white',
            fg='blue',
            font=self.buttonFontSmall,
            relief=RAISED,
            borderwidth=3,
            justify=CENTER,
            command=self.handlerResetAllLegendLabelsTable,
            )
        self.buttonResetAllLegendLabelsTable.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
            
# for Data from Buffer
# ... legend label defined
        label = Label(
            frame_00_Buffer,
            text=(
                'LEGEND LABELS FROM BUFFER DATA\n\n' +
                ' '*5 + 'Buffer Y-select header' +
                ' + first values from Buffer text fields' +
                ' + user text'
                ),
            bg=colorbg,
            justify=LEFT,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )

# ...       legend label specified
        '''
        label = Label( 
            frame_10_Buffer,
            text=(
                'Y header'
                ),
            bg=colorbg,
            justify=RIGHT,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
        label = Label(
            frame_10_Buffer,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            )
        '''

        self.varCheckbuttonYHeaderLabelAllCurvesOnOnePlotBuffer = IntVar()
        self.checkbuttonYHeaderLabelAllCurvesOnOnePlotBuffer = Checkbutton(
            frame_10_Buffer,
            text=' Y header + ',
            variable=self.varCheckbuttonYHeaderLabelAllCurvesOnOnePlotBuffer,
            bg=colorbg,
            relief=FLAT,
            )
        self.checkbuttonYHeaderLabelAllCurvesOnOnePlotBuffer.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
        self.varCheckbuttonYHeaderLabelAllCurvesOnOnePlotBuffer.set(1)        
               
        self.comboboxLegend1LabelAllCurvesOnOnePlotBuffer = Pmw.ComboBox(
            frame_10_Buffer,
            scrolledlist_items=self.labelNamesBufferStorage,
            listheight=130,
            entry_width=15,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxLegend1LabelAllCurvesOnOnePlotBuffer.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            )
        self.comboboxLegend1LabelAllCurvesOnOnePlotBuffer.setentry('')
        
        label = Label(
            frame_10_Buffer,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=2,
            padx=0,
            pady=0,
            )
            
        self.comboboxLegend2LabelAllCurvesOnOnePlotBuffer = Pmw.ComboBox(
            frame_10_Buffer,
            scrolledlist_items=self.labelNamesBufferStorage,
            listheight=130,
            entry_width=15,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxLegend2LabelAllCurvesOnOnePlotBuffer.grid(
            row=0,
            column=3,
            padx=0,
            pady=0,
            )
        self.comboboxLegend2LabelAllCurvesOnOnePlotBuffer.setentry('')
        
        label = Label(
            frame_10_Buffer,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=4,
            padx=0,
            pady=0,
            )
            
        self.comboboxLegend3LabelAllCurvesOnOnePlotBuffer = Pmw.ComboBox(
            frame_10_Buffer,
            scrolledlist_items=self.labelNamesBufferStorage,
            listheight=130,
            entry_width=15,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxLegend3LabelAllCurvesOnOnePlotBuffer.grid(
            row=0,
            column=5,
            padx=0,
            pady=0,
            )
        self.comboboxLegend3LabelAllCurvesOnOnePlotBuffer.setentry('')
        
        label = Label(
            frame_10_Buffer,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=1,
            column=1,
            padx=0,
            pady=0,
            sticky=E
            )
            
        self.entryfieldLegendUserLabelAllCurvesOnOnePlotBuffer = Pmw.EntryField(
            frame_10_Buffer,
            entry_width=30,
            value='',
            )
        self.entryfieldLegendUserLabelAllCurvesOnOnePlotBuffer.grid(
            row=1,
            column=2,
            columnspan=3,
            padx=0,
            pady=2,
            sticky=W,
            )
        self.entryfieldLegendUserLabelAllCurvesOnOnePlotBuffer.setvalue('')
        
# ... show labels
# ...       show labels widgets
        label = Label(
            frame_20_Buffer,
            text='LEGEND LABEL: ',
            bg=colorbg,
            justify=RIGHT,
            )
        label.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            )
            
        self.entryfieldLegendLabelShowBuffer = Pmw.EntryField(
            frame_20_Buffer,
            entry_width=35,
            value='',
            entry_state='normal',
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            )
        self.entryfieldLegendLabelShowBuffer.grid(
            row=0,
            column=2,
            padx=0,
            pady=0,
            )
        self.entryfieldLegendLabelShowBuffer.setvalue('')
        
        buttonShowLegendLabelsBuffer = Button(
            frame_20_Buffer,
            text='Preview first legend label',
            width=22,
            font=self.buttonFontSmall,
            relief=RAISED,
            borderwidth=3,
            justify=CENTER,
            command=self.handlerShowLegendLabelsBuffer,
            )
        buttonShowLegendLabelsBuffer.grid(
            row=0,
            column=0,
            padx=5,
            pady=2,
            )
            
# ... reset all
        self.buttonResetAllLegendLabelsBuffer = Button(
            frame_30_Buffer,
            text='Clear all',
            width=12,
            bg='white',
            fg='blue',
            font=self.buttonFontSmall,
            relief=RAISED,
            borderwidth=3,
            justify=CENTER,
            command=self.handlerResetAllLegendLabelsBuffer,
            )
        self.buttonResetAllLegendLabelsBuffer.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )

# call 'Preview' handlers to show default labels
        self.handlerShowLegendLabelsTable_NoErrMsg()
        self.handlerShowLegendLabelsBuffer_NoErrMsg()

        return
        
        
    def labels_AllCurvesOnePlot_Scatter(self,xwin,ywin):
        '''
        Purpose:
            Generate legend labels for 'All Curves On One Plot' mode in Scatter Plots
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'labels_AllCurvesOnePlot_Scatter')
            
        colorbg='lightyellow'  
# open Toplevel frame for entering database name
        self.toplevelLegendLabelsAllCurvesOnePlot_Scatter = Toplevel(
            self.toplevelScatterPlotPreprocess,
            bg=colorbg,
            )
        self.toplevelLegendLabelsAllCurvesOnePlot_Scatter.title(
            'LEGEND LABELS'
            )
#        self.toplevelLegendLabelsAllCurvesOnePlot.transient(self.toplevelTableValues)
        self.toplevelLegendLabelsAllCurvesOnePlot_Scatter.transient(self.toplevelScatterPlotPreprocess)
# place the top window
        x_Windows=xwin
        y_Windows=ywin
        self.toplevelLegendLabelsAllCurvesOnePlot_Scatter.geometry(
            '+%d+%d' % (x_Windows, y_Windows)
            )  
            
# determine list of text fields in current table
        listOfTextFields = []
        for row in range(len(self.tableStructure)):
#            fieldType = self.tableStructure[row][1]
            myField, myDatatype, myNull, myKey, myDefault, myExtra = \
                self.tableStructure[row]
            varfirst2 = myDatatype[0:2]
# check if text
            fieldNameIsText = self.checkIsFieldText(varfirst2)
            if fieldNameIsText:
                listOfTextFields.append(myField)  


# FRAMES
# ... title
        Row = 0
        frame_00 = Frame(
            self.toplevelLegendLabelsAllCurvesOnePlot_Scatter,
            bg=colorbg,
            )
        frame_00.grid(
            row=Row,
            column=0,
            padx=2,
            pady=2,
            )
# ... plot label separator
        Row += 1
        frame_10 = Frame(
            self.toplevelLegendLabelsAllCurvesOnePlot_Scatter,
            bg=colorbg,
            )
        frame_10.grid(
            row=Row,
            column=0,
            padx=2,
            pady=2,
            )
# ... frame for TABLE data
        Row += 1
        frameTable = Frame(
            self.toplevelLegendLabelsAllCurvesOnePlot_Scatter,
            bg=colorbg,
            relief=RIDGE,
            borderwidth=2,
            )
        frameTable.grid(
            row=Row,
            column=0,
            padx=2,
            pady=5,
            )
# ... frame for Buffer data
        Row += 1
        frameBuffer = Frame(
            self.toplevelLegendLabelsAllCurvesOnePlot_Scatter,
            bg=colorbg,
            relief=RIDGE,
            borderwidth=2,
            )
        frameBuffer.grid(
            row=Row,
            column=0,
            padx=2,
            pady=5
            )
         
# frames for TABLE frame     
        refFrame = frameTable
# ... sub-title and legend defined
        Row = 0
        frame_00_Table = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_00_Table.grid(
            row=Row,
            column=0,
            padx=2,
            pady=2,
            sticky=W,
            )
# ... legend label specified
        Row += 1
        frame_10_Table = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_10_Table.grid(
            row=Row,
            column=0,
            padx=2,
            pady=2,
            )
# ...      preview first legend label 
        Row += 1
        frame_20_Table = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_20_Table.grid(
            row=Row,
            column=0,
            padx=10,
            pady=2,
            sticky=W,
            )
# ... clear all
        Row += 1
        frame_30_Table = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_30_Table.grid(
            row=Row,
            column=0,
            padx=2,
            pady=2,
            )

# ... frames for BUFFER frame
        refFrame = frameBuffer
# ... sub-title
        Row = 0
        frame_00_Buffer = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_00_Buffer.grid(
            row=Row,
            column=0,
            padx=2,
            pady=2,
            sticky=W,
            )
# ... x-label
        Row += 1
        frame_10_Buffer = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_10_Buffer.grid(
            row=Row,
            column=0,
            padx=2,
            pady=2,
            sticky=W,
            )
# ...       x-label defined
        Row += 1
        frame_20_Buffer = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_20_Buffer.grid(
            row=Row,
            column=0,
            padx=10,
            pady=2,
            )
# ... y-label
        Row += 1
        frame_30_Buffer = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_30_Buffer.grid(
            row=Row,
            column=0,
            padx=2,
            pady=2,
            )

# WIDGETS
# ... title
        label = Label(
            frame_00,
            text=(
                'LEGEND LABELS\n' +
                'For All Curves on Scatter Plot\n'
                ),
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=0,
            padx=2,
            pady=2,
            )
# ... plot label separator
        label = Label(
            frame_10,
            text=(
                'Plot label separator: '
                ),
            bg=colorbg,
            justify=RIGHT,
            )
        label.grid(
            row=0,
            column=0,
            padx=5,
            pady=0,
            )
        self.comboboxLegendLabelSeparatorAll_Scatter = Pmw.ComboBox(
            frame_10,
            scrolledlist_items=self.separatorsPlotLabelsAndLegends,
            listheight=190,
            entry_width=20,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxLegendLabelSeparatorAll_Scatter.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            sticky=W,
            )
        self.comboboxLegendLabelSeparatorAll_Scatter.selectitem(
           self.separatorsPlotLabelsAndLegends[0]
           )
           
# for Data from Table
# ... legend label defined
        label = Label(
            frame_00_Table,
            text=(
                'LEGEND LABELS FROM TABLE DATA\n\n' +
                ' '*5 + 'Table Y-select header' +
                ' + first values from Table text fields' +
                ' + user text'
                ),
            bg=colorbg,
            justify=LEFT,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )

# ...       legend label specified
        '''
        label = Label( 
            frame_10_Table,
            text=(
                'Y header'
                ),
            bg=colorbg,
            justify=RIGHT,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
        label = Label(
            frame_10_Table,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            )
        '''  
        self.varCheckbuttonYHeaderLabelAllCurvesOnOnePlotTable_Scatter = IntVar()
        self.checkbuttonYHeaderLabelAllCurvesOnOnePlotTable_Scatter = Checkbutton(
            frame_10_Table,
            text=' Y header + ',
            variable=self.varCheckbuttonYHeaderLabelAllCurvesOnOnePlotTable_Scatter,
            bg=colorbg,
            relief=FLAT,
            )
        self.checkbuttonYHeaderLabelAllCurvesOnOnePlotTable_Scatter.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
        self.varCheckbuttonYHeaderLabelAllCurvesOnOnePlotTable_Scatter.set(1)
        
        tempListOfAllFields = []
        for number,field in enumerate(self.myDatabaseFields):
            tempListOfAllFields.append(str(number + 1) + '. ' + field)       
            
        self.comboboxLegend1LabelAllCurvesOnOnePlotTable_Scatter = Pmw.ComboBox(
            frame_10_Table,
            scrolledlist_items=tempListOfAllFields,
            listheight=150,
            entry_width=15,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxLegend1LabelAllCurvesOnOnePlotTable_Scatter.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            )
        self.comboboxLegend1LabelAllCurvesOnOnePlotTable_Scatter.setentry('')
        
        label = Label(
            frame_10_Table,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=2,
            padx=0,
            pady=0,
            )
            
        self.comboboxLegend2LabelAllCurvesOnOnePlotTable_Scatter = Pmw.ComboBox(
            frame_10_Table,
            scrolledlist_items=tempListOfAllFields,
            listheight=150,
            entry_width=15,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxLegend2LabelAllCurvesOnOnePlotTable_Scatter.grid(
            row=0,
            column=3,
            padx=0,
            pady=0,
            )
        self.comboboxLegend2LabelAllCurvesOnOnePlotTable_Scatter.setentry('')
        
        label = Label(
            frame_10_Table,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=4,
            padx=0,
            pady=0,
            )
            
        self.comboboxLegend3LabelAllCurvesOnOnePlotTable_Scatter = Pmw.ComboBox(
            frame_10_Table,
            scrolledlist_items=tempListOfAllFields,
            listheight=150,
            entry_width=15,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxLegend3LabelAllCurvesOnOnePlotTable_Scatter.grid(
            row=0,
            column=5,
            padx=0,
            pady=0,
            )
        self.comboboxLegend3LabelAllCurvesOnOnePlotTable_Scatter.setentry('')
        
        label = Label(
            frame_10_Table,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=1,
            column=1,
            padx=0,
            pady=0,
            sticky=E,
            )
            
        self.entryfieldLegendUserLabelAllCurvesOnOnePlotTable_Scatter = Pmw.EntryField(
            frame_10_Table,
            entry_width=30,
            value='',
            )
        self.entryfieldLegendUserLabelAllCurvesOnOnePlotTable_Scatter.grid(
            row=1,
            column=2,
            columnspan=3,
            padx=0,
            pady=2,
            sticky=W,
            )
        self.entryfieldLegendUserLabelAllCurvesOnOnePlotTable_Scatter.setvalue('')
        
# ... show labels
# ...       show labels widgets
        label = Label(
            frame_20_Table,
            text='LEGEND LABEL: ',
            bg=colorbg,
            justify=RIGHT,
            )
        label.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            )
            
        self.entryfieldLegendLabelShowTable_Scatter = Pmw.EntryField(
            frame_20_Table,
            entry_width=35,
            value='',
            entry_state='normal',
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            )
        self.entryfieldLegendLabelShowTable_Scatter.grid(
            row=0,
            column=2,
            padx=0,
            pady=0,
            )
        self.entryfieldLegendLabelShowTable_Scatter.setvalue('')
        
        buttonShowLegendLabelsTable_Scatter = Button(
            frame_20_Table,
            text='Preview first legend label',
            width=22,
            font=self.buttonFontSmall,
            relief=RAISED,
            borderwidth=3,
            justify=CENTER,
            command=self.handlerShowLegendLabelsTable_Scatter,
            )
        buttonShowLegendLabelsTable_Scatter.grid(
            row=0,
            column=0,
            padx=5,
            pady=2,
            )
# ... reset all
        self.buttonResetAllLegendLabelsTable_Scatter = Button(
            frame_30_Table,
            text='Clear all',
            width=12,
            bg='white',
            fg='blue',
            font=self.buttonFontSmall,
            relief=RAISED,
            borderwidth=3,
            justify=CENTER,
            command=self.handlerResetAllLegendLabelsTable_Scatter,
            )
        self.buttonResetAllLegendLabelsTable_Scatter.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
            
# for Data from Buffer
# ... legend label defined
        label = Label(
            frame_00_Buffer,
            text=(
                'LEGEND LABELS FROM BUFFER DATA\n\n' +
                ' '*5 + 'Buffer Y-select header' +
                ' + first values from Buffer text fields' +
                ' + user text'
                ),
            bg=colorbg,
            justify=LEFT,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )

# ...       legend label specified
        '''
        label = Label( 
            frame_10_Buffer,
            text=(
                'Y header'
                ),
            bg=colorbg,
            justify=RIGHT,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
        label = Label(
            frame_10_Buffer,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            )
        '''

        self.varCheckbuttonYHeaderLabelAllCurvesOnOnePlotBuffer_Scatter = IntVar()
        self.checkbuttonYHeaderLabelAllCurvesOnOnePlotBuffer_Scatter = Checkbutton(
            frame_10_Buffer,
            text=' Y header + ',
            variable=self.varCheckbuttonYHeaderLabelAllCurvesOnOnePlotBuffer_Scatter,
            bg=colorbg,
            relief=FLAT,
            )
        self.checkbuttonYHeaderLabelAllCurvesOnOnePlotBuffer_Scatter.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
        self.varCheckbuttonYHeaderLabelAllCurvesOnOnePlotBuffer_Scatter.set(1)        
               
        self.comboboxLegend1LabelAllCurvesOnOnePlotBuffer_Scatter = Pmw.ComboBox(
            frame_10_Buffer,
            scrolledlist_items=self.labelNamesBufferStorage,
            listheight=130,
            entry_width=15,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxLegend1LabelAllCurvesOnOnePlotBuffer_Scatter.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            )
        self.comboboxLegend1LabelAllCurvesOnOnePlotBuffer_Scatter.setentry('')
        
        label = Label(
            frame_10_Buffer,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=2,
            padx=0,
            pady=0,
            )
            
        self.comboboxLegend2LabelAllCurvesOnOnePlotBuffer_Scatter = Pmw.ComboBox(
            frame_10_Buffer,
            scrolledlist_items=self.labelNamesBufferStorage,
            listheight=130,
            entry_width=15,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxLegend2LabelAllCurvesOnOnePlotBuffer_Scatter.grid(
            row=0,
            column=3,
            padx=0,
            pady=0,
            )
        self.comboboxLegend2LabelAllCurvesOnOnePlotBuffer_Scatter.setentry('')
        
        label = Label(
            frame_10_Buffer,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=4,
            padx=0,
            pady=0,
            )
            
        self.comboboxLegend3LabelAllCurvesOnOnePlotBuffer_Scatter = Pmw.ComboBox(
            frame_10_Buffer,
            scrolledlist_items=self.labelNamesBufferStorage,
            listheight=130,
            entry_width=15,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxLegend3LabelAllCurvesOnOnePlotBuffer_Scatter.grid(
            row=0,
            column=5,
            padx=0,
            pady=0,
            )
        self.comboboxLegend3LabelAllCurvesOnOnePlotBuffer_Scatter.setentry('')
        
        label = Label(
            frame_10_Buffer,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=1,
            column=1,
            padx=0,
            pady=0,
            sticky=E
            )
            
        self.entryfieldLegendUserLabelAllCurvesOnOnePlotBuffer_Scatter = Pmw.EntryField(
            frame_10_Buffer,
            entry_width=30,
            value='',
            )
        self.entryfieldLegendUserLabelAllCurvesOnOnePlotBuffer_Scatter.grid(
            row=1,
            column=2,
            columnspan=3,
            padx=0,
            pady=2,
            sticky=W,
            )
        self.entryfieldLegendUserLabelAllCurvesOnOnePlotBuffer_Scatter.setvalue('')
        
# ... show labels
# ...       show labels widgets
        label = Label(
            frame_20_Buffer,
            text='LEGEND LABEL: ',
            bg=colorbg,
            justify=RIGHT,
            )
        label.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            )
            
        self.entryfieldLegendLabelShowBuffer_Scatter = Pmw.EntryField(
            frame_20_Buffer,
            entry_width=35,
            value='',
            entry_state='normal',
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            )
        self.entryfieldLegendLabelShowBuffer_Scatter.grid(
            row=0,
            column=2,
            padx=0,
            pady=0,
            )
        self.entryfieldLegendLabelShowBuffer_Scatter.setvalue('')
        buttonShowLegendLabelsBuffer = Button(
            frame_20_Buffer,
            text='Preview first legend label',
            width=22,
            font=self.buttonFontSmall,
            relief=RAISED,
            borderwidth=3,
            justify=CENTER,
            command=self.handlerShowLegendLabelsBuffer_Scatter,
            )
        buttonShowLegendLabelsBuffer.grid(
            row=0,
            column=0,
            padx=5,
            pady=2,
            )
# ... reset all
        self.buttonResetAllLegendLabelsBuffer_Scatter = Button(
            frame_30_Buffer,
            text='Clear all',
            width=12,
            bg='white',
            fg='blue',
            font=self.buttonFontSmall,
            relief=RAISED,
            borderwidth=3,
            justify=CENTER,
            command=self.handlerResetAllLegendLabelsBuffer_Scatter,
            )
        self.buttonResetAllLegendLabelsBuffer_Scatter.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )

# call 'Preview' handlers to show default labels
        self.handlerShowLegendLabelsTable_NoErrMsg_Scatter()
        self.handlerShowLegendLabelsBuffer_NoErrMsg_Scatter()

        return

      
    def handlerShowLegendLabelsTable(self):
        '''
        Purpose:
            - For all curves on one plot in one window
            Preview first legend label from Table in 'Legend Labels' window
            with error msg.
            Only Y-headers needed to form legend labels; X-Headers are not needed.
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerShowLegendLabelsTable')
            
# error message
        if self.varNumberOfTableCurves.get() == 0:
            stringNoTableRowsSelected = (
                'No data have been selected from the current table\n' +
                'for plotting.\n\n' +
                'Please select at least one data pair and try again.'
                )
            print stringNoTableRowsSelected
            self.MySQL_Output(
                0,
                stringNoTableRowsSelected
                )
            try:
                showerror(
                    'Error: no data',
                    stringNoTableRowsSelected,
                    parent=self.toplevelLegendLabelsAllCurvesOnePlot,
                    )
            except:
                showerror(
                    'Error: no data',
                    stringNoTableRowsSelected
                    )
            return
 
# determine y index and header
        '''
        i = 0
        j = 0
        yHeaders = []
        index_Y = []
        for var in self.varYSelect:
            if var.get():
                index_Y.append(j)
                yHeaders.append(self.tableStructure[index_Y[i]][0])
                i += 1
            j+=1 
        '''
        yHeaders = self.headerNames_Y_Table
        
        if DEBUG_XY_LABELS:
            print('\nyHeaders for X-Y plots in handlerShowLegendLabelsTable:\n')
            print(yHeaders)

# determine plot label separator
        separator = self.determinePlotLabelSeparator(
            self.comboboxLegendLabelSeparatorAll.get()
            )
            
        if DEBUG_XY_LABELS:
            print('-'*80)
            print('\n\n*** In ' + MODULE + '/' + 'handlerShowLegendLabelsTable ***')
            print('self.headerNames_X_Table =\n%s' % self.headerNames_X_Table)
            print('self.headerNames_Y_Table =\n%s' % self.headerNames_Y_Table)
            print '-'*80
        
# concatenate Y-label strings
        self.legendLabelStringTable = []
        for header in yHeaders:
            legendLabelString = ''
            if self.varCheckbuttonYHeaderLabelAllCurvesOnOnePlotTable.get():
                legendLabelString = header
            if self.comboboxLegend1LabelAllCurvesOnOnePlotTable.get().strip() <> '':
#                field1 = self.comboboxLegend1LabelAllCurvesOnOnePlotTable.get().split('.')[1].strip()
                field1 = self.comboboxLegend1LabelAllCurvesOnOnePlotTable.get().strip()
                for key,value in self.dictColumnHeaders.iteritems():
                    if key == field1:
                        if(
                        self.tableValues[0][value-1] <> None
                        and
                        self.tableValues[0][value-1] <> ''
                        ):
                            if legendLabelString <> '':
                                legendLabelString += separator + str(self.tableValues[0][value-1])
                            else:
                                legendLabelString = str(self.tableValues[0][value-1])
                            break
                        else:
                            stringNoValue = (
                                'No value associated with field\n' +
                                '  - %s\n\n' +
                                'Select another field.'
                                ) % (
                                key
                                )
                            print('\n' + stringNoValue)
                            self.MySQL_Output(
                                0,
                                stringNoValue
                                )
                            try:
                                showerror(
                                    'Error: no value',
                                    stringNoValue,
                                    parent=self.toplevelXYPlotPreprocess
                                    )
                            except:
                                showerror(
                                    'Error: no value',
                                    stringNoValue
                                    )
                            return
            if self.comboboxLegend2LabelAllCurvesOnOnePlotTable.get().strip() <> '':
#                field2 = self.comboboxLegend2LabelAllCurvesOnOnePlotTable.get().split('.')[1].strip()                
                field2 = self.comboboxLegend2LabelAllCurvesOnOnePlotTable.get().strip()                
                for key,value in self.dictColumnHeaders.iteritems():
                    if key == field2:
                        if(
                        self.tableValues[0][value-1] <> None
                        and
                        self.tableValues[0][value-1] <> ''
                        ):
                            if legendLabelString <> '':
                                legendLabelString += separator + str(self.tableValues[0][value-1])
                            else:
                                legendLabelString = str(self.tableValues[0][value-1])
                            break
                        else:
                            stringNoValue = (
                                'No value associated with field\n' +
                                '  - %s\n\n' +
                                'Select another field.'
                                ) % (
                                key
                                )
                            print('\n' + stringNoValue)
                            self.MySQL_Output(
                                0,
                                stringNoValue
                                )
                            try:
                                showerror(
                                    'Error: no value',
                                    stringNoValue,
                                    parent=self.toplevelXYPlotPreprocess
                                    )
                            except:
                                showerror(
                                    'Error: no value',
                                    stringNoValue
                                    )
                            return
            if self.comboboxLegend3LabelAllCurvesOnOnePlotTable.get().strip() <> '':
#                field3 = self.comboboxLegend3LabelAllCurvesOnOnePlotTable.get().split('.')[1].strip()
                field3 = self.comboboxLegend3LabelAllCurvesOnOnePlotTable.get().strip()
                for key,value in self.dictColumnHeaders.iteritems():
                    if key == field3:
                        if(
                        self.tableValues[0][value-1] <> None
                        and
                        self.tableValues[0][value-1] <> ''
                        ):
                            if legendLabelString <> '':
                                legendLabelString += separator + str(self.tableValues[0][value-1])
                            else:
                                legendLabelString = str(self.tableValues[0][value-1])
                            break
                        else:
                            stringNoValue = (
                                'No value associated with field\n' +
                                '  - %s\n\n' +
                                'Select another field.'
                                ) % (
                                key
                                )
                            print('\n' + stringNoValue)
                            self.MySQL_Output(
                                0,
                                stringNoValue
                                )
                            try:
                                showerror(
                                    'Error: no value',
                                    stringNoValue,
                                    parent=self.toplevelXYPlotPreprocess
                                    )
                            except:
                                showerror(
                                    'Error: no value',
                                    stringNoValue
                                    )
                            return
                            
            if self.entryfieldLegendUserLabelAllCurvesOnOnePlotTable.get().strip() <> '':
                if legendLabelString <> '':
                    legendLabelString += separator + self.entryfieldLegendUserLabelAllCurvesOnOnePlotTable.get().strip()
                else:
                    legendLabelString = self.entryfieldLegendUserLabelAllCurvesOnOnePlotTable.get().strip()
            
            self.legendLabelStringTable.append(legendLabelString)
            
# show string in LEGEND LABEL field
        self.entryfieldLegendLabelShowTable.setvalue(self.legendLabelStringTable[0])
                 
        return
        
        
    def handlerShowLegendLabelsTable_Scatter(self):
        '''
        Purpose:
            Preview first legend label from Table in 'Legend Labels' window for scatter plots,
            with error msg.
            Only Y-headers needed to form legend labels; X-Headers are not needed.
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerShowLegendLabelsTable_Scatter')
            
# error message
        if self.varNumberOfTableCurves_Scatter.get() == 0:
            stringNoTableRowsSelected = (
                'No data have been selected from the current table\n' +
                'for plotting.\n\n' +
                'Please select at least one data pair and try again.'
                )
            print stringNoTableRowsSelected
            self.MySQL_Output(
                0,
                stringNoTableRowsSelected
                )
            try:
                showerror(
                    'Error: no data',
                    stringNoTableRowsSelected,
                    parent=self.toplevelLegendLabelsAllCurvesOnePlot_Scatter,
                    )
            except:
                showerror(
                    'Error: no data',
                    stringNoTableRowsSelected
                    )
            return
 
# determine y index and header
        yHeaders = []
        yHeaders.extend(self.headerNames_Y_Table_Scatter)
        
        if DEBUG_SCATTER_LEGEND:
            print('\nyHeaders in handlerShowLegendLabelsTable_Scatter:\n%s\n' % yHeaders)

# determine plot label separator
        separator = self.determinePlotLabelSeparator(
            self.comboboxLegendLabelSeparatorAll_Scatter.get()
            )
        
# concatenate Y-label strings
        self.legendLabelStringTable_Scatter= []
        for header in yHeaders:
            legendLabelString = ''
            if self.varCheckbuttonYHeaderLabelAllCurvesOnOnePlotTable_Scatter.get():
                legendLabelString = header
            if self.comboboxLegend1LabelAllCurvesOnOnePlotTable_Scatter.get().strip() <> '':
#                field1 = self.comboboxLegend1LabelAllCurvesOnOnePlotTable_Scatter.get().split('.')[1].strip()
                field1 = self.comboboxLegend1LabelAllCurvesOnOnePlotTable_Scatter.get().strip()
                for key,value in self.dictColumnHeaders.iteritems():
                    if key == field1:
                        if(
                        self.tableValues[0][value-1] <> None
                        and
                        self.tableValues[0][value-1] <> ''
                        ):
                            if legendLabelString <> '':
                                legendLabelString += separator + str(self.tableValues[0][value-1])
                            else:
                                legendLabelString = str(self.tableValues[0][value-1])
                            break
                        else:
                            stringNoValue = (
                                'No value associated with field\n' +
                                '  - %s\n\n' +
                                'Select another field.'
                                ) % (
                                key
                                )
                            print('\n' + stringNoValue)
                            self.MySQL_Output(
                                0,
                                stringNoValue
                                )
                            try:
                                showerror(
                                    'Error: no value',
                                    stringNoValue,
                                    parent=self.toplevelXYPlotPreprocess
                                    )
                            except:
                                showerror(
                                    'Error: no value',
                                    stringNoValue
                                    )
                            return
            if self.comboboxLegend2LabelAllCurvesOnOnePlotTable_Scatter.get().strip() <> '':
#                field2 = self.comboboxLegend2LabelAllCurvesOnOnePlotTable_Scatter.get().split('.')[1].strip()
                field2 = self.comboboxLegend2LabelAllCurvesOnOnePlotTable_Scatter.get().strip()
                for key,value in self.dictColumnHeaders.iteritems():
                    if key == field2:
                        if(
                        self.tableValues[0][value-1] <> None
                        and
                        self.tableValues[0][value-1] <> ''
                        ):
                            if legendLabelString <> '':
                                legendLabelString += separator + str(self.tableValues[0][value-1])
                            else:
                                legendLabelString = str(self.tableValues[0][value-1])
                            break
                        else:
                            stringNoValue = (
                                'No value associated with field\n' +
                                '  - %s\n\n' +
                                'Select another field.'
                                ) % (
                                key
                                )
                            print('\n' + stringNoValue)
                            self.MySQL_Output(
                                0,
                                stringNoValue
                                )
                            try:
                                showerror(
                                    'Error: no value',
                                    stringNoValue,
                                    parent=self.toplevelScatterPlotPreprocess
                                    )
                            except:
                                showerror(
                                    'Error: no value',
                                    stringNoValue
                                    )
                            return
            if self.comboboxLegend3LabelAllCurvesOnOnePlotTable_Scatter.get().strip() <> '':
#                field3 = self.comboboxLegend3LabelAllCurvesOnOnePlotTable_Scatter.get().split('.')[1].strip()
                field3 = self.comboboxLegend3LabelAllCurvesOnOnePlotTable_Scatter.get().strip()
                for key,value in self.dictColumnHeaders.iteritems():
                    if key == field3:
                        if(
                        self.tableValues[0][value-1] <> None
                        and
                        self.tableValues[0][value-1] <> ''
                        ):
                            if legendLabelString <> '':
                                legendLabelString += separator + str(self.tableValues[0][value-1])
                            else:
                                legendLabelString = str(self.tableValues[0][value-1])
                            break
                        else:
                            stringNoValue = (
                                'No value associated with field\n' +
                                '  - %s\n\n' +
                                'Select another field.'
                                ) % (
                                key
                                )
                            print('\n' + stringNoValue)
                            self.MySQL_Output(
                                0,
                                stringNoValue
                                )
                            try:
                                showerror(
                                    'Error: no value',
                                    stringNoValue,
                                    parent=self.toplevelScatterPlotPreprocess
                                    )
                            except:
                                showerror(
                                    'Error: no value',
                                    stringNoValue
                                    )
                            return
                            
            if self.entryfieldLegendUserLabelAllCurvesOnOnePlotTable_Scatter.get().strip() <> '':
                if legendLabelString <> '':
                    legendLabelString += separator + self.entryfieldLegendUserLabelAllCurvesOnOnePlotTable_Scatter.get().strip()
                else:
                    legendLabelString = self.entryfieldLegendUserLabelAllCurvesOnOnePlotTable_Scatter.get().strip()
            
            self.legendLabelStringTable_Scatter.append(legendLabelString)
            
# show string in LEGEND LABEL field
        if DEBUG_SCATTER_LEGEND:
            print('\nself.legendLabelStringTable_Scatter =')
            print(self.legendLabelStringTable_Scatter)
        
        self.entryfieldLegendLabelShowTable_Scatter.setvalue(self.legendLabelStringTable_Scatter[0])
                 
        return
        
                
    def handlerShowLegendLabelsTable_NoErrMsg(self):
        '''
        Purpose:
            Preview first legend label from Table in 'Legend Labels' window for x-y plots.
            Only Y-headers needed to form legend labels; X-Headers are not needed.
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerShowLegendLabelsTable_NoErrMsg')
            
# determine y index and header
        i = 0
        j = 0
        yHeaders = []
        index_Y = []
        for var in self.varYSelect:
            if var.get():
                index_Y.append(j)
                yHeaders.append(self.tableStructure[index_Y[i]][0])
                i += 1
            j+=1  

# ERROR CHECK
# ... if no headers have been chosen, then just return
        if yHeaders == []:
            return

# determine plot label separator
        separator = self.determinePlotLabelSeparator(
            self.comboboxLegendLabelSeparatorAll.get()
            )
        
# concatenate Y-label strings
        self.legendLabelStringTable = []
        for header in yHeaders:
            legendLabelString = ''
            if self.varCheckbuttonYHeaderLabelAllCurvesOnOnePlotTable.get():
                legendLabelString = header
            if self.comboboxLegend1LabelAllCurvesOnOnePlotTable.get().strip() <> '':
#                field1 = self.comboboxLegend1LabelAllCurvesOnOnePlotTable.get().split('.')[1].strip()
                field1 = self.comboboxLegend1LabelAllCurvesOnOnePlotTable.get().strip()
                for key,value in self.dictColumnHeaders.iteritems():
                    if key == field1:
                        if(
                        self.tableValues[0][value-1] <> None
                        and
                        self.tableValues[0][value-1] <> ''
                        ):
                            if legendLabelString <> '':
                                legendLabelString += separator + str(self.tableValues[0][value-1])
                            else:
                                legendLabelString = str(self.tableValues[0][value-1])
                            break
                        else:
                            stringNoValue = (
                                'No value associated with field\n' +
                                '  - %s\n\n' +
                                'Select another field.'
                                ) % (
                                key
                                )
                            print('\n' + stringNoValue)
                            self.MySQL_Output(
                                0,
                                stringNoValue
                                )
                            try:
                                showerror(
                                    'Error: no value',
                                    stringNoValue,
                                    parent=self.toplevelXYPlotPreprocess
                                    )
                            except:
                                showerror(
                                    'Error: no value',
                                    stringNoValue
                                    )
                            return
            if self.comboboxLegend2LabelAllCurvesOnOnePlotTable.get().strip() <> '':
#                field2 = self.comboboxLegend2LabelAllCurvesOnOnePlotTable.get().split('.')[1].strip()
                field2 = self.comboboxLegend2LabelAllCurvesOnOnePlotTable.get().strip()
                for key,value in self.dictColumnHeaders.iteritems():
                    if key == field2:
                        if(
                        self.tableValues[0][value-1] <> None
                        and
                        self.tableValues[0][value-1] <> ''
                        ):
                            if legendLabelString <> '':
                                legendLabelString += separator + str(self.tableValues[0][value-1])
                            else:
                                legendLabelString = str(self.tableValues[0][value-1])
                            break
                        else:
                            stringNoValue = (
                                'No value associated with field\n' +
                                '  - %s\n\n' +
                                'Select another field.'
                                ) % (
                                key
                                )
                            print('\n' + stringNoValue)
                            self.MySQL_Output(
                                0,
                                stringNoValue
                                )
                            try:
                                showerror(
                                    'Error: no value',
                                    stringNoValue,
                                    parent=self.toplevelXYPlotPreprocess
                                    )
                            except:
                                showerror(
                                    'Error: no value',
                                    stringNoValue
                                    )
                            return
            if self.comboboxLegend3LabelAllCurvesOnOnePlotTable.get().strip() <> '':
#                field3 = self.comboboxLegend3LabelAllCurvesOnOnePlotTable.get().split('.')[1].strip()
                field3 = self.comboboxLegend3LabelAllCurvesOnOnePlotTable.get().strip()
                for key,value in self.dictColumnHeaders.iteritems():
                    if key == field3:
                        if(
                        self.tableValues[0][value-1] <> None
                        and
                        self.tableValues[0][value-1] <> ''
                        ):
                            if legendLabelString <> '':
                                legendLabelString += separator + str(self.tableValues[0][value-1])
                            else:
                                legendLabelString = str(self.tableValues[0][value-1])
                            break
                        else:
                            stringNoValue = (
                                'No value associated with field\n' +
                                '  - %s\n\n' +
                                'Select another field.'
                                ) % (
                                key
                                )
                            print('\n' + stringNoValue)
                            self.MySQL_Output(
                                0,
                                stringNoValue
                                )
                            try:
                                showerror(
                                    'Error: no value',
                                    stringNoValue,
                                    parent=self.toplevelXYPlotPreprocess
                                    )
                            except:
                                showerror(
                                    'Error: no value',
                                    stringNoValue
                                    )
                            return
            if self.entryfieldLegendUserLabelAllCurvesOnOnePlotTable.get().strip() <> '':
                if legendLabelString <> '':
                    legendLabelString += separator + self.entryfieldLegendUserLabelAllCurvesOnOnePlotTable.get().strip()
                else:
                    legendLabelString = self.entryfieldLegendUserLabelAllCurvesOnOnePlotTable.get().strip()
            
            self.legendLabelStringTable.append(legendLabelString)
            
# show string in LEGEND LABEL field
        self.entryfieldLegendLabelShowTable.setvalue(self.legendLabelStringTable[0])
                 
        return
        
        
    def handlerShowLegendLabelsTable_NoErrMsg_Scatter(self):
        '''
        Purpose:
            Preview first legend label from Table in 'Legend Labels' window for scatter plots.
            Only Y-headers needed to form legend labels; X-Headers are not needed.
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerShowLegendLabelsTable_NoErrMsg_Scatter')
            
# determine y index and header
        i = 0
        j = 0
        yHeaders = []
        index_Y = []
        for var in self.varYSelect:
            if var.get():
                index_Y.append(j)
                yHeaders.append(self.tableStructure[index_Y[i]][0])
                i += 1
            j+=1  

# ERROR CHECK
# ... if no headers have been chosen, then just return
        if yHeaders == []:
            return

# determine plot label separator
        separator = self.determinePlotLabelSeparator(
            self.comboboxLegendLabelSeparatorAll_Scatter.get()
            )
        
# concatenate Y-label strings
        self.legendLabelStringTable_Scatter = []
        for header in yHeaders:
            legendLabelString = ''
            if self.varCheckbuttonYHeaderLabelAllCurvesOnOnePlotTable_Scatter.get():
                legendLabelString = header
            if self.comboboxLegend1LabelAllCurvesOnOnePlotTable_Scatter.get().strip() <> '':
#                field1 = self.comboboxLegend1LabelAllCurvesOnOnePlotTable_Scatter.get().split('.')[1].strip()
                field1 = self.comboboxLegend1LabelAllCurvesOnOnePlotTable_Scatter.get().strip()
                for key,value in self.dictColumnHeaders.iteritems():
                    if key == field1:
                        if(
                        self.tableValues[0][value-1] <> None
                        and
                        self.tableValues[0][value-1] <> ''
                        ):
                            if legendLabelString <> '':
                                legendLabelString += separator + str(self.tableValues[0][value-1])
                            else:
                                legendLabelString = str(self.tableValues[0][value-1])
                            break
                        else:
                            stringNoValue = (
                                'No value associated with field\n' +
                                '  - %s\n\n' +
                                'Select another field.'
                                ) % (
                                key
                                )
                            print('\n' + stringNoValue)
                            self.MySQL_Output(
                                0,
                                stringNoValue
                                )
                            try:
                                showerror(
                                    'Error: no value',
                                    stringNoValue,
                                    parent=self.toplevelScatterPlotPreprocess
                                    )
                            except:
                                showerror(
                                    'Error: no value',
                                    stringNoValue
                                    )
                            return
                            
            if self.comboboxLegend2LabelAllCurvesOnOnePlotTable_Scatter.get().strip() <> '':
#                field2 = self.comboboxLegend2LabelAllCurvesOnOnePlotTable_Scatter.get().split('.')[1].strip()
                field2 = self.comboboxLegend2LabelAllCurvesOnOnePlotTable_Scatter.get().strip()
                for key,value in self.dictColumnHeaders.iteritems():
                    if key == field2:
                        if(
                        self.tableValues[0][value-1] <> None
                        and
                        self.tableValues[0][value-1] <> ''
                        ):
                            if legendLabelString <> '':
                                legendLabelString += separator + str(self.tableValues[0][value-1])
                            else:
                                legendLabelString = str(self.tableValues[0][value-1])
                            break
                        else:
                            stringNoValue = (
                                'No value associated with field\n' +
                                '  - %s\n\n' +
                                'Select another field.'
                                ) % (
                                key
                                )
                            print('\n' + stringNoValue)
                            self.MySQL_Output(
                                0,
                                stringNoValue
                                )
                            try:
                                showerror(
                                    'Error: no value',
                                    stringNoValue,
                                    parent=self.toplevelScatterPlotPreprocess
                                    )
                            except:
                                showerror(
                                    'Error: no value',
                                    stringNoValue
                                    )
                            return
                            
            if self.comboboxLegend3LabelAllCurvesOnOnePlotTable_Scatter.get().strip() <> '':
#                field3 = self.comboboxLegend3LabelAllCurvesOnOnePlotTable_Scatter.get().split('.')[1].strip()
                field3 = self.comboboxLegend3LabelAllCurvesOnOnePlotTable_Scatter.get().strip()
                for key,value in self.dictColumnHeaders.iteritems():
                    if key == field3:
                        if(
                        self.tableValues[0][value-1] <> None
                        and
                        self.tableValues[0][value-1] <> ''
                        ):
                            if legendLabelString <> '':
                                legendLabelString += separator + str(self.tableValues[0][value-1])
                            else:
                                legendLabelString = str(self.tableValues[0][value-1])
                            break
                        else:
                            stringNoValue = (
                                'No value associated with field\n' +
                                '  - %s\n\n' +
                                'Select another field.'
                                ) % (
                                key
                                )
                            print('\n' + stringNoValue)
                            self.MySQL_Output(
                                0,
                                stringNoValue
                                )
                            try:
                                showerror(
                                    'Error: no value',
                                    stringNoValue,
                                    parent=self.toplevelScatterPlotPreprocess
                                    )
                            except:
                                showerror(
                                    'Error: no value',
                                    stringNoValue
                                    )
                            return
                            
            if self.entryfieldLegendUserLabelAllCurvesOnOnePlotTable_Scatter.get().strip() <> '':
                if legendLabelString <> '':
                    legendLabelString += separator + self.entryfieldLegendUserLabelAllCurvesOnOnePlotTable_Scatter.get().strip()
                else:
                    legendLabelString = self.entryfieldLegendUserLabelAllCurvesOnOnePlotTable_Scatter.get().strip()
            
            self.legendLabelStringTable_Scatter.append(legendLabelString)
            
            
# show string in LEGEND LABEL field
        if DEBUG_SCATTER_LEGEND:
            print('\nself.legendLabelStringTable_Scatter =')
            print(self.legendLabelStringTable_Scatter)
            
        self.entryfieldLegendLabelShowTable_Scatter.setvalue(self.legendLabelStringTable_Scatter[0])
                 
        return
        

    def handlerShowLegendLabelsBuffer(self):
        '''
        Purpose:
            take user input from designated widgets and display
            Y Labels for legend in respective display fields.
            
            All Y legend labels for Storage Buffer data are determined here.
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerShowLegendLabelsBuffer')
            
#        if self.varNumberOfStorageBufferCurves.get() == 0:
#            return
            
# ... determine first row checked in Storage Buffer
#   (number of Storage Buffer curves total: len(self.varSelectAnyRow_Buffer)
# ... if no Buffer Rows are checked, return
        if len(self.listWhichBufferRowsAreChecked) == 0:
            stringNoBufferRowsSelected = (
                'No data rows have been selected from the Storage Buffer\n' +
                'for plotting.\n' 
                )
            print stringNoBufferRowsSelected
            self.MySQL_Output(
                0,
                stringNoBufferRowsSelected
                )
            showerror(
                'Error: no selection',
                stringNoBufferRowsSelected
                )
            return
# determine row index and x-y headers       
        indexBufferRow = self.listWhichBufferRowsAreChecked        
# determine plot label separator
        separator = self.determinePlotLabelSeparator(
            self.comboboxLegendLabelSeparatorAll.get()
            )
        
        self.legendLabelStringBuffer = []
        
        '''
        icount = 0
        for indexBufferRow in self.listWhichBufferRowsAreChecked:
            index=indexBufferRow - 1
            self.legendLabelStringBuffer.append(self.bufferRowStore[index][6])                 
# concatenate Y-label strings
            legendLabelString = ''
            if self.comboboxLegend1LabelAllCurvesOnOnePlotBuffer.get().strip() <> '':
                field1 = self.comboboxLegend1LabelAllCurvesOnOnePlotBuffer.get()
                for key,value in self.dictNamesBufferStorage.iteritems():
                    if key == field1:
                        legendLabelString += separator + self.bufferRowStore[index][value]
                        break
            if self.comboboxLegend2LabelAllCurvesOnOnePlotBuffer.get().strip() <> '':
                field2 = self.comboboxLegend2LabelAllCurvesOnOnePlotBuffer.get()
                for key,value in self.dictNamesBufferStorage.iteritems():
                    if key == field2:
                        legendLabelString += separator + self.bufferRowStore[index][value]
                        break
            if self.comboboxLegend3LabelAllCurvesOnOnePlotBuffer.get().strip() <> '':
                field3 = self.comboboxLegend3LabelAllCurvesOnOnePlotBuffer.get()
                for key,value in self.dictNamesBufferStorage.iteritems():
                    if key == field3:
                        legendLabelString += separator + self.bufferRowStore[index][value]
                        break
            if self.entryfieldLegendUserLabelAllCurvesOnOnePlotBuffer.get().strip() <> '':
                legendLabelString += separator + self.entryfieldLegendUserLabelAllCurvesOnOnePlotBuffer.get()
            self.legendLabelStringBuffer[icount] += legendLabelString
            
            icount += 1
            '''
            
# concatenate Y-label strings            
        for indexBufferRow in self.listWhichBufferRowsAreChecked:
            index=indexBufferRow - 1
            legendLabelString = ''
            if self.varCheckbuttonYHeaderLabelAllCurvesOnOnePlotBuffer.get():
#                self.legendLabelStringBuffer.append(self.bufferRowStore[index][6])                 
                legendLabelString = self.bufferRowStore[index][6]                 
            if self.comboboxLegend1LabelAllCurvesOnOnePlotBuffer.get().strip() <> '':
#                field1 = self.comboboxLegend1LabelAllCurvesOnOnePlotBuffer.get().split('.')[1].strip()
                field1 = self.comboboxLegend1LabelAllCurvesOnOnePlotBuffer.get().strip()
                for key,value in self.dictNamesBufferStorage.iteritems():
                    if key == field1:
                        if(
                        self.bufferRowStore[index][value] <> None
                        and
                        self.bufferRowStore[index][value] <> ''
                        ):
                            if legendLabelString <> '':
                                legendLabelString += separator + str(self.bufferRowStore[index][value])
                            else:
                                legendLabelString = str(self.bufferRowStore[index][value])
                            break
                        else:
                            stringNoValue = (
                                'No value associated with field\n' +
                                '  - %s\n\n' +
                                'Select another field.'
                                ) % (
                                key
                                )
                            print('\n' + stringNoValue)
                            self.MySQL_Output(
                                0,
                                stringNoValue
                                )
                            try:
                                showerror(
                                    'Error: no value',
                                    stringNoValue,
                                    parent=self.toplevelXYPlotPreprocess
                                    )
                            except:
                                showerror(
                                    'Error: no value',
                                    stringNoValue
                                    )
                            return
            if self.comboboxLegend2LabelAllCurvesOnOnePlotBuffer.get().strip() <> '':
#                field2 = self.comboboxLegend2LabelAllCurvesOnOnePlotBuffer.get().split('.')[1].strip()
                field2 = self.comboboxLegend2LabelAllCurvesOnOnePlotBuffer.get().strip()
                for key,value in self.dictNamesBufferStorage.iteritems():
                    if key == field2:
                        if(
                        self.bufferRowStore[index][value] <> None
                        and
                        self.bufferRowStore[index][value] <> ''
                        ):
                            if legendLabelString <> '':
                                legendLabelString += separator + str(self.bufferRowStore[index][value])
                            else:
                                legendLabelString = str(self.bufferRowStore[index][value])
                            break
                        else:
                            stringNoValue = (
                                'No value associated with field\n' +
                                '  - %s\n\n' +
                                'Select another field.'
                                ) % (
                                key
                                )
                            print('\n' + stringNoValue)
                            self.MySQL_Output(
                                0,
                                stringNoValue
                                )
                            try:
                                showerror(
                                    'Error: no value',
                                    stringNoValue,
                                    parent=self.toplevelXYPlotPreprocess
                                    )
                            except:
                                showerror(
                                    'Error: no value',
                                    stringNoValue
                                    )
                            return
            if self.comboboxLegend3LabelAllCurvesOnOnePlotBuffer.get().strip() <> '':
#                field3 = self.comboboxLegend3LabelAllCurvesOnOnePlotBuffer.get().split('.')[1].strip()
                field3 = self.comboboxLegend3LabelAllCurvesOnOnePlotBuffer.get().strip()
                for key,value in self.dictNamesBufferStorage.iteritems():
                    if key == field3:
                        if(
                        self.bufferRowStore[index][value] <> None
                        and
                        self.bufferRowStore[index][value] <> ''
                        ):
                            if legendLabelString <> '':
                                legendLabelString += separator + str(self.bufferRowStore[index][value])
                            else:
                                legendLabelString = str(self.bufferRowStore[index][value])
                            break
                        else:
                            stringNoValue = (
                                'No value associated with field\n' +
                                '  - %s\n\n' +
                                'Select another field.'
                                ) % (
                                key
                                )
                            print('\n' + stringNoValue)
                            self.MySQL_Output(
                                0,
                                stringNoValue
                                )
                            try:
                                showerror(
                                    'Error: no value',
                                    stringNoValue,
                                    parent=self.toplevelXYPlotPreprocess
                                    )
                            except:
                                showerror(
                                    'Error: no value',
                                    stringNoValue
                                    )
                            return
            if self.entryfieldLegendUserLabelAllCurvesOnOnePlotBuffer.get().strip() <> '':
                if legendLabelString <> '':
                    legendLabelString += separator + self.entryfieldLegendUserLabelAllCurvesOnOnePlotBuffer.get().strip()
                else:
                    legendLabelString = self.entryfieldLegendUserLabelAllCurvesOnOnePlotBuffer.get().strip()

            self.legendLabelStringBuffer.append(legendLabelString)
            
# show strings in respective fields
        self.entryfieldLegendLabelShowBuffer.setvalue(self.legendLabelStringBuffer[0])
                 
        return
        
        
    def handlerShowLegendLabelsBuffer_Scatter(self):
        '''
        Purpose:
            take user input from designated widgets and display
            Y Labels for legend in respective display fields for scatter plots.
            
            All Y legend labels for Storage Buffer data are determined here.
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerShowLegendLabelsBuffer_Scatter')
            
#        if self.varNumberOfStorageBufferCurves.get() == 0:
#            return
            
# ... determine first row checked in Storage Buffer
#   (number of Storage Buffer curves total: len(self.varSelectAnyRow_Buffer)
# ... if no Buffer Rows are checked, return
        if len(self.listWhichBufferRowsAreChecked_Scatter) == 0:
            stringNoBufferRowsSelected = (
                'No data rows have been selected from the Storage Buffer\n' +
                'for plotting.\n' 
                )
            print stringNoBufferRowsSelected
            self.MySQL_Output(
                0,
                stringNoBufferRowsSelected
                )
            showerror(
                'Error: no selection',
                stringNoBufferRowsSelected
                )
            return
# determine row index and x-y headers       
        indexBufferRow = self.listWhichBufferRowsAreChecked_Scatter     
# determine plot label separator
        separator = self.determinePlotLabelSeparator(
            self.comboboxLegendLabelSeparatorAll_Scatter.get()
            )
        
        self.legendLabelStringBuffer_Scatter = []
        
        if DEBUG_PLOT_SCATTER:
            print('\n-- In handlerShowLegendLabelsBuffer_Scatter --')
            print('\n *** self.listWhichBufferRowsAreChecked_Scatter:')
            print(self.listWhichBufferRowsAreChecked_Scatter)
            
# concatenate Y-label strings            
        for indexBufferRow in self.listWhichBufferRowsAreChecked_Scatter:
            index=indexBufferRow - 1
            legendLabelString = ''
            if self.varCheckbuttonYHeaderLabelAllCurvesOnOnePlotBuffer_Scatter.get():
#                self.legendLabelStringBuffer.append(self.bufferRowStore[index][6])                 
                legendLabelString = self.bufferRowStore[index][6]                 
            if self.comboboxLegend1LabelAllCurvesOnOnePlotBuffer_Scatter.get().strip() <> '':
#                field1 = self.comboboxLegend1LabelAllCurvesOnOnePlotBuffer_Scatter.get().split('.')[1].strip()
                field1 = self.comboboxLegend1LabelAllCurvesOnOnePlotBuffer_Scatter.get().strip()
                for key,value in self.dictNamesBufferStorage.iteritems():
                    if key == field1:
                        if(
                        self.bufferRowStore[index][value] <> None
                        and
                        self.bufferRowStore[index][value] <> ''
                        ):
                            if legendLabelString <> '':
                                legendLabelString += separator + str(self.bufferRowStore[index][value])
                            else:
                                legendLabelString = str(self.bufferRowStore[index][value])
                            break
                        else:
                            stringNoValue = (
                                'No value associated with field\n' +
                                '  - %s\n\n' +
                                'Select another field.'
                                ) % (
                                key
                                )
                            print('\n' + stringNoValue)
                            self.MySQL_Output(
                                0,
                                stringNoValue
                                )
                            try:
                                showerror(
                                    'Error: no value',
                                    stringNoValue,
                                    parent=self.toplevelXYPlotPreprocess
                                    )
                            except:
                                showerror(
                                    'Error: no value',
                                    stringNoValue
                                    )
                            return
            if self.comboboxLegend2LabelAllCurvesOnOnePlotBuffer_Scatter.get().strip() <> '':
#                field2 = self.comboboxLegend2LabelAllCurvesOnOnePlotBuffer_Scatter.get().split('.')[1].strip()
                field2 = self.comboboxLegend2LabelAllCurvesOnOnePlotBuffer_Scatter.get().strip()
                for key,value in self.dictNamesBufferStorage.iteritems():
                    if key == field2:
                        if(
                        self.bufferRowStore[index][value] <> None
                        and
                        self.bufferRowStore[index][value] <> ''
                        ):
                            if legendLabelString <> '':
                                legendLabelString += separator + str(self.bufferRowStore[index][value])
                            else:
                                legendLabelString = str(self.bufferRowStore[index][value])
                            break
                        else:
                            stringNoValue = (
                                'No value associated with field\n' +
                                '  - %s\n\n' +
                                'Select another field.'
                                ) % (
                                key
                                )
                            print('\n' + stringNoValue)
                            self.MySQL_Output(
                                0,
                                stringNoValue
                                )
                            try:
                                showerror(
                                    'Error: no value',
                                    stringNoValue,
                                    parent=self.toplevelScatterPlotPreprocess
                                    )
                            except:
                                showerror(
                                    'Error: no value',
                                    stringNoValue
                                    )
                            return
            if self.comboboxLegend3LabelAllCurvesOnOnePlotBuffer_Scatter.get().strip() <> '':
#                field3 = self.comboboxLegend3LabelAllCurvesOnOnePlotBuffer_Scatter.get().split('.')[1].strip()
                field3 = self.comboboxLegend3LabelAllCurvesOnOnePlotBuffer_Scatter.get().strip()
                for key,value in self.dictNamesBufferStorage.iteritems():
                    if key == field3:
                        if(
                        self.bufferRowStore[index][value] <> None
                        and
                        self.bufferRowStore[index][value] <> ''
                        ):
                            if legendLabelString <> '':
                                legendLabelString += separator + str(self.bufferRowStore[index][value])
                            else:
                                legendLabelString = str(self.bufferRowStore[index][value])
                            break
                        else:
                            stringNoValue = (
                                'No value associated with field\n' +
                                '  - %s\n\n' +
                                'Select another field.'
                                ) % (
                                key
                                )
                            print('\n' + stringNoValue)
                            self.MySQL_Output(
                                0,
                                stringNoValue
                                )
                            try:
                                showerror(
                                    'Error: no value',
                                    stringNoValue,
                                    parent=self.toplevelScatterPlotPreprocess
                                    )
                            except:
                                showerror(
                                    'Error: no value',
                                    stringNoValue
                                    )
                            return
            if self.entryfieldLegendUserLabelAllCurvesOnOnePlotBuffer_Scatter.get().strip() <> '':
                if legendLabelString <> '':
                    legendLabelString += separator + self.entryfieldLegendUserLabelAllCurvesOnOnePlotBuffer_Scatter.get().strip()
                else:
                    legendLabelString = self.entryfieldLegendUserLabelAllCurvesOnOnePlotBuffer_Scatter.get().strip()

            self.legendLabelStringBuffer_Scatter.append(legendLabelString)
            
# show strings in respective fields
        self.entryfieldLegendLabelShowBuffer_Scatter.setvalue(self.legendLabelStringBuffer_Scatter[0])
                 
        return
        
        
    def handlerShowLegendLabelsBuffer_NoErrMsg(self):
        '''
        Purpose:
            take user input from designated widgets and display
            X and Y Labels for plots in respective display fields,
            but do not display error msg if no data to choose from
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerShowLegendLabelsBuffer_NoErrMsg')
            
# ... determine first row checked in Storage Buffer
#   (number of Storage Buffer curves total: len(self.varSelectAnyRow_Buffer)
# ... if no Buffer Rows are checked, return
        if len(self.listWhichBufferRowsAreChecked) == 0:
            return
# determine row index and x-y headers       
        indexBufferRow = self.listWhichBufferRowsAreChecked        
# determine plot label separator
        separator = self.determinePlotLabelSeparator(
            self.comboboxLegendLabelSeparatorAll.get()
            )
        
        self.legendLabelStringBuffer = []
        
        for indexBufferRow in self.listWhichBufferRowsAreChecked:
            index=indexBufferRow - 1
            legendLabelString = ''
            if self.varCheckbuttonYHeaderLabelAllCurvesOnOnePlotBuffer.get():
#                self.legendLabelStringBuffer.append(self.bufferRowStore[index][6])                 
                legendLabelString = self.bufferRowStore[index][6]                 
            if self.comboboxLegend1LabelAllCurvesOnOnePlotBuffer.get().strip() <> '':
#                field1 = self.comboboxLegend1LabelAllCurvesOnOnePlotBuffer.get().split('.')[1].strip()
                field1 = self.comboboxLegend1LabelAllCurvesOnOnePlotBuffer.get().strip()
                for key,value in self.dictNamesBufferStorage.iteritems():
                    if key == field1:
                        if(
                        self.bufferRowStore[index][value] <> None
                        and
                        self.bufferRowStore[index][value] <> ''
                        ):
                            if legendLabelString <> '':
                                legendLabelString += separator + str(self.bufferRowStore[index][value])
                            else:
                                legendLabelString = str(self.bufferRowStore[index][value])
                            break
                        else:
                            stringNoValue = (
                                'No value associated with field\n' +
                                '  - %s\n\n' +
                                'Select another field.'
                                ) % (
                                key
                                )
                            print('\n' + stringNoValue)
                            self.MySQL_Output(
                                0,
                                stringNoValue
                                )
                            try:
                                showerror(
                                    'Error: no value',
                                    stringNoValue,
                                    parent=self.toplevelXYPlotPreprocess
                                    )
                            except:
                                showerror(
                                    'Error: no value',
                                    stringNoValue
                                    )
                            return
            if self.comboboxLegend2LabelAllCurvesOnOnePlotBuffer.get().strip() <> '':
#                field2 = self.comboboxLegend2LabelAllCurvesOnOnePlotBuffer.get().split('.')[1].strip()
                field2 = self.comboboxLegend2LabelAllCurvesOnOnePlotBuffer.get().strip()
                for key,value in self.dictNamesBufferStorage.iteritems():
                    if key == field2:
                        if(
                        self.bufferRowStore[index][value] <> None
                        and
                        self.bufferRowStore[index][value] <> ''
                        ):
                            if legendLabelString <> '':
                                legendLabelString += separator + str(self.bufferRowStore[index][value])
                            else:
                                legendLabelString = str(self.bufferRowStore[index][value])
                            break
                        else:
                            stringNoValue = (
                                'No value associated with field\n' +
                                '  - %s\n\n' +
                                'Select another field.'
                                ) % (
                                key
                                )
                            print('\n' + stringNoValue)
                            self.MySQL_Output(
                                0,
                                stringNoValue
                                )
                            try:
                                showerror(
                                    'Error: no value',
                                    stringNoValue,
                                    parent=self.toplevelXYPlotPreprocess
                                    )
                            except:
                                showerror(
                                    'Error: no value',
                                    stringNoValue
                                    )
                            return
            if self.comboboxLegend3LabelAllCurvesOnOnePlotBuffer.get().strip() <> '':
#                field3 = self.comboboxLegend3LabelAllCurvesOnOnePlotBuffer.get().split('.')[1].strip()
                field3 = self.comboboxLegend3LabelAllCurvesOnOnePlotBuffer.get().strip()
                for key,value in self.dictNamesBufferStorage.iteritems():
                    if key == field3:
                        if(
                        self.bufferRowStore[index][value] <> None
                        and
                        self.bufferRowStore[index][value] <> ''
                        ):
                            if legendLabelString <> '':
                                legendLabelString += separator + str(self.bufferRowStore[index][value])
                            else:
                                legendLabelString = str(self.bufferRowStore[index][value])
                            break
                        else:
                            stringNoValue = (
                                'No value associated with field\n' +
                                '  - %s\n\n' +
                                'Select another field.'
                                ) % (
                                key
                                )
                            print('\n' + stringNoValue)
                            self.MySQL_Output(
                                0,
                                stringNoValue
                                )
                            try:
                                showerror(
                                    'Error: no value',
                                    stringNoValue,
                                    parent=self.toplevelXYPlotPreprocess
                                    )
                            except:
                                showerror(
                                    'Error: no value',
                                    stringNoValue
                                    )
                            return
            if self.entryfieldLegendUserLabelAllCurvesOnOnePlotBuffer.get().strip() <> '':
                if legendLabelString <> '':
                    legendLabelString += separator + self.entryfieldLegendUserLabelAllCurvesOnOnePlotBuffer.get().strip()
                else:
                    legendLabelString = self.entryfieldLegendUserLabelAllCurvesOnOnePlotBuffer.get().strip()

            self.legendLabelStringBuffer.append(legendLabelString)
            
# show strings in respective fields
        self.entryfieldLegendLabelShowBuffer.setvalue(self.legendLabelStringBuffer[0])
                 
        return
        
        
    def handlerShowLegendLabelsBuffer_NoErrMsg_Scatter(self):
        '''
        Purpose:
            take user input from designated widgets in scatter plot window and display
            X and Y Labels for plots in respective display fields, but do not display
           error msg if no data to choose from
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerShowLegendLabelsBuffer_NoErrMsg_Scatter')
            
# ... determine first row checked in Storage Buffer
#   (number of Storage Buffer curves total: len(self.varSelectAnyRow_Buffer)
# ... if no Buffer Rows are checked, return
        if DEBUG_SHOWLEGENDLABELSBUFFER_NOERRMSG_SCATTER:
            print('\nself.listWhichBufferRowsAreChecked:')
            print(self.listWhichBufferRowsAreChecked)
        if len(self.listWhichBufferRowsAreChecked) == 0:
            return
# determine row index and x-y headers       
        indexBufferRow = self.listWhichBufferRowsAreChecked        
# determine plot label separator
        separator = self.determinePlotLabelSeparator(
            self.comboboxLegendLabelSeparatorAll_Scatter.get()
            )
        
        self.legendLabelStringBuffer_Scatter = []
        
        for indexBufferRow in self.listWhichBufferRowsAreChecked:
            index=indexBufferRow - 1
            legendLabelString = ''
            if self.varCheckbuttonYHeaderLabelAllCurvesOnOnePlotBuffer_Scatter.get():
#                self.legendLabelStringBuffer.append(self.bufferRowStore[index][6])                 
                legendLabelString = self.bufferRowStore[index][6]                 
            if self.comboboxLegend1LabelAllCurvesOnOnePlotBuffer_Scatter.get().strip() <> '':
#                field1 = self.comboboxLegend1LabelAllCurvesOnOnePlotBuffer_Scatter.get().split('.')[1].strip()
                field1 = self.comboboxLegend1LabelAllCurvesOnOnePlotBuffer_Scatter.get().strip()
                for key,value in self.dictNamesBufferStorage.iteritems():
                    if key == field1:
                        if(
                        self.bufferRowStore[index][value] <> None
                        and
                        self.bufferRowStore[index][value] <> ''
                        ):
                            if legendLabelString <> '':
                                legendLabelString += separator + str(self.bufferRowStore[index][value])
                            else:
                                legendLabelString = str(self.bufferRowStore[index][value])
                            break
                        else:
                            stringNoValue = (
                                'No value associated with field\n' +
                                '  - %s\n\n' +
                                'Select another field.'
                                ) % (
                                key
                                )
                            print('\n' + stringNoValue)
                            self.MySQL_Output(
                                0,
                                stringNoValue
                                )
                            try:
                                showerror(
                                    'Error: no value',
                                    stringNoValue,
                                    parent=self.toplevelScatterPlotPreprocess
                                    )
                            except:
                                showerror(
                                    'Error: no value',
                                    stringNoValue
                                    )
                            return
            if self.comboboxLegend2LabelAllCurvesOnOnePlotBuffer_Scatter.get().strip() <> '':
#                field2 = self.comboboxLegend2LabelAllCurvesOnOnePlotBuffer_Scatter.get().split('.')[1].strip()
                field2 = self.comboboxLegend2LabelAllCurvesOnOnePlotBuffer_Scatter.get().strip()
                for key,value in self.dictNamesBufferStorage.iteritems():
                    if key == field2:
                        if(
                        self.bufferRowStore[index][value] <> None
                        and
                        self.bufferRowStore[index][value] <> ''
                        ):
                            if legendLabelString <> '':
                                legendLabelString += separator + str(self.bufferRowStore[index][value])
                            else:
                                legendLabelString = str(self.bufferRowStore[index][value])
                            break
                        else:
                            stringNoValue = (
                                'No value associated with field\n' +
                                '  - %s\n\n' +
                                'Select another field.'
                                ) % (
                                key
                                )
                            print('\n' + stringNoValue)
                            self.MySQL_Output(
                                0,
                                stringNoValue
                                )
                            try:
                                showerror(
                                    'Error: no value',
                                    stringNoValue,
                                    parent=self.toplevelScatterPlotPreprocess
                                    )
                            except:
                                showerror(
                                    'Error: no value',
                                    stringNoValue
                                    )
                            return
            if self.comboboxLegend3LabelAllCurvesOnOnePlotBuffer_Scatter.get().strip() <> '':
#                field3 = self.comboboxLegend3LabelAllCurvesOnOnePlotBuffer_Scatter.get().split('.')[1].strip()
                field3 = self.comboboxLegend3LabelAllCurvesOnOnePlotBuffer_Scatter.get().strip()
                for key,value in self.dictNamesBufferStorage.iteritems():
                    if key == field3:
                        if(
                        self.bufferRowStore[index][value] <> None
                        and
                        self.bufferRowStore[index][value] <> ''
                        ):
                            if legendLabelString <> '':
                                legendLabelString += separator + str(self.bufferRowStore[index][value])
                            else:
                                legendLabelString = str(self.bufferRowStore[index][value])
                            break
                        else:
                            stringNoValue = (
                                'No value associated with field\n' +
                                '  - %s\n\n' +
                                'Select another field.'
                                ) % (
                                key
                                )
                            print('\n' + stringNoValue)
                            self.MySQL_Output(
                                0,
                                stringNoValue
                                )
                            try:
                                showerror(
                                    'Error: no value',
                                    stringNoValue,
                                    parent=self.toplevelScatterPlotPreprocess
                                    )
                            except:
                                showerror(
                                    'Error: no value',
                                    stringNoValue
                                    )
                            return
            if self.entryfieldLegendUserLabelAllCurvesOnOnePlotBuffer_Scatter.get().strip() <> '':
                if legendLabelString <> '':
                    legendLabelString += separator + self.entryfieldLegendUserLabelAllCurvesOnOnePlotBuffer_Scatter.get().strip()
                else:
                    legendLabelString = self.entryfieldLegendUserLabelAllCurvesOnOnePlotBuffer_Scatter.get().strip()

            self.legendLabelStringBuffer_Scatter.append(legendLabelString)
            
        if DEBUG_SHOWLEGENDLABELSBUFFER_NOERRMSG_SCATTER:
            print('\nself.legendLabelStringBuffer_Scatter:')
            print(self.legendLabelStringBuffer_Scatter)
            
# show strings in respective fields
        self.entryfieldLegendLabelShowBuffer_Scatter.setvalue(self.legendLabelStringBuffer_Scatter[0])
                 
        return
                
        
    def handlerResetAllLegendLabelsTable(self):
        '''
        Purpose:
            reset all Table Data fields in 'Legend Labels' window for x-y plots
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerResetAllLegendLabelsTable')
            
        if self.comboboxLegend1LabelAllCurvesOnOnePlotTable.get().strip() <> '':
            self.comboboxLegend1LabelAllCurvesOnOnePlotTable.setentry('')
        if self.comboboxLegend2LabelAllCurvesOnOnePlotTable.get().strip() <> '':
            self.comboboxLegend2LabelAllCurvesOnOnePlotTable.setentry('')
        if self.comboboxLegend3LabelAllCurvesOnOnePlotTable.get().strip() <> '':
            self.comboboxLegend3LabelAllCurvesOnOnePlotTable.setentry('')
        if self.entryfieldLegendUserLabelAllCurvesOnOnePlotTable.get().strip() <> '':
            self.entryfieldLegendUserLabelAllCurvesOnOnePlotTable.setvalue('')
        
        self.entryfieldLegendLabelShowTable.setvalue('')
       
        return
        
        
    def handlerResetAllLegendLabelsTable_Scatter(self):
        '''
        Purpose:
            reset all Table Data fields in 'Legend Labels' window for scatter plots
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerResetAllLegendLabelsTable_Scatter')
            
        if self.comboboxLegend1LabelAllCurvesOnOnePlotTable_Scatter.get().strip() <> '':
            self.comboboxLegend1LabelAllCurvesOnOnePlotTable_Scatter.setentry('')
        if self.comboboxLegend2LabelAllCurvesOnOnePlotTable_Scatter.get().strip() <> '':
            self.comboboxLegend2LabelAllCurvesOnOnePlotTable_Scatter.setentry('')
        if self.comboboxLegend3LabelAllCurvesOnOnePlotTable_Scatter.get().strip() <> '':
            self.comboboxLegend3LabelAllCurvesOnOnePlotTable_Scatter.setentry('')
        if self.entryfieldLegendUserLabelAllCurvesOnOnePlotTable_Scatter.get().strip() <> '':
            self.entryfieldLegendUserLabelAllCurvesOnOnePlotTable_Scatter.setvalue('')
        
        self.entryfieldLegendLabelShowTable_Scatter.setvalue('')
       
        return
        
        
    def handlerResetAllLegendLabelsBuffer(self):
        '''
        Purpose:
            reset all Buffer Data fields in 'Legend Labels' window for X-Y plots
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerResetAllLegendLabelsBuffer')
            
        if self.comboboxLegend1LabelAllCurvesOnOnePlotBuffer.get().strip() <> '':
            self.comboboxLegend1LabelAllCurvesOnOnePlotBuffer.setentry('')
        if self.comboboxLegend2LabelAllCurvesOnOnePlotBuffer.get().strip() <> '':
            self.comboboxLegend2LabelAllCurvesOnOnePlotBuffer.setentry('')
        if self.comboboxLegend3LabelAllCurvesOnOnePlotBuffer.get().strip() <> '':
            self.comboboxLegend3LabelAllCurvesOnOnePlotBuffer.setentry('')
        if self.entryfieldLegendUserLabelAllCurvesOnOnePlotBuffer.get().strip() <> '':
            self.entryfieldLegendUserLabelAllCurvesOnOnePlotBuffer.setvalue('')
        
        self.entryfieldLegendLabelShowBuffer.setvalue('')
       
        return
        
        
    def handlerResetAllLegendLabelsBuffer_Scatter(self):
        '''
        Purpose:
            reset all Buffer Data fields in 'Legend Labels' window for scatter plots
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerResetAllLegendLabelsBuffer_Scatter')
            
        if self.comboboxLegend1LabelAllCurvesOnOnePlotBuffer_Scatter.get().strip() <> '':
            self.comboboxLegend1LabelAllCurvesOnOnePlotBuffer_Scatter.setentry('')
        if self.comboboxLegend2LabelAllCurvesOnOnePlotBuffer_Scatter.get().strip() <> '':
            self.comboboxLegend2LabelAllCurvesOnOnePlotBuffer_Scatter.setentry('')
        if self.comboboxLegend3LabelAllCurvesOnOnePlotBuffer_Scatter.get().strip() <> '':
            self.comboboxLegend3LabelAllCurvesOnOnePlotBuffer_Scatter.setentry('')
        if self.entryfieldLegendUserLabelAllCurvesOnOnePlotBuffer_Scatter.get().strip() <> '':
            self.entryfieldLegendUserLabelAllCurvesOnOnePlotBuffer_Scatter.setvalue('')
        
        self.entryfieldLegendLabelShowBuffer_Scatter.setvalue('')
       
        return

               
    def handlerResetAllPlotXYSelect(self):
        '''
        Purpose: 
            reset all values in 'X-Y Plot Specs' window to default values
            
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerResetAllPlotXYSelect')
            
        self.plottingspecs_xWindowLocation_XY= self.toplevelXYPlotPreprocess.winfo_rootx() - self.offsetWindowX
        self.plottingspecs_yWindowLocation_XY= self.toplevelXYPlotPreprocess.winfo_rooty() - self.offsetWindowY
        self.toplevelXYPlotPreprocess.destroy()
        self.handlerXYPlotPreprocess()
        
        return
        
        
    def handlerResetAllPlotScatterSelect(self):
        '''
        Purpose: 
            reset all values in 'Scatter Plot Specs' window to default values
            
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerResetAllPlotScatterSelect')
            
        self.plottingspecs_xWindowLocation_Scatter= self.toplevelScatterPlotPreprocess.winfo_rootx() - self.offsetWindowX
        self.plottingspecs_yWindowLocation_Scatter= self.toplevelScatterPlotPreprocess.winfo_rooty() - self.offsetWindowY
        self.toplevelScatterPlotPreprocess.destroy()
        self.handlerScatterPlotPreprocess()
        
        return
        
    
    def handlerPlotBarChart(self):
        '''
        Purpose:
            prepares data and labels for plotting statistics
            using bar charts
            
        Calls
            module_PylabPlotMySQL_BarChart
            
        Called by:
            handlerSummarizeField
            
        Significant variables:
            self.plot_X_BarChart
            self.plot_Y_BarChart
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerPlotBarChart')
            
        self.MySQL_Output(
            0,
            '  Database: ' + self.myDatabase + '  Table: ' +
            self.myTable
            )
# misc plot parameters            
        xwin=250
        ywin=100
        colorbg2='lightblue'
        
# get x-select header name
# ... get X header
        index_X = self.varXSelect.get()
        headerNameX = ''
# ... now find the key that goes with this index
        for key,value in self.dictColumnHeaders.iteritems():
            if value == index_X:
                headerNameX = key
                break            
# get table name
        tableName = self.myTable
        
# if adjust=True, redefine plot params
        
        if self.adjustPlotBarChartParams:          
# title
#            if self.varCheckbuttonShowTitleAdjustBarChart.get():
            stringTitleBarChart = self.varEntryShowTitleAdjustBarChart.get()
            fontsizeTitle = self.comboboxTitleFontAdjustBarChart.get()
            colorTitle = self.comboboxTitleColorAdjustBarChart.get()
                
# error checks   
            '''
                errFlag = 0
                if stringTitleBarChart.strip() == '':
                    errFlag = 1
                    stringErrorTitleBarChart += (
                        'Please enter a title.\n'
                        )
                if fontsizeTitle.strip() == '':
                    errFlag = 1
                    stringErrorTitle += (
                        'Please enter a title font size.\n'
                        )
                if colorTitle.strip() == '':
                    errFlag = 1
                    stringErrorTitle += (
                        'Please enter a title color.\n'
                        )
                if errFlag == 1:
                    self.MySQL_Output(
                        1,
                        stringErrorTitle
                        )
                    showerror(
                        'Error: invalid title value',
                        '\n' + stringErrorTitle + '\n'
                        )
                    return
            '''
                    
# labels
#            if self.varCheckbuttonShowYLabelAdjustBarChart.get():
            stringYLabel = self.varEntryShowYLabelAdjustBarChart.get()
            fontsizeLabels = self.comboboxLabelsFontAdjustBarChart.get()
            colorLabels = self.comboboxLabelsColorAdjustBarChart.get()
            
# grid
            showGrid = self.varCheckbuttonShowGridAdjustBarChart.get()
            
# log scale
            '''
            showLogScale = self.varCheckbuttonLogScaleAdjustBarChart.get()
            '''

# horizontal
            '''
            showHorizontal = self.varCheckbuttonOrientAdjustBarChart.get()
            '''

# figure width and height
            figureWidth = self.comboboxFigureWidthAdjustBarChart.get()
            figureHeight = self.comboboxFigureHeightAdjustBarChart.get()
# ... error checks
            errFlag = 0
            stringErrorFigure = ''
            if figureWidth.strip() == '':
                errFlag = 1
                stringErrorFigure += (
                    'Please enter a figure width.\n'
                    )
            if figureHeight.strip() == '':
                errFlag = 1
                stringErrorFigure += (
                    'Please enter a figure height.\n'
                    )
            if errFlag == 1:
                self.MySQL_Output(
                    1,
                    stringErrorFigure
                    )
                showerror(
                    'Error: invalid label value',
                    '\n' + stringErrorFigureWidth + '\n'
                    )
                return
# axes
            axesLeft = self.comboboxAxesLeftAdjustBarChart.get()
            axesBottom = self.comboboxAxesBottomAdjustBarChart.get()
            axesWidth = self.comboboxAxesWidthAdjustBarChart.get()
            axesHeight = self.comboboxAxesHeightAdjustBarChart.get()
# error checks
            '''
            errFlag = 0
            stringErrorAxes = ''
            if axesLeft.strip() == '':
                errFlag = 1
                stringErrorAxes += (
                    'Enter a value for axes left.\n'
                    )
            if axesBottom.strip() == '':
                errFlag = 1
                stringErrorAxes += (
                    'Enter a value for axes bottom.\n'
                    )
            if axesWidth.strip() == '':
                errFlag = 1
                stringErrorAxes += (
                    'Enter a value for axes width.\n'
                    )
            if axesHeight.strip() == '':
                errFlag = 1
                stringErrorAxes += (
                    'Enter a value for axes height.\n'
                    )
            if errFlag == 1:
                self.MySQL_Output(
                    1,
                    stringErrorAxes
                    )
                showerror(
                    'Error: invalid axes value',
                    '\n' + stringErrorAxes + '\n'
                    )
                return
            '''
# background color
            colorBackground = self.comboboxBackgroundColorAdjustBarChart.get()
            colorBorder = self.comboboxBorderColorAdjustBarChart.get()
# error checks
            errFlag = 0
            stringErrorColorBackground = ''
            if colorBackground.strip() == '':
                errFlag = 1
                stringErrorColorBackground += (
                    'Enter a value for background color.\n'
                    )
            if colorBorder.strip() == '':
                errFlag = 1
                stringErrorColorBakcground += (
                    'Enter a value for border color.\n'
                    )
            if errFlag == 1:
                self.MySQL_Output(
                    1,
                    stringErrorColorBackground
                    )
                showerror(
                    'Error: invalid background color',
                    '\n' + stringErrorColorBackground + '\n'
                    )
                return
                    

# y-axis tick marks
            tickmarksYFontSize = self.comboboxTickYFontSize.get()
            tickmarksYColor = self.comboboxTickYColor.get()
# error checks
            errFlag = 0
            stringErrorTickMarksY = ''
            if tickmarksYFontSize.strip() == '':
                errFlag = 1
                stringErrorTickMarksY += (
                    'Enter a value for Y-axis tick mark font size.\n'
                    )
            if tickmarksYColor.strip() == '':
                errFlag = 1
                stringErrorTickMarksY += (
                    'Enter a value for Y-axis tick mark color.\n'
                    )
            if errFlag == 1:
                self.MySQL_Output(
                    1,
                    stringErrorTickMarksY
                    )
                showerror(
                    'Error: invalid tick mark value:',
                    '\n' + stringErrorTickMarksY + '\n'
                    )
                return

# x-axis tick marks
            tickmarksXFontSize = self.comboboxTickXFontSize.get()
            tickmarksXColor = self.comboboxTickXColor.get()
# error checks
            errFlag = 0
            stringErrorTickMarksX = ''
            if tickmarksXFontSize.strip() == '':
                errFlag = 1
                stringErrorTickMarksX += (
                    'Enter a value for X-axis tick mark font size.\n'
                    )
            if tickmarksXColor.strip() == '':
                errFlag = 1
                stringErrorTickMarksX += (
                    'Enter a value for X-axis tick mark color.\n'
                    )
            if errFlag == 1:
                self.MySQL_Output(
                    1,
                    stringErrorTickMarksX
                    )
                showerror(
                    'Error: invalid tick mark value:',
                    '\n' + stringErrorTickMarksX + '\n'
                    )
                return
# width of bars
            widthBars = self.comboboxBarWidth.get()
            widthBarsEdge = self.comboboxBarEdgeWidth.get()
            colorBars = self.comboboxBarColor.get()
            colorBarsEdge = self.comboboxBarEdgeColor.get()
             
# error checks
            errFlag = 0
            stringErrorBars = ''
            if widthBars.strip() == '':
                errFlag = 1
                stringErrorBars += (
                    'Enter a value for width of bars.\n'
                    )
            if colorBars.strip() == '':
                errFlag = 1
                stringErrorBars += (
                    'Enter a value for color of bars.\n'
                    )
            if colorBarsEdge.strip() == '':
                errFlag = 1
                stringErrorBars += (
                    'Enter a value for edge color of bars.\n'
                    )
            if errFlag == 1:
                self.MySQL_Output(
                    1,
                    stringErrorBars
                    )
                showerror(
                    'Error: invalid bar width',
                    '\n' + stringErrorBars + '\n'
                    )
                return

# if we get here, all error checks have passed                
            self.dictBarChartPlotParams = {
                'showTitle' : self.varCheckbuttonShowTitleAdjustBarChart.get(),
                'showYLabel' : self.varCheckbuttonShowYLabelAdjustBarChart.get(),
                'showGrid' : showGrid,
                'useLogScale' : 0,  #showLogScale,
                'orientBarsHorizontal' : 0,     #showHorizontal,
                'titleBarChart' : stringTitleBarChart,      
                'labelYBarChart' : stringYLabel,    
                'fontsizeChartTitle' : fontsizeTitle,       
                'fontsizeChartLabels' : fontsizeLabels,     
                'fontsizeGeneral' : 12,
                'fontsizeXTickLabels' : tickmarksXFontSize, 
                'fontsizeYTickLabels' : tickmarksYFontSize, 
                'fontsizeLegend' : 'large',
                'colorChartTitle' : colorTitle,             
                'colorChartBackground' : colorBackground, 
                'colorChartBorder' : colorBorder,
                'colorChartLabels' : colorLabels,           
                'colorXTickLabels' : tickmarksXColor,       
                'colorYTickLabels' : tickmarksYColor,       
                'widthChartFigure' : figureWidth,           
                'heightChartFigure' : figureHeight,         
                'widthBars' : widthBars,                    
                'widthBarsEdge' : widthBarsEdge,
                'colorBars' : colorBars,                    
                'colorBarsEdge' : colorBarsEdge,                  
                'alignBars' : 'edge',                       
                'axesLeft' : 0.1,       #axesLeft,                      
                'axesBottom' : 0.1,     #axesBottom,                  
                'axesWidth' : 0.9,       #axesWidth,                    
                'axesHeight' : 0.9,     #axesHeight,                  
                }
                
# activate 'adjust bar chart' button
        self.buttonBarChartAdjust.configure(state=NORMAL)
        
#  plot
#        import module_PylabPlotMySQL_BarChart
        module_PylabPlotMySQL_BarChart.PlotsForPylotDB(
            self,
            self.toplevelSummarize,
            xwin,
            ywin,
            colorbg2,
            self.plot_X_BarChart,
            self.plot_Y_BarChart,
            headerNameX,
            tableName,
            **self.dictBarChartPlotParams
            )
        
        return
            
            
          
    def handlerChartBarAdjust(self):
        '''
        Purpose:
         adjust plot parameters of bar chart, then re-plot
         
         Called by:
         
         Calls:
          handlerTableFunctionsShowValues
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerChartBarAdjust')
            
# check if connected to a MySQL server
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return
        
# toplevel
        frameParent = self.toplevelSummarize
        colorbg = 'lightblue'
# destroy any old toplevel frames
        try:
            self.toplevelChartBarAdjust.destroy()
            self.MySQL_Output(
            1,
            'Previous toplevel widget removed from screen.'
            )
        except: 
            self.MySQL_Output(
            1,
            'No previous toplevel widget to remove from screen.'
            )
        
        myDatabase = self.varTableFunctionsSelectDatabase.get()
        myTable = self.varEntryTableFunctionsSelectTable.get()
# get index of X header
        index_X = self.varXSelect.get()
# ... now find key that goes with this index value
        for key,value in self.dictColumnHeaders.iteritems():
            if value == index_X:
                headerNameX = key
                break
        myField = headerNameX
                
# open Toplevel frame for entering database name
        self.toplevelChartBarAdjust = Toplevel(
            frameParent,
            bg=colorbg
            )
        self.toplevelChartBarAdjust.title(
            'Server: ' + self.comboServerMySQL.get() + '     ' +
            'Database: ' + myDatabase + '     ' +
            'Table: ' + myTable
            )
            
        self.toplevelChartBarAdjust.transient(frameParent)
# place the top window
        x_Windows=50
        y_Windows=50
        self.toplevelChartBarAdjust.geometry(
            '+%d+%d' % (x_Windows, y_Windows)
            )
# add frames to toplevel   
# ... frame_00: title    
        frame_00 = Frame(
            self.toplevelChartBarAdjust,
            bg=colorbg,
            )
        frame_00.grid(
            row=0,
            column=0,
            columnspan=99,
#            sticky=E+W,
            )
# ... frame_10: show title   
        frame_10 = Frame(
            self.toplevelChartBarAdjust,
            bg=colorbg,
            )
        frame_10.grid(
            row=1,
            column=0,
            padx=5,
            pady=5,
            sticky=W,
            )
# ... frame_20: show labels
        frame_20 = Frame(
            self.toplevelChartBarAdjust,
            bg=colorbg,
#            relief=RIDGE,
#            borderwidth=3,
            )
        frame_20.grid(
            row=2,
            column=0,
            padx=5,
            pady=5,
            sticky=W,
            )
# ... frame_30: figure width and height
        frame_30 = Frame(
            self.toplevelChartBarAdjust,
            bg=colorbg,
#            relief=RIDGE,
#            borderwidth=3,
            )
        frame_30.grid(
            row=3,
            column=0,
            padx=5,
            pady=5,
            sticky=W,
            )
# ... frame_40: axes label
        frame_40 = Frame(
            self.toplevelChartBarAdjust,
            bg=colorbg,
            )
        '''
        frame_40.grid(
            row=4,
            column=0,
            sticky=W,
            padx=5,
            pady=5,
            )
        '''
# ... frame_50: axes comboboxes
        frame_50 = Frame(
            self.toplevelChartBarAdjust,
            bg=colorbg,
            )
        '''
        frame_50.grid(
            row=5,
            column=0,
            padx=5,
            pady=5,
            sticky=W,
            )
        '''
# ... frame_60: axes height and width and left and bottom
        frame_60 = Frame(
            self.toplevelChartBarAdjust,
            bg=colorbg,
            )
        '''
        frame_60.grid(
            row=6,
            column=0,
            padx=20,
            pady=5,
            sticky=W,
            )
        '''
# ... frame_70: background color
        frame_70 = Frame(
            self.toplevelChartBarAdjust,
            bg=colorbg,
            )
        frame_70.grid(
            row=7,
            column=0,
            padx=5,
            pady=5,
            sticky=W,
            )
# ... frame_80: tick labels: font size and color
        frame_80 = Frame(
            self.toplevelChartBarAdjust,
            bg=colorbg,
            )
        frame_80.grid(
            row=8,
            column=0,
            padx=5,
            pady=5,
            sticky=W,
            )
# ... frame_90: bars label
        frame_90 = Frame(
            self.toplevelChartBarAdjust,
            bg=colorbg,
            )
        frame_90.grid(
            row=9,
            column=0,
            padx=5,
            pady=5,
            sticky=W,
            )
# ... frame_100: bar params
        frame_100 = Frame(
            self.toplevelChartBarAdjust,
            bg=colorbg,
            )
        frame_100.grid(
            row=10,
            column=0,
            padx=20,
            pady=0,
            sticky=W,
            )
# ... frame_999: plot and cancel
        frame_999 = Frame(
            self.toplevelChartBarAdjust,
            bg=colorbg,
            )
        frame_999.grid(
            row=999,
            column=0,
            columnspan=99,
            padx=5,
            pady=10,
#            sticky=E+W,
            )
            
# WIDGETS
        
# ... frame_00: title
        stringTitle = (
            'ADJUST BAR CHART SPECS FOR\n' + 
#            'DATABASE: ' + myDatabase + '\n' +
#            'TABLE: ' + myTable + '\n' +
            'FIELD: "' + myField + '"'
            )
        labelAdjustBarChart = Label(
            frame_00,
            text=stringTitle,
            font=self.titleFont,
            bg=colorbg,
            justify=CENTER,
            )
        labelAdjustBarChart.grid(
            row=0,
            column=0,
            columnspan = 99,
            padx=5,
            pady=5,
            )
            
# ... frame_10: title
# ...       row 0
# ...       checbutton to show title
        self.varCheckbuttonShowTitleAdjustBarChart = IntVar()
        self.varCheckbuttonShowTitleAdjustBarChart.set(
            self.dictBarChartPlotParams_Defaults['showTitle']
            )
        self.checkbuttonShowTitleAdjustBarChart = Checkbutton(
            frame_10,
            bg=colorbg,
            variable=self.varCheckbuttonShowTitleAdjustBarChart
            )
        self.checkbuttonShowTitleAdjustBarChart.grid(
            row=0,
            column=0,
            padx=0,
            pady=5,
            sticky=W,
            )
# ...       'show title'
        labelShowTitleAdjustBarChart = Label(
            frame_10,
            text='Show title: ',
            bg=colorbg,
            justify=LEFT,
            )
        labelShowTitleAdjustBarChart.grid(
            row=0,
            column=1,
            padx=0,
            pady=5,
            sticky=W,
            )
# ...       title entry
        self.varEntryShowTitleAdjustBarChart = StringVar()
        self.varEntryShowTitleAdjustBarChart.set(
            self.defaultTitleBarChart
            )
        self.entryShowTitleAdjustBarChart = Entry(
            frame_10,
            width=40,
            textvariable=self.varEntryShowTitleAdjustBarChart,
            disabledbackground='lightgray',
            )
        self.entryShowTitleAdjustBarChart.grid(
            row=0,
            column=2,
            columnspan=2,
            padx=5,
            pady=5,
            sticky=W,
            )
# ...       font size
        self.comboboxTitleFontAdjustBarChart = Pmw.ComboBox(
            frame_10,
            scrolledlist_items = self.fontsizesChartTitle,
            listheight=180,
            label_text='size:',
            label_background=colorbg,
            labelpos='w',
            entry_width=5,
            scrolledlist_hull_width=500,
            )
        self.comboboxTitleFontAdjustBarChart.grid(
            row=1,
            column=2,
            padx=5,
            pady=0,
            sticky=W
            )
        self.comboboxTitleFontAdjustBarChart.selectitem(self.fontsizesChartTitle[4])
# ...       color for title
        self.comboboxTitleColorAdjustBarChart = Pmw.ComboBox(
            frame_10,
            scrolledlist_items = self.colorsChartTitle,
            listheight=160,
            label_text='color: ',
            label_background=colorbg,
            entry_width=10,
            labelpos='w',
            scrolledlist_hull_width=500,
            )
        self.comboboxTitleColorAdjustBarChart.grid(
            row=1,
            column=3,
            padx=5,
            pady=0,
            sticky=W,
            )
        self.comboboxTitleColorAdjustBarChart.selectitem(self.colorsChartTitle[1])

# ... frame_20
# ...       row 0  
        self.varCheckbuttonShowYLabelAdjustBarChart = IntVar()
        self.varCheckbuttonShowYLabelAdjustBarChart.set(
            self.dictBarChartPlotParams_Defaults['showYLabel']
            )
        self.checkbuttonShowYLabelAdjustBarChart = Checkbutton(
            frame_20,
            bg=colorbg,
            variable=self.varCheckbuttonShowYLabelAdjustBarChart,
            justify=LEFT,
            )
        self.checkbuttonShowYLabelAdjustBarChart.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            sticky=W,
            )
        labelShowYLabelAdjustBarChart = Label(
            frame_20,
            text='Show Y label: ',
            bg=colorbg,
            justify=LEFT,
            )
        labelShowYLabelAdjustBarChart.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            sticky=W,
            )
# ... y label
        self.varEntryShowYLabelAdjustBarChart = StringVar()
        self.varEntryShowYLabelAdjustBarChart.set(
            self.defaultLabelYBarChart
            )
        self.entryShowYLabelAdjustBarChart = Entry(
            frame_20,
            width=35,
            textvariable=self.varEntryShowYLabelAdjustBarChart,
            disabledbackground='lightgray',
            )
        self.entryShowYLabelAdjustBarChart.grid(
            row=0,
            column=2,
            columnspan=2,
            padx=5,
            pady=5,
            sticky=W,
            )
# ... font size for y label
        self.comboboxLabelsFontAdjustBarChart = Pmw.ComboBox(
            frame_20,
            scrolledlist_items = self.fontsizesChartLabels,
            listheight=160,
            label_text='size:',
            label_background=colorbg,
            labelpos='w',
            scrolledlist_hull_width=500,
            )
        self.comboboxLabelsFontAdjustBarChart.grid(
            row=1,
            column=2,
            padx=5,
            pady=0,
            sticky=W,
            )
        self.comboboxLabelsFontAdjustBarChart.configure(entry_width=5)
        self.comboboxLabelsFontAdjustBarChart.selectitem(self.fontsizesChartLabels[3])
# ...       color for y label
        self.comboboxLabelsColorAdjustBarChart = Pmw.ComboBox(
            frame_20,
            scrolledlist_items = self.colorsChartLabels,
            listheight=160,
            label_text='color: ',
            label_background=colorbg,
            entry_width=10,
            labelpos='w',
            scrolledlist_hull_width=500,
            )
        self.comboboxLabelsColorAdjustBarChart.grid(
            row=1,
            column=3,
            padx=5,
            pady=0,
            sticky=W
            )
        self.comboboxLabelsColorAdjustBarChart.selectitem(self.colorsChartLabels[1])

# ... frame_30
# ...       show grid 
        self.varCheckbuttonShowGridAdjustBarChart = IntVar()
        self.varCheckbuttonShowGridAdjustBarChart.set(0)
        self.checkbuttonShowGridAdjustBarChart = Checkbutton(
            frame_30,
            variable=self.varCheckbuttonShowGridAdjustBarChart,
            bg=colorbg,
            )
        self.checkbuttonShowGridAdjustBarChart.grid(
            row=0,
            column=0,
            padx=0,
            pady=5,
            sticky=W,
            )
        self.labelShowGridAdjustBarChart = Label(
            frame_30,
            background=colorbg,
            text='Show grid'
            )
        self.labelShowGridAdjustBarChart.grid(
            row=0,
            column=1,
            padx=5,
            pady=5,
            sticky=W,
            )
# ...       use log scale
        '''
        self.varCheckbuttonLogScaleAdjustBarChart = IntVar()
        self.varCheckbuttonLogScaleAdjustBarChart.set(0)
        self.checkbuttonLogScaleAdjustBarChart = Checkbutton(
            frame_30,
            variable=self.varCheckbuttonLogScaleAdjustBarChart,
            bg=colorbg,
            )
        self.checkbuttonLogScaleAdjustBarChart.grid(
            row=1,
            column=0,
            padx=0,
            pady=5,
            )
        self.labelLogScaleAdjustBarChart = Label(
            frame_30,
            background=colorbg,
            text='Use log scale'
            )
        self.labelLogScaleAdjustBarChart.grid(
            row=1,
            column=1,
            padx=5,
            pady=5,
            sticky=W,
            )
        '''
# ...       orient horizontal
        '''
        self.varCheckbuttonOrientAdjustBarChart = IntVar()
        self.varCheckbuttonOrientAdjustBarChart.set(0)
        self.checkbuttonOrientAdjustBarChart = Checkbutton(
            frame_30,
            variable=self.varCheckbuttonOrientAdjustBarChart,
            bg=colorbg,
            )
        self.checkbuttonOrientAdjustBarChart.grid(
            row=2,
            column=0,
            padx=0,
            pady=5,
            )
        self.labelOrientAdjustBarChart = Label(
            frame_30,
            background=colorbg,
            text='Horizontal bars'
            )
        self.labelOrientAdjustBarChart.grid(
            row=2,
            column=1,
            padx=5,
            pady=5,
            sticky=W,
            )
        '''

# ... frame_40
# ...       figure width
        self.comboboxFigureWidthAdjustBarChart = Pmw.ComboBox(
            frame_40,
            scrolledlist_items = self.widthsChartFigure,
            listheight=100,
            label_text='Figure width: ',
            label_background=colorbg,
            labelpos='w',
            entry_width=5,
            scrolledlist_hull_width=500,
            )
        self.comboboxFigureWidthAdjustBarChart.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
        self.comboboxFigureWidthAdjustBarChart.selectitem(self.widthsChartFigure[1])
# ...       figure height
        self.comboboxFigureHeightAdjustBarChart = Pmw.ComboBox(
            frame_40,
            scrolledlist_items = self.widthsChartFigure,
            listheight=100,
            label_text='Figure height: ',
            label_background=colorbg,
            labelpos='w',
            entry_width=5,
            scrolledlist_hull_width=500,
            )
        self.comboboxFigureHeightAdjustBarChart.grid(
            row=0,
            column=1,
            padx=10,
            pady=0,
            )
        self.comboboxFigureHeightAdjustBarChart.selectitem(self.widthsChartFigure[1])        

# ... frame_50
# ...       axes
        labelAxesNormalized = Label(
            frame_50,
            text='Axes (in normalized 0->1 units):',
            bg=colorbg,
            )
        labelAxesNormalized.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            sticky=W,
            )
# ... frame_60
# ...       axes left
        self.comboboxAxesLeftAdjustBarChart = Pmw.ComboBox(
            frame_60,
            scrolledlist_items = self.leftsChartAxes,
            listheight=120,
            label_text='left: ',
            label_background=colorbg,
            labelpos='w',
            entry_width=5,
            scrolledlist_hull_width=500,
            )
        self.comboboxAxesLeftAdjustBarChart.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
        self.comboboxAxesLeftAdjustBarChart.selectitem(self.leftsChartAxes[1])
# ...       axes bottom
        self.comboboxAxesBottomAdjustBarChart = Pmw.ComboBox(
            frame_60,
            scrolledlist_items = self.bottomsChartAxes,
            listheight=120,
            label_text='bottom: ',
            label_background=colorbg,
            labelpos='w',
            entry_width=5,
            scrolledlist_hull_width=500,
            )
        self.comboboxAxesBottomAdjustBarChart.grid(
            row=0,
            column=1,
            padx=10,
            pady=0,
            )
        self.comboboxAxesBottomAdjustBarChart.selectitem(self.bottomsChartAxes[1])         
# ...       axes width
        self.comboboxAxesWidthAdjustBarChart = Pmw.ComboBox(
            frame_60,
            scrolledlist_items = self.widthsChartAxes,
            listheight=120,
            label_text='width: ',
            label_background=colorbg,
            labelpos='w',
            entry_width=5,
            scrolledlist_hull_width=500,
            )

        self.comboboxAxesWidthAdjustBarChart.grid(
            row=1,
            column=0,
            padx=0,
            pady=2,
            )
        self.comboboxAxesWidthAdjustBarChart.selectitem(self.widthsChartAxes[4])   
# ...       axes height
        self.comboboxAxesHeightAdjustBarChart = Pmw.ComboBox(
            frame_60,
            scrolledlist_items = self.heightsChartAxes,
            listheight=120,
            label_text='height: ',
            label_background=colorbg,
            labelpos='w',
            entry_width=5,
            scrolledlist_hull_width=500,
            )

        self.comboboxAxesHeightAdjustBarChart.grid(
            row=1,
            column=1,
            padx=10,
            pady=2,
            )
        self.comboboxAxesHeightAdjustBarChart.selectitem(self.heightsChartAxes[4]) 
# ...  frame_70
# ...       chart background color
        self.comboboxBackgroundColorAdjustBarChart = Pmw.ComboBox(
            frame_70,
            scrolledlist_items=self.colorsChartBackground,
            listheight=150,
            label_text='Background color: ',
            labelpos='w',
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            label_background=colorbg,
            entry_width=10,
            scrolledlist_hull_width=500,
            )
        self.comboboxBackgroundColorAdjustBarChart.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
        self.comboboxBackgroundColorAdjustBarChart.selectitem(self.colorsChartBackground[0])
# ...       chart border color
        self.comboboxBorderColorAdjustBarChart = Pmw.ComboBox(
            frame_70,
            scrolledlist_items=self.colorsChartBorder,
            listheight=150,
            label_text='Border color: ',
            labelpos='w',
            label_background=colorbg,
            entry_width=10,
            scrolledlist_hull_width=500,
            )
        '''
        self.comboboxBorderColorAdjustBarChart.grid(
            row=0,
            column=1,
            padx=5,
            pady=0,
            )
        '''
        self.comboboxBorderColorAdjustBarChart.selectitem(self.colorsChartBorder[0])

# ... frame 80
# ...       Y tick labels: font size
        self.comboboxTickYFontSize = Pmw.ComboBox(
            frame_80,
            scrolledlist_items=self.fontsizesTickY,
            listheight=160,
            label_text='Y-axis tick-mark font size:',
            labelpos='w',
            entry_width=5,
            label_background=colorbg,
            scrolledlist_hull_width=500,
            )
        self.comboboxTickYFontSize.grid(
            row=0,
            column=0,
            padx=0,
            pady=2,
            )
        self.comboboxTickYFontSize.selectitem(self.fontsizesTickY[2])
# ...       Y tick labels: color     
        self.comboboxTickYColor = Pmw.ComboBox(
            frame_80,
            scrolledlist_items=self.colorsTickY,
            listheight=160,
            label_text='color: ',
            labelpos='w',
            entry_width=10,
            label_background=colorbg,
            scrolledlist_hull_width=500,
            )
        self.comboboxTickYColor.grid(
            row=0,
            column=1,
            padx=5,
            pady=2,
            )
        self.comboboxTickYColor.selectitem(self.colorsTickY[1])
# ...       X tick labels: font size
        self.comboboxTickXFontSize = Pmw.ComboBox(
            frame_80,
            scrolledlist_items=self.fontsizesTickX,
            listheight=160,
            label_text='X-axis tick-mark font size:',
            labelpos='w',
            entry_width=5,
            label_background=colorbg,
            scrolledlist_hull_width=500,
            )
        self.comboboxTickXFontSize.grid(
            row=1,
            column=0,
            padx=0,
            pady=2,
            )
        self.comboboxTickXFontSize.selectitem(self.fontsizesTickX[2])
        self.comboboxTickXColor = Pmw.ComboBox(
            frame_80,
            scrolledlist_items=self.colorsTickX,
            listheight=160,
            label_text='color: ',
            labelpos='w',
            entry_width=10,
            label_background=colorbg,
            scrolledlist_hull_width=500,
            )
        self.comboboxTickXColor.grid(
            row=1,
            column=1,
            padx=0,
            pady=2,
            )
        self.comboboxTickXColor.selectitem(self.colorsTickX[1])
# ... frame_90
        labelBarParams = Label(
            frame_90,
            text='Bars:',
            bg=colorbg,
            )
        labelBarParams.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
# ...       bar width
        self.comboboxBarWidth = Pmw.ComboBox(
            frame_100,
            scrolledlist_items=self.widthsChartBar,
            listheight=180,
            label_text='width: ',
            labelpos='w',
            entry_width=5,
            label_background=colorbg,
            scrolledlist_hull_width=500,
            )
        self.comboboxBarWidth.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            sticky=E,
            )
        self.comboboxBarWidth.selectitem(self.widthsChartBar[5])
# ...       bar color
        self.comboboxBarColor = Pmw.ComboBox(
            frame_100,
            scrolledlist_items=self.colorsBar,
            listheight=160,
            label_text='color: ',
            labelpos='w',
            entry_width=10,
            label_background=colorbg,
            scrolledlist_hull_width=500,
            )
        self.comboboxBarColor.grid(
            row=0,
            column=1,
            padx=10,
            pady=0,
            sticky=E,
            )
        self.comboboxBarColor.selectitem(self.colorsBar[2])
# ...       bar edge width
        self.comboboxBarEdgeWidth = Pmw.ComboBox(
            frame_100,
            scrolledlist_items=self.widthsChartBarEdge,
            listheight=140,
            label_text='edge width: ',
            labelpos='w',
            entry_width=5,
            label_background=colorbg,
            scrolledlist_hull_width=500,
            )
        self.comboboxBarEdgeWidth.grid(
            row=1,
            column=0,
            padx=0,
            pady=2,
            sticky=E,
            )
        self.comboboxBarEdgeWidth.selectitem(self.widthsChartBarEdge[0])
# ...       bar edge color
        self.comboboxBarEdgeColor = Pmw.ComboBox(
            frame_100,
            scrolledlist_items=self.colorsBarEdge,
            listheight=160,
            label_text='edge color: ',
            labelpos='w',
            entry_width=10,
            label_background=colorbg,
            scrolledlist_hull_width=500,
            )
        self.comboboxBarEdgeColor.grid(
            row=1,
            column=1,
            padx=10,
            pady=2,
            sticky=E,
            )
        self.comboboxBarEdgeColor.selectitem(self.colorsBarEdge[1])
        
# ... frame_999
# ...       re-plot
        buttonReplot = Button(
            frame_999,
            text='Re-plot bar chart',
            width=15,
            relief=RAISED,
            borderwidth=5,
            command=self.handlerReplotBarChart,
            )
        buttonReplot.grid(
            row=1,
            column=0,
            padx=5,
            pady=5,
            )
# ...       cancel
        buttonCancel = Button(
            frame_999,
            text='Cancel',
            width=15,
            relief=RAISED,
            borderwidth=5,
            command=self.handlerQuitBarChartAdjust,
            )
        buttonCancel.grid(
            row=1,
            column=1,
            padx=5,
            pady=5,
            )
# ...       reset
        buttonResetBarAdjust = Button(
            frame_999,
            text='Reset all',
            font=self.buttonFontSmallest,
            width=12,
            relief=RAISED,
            borderwidth=5,
            background='white',
            foreground='blue',
            command=self.handlerResetBarAdjust
            )
        buttonResetBarAdjust.grid(
            row=0,
            column=0,
            columnspan=99,
            padx=0,
            pady=5,
            )
        
        return
            
            
    def handlerQuitBarChartAdjust(self):
        '''
        Purpose:
            quit the 'Adjust Bar Chart Specs' window 
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerQuitBarChartAdjust')
            
        self.dictBarChartPlotParams = copy.deepcopy(self.dictBarChartPlotParams_Defaults)
        self.handlerResetBarAdjust()
        self.toplevelChartBarAdjust.destroy()
        
        return


    def handlerResetBarAdjust(self):
        '''
        Purpose: reset Bar Adjust window to default values
        
        self.dictBarChartPlotParams_Defaults = {
            'showTitle' : 1,
            'showYLabel' : 1,
            'showGrid' : 0,
            'useLogScale' : 0,
            'orientBarsHorizontal' : 0,
            'titleBarChart' : '',
            'labelYBarChart' : '',
            'fontsizeChartTitle' : 16,
            'fontsizeChartLabels' : 14,
            'fontsizeGeneral' : 12,
            'fontsizeXTickLabels' : 10,   #'medium',
            'fontsizeYTickLabels' : 10,   #'medium',
            'fontsizeLegend' : 14,  #'large',
            'colorChartTitle' : 'black',
            'colorChartBackground' : 'white',
            'colorChartBorder' : 'white',
            'colorChartLabels' : 'black',
            'colorXTickLabels' : 'black',
            'colorYTickLabels' : 'black',
            'widthChartFigure' : 6,
            'heightChartFigure' : 6,
            'widthBars' : 0.35,
            'widthBarsEdge' : widthBarsEdge,
            'colorBars' : 'blue',
            'colorBarsEdge' : 'black',
            'alignBars' : 'edge',
            'axesLeft' : 0.1,
            'axesBottom' : 0.1,
            'axesWidth' : 0.9,
            'axesHeight' : 0.9,
            }
        '''
# set all buttons
        self.varCheckbuttonShowTitleAdjustBarChart.set(1)
        self.varCheckbuttonShowYLabelAdjustBarChart.set(1)
        self.varCheckbuttonShowGridAdjustBarChart.set(0)
        '''
        self.varCheckbuttonLogScaleAdjustBarChart.set(0)
        '''
        
# default values from self.dictBarChartPlotParams_Defaults
        self.varEntryShowTitleAdjustBarChart.set(
            self.defaultTitleBarChart
            )
        self.comboboxTitleFontAdjustBarChart.selectitem(
            self.fontsizesChartTitle[4]
            )

        self.comboboxTitleColorAdjustBarChart.selectitem(
            self.colorsChartTitle[1]
            )

        self.varEntryShowYLabelAdjustBarChart.set(
            self.defaultLabelYBarChart
            )
        self.comboboxLabelsFontAdjustBarChart.selectitem(
            self.fontsizesChartLabels[3]
            )
        self.comboboxLabelsColorAdjustBarChart.selectitem(
            self.colorsChartLabels[1]
            )
        self.varCheckbuttonShowGridAdjustBarChart.set(
            0
            )
        '''
        self.varCheckbuttonLogScaleAdjustBarChart.set(
            0
            )
        self.varCheckbuttonOrientAdjustBarChart.set(
            0
            )
        '''
        self.comboboxFigureWidthAdjustBarChart.selectitem(
            self.widthsChartFigure[1]
            )
        self.comboboxFigureHeightAdjustBarChart.selectitem(
            self.widthsChartFigure[1]
            )
        '''
        self.comboboxAxesLeftAdjustBarChart.selectitem(
            self.leftsChartAxes[1]
            )
        self.comboboxAxesBottomAdjustBarChart.selectitem(
            self.bottomsChartAxes[1]
            )
        self.comboboxAxesWidthAdjustBarChart.selectitem(
            self.widthsChartAxes[4]
            )
        self.comboboxAxesHeightAdjustBarChart.selectitem(
            self.heightsChartAxes[4]
            )
        '''
        self.comboboxBackgroundColorAdjustBarChart.selectitem(
            self.colorsChartBackground[0]
            )
        self.comboboxBorderColorAdjustBarChart.selectitem(
            self.colorsChartBorder[0]
            )
        self.comboboxTickYFontSize.selectitem(
            self.fontsizesTickY[2]
            )
        self.comboboxTickYColor.selectitem(
            self.colorsTickY[1]
            )
        self.comboboxTickXFontSize.selectitem(
            self.fontsizesTickX[2]
            )
        self.comboboxTickXColor.selectitem(
            self.colorsTickX[1]
            )
        self.comboboxBarWidth.selectitem(
            self.widthsChartBar[5]
            )
        self.comboboxBarColor.selectitem(
            self.colorsBar[2]
            )
        self.comboboxBarEdgeWidth.selectitem(
            self.widthsChartBarEdge[0]
            )
        self.comboboxBarEdgeColor.selectitem(
            self.colorsBarEdge[1]
            )
        
        return
        
            
    def handlerReplotBarChart(self):
        '''
        Purpose:
            replot bar chart with user-defined parameters
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerReplotBarChart')
            
# plot bar chart with new params
        self.adjustPlotBarChartParams = True
        self.handlerPlotBarChart()
        
        return
              
            
    def handlerPlotPieChart(self):
        '''
        Purpose:
            prepares data and labels for plotting statistics
            using pie charts
            
        Calls
            module_PylabPlotMySQL_PieChart
            
        Called by:
            handlerSummarizeField
            
        Significant variables:
            self.plot_X_BarChart
            self.plot_Y_BarChart
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerPlotPieChart')
            
        self.MySQL_Output(
            0,
            '  Database: ' + self.myDatabase + '  Table: ' +
            self.myTable
            )
# misc plot parameters            
        xwin=350
        ywin=150
        colorbg2='lightblue'
        
# get x-select header name
# get X header
        index_X = self.varXSelect.get()
        headerNameX = ''
# ... now find the key that goes with this index
        for key,value in self.dictColumnHeaders.iteritems():
            if value == index_X:
                headerNameX = key
                break
                
# get table name
        tableName = self.myTable
        
# if adjust = True, redefine plot params
        if self.adjustPlotPieChartParams:       
# title
            showTitle = self.intvarCheckbuttonShowTitleAdjustPieChart.get()
            title = self.stringvarEntryShowTitleAdjustPieChart.get()
            colorTitle = self.comboboxTitleColorAdjustPieChart.get()
            fontsizeTitle = self.comboboxTitleFontAdjustPieChart.get()

# legend
            '''
            showLegend = self.varCheckbuttonShowLegendAdjustPieChart.get()
            fontsizeLegend = self.comboboxLegendFontAdjustPieChart.get()
            colorLegend = self.comboboxLegendColorAdjustPieChart.get()
            '''

# explode
            showExplode = self.intvarCheckbuttonExplodeAdjustPieChart.get()
            factorExplode = self.comboboxExplodeAdjustPieChart.get()
            
# background color
            '''
            colorBackground = self.comboboxBackgroundColorAdjustPieChart.get()
            '''
            
# font size labels
            fontsizeLabels = self.comboboxLabelsFontAdjustPieChart.get()
            
# font color labels
            colorLabels = self.comboboxLabelsColorAdjustPieChart.get()
            
# ... error checks
            '''
            errFlag = 0
            stringErrorFigure = ''
            if figureWidth.strip() == '':
                errFlag = 1
                stringErrorFigure += (
                    'Please enter a figure width.\n'
                    )
            if figureHeight.strip() == '':
                errFlag = 1
                stringErrorFigure += (
                    'Please enter a figure height.\n'
                    )
            if errFlag == 1:
                self.MySQL_Output(
                    1,
                    stringErrorFigure
                    )
                showerror(
                    'Error: invalid label value',
                    '\n' + stringErrorFigureWidth + '\n'
                    )
                return
            '''
                
# if we get here, all error checks have passed
            self.dictPieChartPlotParams = {
                'showTitle' : showTitle,
                'titlePieChart' : title,
                'colorTitle' : colorTitle,
                'fontsizeTitle' : fontsizeTitle,
#                'showLegend' : showLegend,
#                'fontsizeLegend' : fontsizeLegend,
                'showExplodedView' : showExplode,
                'factorExplodeWedges' : factorExplode,
#                'colorChartBackground' : colorBackground,
                'fontsizeLabels' : fontsizeLabels,
                'colorLabels' : colorLabels,     
                }

# activate 'adjust pie chart' button
        self.buttonPieChartAdjust.configure(state=NORMAL)

                
#  plot
#        import module_PylabPlotMySQL_PieChart
        module_PylabPlotMySQL_PieChart.PlotsForPylotDB(
            self,
            self.toplevelSummarize,
            xwin,
            ywin,
            colorbg2,
            self.plot_X_BarChart,
            self.plot_Y_BarChart,
            headerNameX,
            tableName,
            self.countTotalBarChart,
            **self.dictPieChartPlotParams
            )  
        
        return
        

    def handlerChartPieAdjust(self):
        '''
        Purpose:
         adjust plot parameters of pie chart, then re-plot
         
         Called by:
         
         Calls:
          handlerTableFunctionsShowValues
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerChartPieAdjust')
            
# check if connected to a MySQL server
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return
        
# toplevel
        frameParent = self.toplevelSummarize
        colorbg = 'lightblue'
# destroy any old toplevel frames
        try:
            self.toplevelChartPieAdjust.destroy()
            self.MySQL_Output(
            1,
            'Previous toplevel widget removed from screen.'
            )
        except: 
            self.MySQL_Output(
            1,
            'No previous toplevel widget to remove from screen.'
            )
        
        myDatabase = self.varTableFunctionsSelectDatabase.get()
        myTable = self.varEntryTableFunctionsSelectTable.get()
# get index of X header
        index_X = self.varXSelect.get()
# ... now find key that goes with this index value
        for key,value in self.dictColumnHeaders.iteritems():
            if value == index_X:
                headerNameX = key
                break
        myField = headerNameX
                
# open Toplevel frame for entering database name
        self.toplevelChartPieAdjust = Toplevel(
            frameParent,
            bg=colorbg
            )
        self.toplevelChartPieAdjust.title(
            'Server: ' + self.comboServerMySQL.get() + '     ' +
            'Database: ' + myDatabase + '     ' +
            'Table: ' + myTable
            )
            
        self.toplevelChartPieAdjust.transient(frameParent)
# place the top window
        x_Windows=00
        y_Windows=100
        self.toplevelChartPieAdjust.geometry(
            '+%d+%d' % (x_Windows, y_Windows)
            )
# add frames to toplevel   
# ... frame_00: title    
        frame_00 = Frame(
            self.toplevelChartPieAdjust,
            bg=colorbg,
            )
        frame_00.grid(
            row=0,
            column=0,
            columnspan=99,
            )
# ... frame_10: show title   
        frame_10 = Frame(
            self.toplevelChartPieAdjust,
            bg=colorbg,
            )
        frame_10.grid(
            row=1,
            column=0,
            padx=5,
            pady=5,
            sticky=W,
            )
# ... frame_20: show legend
        frame_20 = Frame(
            self.toplevelChartPieAdjust,
            bg=colorbg,
#            relief=RIDGE,
#            borderwidth=3,
            )
        frame_20.grid(
            row=2,
            column=0,
            padx=5,
            pady=5,
            sticky=W,
            )
# ... frame_30: explode factor
        frame_30 = Frame(
            self.toplevelChartPieAdjust,
            bg=colorbg,
#            relief=RIDGE,
#            borderwidth=3,
            )
        frame_30.grid(
            row=3,
            column=0,
            padx=5,
            pady=5,
            sticky=W,
            )
# ... frame_40: chart bakcground  
        frame_40 = Frame(
            self.toplevelChartPieAdjust,
            bg=colorbg,
            )
        frame_40.grid(
            row=4,
            column=0,
            sticky=W,
            padx=5,
            pady=5,
            )
# ... frame_50: labels, labels font size, labels color
        frame_50 = Frame(
            self.toplevelChartPieAdjust,
            bg=colorbg,
            )
        frame_50.grid(
            row=5,
            column=0,
            padx=5,
            pady=5,
            sticky=W,
            )

# ... frame_999: plot, cancel, and reset all
        frame_999 = Frame(
            self.toplevelChartPieAdjust,
            bg=colorbg,
            )
        frame_999.grid(
            row=999,
            column=0,
            columnspan=99,
            padx=5,
            pady=10,
#            sticky=E+W,
            )
            
# WIDGETS
        
# ... frame_00: title
        stringTitle = (
            'ADJUST PIE CHART SPECS FOR\n' + 
#            'DATABASE: ' + myDatabase + '\n' +
#            'TABLE: ' + myTable + '\n' +
            'FIELD: "' + myField + '"'
            )
        labelAdjustPieChart = Label(
            frame_00,
            text=stringTitle,
            font=self.titleFont,
            bg=colorbg,
            justify=CENTER,
            )
        labelAdjustPieChart.grid(
            row=0,
            column=0,
            padx=5,
            pady=5,
            )
# ... frame_10: title
# ...       row 0

# ...       checkbutton to show title
        self.intvarCheckbuttonShowTitleAdjustPieChart = IntVar()
        self.intvarCheckbuttonShowTitleAdjustPieChart.set(
            self.dictPieChartPlotParams_Defaults['showTitle']
            )
        self.checkbuttonShowTitleAdjustPieChart = Checkbutton(
            frame_10,
            bg=colorbg,
            variable=self.intvarCheckbuttonShowTitleAdjustPieChart
            )
        self.checkbuttonShowTitleAdjustPieChart.grid(
            row=0,
            column=0,
            padx=0,
            pady=5,
            sticky=W,
            )
            
# ...       'show title'
        labelShowTitleAdjustPieChart = Label(
            frame_10,
            text='Show title: ',
            bg=colorbg,
            justify=LEFT,
            )
        labelShowTitleAdjustPieChart.grid(
            row=0,
            column=1,
            padx=0,
            pady=5,
            sticky=W,
            )
            
# ...       title entry
        self.stringvarEntryShowTitleAdjustPieChart = StringVar()
        self.stringvarEntryShowTitleAdjustPieChart.set(
            self.defaultTitlePieChart
            )
        self.entryShowTitleAdjustPieChart = Entry(
            frame_10,
            width=40,
            textvariable=self.stringvarEntryShowTitleAdjustPieChart,
            disabledbackground='lightgray',
            )
        self.entryShowTitleAdjustPieChart.grid(
            row=0,
            column=2,
            columnspan=2,
            padx=5,
            pady=5,
            sticky=W,
            )
            
# ...       font size
        self.comboboxTitleFontAdjustPieChart = Pmw.ComboBox(
            frame_10,
            scrolledlist_items = self.fontsizesChartTitle,
            listheight=180,
            label_text='size:',
            label_background=colorbg,
            labelpos='w',
            entry_width=5,
            scrolledlist_hull_width=500,
            )
        self.comboboxTitleFontAdjustPieChart.grid(
            row=1,
            column=2,
            padx=5,
            pady=0,
            sticky=W
            )
        self.comboboxTitleFontAdjustPieChart.selectitem(self.fontsizesChartTitle[4])
        
# ...       color for title
        self.comboboxTitleColorAdjustPieChart = Pmw.ComboBox(
            frame_10,
            scrolledlist_items = self.colorsChartTitle,
            listheight=160,
            label_text='color: ',
            label_background=colorbg,
            entry_width=10,
            labelpos='w',
            scrolledlist_hull_width=500,
            )
        self.comboboxTitleColorAdjustPieChart.grid(
            row=1,
            column=3,
            padx=5,
            pady=0,
            sticky=E,
            )
        self.comboboxTitleColorAdjustPieChart.selectitem(self.colorsChartTitle[1])

# ... frame_20: legend
# ...       row 0  
# ...       checkbutton
        '''
        self.varCheckbuttonShowLegendAdjustPieChart = IntVar()
        self.varCheckbuttonShowLegendAdjustPieChart.set(
            self.dictPieChartPlotParams_Defaults['showLegend']
            )
        self.checkbuttonShowLegendAdjustPieChart = Checkbutton(
            frame_20,
            bg=colorbg,
            variable=self.varCheckbuttonShowLegendAdjustPieChart,
            justify=LEFT,
            )
        self.checkbuttonShowLegendAdjustPieChart.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            sticky=W,
            )
# ...       label
        labelShowLegendAdjustPieChart = Label(
            frame_20,
            text='Show legend: ',
            bg=colorbg,
            justify=LEFT,
            )
        labelShowLegendAdjustPieChart.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            sticky=W,
            )
# ... font size for legend
        self.comboboxLegendFontAdjustPieChart = Pmw.ComboBox(
            frame_20,
            scrolledlist_items = self.fontsizesChartLabels,
            listheight=160,
            label_text='size:',
            label_background=colorbg,
            labelpos='w',
            entry_width=5,
            )
        self.comboboxLegendFontAdjustPieChart.grid(
            row=0,
            column=2,
            padx=5,
            pady=0,
            sticky=W,
            )
        self.comboboxLegendFontAdjustPieChart.selectitem(self.fontsizesChartLabels[3])
# ... font color for legend
        self.comboboxLegendColorAdjustPieChart = Pmw.ComboBox(
            frame_20,
            scrolledlist_items=self.colorsLegendPieChart,
            listheight=160,
            label_text='  color: ',
            labelpos='w',
            entry_width=10,
            label_background=colorbg,
            )
        self.comboboxLegendColorAdjustPieChart.grid(
            row=0,
            column=3,
            padx=5,
            pady=0,
            )
        self.comboboxLegendColorAdjustPieChart.selectitem(self.colorsLegendPieChart[1])
        '''
        
# frame_30: explode factor
# ...       row 0  
# ...       checkbutton
        self.intvarCheckbuttonExplodeAdjustPieChart = IntVar()
        self.intvarCheckbuttonExplodeAdjustPieChart.set(
            self.dictPieChartPlotParams_Defaults['showExplodedView']
            )
        self.checkbuttonExplodeAdjustPieChart = Checkbutton(
            frame_30,
            bg=colorbg,
            variable=self.intvarCheckbuttonExplodeAdjustPieChart,
            justify=LEFT,
            )
        self.checkbuttonExplodeAdjustPieChart.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            sticky=W,
            )
# ...       label
        labelExplodeAdjustPieChart = Label(
            frame_30,
            text='Show exploded view: ',
            bg=colorbg,
            justify=LEFT,
            )
        labelExplodeAdjustPieChart.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            sticky=W,
            )
# ...       combobox
        self.comboboxExplodeAdjustPieChart = Pmw.ComboBox(
            frame_30,
            scrolledlist_items = self.factorsChartExplodeWedges,
            listheight=160,
            label_text='factor: ',
            label_background=colorbg,
            entry_width=10,
            labelpos='w',
            scrolledlist_hull_width=500,
            )
        self.comboboxExplodeAdjustPieChart.grid(
            row=0,
            column=2,
            padx=5,
            pady=0,
            sticky=W
            )
        self.comboboxExplodeAdjustPieChart.selectitem(self.factorsChartExplodeWedges[4])

# ... frame_40
        '''
# ...       background color
        self.comboboxBackgroundColorAdjustPieChart = Pmw.ComboBox(
            frame_40,
            scrolledlist_items=self.colorsChartBackground,
            listheight=150,
            label_text='Background color: ',
            labelpos='w',
            label_background=colorbg,
            entry_width=10,
            )
        self.comboboxBackgroundColorAdjustPieChart.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
        self.comboboxBackgroundColorAdjustPieChart.selectitem(self.colorsChartBackground[0])
        '''
# ...       text color
        self.comboboxLabelsColorAdjustPieChart = Pmw.ComboBox(
            frame_40,
            scrolledlist_items=self.colorsLabelsPieChart,
            listheight=160,
            label_text='Text color: ',
            labelpos='w',
            entry_width=10,
            label_background=colorbg,
            scrolledlist_hull_width=500,
            )
        self.comboboxLabelsColorAdjustPieChart.grid(
            row=0,
            column=2,
            padx=0,
            pady=0,
            sticky=W,
            )
        self.comboboxLabelsColorAdjustPieChart.selectitem(self.colorsLabelsPieChart[1])
# ... frame 50
# ...       labels
        labelLabelsAdjustPieChart = Label(
            frame_50,
            text='Labels: ',
            bg=colorbg,
            )
        labelLabelsAdjustPieChart.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            sticky=W,
            )
# ...       labels font size
        self.comboboxLabelsFontAdjustPieChart = Pmw.ComboBox(
            frame_50,
            scrolledlist_items = self.fontsizesChartLabels,
            listheight=160,
            label_text='size:',
            label_background=colorbg,
            entry_width=5,
            labelpos='w',
            scrolledlist_hull_width=500,
            )
        self.comboboxLabelsFontAdjustPieChart.grid(
            row=0,
            column=1,
            padx=5,
            pady=0,
            sticky=W,
            )
        self.comboboxLabelsFontAdjustPieChart.selectitem(self.fontsizesChartLabels[3])
# ...       labels color
        '''
        self.comboboxLabelsColorAdjustPieChart = Pmw.ComboBox(
            frame_50,
            scrolledlist_items=self.colorsLabelsPieChart,
            listheight=160,
            label_text='  color: ',
            labelpos='w',
            entry_width=10,
            label_background=colorbg,
            )
        self.comboboxLabelsColorAdjustPieChart.grid(
            row=0,
            column=2,
            padx=10,
            pady=0,
            )
        self.comboboxLabelsColorAdjustPieChart.selectitem(self.colorsLabelsPieChart[1])  
        '''

# ... frame_999
# ...       reset
        buttonResetPieAdjust = Button(
            frame_999,
            text='Reset all',
            font=self.buttonFontSmallest,
            width=12,
            relief=RAISED,
            borderwidth=5,
            background='white',
            foreground='blue',
            command=self.handlerResetPieAdjust
            )
        buttonResetPieAdjust.grid(
            row=0,
            column=0,
            columnspan=2,
            padx=0,
            pady=5,
            )
# ...       re-plot
        buttonReplot = Button(
            frame_999,
            text='Re-plot pie chart',
            width=15,
            relief=RAISED,
            borderwidth=5,
            command=self.handlerReplotPieChart,
            )
        buttonReplot.grid(
            row=1,
            column=0,
            padx=5,
            pady=5,
            )
# ...       cancel
        buttonCancel = Button(
            frame_999,
            text='Cancel',
            width=15,
            relief=RAISED,
            borderwidth=5,
            command=self.handlerQuitPieChartAdjust,
            )
        buttonCancel.grid(
            row=1,
            column=1,
            padx=5,
            pady=5,
            )
        
        return
            
            
    def handlerQuitPieChartAdjust(self):
        '''
        Purpose:
            quit the 'Adjust Pie Chart Specs' window 
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerQuitPieChartAdjust')
            
        self.dictPieChartPlotParams = copy.deepcopy(self.dictPieChartPlotParams_Defaults)
        self.handlerResetPieAdjust()
        self.toplevelChartPieAdjust.destroy()
        
        return


    def handlerResetPieAdjust(self):
        '''
        Purpose: reset Pie Adjust window to default values
        
         self.dictPieChartPlotParams_Defaults = {
            'showTitle' : 1,
            'showYLabel' : 1,
            'titlePieChart' : '',
            'fontsizeTitle' : 16,
            'colorTitle' : 'black',
            'fontsizeLabels' : 14,
            'fontsizeGeneral' : 12,
            'fontsizeLegend' : 'large',
            'factorExplodeWedges' : 0.05,
            'colorChartBackground' : 'white',
            'colorLabels' : 'black',
            'widthChartFigure' : 6,
            'heightChartFigure' : 6,
            }       
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerResetPieAdjust')
            
# set all buttons
        self.intvarCheckbuttonShowTitleAdjustPieChart.set(1)
        
# default values from self.dictPieChartPlotParams_Defaults
# ... title
        self.stringvarEntryShowTitleAdjustPieChart.set(
            self.defaultTitlePieChart
            )
# ... title font
        self.comboboxTitleFontAdjustPieChart.selectitem(
            self.fontsizesChartTitle[4]
            )
# ... figure widths
        '''
        self.comboboxFigureWidthAdjustPieChart.selectitem(
            self.widthsChartFigure[1]
            )
        self.comboboxFigureHeightAdjustPieChart.selectitem(
            self.widthsChartFigure[1]
            )
        '''
# ... exploded view
        self.intvarCheckbuttonExplodeAdjustPieChart.set(1)
        self.comboboxExplodeAdjustPieChart.selectitem(
            self.factorsChartExplodeWedges[4]
            )
# ... background
        '''
        self.comboboxBackgroundColorAdjustPieChart.selectitem(
            self.colorsChartBackground[0]
            )
        '''
# ... labels font size and color
        self.comboboxLabelsFontAdjustPieChart.selectitem(
            self.fontsizesChartLabels[3]
            )
        self.comboboxLabelsColorAdjustPieChart.selectitem(
            self.colorsLabelsPieChart[1]
            )
        
        return
            
            
    def handlerReplotPieChart(self):
        '''
        Purpose:
            replot pie chart with user-defined parameters
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerReplotPieChart')
# plot pie chart with new params
        self.adjustPlotPieChartParams = True
        self.handlerPlotPieChart()
        
        return
                                 
              
    def handlerPlotXYSelect(self):
        '''
        Purpose:
            prepares X-Y data and labels for plotting; 
            calls plot routine
        
        Calls:
            PlotsForPylotDB in module_PylabPlotMySQL_Single
            PlotsForPylotDB in module_PylabPlotMySQL_All
            
        Called by:
            handlerXYPlotPreprocess
            
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerPlotXYSelect')

        self.MySQL_Output(
            0,
            '  Database: ' + self.myDatabase + '  Table: ' +
            self.myTable
            )
            
        xwin=250
        ywin=100
        colorbg2='lightblue'
# one plot or multi-plot            
        selectSingleOrAll = self.varCurvesSelection.get()
#  re-plot in current plot window 
      
        replotPreviousPlot = self.varReplotInCurrentWindow.get()
# ... show current curves on next plot
        keepPreviousPlot = self.varKeepPreviousPlotInCurrentWindow.get()
        if not replotPreviousPlot:
            self.numberPylabPlotFigure += 1
        else:   
            if self.numberPylabPlotFigure == 0:
                self.numberPylabPlotFigure = 1
              
# TABLE
# include select curves from storage buffer
        includeTable = self.varCheckbuttonTableData.get()
        numCurvesSelectedInTable = self.varNumberOfTableCurves.get()
# even tho buffer curves are selected, do not plot if 'includeStorageBuffer' is not checked
        '''
        if not includeTable:
            numCurvesSelectedInTable = 0
        '''
           
# STORAGE BUFFER
# include select cuves from storage buffer
        includeStorageBuffer = self.varCheckbuttonBufferData.get()
        numCurvesSelectedInStorageBuffer = self.varNumberOfStorageBufferCurves.get()
# even tho buffer curves are selected, do not plot if 'includeStorageBuffer' is not checked
        '''
        if not includeStorageBuffer:
            numCurvesSelectedInStorageBuffer = 0
            icount = 0
        '''
        
        if DEBUG_PLOT_XY:
            print 'includeTable =\n'
            print includeTable
            print 'numCurvesSelectedInTable =\n'
            print numCurvesSelectedInTable
            print 'includeStorageBuffer =\n'
            print includeStorageBuffer
            print 'numCurvesSelectedInStorageBuffer = \n'
            print numCurvesSelectedInStorageBuffer
        
            
# ERROR CHECK
# if both numCurvesSelectedInTable and numCurves Selected in Buffer are zero,
#   ... print msg to user to check one or the other only if there are curves to plot!
        '''
        showinfo(
            'Info',
            'includeTable = ' + str(includeTable) + '\n' +
            'numCurvesSelectedInTable = ' + str(numCurvesSelectedInTable) + '\n' +
            'includeStorageBuffer = ' + str(includeStorageBuffer) + '\n' +
            'numCurvesSelectedInStorageBuffer = ' + str(numCurvesSelectedInStorageBuffer),
            parent=self.toplevelXYPlotPreprocess,
            )
        '''

#   ...     if both boxes are unchecked and there is a curve listed for Table or Buffer:
        if (
         (not includeTable)
          and
         (not includeStorageBuffer)
          and
         ((numCurvesSelectedInTable <> 0)
          or
         (numCurvesSelectedInStorageBuffer <> 0))
          ):
            stringNoPlots = (
                'Please check one or both of the following boxes\n' +
                'in the X-Y PLOT SPECS window:\n\n' +
                '  - "Plot curves from Table"\n' +
                '  - "Plot curves from Storage Buffer"\n\n' 
                )
            print stringNoPlots
            self.MySQL_Output(
                0,
                stringNoPlots
                )
            try:
                showerror(
                    'Error: no plots',
                    stringNoPlots,
                    parent=self.toplevelXYPlotPreprocess,
                    )
            except:
                showerror(
                    'Error: no plots',
                    stringNoPlots
                    )
            return
            
#   ...     if there are no curves listed
        elif(
         (numCurvesSelectedInTable == 0)
          and
         (numCurvesSelectedInStorageBuffer == 0)
          ):
            stringNoPlots = (
                'There are no curves available for plotting.\n\n' +
                'Select at least one set of X-Y data and\n' +
                'and try again.'
                )
            print stringNoPlots
            self.MySQL_Output(
                0,
                stringNoPlots
                )
            try:
                showerror(
                    'Error: no plots',
                    stringNoPlots,
                    parent=self.toplevelXYPlotPreprocess,
                    )
            except:
                showerror(
                    'Error: no plots',
                    stringNoPlots
                    )
            return
            
# ...       table curves are zero and buffer curves are not, but Plot Buffer is not checked
        elif(
         (numCurvesSelectedInTable == 0)
          and
         (numCurvesSelectedInStorageBuffer > 0)
          and
         (not includeStorageBuffer)
         ):
            stringNoPlot = (
                'There are no curves selected for plotting.\n\n' +
                'Check the box "Plot curves from Storage Buffer"\n' +
                'and try again.'
                )
            print stringNoPlot
            self.MySQL_Output(
                0,
                stringNoPlots
                )
            try:
                showerror(
                    'Error: no plots',
                    stringNoPlots,
                    parent=self.toplevelXYPlotPreprocess,
                    )
            except:
                showerror(
                    'Error: no plots',
                    stringNoPlots
                    )
            return
            
# ...       buffer curves are zero and table curves are not, but PlotTable is not checked
        elif(
         (numCurvesSelectedInStorageBuffer == 0)
          and
         (numCurvesSelectedInTable > 0)
          and
         (not includeTable)
         ):
            stringNoPlots = (
                'There are no curves selected for plotting.\n\n' +
                'Check the box "Plot curves from Table"\n' +
                'and try again.'
                )
            print stringNoPlots
            self.MySQL_Output(
                0,
                stringNoPlots
                )
            try:
                showerror(
                    'Error: no plots',
                    stringNoPlots,
                    parent=self.toplevelXYPlotPreprocess,
                    )
            except:
                showerror(
                    'Error: no plots',
                    stringNoPlots
                    )
            return
            
        else:
# ...       if get here, everything should be ok
            pass

# END OF ERROR CHECK

            
# if storage buffer data is to be included, find indices of checked data
        indexStorageBuffer = []
        if (numCurvesSelectedInStorageBuffer and includeStorageBuffer):
            for icount,var in enumerate(self.varSelectAnyRow_Buffer):
                if var.get():
                    indexStorageBuffer.append(icount)


# ... plots
#        self.plot_X_Buffer = []
#        self.plot_Y_Buffer = []

# assign index_X 
        index_X = self.varXSelect.get() - 1    
        
# determine base_x and base_y for plots
        forLogPlotsX = self.comboboxBaseForLogPlotsX.get()
        if forLogPlotsX == 'e' or forLogPlotsX == 'log_e' or forLogPlotsX == 'log_10':
            plotbasex = forLogPlotsX
        else:
            plotbasex = float(forLogPlotsX)
                
        forLogPlotsY = self.comboboxBaseForLogPlotsY.get()
        if forLogPlotsY == 'e' or forLogPlotsY == 'log_e' or forLogPlotsY == 'log_10':
            plotbasey = forLogPlotsY
        else:
            plotbasey = float(forLogPlotsY)
      
           
        if selectSingleOrAll == 'single':
            print '\n******* selectSingleOrAll = single *********' 
# initialize
# form plot variables and labels; keep values until new 'Update' is done
# summed values
            self.label_X = []
            self.label_Y = [] 
# for TABLE        
# ... labels
            self.label_X_Table = []
            self.label_Y_Table = []
     
# for STORAGE BUFFER
# ... labels
            self.label_X_Buffer = []
            self.label_Y_Buffer = []
            
# for plots     
            self.plot_Y = []
            self.plot_X = []
            
# if X-Y PLOT LABELS window exists, call method to define labels; else, use default values
            if (numCurvesSelectedInTable and includeTable):
                try:
                    mapped0 = self.toplevelLabelsSinglePlotPerCurve.winfo_exists()
                except:
                    mapped0 = False
                if mapped0:
# get X and Y label strings from Table
                    self.handlerShowXYLabelsTable()
                    self.label_Y_Table.extend(self.yLabelStringTable)
                    if DEBUG_PLOT_XY:
                        print 'len(self.label_Y_Table) =',len(self.label_Y_Table)
                        print ' self.xLabelStringTable =',self.xLabelStringTable
                    for i in range(len(self.label_Y_Table)):
                        self.label_X_Table.extend(self.xLabelStringTable)
                else:  
# default plot labels
                    for index in range(len(self.index_Y)):
# label_X is constant
#                        self.label_X.append(self.tableStructure[index_X][0])
                        self.label_X_Table.extend(self.label_X_Table_Default)
# label_Y is NOT constant
#                        self.label_Y.append(self.tableStructure[index][0])
                        self.label_Y_Table.extend(self.label_Y_Table_Default[index])
                   
# plot labels from Buffer                        
            if (numCurvesSelectedInStorageBuffer and includeStorageBuffer):
# if PLOT LABELS window exists, call method to define labels; else, use default values
                try:
                    mapped1 = self.toplevelLabelsSinglePlotPerCurve.winfo_exists()
                except:
                    mapped1 = False
                if mapped1:
# get X and Y label strings from Buffer
                    self.handlerShowXYLabelsBuffer()
                    self.label_X_Buffer.extend(self.xLabelStringBuffer)
                    self.label_Y_Buffer.extend(self.yLabelStringBuffer)
                    
                else:
                    for indexBufferRow in self.listWhichBufferRowsAreChecked:
                        index=indexBufferRow - 1
                        self.label_X_Buffer.extend(self.bufferRowStore[index][5])
                        self.label_Y_Buffer.extend(self.bufferRowStore[index][6]) 
            
            if DEBUG_PLOT_XY:
                print '\n\n===== Check for single curves per plot ====='
#            print 'self.plot_X_Table =\n', self.plot_X_Table
#            print 'self.plot_Y_Table =\n', self.plot_Y_Table
                print 'self.label_X_Table = \n', self.label_X_Table
                print 'self.label_Y_Table = \n', self.label_Y_Table
                print '\n\n\n'
            
# Join table and buffer plots together, along with their respective labels
# 1111            
            if (
             (numCurvesSelectedInTable and numCurvesSelectedInStorageBuffer) 
               and 
             (includeTable and includeStorageBuffer)
             ):
# ... labels
                self.label_X.extend(self.label_X_Table)
                self.label_Y.extend(self.label_Y_Table)
                
                self.label_X.extend(self.label_X_Buffer)
                self.label_Y.extend(self.label_Y_Buffer)
# ... plots
                self.plot_X.extend(self.plot_X_Table)
                self.plot_Y.extend(self.plot_Y_Table)
                
                self.plot_X.extend(self.plot_X_Buffer)
                self.plot_Y.extend(self.plot_Y_Buffer)
# 1?10
            elif numCurvesSelectedInTable and (includeTable and not includeStorageBuffer):
# ... labels
                self.label_X.extend(self.label_X_Table)
                self.label_Y.extend(self.label_Y_Table)
# ... plots
                self.plot_X.extend(self.plot_X_Table)
                self.plot_Y.extend(self.plot_Y_Table)
# 101?
            elif (
              (numCurvesSelectedInTable and (not numCurvesSelectedInStorageBuffer)) 
               and 
               includeTable
               ):
# ... labels
                self.label_X.extend(self.label_X_Table)
                self.label_Y.extend(self.label_Y_Table)
# ... plots
                self.plot_X.extend(self.plot_X_Table)
                self.plot_Y.extend(self.plot_Y_Table)
# 01?1
            elif (
              ((not numCurvesSelectedInTable) and numCurvesSelectedInStorageBuffer) 
               and 
               includeStorageBuffer
               ):
# ... labels
                self.label_X.extend(self.label_X_Buffer)
                self.label_Y.extend(self.label_Y_Buffer)
# ... plots
                self.plot_X.extend(self.plot_X_Buffer)
                self.plot_Y.extend(self.plot_Y_Buffer)
                
            elif (
              (numCurvesSelectedInTable and numCurvesSelectedInStorageBuffer) 
               and 
               (not includeTable and includeStorageBuffer)
               ):
                self.label_X.extend(self.label_X_Buffer)
                self.label_Y.extend(self.label_Y_Buffer)
# ... plots
                self.plot_X.extend(self.plot_X_Buffer)
                self.plot_Y.extend(self.plot_Y_Buffer)               
# 0100
            elif (
              ((not numCurvesSelectedInTable) and numCurvesSelectedInStorageBuffer) 
               and 
              ((not includeTable) and (not includeStorageBuffer))
              ):
                stringErrorNoPlot = (
                    'No curves have been selected for plotting.\n\n' +
                    'To plot Storage Buffer curves, check the box\n' +
                    ' next to "Include select curves" in the \n' +
                    ' X-Y PLOT SPECS window and try again.'
                    )
                print stringErrorNoPlot
                self.MySQL_Output(
                    0,
                    stringErrorNoPlot
                    )
# 0000
            else:
                stringErrorPlotXY = (
                    'No data are available from either the Table\n' +
                    ' or the Storage Buffer to plot.\n\n' +
                    'Select data from either and try again.'
                    )
                print stringErrorPlotXY
                self.MySQL_Output(
                    0,
                    stringErrorPlotXY
                    )
                showerror(
                    'Error: no data to plot',
                    stringErrorPlotXY
                    )
                return
                
            if DEBUG_PLOT_XY:
                print 'self.label_X =',self.label_X
                print 'self.label_Y =',self.label_Y
                
# check for "None" values
            noneX = False
            noneY = False
            for index in range(len(self.plot_Y)):
                if None in self.plot_Y[index]:
                    noneY = True
                if None in self.plot_X[index]:
                    noneX = True
                
            if noneX or noneY:
                stringNoneNotAllowed = (
                    'The following list contains the value "None":\n\n' 
                    )
                if noneX:
                    stringNoneNotAllowed += '  - X values\n'
                if noneY:
                    stringNoneNotAllowed += '  - Y values\n' 
                stringNoneNotAllowed += (
                    '\nThese lists are not allowed to contain values of "None"\n' +
                    'for plotting purposes.\n\n' +
                    'De-select the fields containing "None" values and try again.'
                    )
                showerror(
                    'Error: "None" value not allowed',
                    stringNoneNotAllowed,
                    parent=self.toplevelXYPlotPreprocess
                    )
                return

# setup dictionary of plot parameters
            self.dictSingleCurvePerChartPlotParams = {
                'showMainTitle' : self.varShowMainTitle_SingleCurvePerPlot.get(),
                'showPlotTitles' : self.varShowTitles_SingleCurvePerPlot.get(),
                'showGrids' : self.varShowGrid_SingleCurvePerPlot.get(),
                'mainTitle' : self.varEntryMainTitle_SingleCurvePerPlot.get(),
                'colorMainTitle' : self.comboboxColorMainTitle_SingleCurvePerPlot.get(),
                'fontsizeMainTitle' : self.comboboxFontMainTitle_SingleCurvePerPlot.get(),
                'fontsizePlotTitles' : self.comboboxFontTitle_SingleCurvePerPlot.get(),
                'fontsizeXYLabels' : self.comboboxFontLabels_SingleCurvePerPlot.get(),
                'colorXYLabels' : self.comboboxColorLabels_SingleCurvePerPlot.get(),
                'fontsizeXTicks' : self.comboboxFontXTicks_SingleCurvePerPlot.get(),
                'colorXTicks' : self.comboboxColorXTicks_SingleCurvePerPlot.get(),
                'fontsizeYTicks' : self.comboboxFontYTicks_SingleCurvePerPlot.get(),
                'colorYTicks' : self.comboboxColorYTicks_SingleCurvePerPlot.get(),
                'colorChartBackground' : self.comboboxColorBackground_SingleCurvePerPlot.get(),
                'colorPlotBorder' : self.comboboxColorBorder_SingleCurvePerPlot.get(),
                'plotStyle' : self.var_radiobuttonPlotStyle.get(),
#                'plotBaseX' : float(self.comboboxBaseForLogPlotsX.get()),
#                'plotBaseY' : float(self.comboboxBaseForLogPlotsY.get()),
                'plotBaseX' : plotbasex,
                'plotBaseY' : plotbasey,
                'lineWidth' : float(self.comboboxLineWidthPlots_XY.get()),
                'markerSize': float(self.comboboxMarkerSizePlots_XY.get())
                }
                
# SINGLE CURVE PER PLOT          
#  plot
#            import module_PylabPlotMySQL_Single 
            module_PylabPlotMySQL_Single.PlotsForPylotDB(
                self.toplevelTableValues,
                keepPreviousPlot,
                xwin,
                ywin,
                self.label_X,
                self.label_Y,
                self.plot_X,
                self.plot_Y,
                numCurvesSelectedInTable,
                numCurvesSelectedInStorageBuffer,
                self.numberPylabPlotFigure,
                **self.dictSingleCurvePerChartPlotParams
                )

# MULTI-CURVE PLOT
        elif selectSingleOrAll == 'all':  
            if DEBUG_PLOT_XY:
                print '\n******* selectSingleOrAll = all *********'        
# initialize
# form plot variables and labels; keep values until new 'Update' is done
# summed values
            self.legendlabel_Y = []
# for Table            
            self.legendlabel_Y_Table = []
# for Buffer
            self.legendlabel_Y_Buffer = []
# for plots
#            self.plot_Y_Table = []
#            self.plot_X_Table = []
            
#            self.plot_Y_Buffer = []
#            self.plot_X_Buffer = []
            
            self.plot_Y = []
            self.plot_X = []


# get plot labels from "X-Y Plot Specs" window
            try:
#                label_X = self.varShowLabelX_AllCurvesOnePlot.get()
                label_X = self.comboboxShowLabelX_AllCurvesOnePlot.get()
            except:
                label_X = ''
                
            try:
                label_Y = self.varShowLabelY_AllCurvesOnePlot.get()
            except:
                label_Y = ''
                
            if DEBUG_PLOT_XY:
                print '\n - label_X =',label_X
                print '\n - label_Y =',label_Y

# legend labels from Table and Buffer            
            if (numCurvesSelectedInTable and includeTable):
                try:
                    mappedAllCurvesOnePlot = self.toplevelLegendLabelsAllCurvesOnePlot.winfo_exists()
                except:
                    mappedAllCurvesOnePlot = 0
                    
                if mappedAllCurvesOnePlot:
                    self.handlerShowLegendLabelsTable()
                    self.legendlabel_Y_Table.extend(self.legendLabelStringTable) 
                else:
# default plot labels for table values - no fancy labels here
                    if DEBUG_PLOT_XY:
                        print '\nself.index_Y =',self.index_Y
                    for index in range(len(self.index_Y)):
                        self.legendlabel_Y_Table.extend(self.label_Y_Table_Default[index])
                        
            if DEBUG_PLOT_XY:
                print('\n - self.legendlabel_Y_Table = %s' % self.legendlabel_Y_Table)

# legend labels from Buffer                       
#            if self.varNumberOfStorageBufferCurves.get() <> 0:
            if (numCurvesSelectedInStorageBuffer and includeStorageBuffer):
                try:
                    mapped2 = self.toplevelLegendLabelsAllCurvesOnePlot.winfo_exists()
                except:
                    mapped2 = False
                if mapped2:
                    if DEBUG_PLOT_XY:
                        print(' *** self.legendLabelStringBuffer = %s' % self.legendLabelStringBuffer)
                        print(' *** type(self.legendLabelStringBuffer) = %s' % type(self.legendLabelStringBuffer))
                    
                    self.handlerShowLegendLabelsBuffer()
                    self.legendlabel_Y_Buffer.extend(self.legendLabelStringBuffer)     
                else:
# default plot labels for buffer values - no fancy labels here, either
                    for indexBufferRow in self.listWhichBufferRowsAreChecked:
                        index=indexBufferRow - 1
                        self.legendlabel_Y_Buffer.extend(self.bufferRowStore[index][6]) 
                        
            if DEBUG_PLOT_XY:
                print '\n - self.legendlabel_Y_Buffer =',self.legendlabel_Y_Buffer

# Join table and buffer plots together, along with their respective labels
# 1111            
            if (
             (numCurvesSelectedInTable and numCurvesSelectedInStorageBuffer) 
               and 
             (includeTable and includeStorageBuffer)
             ):
# ... labels
#                self.label_X = self.label_X_Table
#                self.label_X.extend(self.label_X_Buffer)
                self.legendlabel_Y.extend(self.legendlabel_Y_Table)
                self.legendlabel_Y.extend(self.legendlabel_Y_Buffer)
# ... plots
                self.plot_X.extend(self.plot_X_Table)
                self.plot_Y.extend(self.plot_Y_Table)
                
                self.plot_X.extend(self.plot_X_Buffer)
                self.plot_Y.extend(self.plot_Y_Buffer)
# 1?10
            elif numCurvesSelectedInTable and (includeTable and not includeStorageBuffer):
# ... labels
#                self.label_X = self.label_X_Table
                self.legendlabel_Y.extend(self.legendlabel_Y_Table)
# ... plots
                self.plot_X.extend(self.plot_X_Table)
                self.plot_Y.extend(self.plot_Y_Table)
# 101?
            elif (
              (numCurvesSelectedInTable and (not numCurvesSelectedInStorageBuffer)) 
              and includeTable
              ):
# ... labels
#                self.label_X = self.label_X_Table
                self.legendlabel_Y.extend(self.legendlabel_Y_Table)
# ... plots
                self.plot_X.extend(self.plot_X_Table)
                self.plot_Y.extend(self.plot_Y_Table)
# 01?1
            elif (
              ((not numCurvesSelectedInTable) and numCurvesSelectedInStorageBuffer) 
              and includeStorageBuffer
              ):
# ... labels
#                self.label_X = self.label_X_Buffer
                self.legendlabel_Y.extend(self.legendlabel_Y_Buffer)
# ... plots
                self.plot_X.extend(self.plot_X_Buffer)
                self.plot_Y.extend(self.plot_Y_Buffer)
# 0100
            elif (
              ((not numCurvesSelectedInTable) and numCurvesSelectedInStorageBuffer) 
               and 
              ((not includeTable) and (not includeStorageBuffer))
              ):
                stringErrorNoPlot = (
                    'No curves have been selected for plotting.\n\n' +
                    'To plot Storage Buffer curves, check the box\n' +
                    ' next to "Include select curves" in the \n' +
                    ' X-Y PLOT SPECS window and try again.'
                    )
                print stringErrorNoPlot
                self.MySQL_Output(
                    0,
                    stringErrorNoPlot
                    )
#1101                  
            elif (
              (numCurvesSelectedInTable and numCurvesSelectedInStorageBuffer) 
               and 
               ((not includeTable) and includeStorageBuffer)
               ):
#                self.label_X.extend(self.label_X_Buffer)
#                self.label_Y.extend(self.label_Y_Buffer)
                self.legendlabel_Y.extend(self.legendlabel_Y_Buffer)
# ... plots
                self.plot_X.extend(self.plot_X_Buffer)
                self.plot_Y.extend(self.plot_Y_Buffer)      
# 0000
# 
            else:
                stringErrorPlotXY = (
                    'No data are available from either the Table\n' +
                    ' or the Storage Buffer to plot.\n\n' +
                    'Select data from either and try again.'
                    )
                print stringErrorPlotXY
                self.MySQL_Output(
                    0,
                    stringErrorPlotXY
                    )
                showerror(
                    'Error: no data to plot',
                    stringErrorPlotXY
                    )
                return
                
            if DEBUG_PLOT_XY:
                print('\n - label_X = %s' % label_X)
                print('\n - self.legendlabel_Y = %s' % self.legendlabel_Y)
                print('\n - self.legendlabel_Y_Buffer = %s' % self.legendlabel_Y_Buffer)
                        
# error check on labels
            numCurvesToPlot = (
                includeTable * numCurvesSelectedInTable +
                includeStorageBuffer * numCurvesSelectedInStorageBuffer
                )
            
            if len(self.legendlabel_Y) <> numCurvesToPlot:
                stringErrorLabels = (
                    'The number of X-Y Plot labels does not match' + '\n' +
                    '  the number of curves to plot:\n\n' + 
                    '  Number of plot labels: %s' + '\n' +
                    '  Number of curves to plot: %s' + '\n\n' +
                    'These must be equal to proceed.\n\n' +
                    'This error indicates a coding error exists.\n\n' +
                    'Please notify code administrator of this error.'
                    ) % (len(self.legendlabel_Y),numCurvesToPlot)
                print stringErrorLabels
                self.MySQL_Output(
                    1,
                    stringErrorLabels
                    )
                try:    
                    showerror(
                        'Error: labels-indices mismatch',
                        '\n' + stringErrorLabels + '\n\n',
                        parent=self.toplevelXYPlotPreprocess,
                        )
                except:
                    showerror(
                        'Error: labels-indices mismatch',
                        '\n' + stringErrorLabels + '\n\n'
                        )
                return
                    
            
# get reference curve
            refCurveYes = self.varCheckbuttonShowReferenceCurve_AllCurvesOnePlot.get()
            refCurvePlotX = []
            refCurvePlotY = []
            refCurveLabel = ''
            if refCurveYes:
# determine curve index
                labelFromPlottingSpecsWindow = self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot.get()
                i_label = False
#                for index in range(len(self.headerNames_Y_Table)):
#                for index in range(len(self.headerNames_Y)):
                for index in range(len(self.legendlabel_Y)):
#                    if self.headerNames_Y[index] == labelFromPlottingSpecsWindow:
#                    if self.legendlabel_Y[index] == labelFromPlottingSpecsWindow:
                    if self.legendNamesForCurveLabeled[index] == labelFromPlottingSpecsWindow:
                        i_label = True
                        refCurveIndex = index
#                        refCurveLabel = self.headerNames_Y[index]
                        refCurveLabel = self.legendlabel_Y[index]
                        if DEBUG_PLOT_XY:
                            print '\n*****\nrefCurveLabel =',refCurveLabel
                            print '*****\n'
                            print 'refCurveIndex =',refCurveIndex
                        break
                if i_label == False:
                    stringErrorLabel = (
                        'Index for ref curve in Plotting Specs window does\n' +
                        '  NOT match any index in the header names.\n\n' +
                        'This is a coding error. Please contact code administrator.'
                        )
                    print stringErrorLabel
                    self.MySQL_Output(
                        0,
                        '\n' + stringErrorLabel
                        )
                    showerror(
                        'Error: index mismatch',
                        stringErrorLabel
                        )
                    return
                                              
#                refCurveLabel = self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot.get()
# find curve associated with refCurveLabel
# ... must look in Table curves first, then Buffer curves
# ... number of Table curves: self.varNumberOfTableCurves.get()
# ... number of Buffer curves: self.varNumberOfStorageBufferCurves.get()
#
         
#                for index in range(len(self.tableValues)):
#                    refCurvePlotY.append(self.tableValues[index][refCurveIndex])
                    
                refCurvePlotY = self.plot_Y[refCurveIndex]
                refCurvePlotX = self.plot_X[refCurveIndex]
                
                
# get SLOPED straight-line reference curve
            refSlopedStraightLineCurveYes = self.varCheckbuttonShowSlopedStraightReferenceCurve_AllCurvesOnePlot.get()
            refSlopedStraightLineCurvePlotX = []
            refSlopedStraightLineCurvePlotY = []
            refSlopedStraightLineCurveSlopeInDegrees = ''
            if refSlopedStraightLineCurveYes:
# error check
                stringErrorrefSlopedStraightLineCurve = ''
                yRefInitial = self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yinitial.get()
                yRefFinal = self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yfinal.get()
                xRefInitial = self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xinitial.get()
                xRefFinal = self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xfinal.get()
# ... check for blanks
                if ( yRefInitial == '' or yRefFinal == '' or xRefInitial == '' or xRefFinal == ''):
                    if yRefInitial == '':
                        stringErrorrefSlopedStraightLineCurve += (
                            ' - field for Y(initial) is blank\n'
                            )
                    if yRefFinal == '':
                        stringErrorrefSlopedStraightLineCurve += (
                            ' - field for Y(final) is blank\n'
                            )
                    if xRefInitial == '':
                        stringErrorrefSlopedStraightLineCurve += (
                            ' - field for X(initial) is blank\n'
                            )
                    if xRefFinal == '':
                        stringErrorrefSlopedStraightLineCurve += (
                            ' - field for X(final) is blank\n'
                            )
# ... if errors found, print and exit
                if stringErrorrefSlopedStraightLineCurve <> '':
                    stringText = (
                        'The following errors have been found related to\n' +
                        'plotting the sloped reference line:\n\n' +
                        stringErrorrefSlopedStraightLineCurve + '\n\n' +
                        'Correct these errors and try again.'
                        )
                    print stringText
                    self.MySQL_Output(
                        0,
                        stringText
                        )
                    showerror(
                        'Error: sloped ref line',
                        stringText,
                        parent=self.toplevelXYPlotPreprocess
                        )
                    return
                    
# If we get this far, sloped ref line has been specified correctly for plotting

# for plots, specify y = same value twice; x = initial and final values                    
                refSlopedStraightLineCurvePlotY = [
                    float(self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yinitial.get()),
                    float(self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yfinal.get())
                    ]
                refSlopedStraightLineCurvePlotX = [
                    float(self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xinitial.get()),
                    float(self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xfinal.get())
                    ]
                refSlopedStraightLineCurveDeltaY = (
                    float(self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yfinal.get()) - 
                    float(self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yinitial.get())
                    )
                refSlopedStraightLineCurveDeltaX = (
                    float(self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xfinal.get()) - 
                    float(self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xinitial.get())
                    )
                refSlopedStraightLineCurveSlopeInDegrees = '{0:.2f}'.format(
                    math.degrees(
                        math.atan2(
                            refSlopedStraightLineCurveDeltaY,
                            refSlopedStraightLineCurveDeltaX
                            )
                        )
                    )
# label for horizontal straight-line reference curve
            refSlopedStraightLineCurveLabel = ''
# ... add user-specified label
            if self.varCheckbuttonLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot.get():
                refSlopedStraightLineCurveLabel = self.entryfieldLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot.get().strip()
# ... add slope value in degrees
            if self.varCheckbuttonLabelSlopeDegreesSlopedStraightReferenceCurve_AllCurvesOnePlot.get():
                refSlopedStraightLineCurveLabel += ' (' + str(refSlopedStraightLineCurveSlopeInDegrees) + ' degs)'
# ... always add 'ref' to user label, but if no user label, use default
            if refSlopedStraightLineCurveLabel == '':
                refSlopedStraightLineCurveLabel = 'sloped ref line [ref]'  # default value
            else:
                refSlopedStraightLineCurveLabel += ' [ref]'   
                
                
# get HORIZONTAL straight-line reference curve
            refHorizontalStraightLineCurveYes = self.varCheckbuttonShowHorizontalStraightReferenceCurve_AllCurvesOnePlot.get()
            refHorizontalStraightLineCurvePlotX = []
            refHorizontalStraightLineCurvePlotY = []
            if refHorizontalStraightLineCurveYes:
# error check
                stringErrorrefHorizontalStraightLineCurve = ''
                yRef = self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Y.get()
                xRefInitial = self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xinitial.get()
                xRefFinal = self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xfinal.get()
# ... check for blanks
                if ( yRef == '' or xRefInitial == '' or xRefFinal == ''):
                    if yRef == '':
                        stringErrorrefHorizontalStraightLineCurve += (
                            ' - field for Y value is blank\n'
                            )
                    if xRefInitial == '':
                        stringErrorrefHorizontalStraightLineCurve += (
                            ' - field for X(initial) is blank\n'
                            )
                    if xRefFinal == '':
                        stringErrorrefHorizontalStraightLineCurve += (
                            ' - field for X(final) is blank\n'
                            )
# ... check for duplicate x values
                if xRefInitial == xRefFinal:
                    stringErrorrefHorizontalStraightLineCurve += (
                        ' - X(initial = X(final); values must be different'
                        )
# ... if errors found, print and exit
                if stringErrorrefHorizontalStraightLineCurve <> '':
                    stringText = (
                        'The following errors have been found related to\n' +
                        'plotting the horizontal reference line:\n\n' +
                        stringErrorrefHorizontalStraightLineCurve + '\n\n' +
                        'Correct these errors and try again.'
                        )
                    print stringText
                    self.MySQL_Output(
                        0,
                        stringText
                        )
                    showerror(
                        'Error: horizontal ref line',
                        stringText,
                        parent=self.toplevelXYPlotPreprocess
                        )
                    return
                    
# If we get this far, horizontal ref line has been specified correctly for plotting

# for plots, specify y = same value twice; x = initial and final values                    
                refHorizontalStraightLineCurvePlotY = [
                    float(self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Y.get()),
                    float(self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Y.get())
                    ]
                refHorizontalStraightLineCurvePlotX = [
                    float(self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xinitial.get()),
                    float(self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xfinal.get())
                    ]
# label for horizontal straight-line reference curve
            refHorizontalStraightLineCurveLabel = ''
# ... add user-specified label
            if self.varCheckbuttonLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot.get():
                refHorizontalStraightLineCurveLabel = self.entryfieldLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot.get().strip()
# ... add y value
            if self.varCheckbuttonLabelYMaxHorizontalStraightReferenceCurve_AllCurvesOnePlot.get():
                refHorizontalStraightLineCurveLabel += ' (Y=' + self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Y.get().strip() + ')'
# ... always add 'ref' to user label, but if no user label, use default
            if refHorizontalStraightLineCurveLabel == '':
                refHorizontalStraightLineCurveLabel = 'horiz. ref line [ref]'  # default value
            else:
                refHorizontalStraightLineCurveLabel += ' [ref]'  

                
                
# get VERTICAL straight-line reference curve
            refVerticalStraightLineCurveYes = self.varCheckbuttonShowVerticalStraightReferenceCurve_AllCurvesOnePlot.get()
            refVerticalStraightLineCurvePlotX = []
            refVerticalStraightLineCurvePlotY = []
            if refVerticalStraightLineCurveYes:
# error check
                stringErrorRefVerticalStraightLineCurve = ''
                xRef = self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_X.get()
                yRefInitial = self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yinitial.get()
                yRefFinal = self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yfinal.get()
# ... check for blanks
                if ( xRef == '' or yRefInitial == '' or yRefFinal == ''):
                    if xRef == '':
                        stringErrorRefVerticalStraightLineCurve += (
                            ' - field for X value is blank\n'
                            )
                    if yRefInitial == '':
                        stringErrorRefVerticalStraightLineCurve += (
                            ' - field for Y(initial) is blank\n'
                            )
                    if yRefFinal == '':
                        stringErrorRefVerticalStraightLineCurve += (
                            ' - field for Y(final) is blank\n'
                            )
# ... check for duplicate y values
                if yRefInitial == yRefFinal:
                    stringErrorRefVerticalStraightLineCurve += (
                        ' - Y(initial = Y(final); values must be different'
                        )
# ... if errors found, print and exit
                if stringErrorRefVerticalStraightLineCurve <> '':
                    stringText = (
                        'The following errors have been found related to\n' +
                        'plotting the vertical reference line:\n\n' +
                        stringErrorRefVerticalStraightLineCurve + '\n\n' +
                        'Correct these errors and try again.'
                        )
                    print stringText
                    self.MySQL_Output(
                        0,
                        stringText
                        )
                    showerror(
                        'Error: vertical ref line',
                        stringText,
                        parent=self.toplevelXYPlotPreprocess
                        )
                    return
                    
# If we get this far, vertical ref line has been specified correctly for plotting

# for plots, specify y = same value twice; x = initial and final values                    
                refVerticalStraightLineCurvePlotX = [
                    float(self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_X.get()),
                    float(self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_X.get())
                    ]
                refVerticalStraightLineCurvePlotY = [
                    float(self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yinitial.get()),
                    float(self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yfinal.get())
                    ]
# label for vertical straight-line reference curve
            refVerticalStraightLineCurveLabel = ''
# ... add user-specified label
            if self.varCheckbuttonLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot.get():
                refVerticalStraightLineCurveLabel = \
                    self.entryfieldLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot.get().strip()
# ... add y value
            if self.varCheckbuttonLabelXMaxVerticalStraightLineReferenceCurve_AllCurvesOnePlot.get():
                refVerticalStraightLineCurveLabel += (
                    ' (X=' + 
                    self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_X.get().strip() 
                    + ')'
                    )
# ... always add 'ref' to user label, but if no user label, use default
            if refVerticalStraightLineCurveLabel == '':
                refVerticalStraightLineCurveLabel = 'vert. ref line [ref]'  # default value
            else:
                refVerticalStraightLineCurveLabel += ' [ref]'
                        
# set up **kwargs
            self.dictMultiCurvePerChartPlotParams = {
                'showTitle' : self.varCheckbuttonShowTitle_AllCurvesOnePlot.get(),
                'showYLabel' : self.varCheckbuttonShowLabelY_AllCurvesOnePlot.get(),
                'showXLabel' : self.varCheckbuttonShowLabelX_AllCurvesOnePlot.get(),
                'showLegend' : self.varCheckbuttonShowLegend_AllCurvesOnePlot.get(),
                'showGrid' : self.varCheckbuttonShowGrid_AllCurvesOnePlot.get(),
                'showReferenceCurve' : self.varCheckbuttonShowReferenceCurve_AllCurvesOnePlot.get(),
                'showSlopedStraightLineReferenceCurve' : 
                    self.varCheckbuttonShowSlopedStraightReferenceCurve_AllCurvesOnePlot.get(),
                'showHorizontalStraightLineReferenceCurve' : 
                    self.varCheckbuttonShowHorizontalStraightReferenceCurve_AllCurvesOnePlot.get(),
                'showVerticalStraightLineReferenceCurve' : 
                    self.varCheckbuttonShowVerticalStraightReferenceCurve_AllCurvesOnePlot.get(),
                'colorBackground' : self.comboboxColorBackground_AllCurvesOnePlot.get(),
                'colorPlotBorder' : self.comboboxColorBorder_AllCurvesOnePlot.get(),
                'colorXYLabels' : self.comboboxColorXYLabels_AllCurvesOnePlot.get(),
                'colorXTicks' : self.comboboxColorXTicks_AllCurvesOnePlot.get(),
                'colorYTicks' : self.comboboxColorYTicks_AllCurvesOnePlot.get(),
                'colorTitle' : self.comboboxColorTitle_AllCurvesOnePlot.get(),
                'fontsizeTitle' : self.comboboxFontTitle_AllCurvesOnePlot.get(),
                'fontsizeXYLabels' : self.comboboxFontXYLabels_AllCurvesOnePlot.get(),
                'fontsizeXTicks' : self.comboboxFontXTicks_AllCurvesOnePlot.get(),
                'fontsizeYTicks' : self.comboboxFontYTicks_AllCurvesOnePlot.get(),           
                'fontsizeLegend' : self.comboboxFontLegend_AllCurvesOnePlot.get(),
                'valueTitle' : self.varEntryShowTitle_AllCurvesOnePlot.get(),
                'valueLabelY' : label_Y,
                'valueLabelX' : label_X,
                'valueLegendLocation' : self.comboboxShowLegendLocation_AllCurvesOnePlot.get(),
                'valuesLegendLabels' : self.legendlabel_Y,
                'valueRefCurveMultiplier' : self.comboboxShowReferenceCurveMultiplier_AllCurvesOnePlot.get(),
                'valueRefCurveLabel' : refCurveLabel,
                'valueSlopedStraightLineRefCurveLabel' : refSlopedStraightLineCurveLabel,
                'valueHorizontalStraightLineRefCurveLabel' : refHorizontalStraightLineCurveLabel,
                'valueVerticalStraightLineRefCurveLabel' : refVerticalStraightLineCurveLabel,
                'valuesRefCurvePlotYList' : refCurvePlotY,
                'valuesRefCurvePlotXList' : refCurvePlotX,
                'valuesSlopedStraightLineRefCurvePlotYList' : refSlopedStraightLineCurvePlotY,
                'valuesSlopedStraightLineRefCurvePlotXList' : refSlopedStraightLineCurvePlotX,
                'valuesHorizontalStraightLineRefCurvePlotYList' : refHorizontalStraightLineCurvePlotY,
                'valuesHorizontalStraightLineRefCurvePlotXList' : refHorizontalStraightLineCurvePlotX,
                'valuesVerticalStraightLineRefCurvePlotYList' : refVerticalStraightLineCurvePlotY,
                'valuesVerticalStraightLineRefCurvePlotXList' : refVerticalStraightLineCurvePlotX,
                'plotStyle' : self.var_radiobuttonPlotStyle.get(),
                'plotBaseX' : plotbasex,
                'plotBaseY' : plotbasey,
                'lineWidth' : float(self.comboboxLineWidthPlots_XY.get()),
                'markerSize' : float(self.comboboxMarkerSizePlots_XY.get())
                }            
#  plot
            module_PylabPlotMySQL_All.PlotsForPylotDB(
                self,
                self.toplevelTableValues,
                keepPreviousPlot,
                xwin,
                ywin,
                colorbg2,
                self.plot_X,
                self.plot_Y,
                numCurvesSelectedInTable,
                numCurvesSelectedInStorageBuffer,
#                self.varNumberOfTableCurves.get(),
#                self.varNumberOfStorageBufferCurves.get(),
                self.numberPylabPlotFigure,
                **self.dictMultiCurvePerChartPlotParams
                )
        
# ERROR        
        else:
            stringSelectError = (
                'Selection error:\n' +
                '  selection should be "single" or "all".\n' +
                '  selection = ' + selectSingleOrAll + '\n'
                'This is a coding error. Contact code administrator.\n' +
                'This process is terminated.' + '\n'
                )
            print stringSelectError
            self.MySQL_Output(
                1,
                stringSelectError
                )
            showerror(
                'Error: invalid selection value',
                '\n' + stringSelectError + '\n'
                )
                
        return
        
        
    def handlerPlotScatterSelect(self):
        '''
        Purpose:
            prepares scatter plot data and labels for plotting; 
            calls plot routine
        
        Calls:
            PlotsForPylotDB in module_PylabPlotMySQL_All_Scatter
            
        Called by:
            handlerScatterPlotPreprocess
            
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerPlotScatterSelect')

        self.MySQL_Output(
            0,
            '  Database: ' + self.myDatabase + '  Table: ' +
            self.myTable
            )
            
        xwin=250
        ywin=100
        colorbg2='lightblue'

#  re-plot in current plot window       
        replotPreviousPlot = self.varReplotInCurrentWindow_Scatter.get()

# ... show current curves on next plot
        keepPreviousPlot = self.varKeepPreviousPlotInCurrentWindow_Scatter.get()
        if not replotPreviousPlot:
            self.numberPylabPlotFigure_Scatter += 1
        else:   
            if self.numberPylabPlotFigure_Scatter == 0:
                self.numberPylabPlotFigure_Scatter = 1
              
# TABLE
# include select curves from storage buffer
        includeTable = self.varCheckbuttonTableData_Scatter.get()
        numCurvesSelectedInTable = self.varNumberOfTableCurves_Scatter.get()
        
# even tho buffer curves are selected, do not plot if 'includeStorageBuffer' is not checked
        '''
        if not includeTable:
            numCurvesSelectedInTable = 0
        '''
           
# STORAGE BUFFER
# include select cuves from storage buffer
        includeStorageBuffer = self.varCheckbuttonBufferData_Scatter.get()
        numCurvesSelectedInStorageBuffer = self.varNumberOfStorageBufferCurves_Scatter.get()
        
# even tho buffer curves are selected, do not plot if 'includeStorageBuffer' is not checked
        '''
        if not includeStorageBuffer:
            numCurvesSelectedInStorageBuffer = 0
            icount = 0
        '''
        
        if DEBUG_PLOT_SCATTER:
            print('\nFor Scatter Plots:')
            print('  includeTable = %s' % includeTable)
            print('  numCurvesSelectedInTable = %s' % numCurvesSelectedInTable)
            print('  includeStorageBuffer = %s' % includeStorageBuffer)
            print('  numCurvesSelectedInStorageBuffer = %s\n' % numCurvesSelectedInStorageBuffer)
        
            
# ERROR CHECK
# if both numCurvesSelectedInTable and numCurves Selected in Buffer are zero,
#   ... print msg to user to check one or the other only if there are curves to plot!
        '''
        showinfo(
            'Info',
            'includeTable = ' + str(includeTable) + '\n' +
            'numCurvesSelectedInTable = ' + str(numCurvesSelectedInTable) + '\n' +
            'includeStorageBuffer = ' + str(includeStorageBuffer) + '\n' +
            'numCurvesSelectedInStorageBuffer = ' + str(numCurvesSelectedInStorageBuffer),
            parent=self.toplevelXYPlotPreprocess,
            )
        '''

#   ...     if both boxes are unchecked and there is a curve listed for Table or Buffer:
        if (
         (not includeTable)
          and
         (not includeStorageBuffer)
          and
         ((numCurvesSelectedInTable <> 0)
          or
         (numCurvesSelectedInStorageBuffer <> 0))
          ):
            stringNoPlots = (
                'Please check one or both of the following boxes\n' +
                'in the SCATTER PLOT SPECS window:\n\n' +
                '  - "Plot curves from Table"\n' +
                '  - "Plot curves from Storage Buffer"\n\n' 
                )
            print stringNoPlots
            self.MySQL_Output(
                0,
                stringNoPlots
                )
            try:
                showerror(
                    'Error: no plots',
                    stringNoPlots,
                    parent=self.toplevelScatterPlotPreprocess,
                    )
            except:
                showerror(
                    'Error: no plots',
                    stringNoPlots
                    )
            return
            
#   ...     if there are no curves listed
        elif(
         (numCurvesSelectedInTable == 0)
          and
         (numCurvesSelectedInStorageBuffer == 0)
          ):
            stringNoPlots = (
                'There are no curves available for plotting.\n\n' +
                'Select at least one set of X-Y data and\n' +
                'and try again.'
                )
            print stringNoPlots
            self.MySQL_Output(
                0,
                stringNoPlots
                )
            try:
                showerror(
                    'Error: no plots',
                    stringNoPlots,
                    parent=self.toplevelScatterPlotPreprocess,
                    )
            except:
                showerror(
                    'Error: no plots',
                    stringNoPlots
                    )
            return
            
# ...       table curves are zero and buffer curves are not, but Plot Buffer is not checked
        elif(
         (numCurvesSelectedInTable == 0)
          and
         (numCurvesSelectedInStorageBuffer > 0)
          and
         (not includeStorageBuffer)
         ):
            stringNoPlot = (
                'There are no curves selected for plotting.\n\n' +
                'Check the box "Plot curves from Storage Buffer"\n' +
                'and try again.'
                )
            print stringNoPlot
            self.MySQL_Output(
                0,
                stringNoPlots
                )
            try:
                showerror(
                    'Error: no plots',
                    stringNoPlots,
                    parent=self.toplevelScatterPlotPreprocess,
                    )
            except:
                showerror(
                    'Error: no plots',
                    stringNoPlots
                    )
            return
            
# ...       buffer curves are zero and table curves are not, but PlotTable is not checked
        elif(
         (numCurvesSelectedInStorageBuffer == 0)
          and
         (numCurvesSelectedInTable > 0)
          and
         (not includeTable)
         ):
            stringNoPlots = (
                'There are no curves selected for plotting.\n\n' +
                'Check the box "Plot curves from Table"\n' +
                'and try again.'
                )
            print stringNoPlots
            self.MySQL_Output(
                0,
                stringNoPlots
                )
            try:
                showerror(
                    'Error: no plots',
                    stringNoPlots,
                    parent=self.toplevelScatterPlotPreprocess,
                    )
            except:
                showerror(
                    'Error: no plots',
                    stringNoPlots
                    )
            return
            
        else:
# ...       if get here, everything should be ok
            pass

# END OF ERROR CHECK

            
# if storage buffer data is to be included, find indices of checked data
        indexStorageBuffer = []
        if (numCurvesSelectedInStorageBuffer and includeStorageBuffer):
            for icount,var in enumerate(self.varSelectAnyRow_Buffer):
                if var.get():
                    indexStorageBuffer.append(icount)


# ... plots
#        self.plot_X_Buffer = []
#        self.plot_Y_Buffer = []

# assign index_X 
        index_X = self.varXSelect.get() - 1    

        
# initialize and form plot variables and labels; keep values until new 'Update' is done
# ... summed values
        self.legendlabel_Y_Scatter = []
# ... for Table            
        self.legendlabel_Y_Table_Scatter = []
# ... for Buffer
        self.legendlabel_Y_Buffer_Scatter = []
# ... for plots
        
        self.plot_Y_Scatter = []
        self.plot_X_Scatter = []


# get plot labels from "X-Y Plot Specs" window
        try:
#                label_X = self.varShowLabelX_AllCurvesOnePlot.get()
            label_X = self.comboboxShowLabelX_AllCurvesOnePlot_Scatter.get()
        except:
            label_X = ''
            
        try:
            label_Y = self.varEntryShowLabelY_AllCurvesOnePlot_Scatter.get()
        except:
            label_Y = ''
            
        if DEBUG_PLOT_SCATTER:
            print '\n - label_X =',label_X
            print '\n - label_Y =',label_Y

# legend labels from Table and Buffer            
        if (numCurvesSelectedInTable and includeTable):
            try:
                mappedAllCurvesOnePlot = self.toplevelLegendLabelsAllCurvesOnePlot_Scatter.winfo_exists()
            except:
                mappedAllCurvesOnePlot = False
                
            if mappedAllCurvesOnePlot:
                self.handlerShowLegendLabelsTable_Scatter()
                self.legendlabel_Y_Table_Scatter.extend(self.legendLabelStringTable_Scatter) 
            else:
# default plot labels for table values - no fancy labels here
                if DEBUG_PLOT_SCATTER:
                    print '\nself.index_Y_Scatter =',self.index_Y_Scatter
                for index in range(len(self.index_Y_Scatter)):
                    self.legendlabel_Y_Table_Scatter.extend(self.label_Y_Table_Default_Scatter[index])
                    
        if DEBUG_PLOT_SCATTER:
            print('\n - self.legendlabel_Y_Table_Scatter = %s' % self.legendlabel_Y_Table_Scatter)

# legend labels from Buffer                       
#            if self.varNumberOfStorageBufferCurves.get() <> 0:
        if (numCurvesSelectedInStorageBuffer and includeStorageBuffer):
            try:
                mapped = self.toplevelLegendLabelsAllCurvesOnePlot_Scatter.winfo_exists()
            except:
                mapped = False
            if mapped:
                if DEBUG_PLOT_SCATTER:
                    print(' *** self.legendLabelStringBuffer_Scatter = %s' % self.legendLabelStringBuffer_Scatter)
                    print(' *** type(self.legendLabelStringBuffer_Scatter) = %s' % type(self.legendLabelStringBuffer_Scatter))
                    print(' *** numCurvesSelectedInStorageBuffer = %s' % numCurvesSelectedInStorageBuffer)
                    print(' *** self.listWhichBufferRowsAreChecked = %s' % self.listWhichBufferRowsAreChecked)
                
                self.handlerShowLegendLabelsBuffer_Scatter()
                self.legendlabel_Y_Buffer_Scatter.extend(self.legendLabelStringBuffer_Scatter)     
            else:
# default plot labels for buffer values - no fancy labels here, either
                for indexBufferRow in self.listWhichBufferRowsAreChecked:
                    index=indexBufferRow - 1
                    self.legendlabel_Y_Buffer_Scatter.extend(self.bufferRowStore[index][6]) 
                    
        if DEBUG_PLOT_SCATTER:
            print '\n - self.legendlabel_Y_Buffer_Scatter =',self.legendlabel_Y_Buffer_Scatter

# Join table and buffer plots together, along with their respective labels
# 1111            
        if (
         (numCurvesSelectedInTable and numCurvesSelectedInStorageBuffer) 
           and 
         (includeTable and includeStorageBuffer)
         ):
# ... labels
#                self.label_X = self.label_X_Table
#                self.label_X.extend(self.label_X_Buffer)
            self.legendlabel_Y_Scatter.extend(self.legendlabel_Y_Table_Scatter)
            self.legendlabel_Y_Scatter.extend(self.legendlabel_Y_Buffer_Scatter)
# ... plots
            self.plot_X_Scatter.extend(self.plot_X_Table_Scatter)
            self.plot_Y_Scatter.extend(self.plot_Y_Table_Scatter)
            
            self.plot_X_Scatter.extend(self.plot_X_Buffer_Scatter)
            self.plot_Y_Scatter.extend(self.plot_Y_Buffer_Scatter)
# 1?10
        elif numCurvesSelectedInTable and (includeTable and not includeStorageBuffer):
# ... labels
#                self.label_X = self.label_X_Table
            self.legendlabel_Y_Scatter.extend(self.legendlabel_Y_Table_Scatter)
# ... plots
            self.plot_X_Scatter.extend(self.plot_X_Table_Scatter)
            self.plot_Y_Scatter.extend(self.plot_Y_Table_Scatter)
# 101?
        elif (
          (numCurvesSelectedInTable and (not numCurvesSelectedInStorageBuffer)) 
          and includeTable
          ):
# ... labels
#                self.label_X = self.label_X_Table
            self.legendlabel_Y_Scatter.extend(self.legendlabel_Y_Table_Scatter)
# ... plots
            self.plot_X_Scatter.extend(self.plot_X_Table_Scatter)
            self.plot_Y_Scatter.extend(self.plot_Y_Table_Scatter)
# 01?1
        elif (
          ((not numCurvesSelectedInTable) and numCurvesSelectedInStorageBuffer) 
          and includeStorageBuffer
          ):
# ... labels
#                self.label_X = self.label_X_Buffer
            self.legendlabel_Y_Scatter.extend(self.legendlabel_Y_Buffer_Scatter)
# ... plots
            self.plot_X_Scatter.extend(self.plot_X_Buffer_Scatter)
            self.plot_Y_Scatter.extend(self.plot_Y_Buffer_Scatter)
# 0100
        elif (
          ((not numCurvesSelectedInTable) and numCurvesSelectedInStorageBuffer) 
           and 
          ((not includeTable) and (not includeStorageBuffer))
          ):
            stringErrorNoPlot = (
                'No curves have been selected for plotting.\n\n' +
                'To plot Storage Buffer curves, check the box\n' +
                ' next to "Include select curves" in the \n' +
                ' SCATTER PLOT SPECS window and try again.'
                )
            print stringErrorNoPlot
            self.MySQL_Output(
                0,
                stringErrorNoPlot
                )
#1101                  
        elif (
          (numCurvesSelectedInTable and numCurvesSelectedInStorageBuffer) 
           and 
           ((not includeTable) and includeStorageBuffer)
           ):
#                self.label_X.extend(self.label_X_Buffer)
#                self.label_Y.extend(self.label_Y_Buffer)
            self.legendlabel_Y_Scatter.extend(self.legendlabel_Y_Buffer_Scatter)
# ... plots
            self.plot_X_Scatter.extend(self.plot_X_Buffer_Scatter)
            self.plot_Y_Scatter.extend(self.plot_Y_Buffer_Scatter)      
# 0000
# 
        else:
            stringErrorPlotScatter = (
                'No data are available from either the Table\n' +
                ' or the Storage Buffer to plot.\n\n' +
                'Select data from either and try again.'
                )
            print stringErrorPlotScatter
            self.MySQL_Output(
                0,
                stringErrorPlotScatter
                )
            showerror(
                'Error: no data to plot',
                stringErrorPlotScatter
                )
            return
            
        if DEBUG_PLOT_SCATTER:
            print('\n - label_X = %s' % label_X)
            print('\n - self.legendlabel_Y_Scatter = %s' % self.legendlabel_Y_Scatter)
            print('\n - self.legendlabel_Y_Buffer_Scatter = %s' % self.legendlabel_Y_Buffer_Scatter)
            print('\n\nself.plot_Y_Scatter:')
            print(self.plot_Y_Scatter)
            print('\nself.plot_X_Scatter:')
            print(self.plot_X_Scatter)
        
# check for "None" values
        noneX = False
        noneY = False
        for index in range(len(self.plot_Y_Scatter)):
            if None in self.plot_Y_Scatter[index]:
                noneY = True
            if None in self.plot_X_Scatter[index]:
                noneX = True
                
        if noneX or noneY:
            stringNoneNotAllowed = (
                'The following lists contains the value "None":\n\n' 
                )
            if noneX:
                stringNoneNotAllowed += '  - X values\n'
            if noneY:
                stringNoneNotAllowed += '  - Y values\n' 
            stringNoneNotAllowed += (
                '\nThese lists are not allowed to contain values of "None"\n' +
                'for plotting purposes.\n\n' +
                'De-select the fields containing "None" values and try again.'
                )
            showerror(
                'Error: "None" value not allowed',
                stringNoneNotAllowed,
                parent=self.toplevelScatterPlotPreprocess
                )
            return


# determine legend labels
        '''
        valuesLegendLabels = []
        for index in self.index_Y:
            for key,value in self.dictColumnHeaders.iteritems():
                if value == index + 1:
                    valuesLegendLabels.append(key)

        valuesLegendLabels = label_Y
        '''
                    
# error check on labels
        numCurvesToPlot = (
            includeTable * numCurvesSelectedInTable +
            includeStorageBuffer * numCurvesSelectedInStorageBuffer
            )
        
        if len(self.legendlabel_Y_Scatter) <> numCurvesToPlot:
            stringErrorLabels = (
                'The number of Scatter Plot labels does not match' + '\n' +
                '  the number of curves to plot:\n\n' + 
                '  Number of plot labels: %s' + '\n' +
                '  Number of curves to plot: %s' + '\n\n' +
                'These must be equal to proceed.\n\n' +
                'This error indicates a coding error exists.\n\n' +
                'Please notify code administrator of this error.'
                ) % (len(self.legendlabel_Y_Scatter),numCurvesToPlot)
            print stringErrorLabels
            self.MySQL_Output(
                1,
                stringErrorLabels
                )
            try:    
                showerror(
                    'Error: labels-indices mismatch',
                    '\n' + stringErrorLabels + '\n\n',
                    parent=self.toplevelScatterPlotPreprocess,
                    )
            except:
                showerror(
                    'Error: labels-indices mismatch',
                    '\n' + stringErrorLabels + '\n\n'
                    )
            return
            
            
# parameters for polynomial curve fit
                
        
# get reference curve
        refCurveYes = self.varCheckbuttonShowReferenceCurve_AllCurvesOnePlot_Scatter.get()
        refCurvePlotX = []
        refCurvePlotY = []
        refCurveLabel = ''
        if refCurveYes:
# determine curve index
            labelFromPlottingSpecsWindow = self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot_Scatter.get()
            i_label = False
#                for index in range(len(self.headerNames_Y_Table)):
#                for index in range(len(self.headerNames_Y)):
            for index in range(len(self.legendlabel_Y_Scatter)):
#                    if self.headerNames_Y[index] == labelFromPlottingSpecsWindow:
#                    if self.legendlabel_Y[index] == labelFromPlottingSpecsWindow:
                if self.legendNamesForCurveLabeled_Scatter[index] == labelFromPlottingSpecsWindow:
                    i_label = True
                    refCurveIndex = index
#                        refCurveLabel = self.headerNames_Y[index]
                    refCurveLabel = self.legendlabel_Y_Scatter[index]
                    if DEBUG_PLOT_SCATTER:
                        print '\n*****\nrefCurveLabel =',refCurveLabel
                        print '*****\n'
                        print 'refCurveIndex =',refCurveIndex
                    break
            if i_label == False:
                stringErrorLabel = (
                    'Index for ref curve in SCATTER PLOT SPECS window does\n' +
                    '  NOT match any index in the header names.\n\n' +
                    'This is a coding error. Please contact code administrator.'
                    )
                print stringErrorLabel
                self.MySQL_Output(
                    0,
                    '\n' + stringErrorLabel
                    )
                showerror(
                    'Error: index mismatch',
                    stringErrorLabel
                    )
                return
                                          
#                refCurveLabel = self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot.get()
# find curve associated with refCurveLabel
# ... must look in Table curves first, then Buffer curves
# ... number of Table curves: self.varNumberOfTableCurves.get()
# ... number of Buffer curves: self.varNumberOfStorageBufferCurves.get()
#
     
#                for index in range(len(self.tableValues)):
#                    refCurvePlotY.append(self.tableValues[index][refCurveIndex])
                
            refCurvePlotY = self.plot_Y_Scatter[refCurveIndex]
            refCurvePlotX = self.plot_X_Scatter[refCurveIndex]
            
            
# get SLOPED straight-line reference curve
        refSlopedStraightLineCurveYes = self.varCheckbuttonShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter.get()
        refSlopedStraightLineCurvePlotX = []
        refSlopedStraightLineCurvePlotY = []
        refSlopedStraightLineCurveSlopeInDegrees = ''
        if refSlopedStraightLineCurveYes:
# error check
            stringErrorrefSlopedStraightLineCurve = ''
            yRefInitial = self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yinitial_Scatter.get()
            yRefFinal = self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yfinal_Scatter.get()
            xRefInitial = self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xinitial_Scatter.get()
            xRefFinal = self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xfinal_Scatter.get()
# ... check for blanks
            if ( yRefInitial == '' or yRefFinal == '' or xRefInitial == '' or xRefFinal == ''):
                if yRefInitial == '':
                    stringErrorrefSlopedStraightLineCurve += (
                        ' - field for Y(initial) is blank\n'
                        )
                if yRefFinal == '':
                    stringErrorrefSlopedStraightLineCurve += (
                        ' - field for Y(final) is blank\n'
                        )
                if xRefInitial == '':
                    stringErrorrefSlopedStraightLineCurve += (
                        ' - field for X(initial) is blank\n'
                        )
                if xRefFinal == '':
                    stringErrorrefSlopedStraightLineCurve += (
                        ' - field for X(final) is blank\n'
                        )
# ... if errors found, print and exit
            if stringErrorrefSlopedStraightLineCurve <> '':
                stringText = (
                    'The following errors have been found related to\n' +
                    'plotting the sloped reference line:\n\n' +
                    stringErrorrefSlopedStraightLineCurve + '\n\n' +
                    'Correct these errors and try again.'
                    )
                print stringText
                self.MySQL_Output(
                    0,
                    stringText
                    )
                showerror(
                    'Error: sloped ref line',
                    stringText,
                    parent=self.toplevelScatterPlotPreprocess
                    )
                return
                
# If we get this far, sloped ref line has been specified correctly for plotting

# for plots, specify y = same value twice; x = initial and final values                    
            refSlopedStraightLineCurvePlotY = [
                float(self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yinitial_Scatter.get()),
                float(self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yfinal_Scatter.get())
                ]
            refSlopedStraightLineCurvePlotX = [
                float(self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xinitial_Scatter.get()),
                float(self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xfinal_Scatter.get())
                ]
            refSlopedStraightLineCurveDeltaY = (
                float(self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yfinal_Scatter.get()) - 
                float(self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yinitial_Scatter.get())
                )
            refSlopedStraightLineCurveDeltaX = (
                float(self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xfinal_Scatter.get()) - 
                float(self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xinitial_Scatter.get())
                )
            import math
            refSlopedStraightLineCurveSlopeInDegrees = '{0:.2f}'.format(
                math.degrees(
                    math.atan2(
                        refSlopedStraightLineCurveDeltaY,
                        refSlopedStraightLineCurveDeltaX
                        )
                    )
                )
# label for horizontal straight-line reference curve
        refSlopedStraightLineCurveLabel = ''
# ... add user-specified label
        if self.varCheckbuttonLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter.get():
            refSlopedStraightLineCurveLabel = self.entryfieldLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter.get().strip()
# ... add slope value in degrees
        if self.varCheckbuttonLabelSlopeDegreesSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter.get():
            refSlopedStraightLineCurveLabel += ' (' + str(refSlopedStraightLineCurveSlopeInDegrees) + ' degs)'
# ... always add 'ref' to user label, but if no user label, use default
        if refSlopedStraightLineCurveLabel == '':
            refSlopedStraightLineCurveLabel = 'sloped ref line [ref]'  # default value
        else:
            refSlopedStraightLineCurveLabel += ' [ref]'   
            
            
# get HORIZONTAL straight-line reference curve
        refHorizontalStraightLineCurveYes = self.varCheckbuttonShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter.get()
        refHorizontalStraightLineCurvePlotX = []
        refHorizontalStraightLineCurvePlotY = []
        if refHorizontalStraightLineCurveYes:
# error check
            stringErrorrefHorizontalStraightLineCurve = ''
            yRef = self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Y_Scatter.get()
            xRefInitial = self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xinitial_Scatter.get()
            xRefFinal = self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xfinal_Scatter.get()
# ... check for blanks
            if ( yRef == '' or xRefInitial == '' or xRefFinal == ''):
                if yRef == '':
                    stringErrorrefHorizontalStraightLineCurve += (
                        ' - field for Y value is blank\n'
                        )
                if xRefInitial == '':
                    stringErrorrefHorizontalStraightLineCurve += (
                        ' - field for X(initial) is blank\n'
                        )
                if xRefFinal == '':
                    stringErrorrefHorizontalStraightLineCurve += (
                        ' - field for X(final) is blank\n'
                        )
# ... check for duplicate x values
            if xRefInitial == xRefFinal:
                stringErrorrefHorizontalStraightLineCurve += (
                    ' - X(initial = X(final); values must be different'
                    )
# ... if errors found, print and exit
            if stringErrorrefHorizontalStraightLineCurve <> '':
                stringText = (
                    'The following errors have been found related to\n' +
                    'plotting the horizontal reference line:\n\n' +
                    stringErrorrefHorizontalStraightLineCurve + '\n\n' +
                    'Correct these errors and try again.'
                    )
                print stringText
                self.MySQL_Output(
                    0,
                    stringText
                    )
                showerror(
                    'Error: horizontal ref line',
                    stringText,
                    parent=self.toplevelScatterPlotPreprocess
                    )
                return
                
# If we get this far, horizontal ref line has been specified correctly for plotting

# for plots, specify y = same value twice; x = initial and final values                    
            refHorizontalStraightLineCurvePlotY = [
                float(self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Y_Scatter.get()),
                float(self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Y_Scatter.get())
                ]
            refHorizontalStraightLineCurvePlotX = [
                float(self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xinitial_Scatter.get()),
                float(self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xfinal_Scatter.get())
                ]
# label for horizontal straight-line reference curve
        refHorizontalStraightLineCurveLabel = ''
# ... add user-specified label
        if self.varCheckbuttonLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter.get():
            refHorizontalStraightLineCurveLabel = self.entryfieldLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter.get().strip()
# ... add y value
        if self.varCheckbuttonLabelYMaxHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter.get():
            refHorizontalStraightLineCurveLabel += ' (Y=' + self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Y_Scatter.get().strip() + ')'
# ... always add 'ref' to user label, but if no user label, use default
        if refHorizontalStraightLineCurveLabel == '':
            refHorizontalStraightLineCurveLabel = 'horiz. ref line [ref]'  # default value
        else:
            refHorizontalStraightLineCurveLabel += ' [ref]'  

            
            
# get VERTICAL straight-line reference curve
        refVerticalStraightLineCurveYes = self.varCheckbuttonShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Scatter.get()
        refVerticalStraightLineCurvePlotX = []
        refVerticalStraightLineCurvePlotY = []
        if refVerticalStraightLineCurveYes:
# error check
            stringErrorRefVerticalStraightLineCurve = ''
            xRef = self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_X_Scatter.get()
            yRefInitial = self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yinitial_Scatter.get()
            yRefFinal = self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yfinal_Scatter.get()
# ... check for blanks
            if ( xRef == '' or yRefInitial == '' or yRefFinal == ''):
                if xRef == '':
                    stringErrorRefVerticalStraightLineCurve += (
                        ' - field for X value is blank\n'
                        )
                if yRefInitial == '':
                    stringErrorRefVerticalStraightLineCurve += (
                        ' - field for Y(initial) is blank\n'
                        )
                if yRefFinal == '':
                    stringErrorRefVerticalStraightLineCurve += (
                        ' - field for Y(final) is blank\n'
                        )
# ... check for duplicate y values
            if yRefInitial == yRefFinal:
                stringErrorRefVerticalStraightLineCurve += (
                    ' - Y(initial = Y(final); values must be different'
                    )
# ... if errors found, print and exit
            if stringErrorRefVerticalStraightLineCurve <> '':
                stringText = (
                    'The following errors have been found related to\n' +
                    'plotting the vertical reference line:\n\n' +
                    stringErrorRefVerticalStraightLineCurve + '\n\n' +
                    'Correct these errors and try again.'
                    )
                print stringText
                self.MySQL_Output(
                    0,
                    stringText
                    )
                showerror(
                    'Error: vertical ref line',
                    stringText,
                    parent=self.toplevelScatterPlotPreprocess
                    )
                return
                
# If we get this far, vertical ref line has been specified correctly for plotting

# for plots, specify y = same value twice; x = initial and final values                    
            refVerticalStraightLineCurvePlotX = [
                float(self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_X_Scatter.get()),
                float(self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_X_Scatter.get())
                ]
            refVerticalStraightLineCurvePlotY = [
                float(self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yinitial_Scatter.get()),
                float(self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yfinal_Scatter.get())
                ]
# label for vertical straight-line reference curve
        refVerticalStraightLineCurveLabel = ''
# ... add user-specified label
        if self.varCheckbuttonLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot_Scatter.get():
            refVerticalStraightLineCurveLabel = \
                self.entryfieldLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot_Scatter.get().strip()
# ... add y value
        if self.varCheckbuttonLabelXMaxVerticalStraightLineReferenceCurve_AllCurvesOnePlot_Scatter.get():
            refVerticalStraightLineCurveLabel += (
                ' (X=' + 
                self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_X_Scatter.get().strip() 
                + ')'
                )
# ... always add 'ref' to user label, but if no user label, use default
        if refVerticalStraightLineCurveLabel == '':
            refVerticalStraightLineCurveLabel = 'vert. ref line [ref]'  # default value
        else:
            refVerticalStraightLineCurveLabel += ' [ref]'
            
# determine base_x and base_y for plots
        forLogPlotsX_Scatter = self.comboboxBaseForLogPlotsX_Scatter.get()
        if forLogPlotsX_Scatter == 'e' or forLogPlotsX_Scatter == 'log_e' or forLogPlotsX_Scatter == 'log_10':
            plotbasex_Scatter = forLogPlotsX_Scatter
        else:
            plotbasex_Scatter = float(forLogPlotsX_Scatter)
                
        forLogPlotsY_Scatter = self.comboboxBaseForLogPlotsY_Scatter.get()
        if forLogPlotsY_Scatter == 'e' or forLogPlotsY_Scatter == 'log_e' or forLogPlotsY_Scatter == 'log_10':
            plotbasey_Scatter = forLogPlotsY_Scatter
        else:
            plotbasey_Scatter = float(forLogPlotsY_Scatter)
               
# set up **kwargs
        self.dictMultiCurvePerChartPlotParams_Scatter = {
            'showTitle' : self.varCheckbuttonShowTitle_AllCurvesOnePlot_Scatter.get(),
            'showYLabel' : self.varCheckbuttonShowLabelY_AllCurvesOnePlot_Scatter.get(),
            'showXLabel' : self.varCheckbuttonShowLabelX_AllCurvesOnePlot_Scatter.get(),
            'showLegend' : self.varCheckbuttonShowLegend_AllCurvesOnePlot_Scatter.get(),
            'showLegendShadow' : self.varCheckbuttonShowLegendShadow_AllCurvesOnePlot_Scatter.get(),
            'showGrid' : self.varCheckbuttonShowGrid_AllCurvesOnePlot_Scatter.get(),
            'showReferenceCurve' : self.varCheckbuttonShowReferenceCurve_AllCurvesOnePlot_Scatter.get(),
            'showSlopedStraightLineReferenceCurve' : 
                self.varCheckbuttonShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter.get(),
            'showHorizontalStraightLineReferenceCurve' : 
                self.varCheckbuttonShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter.get(),
            'showVerticalStraightLineReferenceCurve' : 
                self.varCheckbuttonShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Scatter.get(),
            'colorBackground' : self.comboboxColorBackground_AllCurvesOnePlot_Scatter.get(),
            'colorXYLabels' : self.comboboxColorXYLabels_AllCurvesOnePlot_Scatter.get(),
            'colorXTicks' : self.comboboxColorXTicks_AllCurvesOnePlot_Scatter.get(),
            'colorYTicks' : self.comboboxColorYTicks_AllCurvesOnePlot_Scatter.get(),
            'colorTitle' : self.comboboxColorTitle_AllCurvesOnePlot_Scatter.get(),
            'colorPlotBorder' : self.comboboxColorPlotBorder_AllCurvesOnePlot_Scatter.get(),
            'fontsizeTitle' : self.comboboxFontTitle_AllCurvesOnePlot_Scatter.get(),
            'fontsizeXYLabels' : self.comboboxFontXYLabels_AllCurvesOnePlot_Scatter.get(),
            'fontsizeXTicks' : self.comboboxFontXTicks_AllCurvesOnePlot_Scatter.get(),
            'fontsizeYTicks' : self.comboboxFontYTicks_AllCurvesOnePlot_Scatter.get(),           
            'fontsizeLegend' : self.comboboxFontLegend_AllCurvesOnePlot_Scatter.get(),
            'valueTitle' : self.varEntryShowTitle_AllCurvesOnePlot_Scatter.get(),
            'valueLabelY' : label_Y,
            'valueLabelX' : label_X,
            'valueLegendLocation' : self.comboboxShowLegendLocation_AllCurvesOnePlot_Scatter.get(),
            'valuesLegendLabels' : self.legendlabel_Y_Scatter,
            'valueRefCurveMultiplier' : self.comboboxShowReferenceCurveMultiplier_AllCurvesOnePlot_Scatter.get(),
            'valueRefCurveLabel' : refCurveLabel,
            'valueSlopedStraightLineRefCurveLabel' : refSlopedStraightLineCurveLabel,
            'valueHorizontalStraightLineRefCurveLabel' : refHorizontalStraightLineCurveLabel,
            'valueVerticalStraightLineRefCurveLabel' : refVerticalStraightLineCurveLabel,
            'valuesRefCurvePlotYList' : refCurvePlotY,
            'valuesRefCurvePlotXList' : refCurvePlotX,
            'valuesSlopedStraightLineRefCurvePlotYList' : refSlopedStraightLineCurvePlotY,
            'valuesSlopedStraightLineRefCurvePlotXList' : refSlopedStraightLineCurvePlotX,
            'valuesHorizontalStraightLineRefCurvePlotYList' : refHorizontalStraightLineCurvePlotY,
            'valuesHorizontalStraightLineRefCurvePlotXList' : refHorizontalStraightLineCurvePlotX,
            'valuesVerticalStraightLineRefCurvePlotYList' : refVerticalStraightLineCurvePlotY,
            'valuesVerticalStraightLineRefCurvePlotXList' : refVerticalStraightLineCurvePlotX,
            'plotStyle' : self.var_radiobuttonPlotStyle_Scatter.get(),  # Cartesian, SemiLog-X, etc.
            'plotBaseX' : plotbasex_Scatter, #float(self.comboboxBaseForLogPlotsX_Scatter.get()),
            'plotBaseY' : plotbasey_Scatter, #float(self.comboboxBaseForLogPlotsY_Scatter.get()),
            'lineWidthCurveFit' : float(self.comboboxLineWidthPlots_Scatter.get()),
            'numPointsForCurveFit' : int(self.comboboxPolynomialNumberOfPoints_AllCurvesOnePlot_Scatter.get()),
            'markerSize' : int(self.comboboxMarkerSizePlots_Scatter.get()),
            'connectDataPoints' : self.varCheckbuttonConnectDataMarkers_Scatter.get(),
            'polyDegree' : int(self.comboboxPolynomialDegree_AllCurvesOnePlot_Scatter.get()),
            'plotPolyDegree' : self.varCheckbuttonShowPolynomialCurveFit_AllCurvesOnePlot_Scatter.get(),
            'plotAllLesserDegrees' : (self.varCheckbuttonShowPolynomialCurveFit_AllCurvesOnePlot_Scatter.get() 
                & self.varCheckbuttonPlotAllLesserDegreePolynomials_AllCurvesOnePlot_Scatter.get()),
            'numberDecimalPlacesInEqn' : self.comboboxPolynomialCoefficientDecimalPlaces_AllCurvesOnePlot_Scatter.get(),
            'formatPolyCoefs' : self.comboboxPolynomialCoefficientOutputFormat_AllCurvesOnePlot_Scatter.get(),
            }  

# zero out attributes that are set in the called module
# ... these values are to be stored in storage buffer if user specifies
# ... one equation per curve, of course, so only one list here
        self.curvefit_CurveFitEquations_Scatter = []
# ... each curve has different y values, so this will be a list of lists
        self.curvefit_BestY_Scatter = []
# ... x values will be same for all curvefits, so only one list here
        self.curvefit_BestX_Scatter = []
# ... X and Y headers
        self.curvefit_YHeader_Scatter = ''
        self.curvefit_XHeader_Scatter = ''
# ... title
        self.curvefit_Title_Scatter = ''
# data may not be from current database when stored in storage buffer
        self.curvefit_Database_Scatter = self.comboboxDbTableSelect.get().strip()
        self.curvefit_Table_Scatter = self.comboboxDbSelect.get().strip()
        
#  plot
        module_PylabPlotMySQL_ScatterPlot.ScatterPlot(
            self,
#            self.toplevelTableValues,
            self.toplevelScatterPlotPreprocess,
            keepPreviousPlot,
            xwin,
            ywin,
            colorbg2,
            self.plot_X_Scatter,
            self.plot_Y_Scatter,
            numCurvesSelectedInTable,
            numCurvesSelectedInStorageBuffer,
#                self.varNumberOfTableCurves.get(),
#                self.varNumberOfStorageBufferCurves.get(),
            self.numberPylabPlotFigure_Scatter,
            **self.dictMultiCurvePerChartPlotParams_Scatter
            )
            
            
        if DEBUG_SCATTER:
            if len(self.curvefit_CurveFitEquations_Scatter) <> 0:
                print('\nCurve fit equations:')
                for (number,eqn) in enumerate(self.curvefit_CurveFitEquations_Scatter):
                    print('%s. %s' % (number + 1,eqn))
                print('')
                
        return

 
    def handlerSelectDisplayOrderedFields(self):
        '''
        widgets for selecting and displaying ordered fields; used for filtering
            aka a fancy sort method
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerSelectDisplayOrderedFields')
            
# set last button pressed
        self.lastButtonPressed(
            BUTTONLABEL_FILTER
            )
            
# toplevel for these widgets
# check if connected to a MySQL server
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return
        
# check if a table has even been read in 
        emptyTableCheck = self.checkIfEmptyTable()
        if emptyTableCheck:
            return
            
# destroy any old toplevel frames
        try:
            self.toplevelSelectDisplayOrderedFields.destroy()
            self.MySQL_Output(
            1,
            'Previous toplevel widget removed from screen.'
            )
        except: 
            self.MySQL_Output(
            1,
            'No previous toplevel widget to remove from screen.'
            )
            
# destroy DELETE window, since its a child of this toplevel
        try:
            self.toplevelOptionsTableManagement.destroy()
        except:
            pass
                    
# open Toplevel frame for entering database name
        self.toplevelSelectDisplayOrderedFields = Toplevel(
            self.frameParent,
            bg='tan'
            )
            
        self.toplevelSelectDisplayOrderedFields.transient(self.toplevelTableValues)
            
        self.toplevelSelectDisplayOrderedFields.title(
#            'Select & Display Fields'
            'Server: ' + self.comboServerMySQL.get() + '     ' +
            'Database: ' + self.varTableFunctionsSelectDatabase.get() + '     ' +
            'Table: ' + self.varEntryTableFunctionsSelectTable.get().strip()
            )

# define parent window            
        self.toplevelSelectDisplayOrderedFields.transient(self.toplevelTableValues)

# place the top window
        x_Windows = self.displayOrderedFields_xWindowLocation
        y_Windows = self.displayOrderedFields_yWindowLocation
        self.toplevelSelectDisplayOrderedFields.geometry(
            '+%d+%d' % (x_Windows, y_Windows)
            )
            
# define initial location of DELETE window; have to do this after
#   frames are gridded or *.winfo_rootx() values will be zero!
        self.displayOptionsTableManagement_xWindowLocation = \
           x_Windows + 10
        self.displayOptionsTableManagement_yWindowLocation = \
           y_Windows + 20
            
# define current database and table
#        myDatabase = self.comboboxDbSelect.get()
#        myTable = self.comboboxDbTableSelect.get().strip()       
        myDatabase = self.myDatabase
        myTable = self.myTable

# define frames
# ... frame_00  (Label)
        frame_00 = Frame(
            self.toplevelSelectDisplayOrderedFields,
            bg='tan',
            )
        frame_00.grid(
            row=0,
            column=0,
            columnspan=99,
            )
            
# ... frame_10  (Columns for MySQL 'SELECT' command)
        frame_10 = Frame(
            self.toplevelSelectDisplayOrderedFields,
            bg='tan',
            )
        frame_10.grid(
            row=1,
            column=0,
            )
#   ... frame_10_00  (Select)
        frame_10_00 = Frame(
            frame_10,
            bg='tan',
            )
        frame_10_00.grid(
            row=0,
            column=0,
            )
#   ... frame_10_01  (Columns)
        frame_10_01 = Frame(
            frame_10,
            bg='tan',
            borderwidth=2,
            relief=RIDGE,
            )
        frame_10_01.grid(
            row=0,
            column=1,
            )
#   ... frame_10_02  (where)
        frame_10_02 = Frame(
            frame_10,
            bg='tan',
            )
        frame_10_02.grid(
            row=0,
            column=2,
            )
#   ... frame_10_03  (Numbers)
        self.frame_10_03 = Frame(
            frame_10,
            bg='tan',
            borderwidth=2,
            relief=RIDGE,
            )
        self.frame_10_03.grid(
            row=0,
            column=3,
            )
#       for field1 Boolean
        frame_10_03_12 = Frame(
            self.frame_10_03,
            bg='tan',
            )
        frame_10_03_12.grid(
            row=1,
            column=2,
            columnspan=3,
            )
#       for field2 Boolean
        frame_10_03_32 = Frame(
            self.frame_10_03,
            bg='tan',
            )
        frame_10_03_32.grid(
            row=3,
            column=2,
            columnspan=3,
            )
#       for field3 Boolean
        frame_10_03_52 = Frame(
            self.frame_10_03,
            bg='tan',
            )
        frame_10_03_52.grid(
            row=5,
            column=2,
            columnspan=3,
            )
            
#   ... frame_10_04: Order by
        frame_10_04 = Frame(
            frame_10,
            bg='tan',
            )
        frame_10_04.grid(
            row=0,
            column=4,
            )
#   ... frame_10_05: Fields
        self.frame_10_05 = Frame(
            frame_10,
            bg='tan',
            borderwidth=2,
            relief=RIDGE,
            )
        self.frame_10_05.grid(
            row=0,
            column=5,
            padx=5,
            )

# ...frame_20  (Display, Cancel)
        frame_20 = Frame(
            self.toplevelSelectDisplayOrderedFields,
            bg='tan',
            )
        frame_20.grid(
            row=2,
            column=0,
            columnspan=99,
            )
#   ... frame_20_00 (filler)
        frame_20_00 = Frame(
            frame_20,
            bg='tan',
            )
        frame_20_00.grid(
            row=0,
            column=0,
            )
#   ... frame_20_01 (Display, Cancel)
        frame_20_01 = Frame(
            frame_20,
            bg='tan',
            )
        frame_20_01.grid(
            row=0,
            column=1,
            )
#   ... frame_20_02 (More options...)
        frame_20_02 = Frame(
            frame_20,
            bg='tan',
            )
        frame_20_02.grid(
            row=0,
            column=2,
            )

#------Add Widgets------------
# Frame_00
# top label
        labelEnterDatabaseNameAdd = Label(
            frame_00,
            text='TABLE FILTERS TO SELECT & DISPLAY ORDERED FIELDS' + '\n' + 
                'FOR TABLE "' + myTable + '"\n' +
                'IN DATABASE "' + myDatabase + '"',
            bg='tan',
            justify=CENTER,
            font=self.titleFont,
            )
        labelEnterDatabaseNameAdd.grid(
            row=0,
            column=0,
            padx=0,
            pady=5,
            sticky=N,
            )
        labelExtractsDataFromDatabase = Label(
            frame_00,
            text=(
            'Drop-down menus show data from complete table on server, ' +
            'not the displayed table. \n' +
            '"Display" button always accesses database server to generate displayed table.'
            ),
            bg='tan',
            justify=CENTER,
            )
        labelExtractsDataFromDatabase.grid(
            row=1,
            column=0,
            padx=0,
            pady=2,
            )
            
# Frame_10
        label_10_00 = Label(
            frame_10_00,
            text='SELECT',
            bg='tan',
            justify=CENTER,
            )
        label_10_00.grid(
            row=0,
            column=0,
            padx=5,
            pady=5,
            )
            
# choose columns
        self.varColumnSelect = StringVar()
        radiobuttonSelectAll = Radiobutton(
            frame_10_01,
            text='Display all columns\nfrom table on server',
            bg='tan',
            justify=LEFT,
            value='all',
            variable=self.varColumnSelect,
            command=self.handlerUpdateFieldSelectValues,
            )
        radiobuttonSelectAll.grid(
            row=0,
            column=0,
            padx=5,
            pady=5,
            sticky=W,
            )
            
        radiobuttonSelectYSelect = Radiobutton(
            frame_10_01,
            text='Display only Y-Select fields\nfrom table on server',
            bg='tan',
            justify=LEFT,
            value='yselect',
            variable=self.varColumnSelect,
            command=self.handlerUpdateFieldSelectValues,
            )
        radiobuttonSelectYSelect.grid(
            row=1,
            column=0,
            padx=5,
            pady=5,
            sticky=W,
            )  
        
        radiobuttonSelectYSelect = Radiobutton(
            frame_10_01,
            text='Display both Y-Select and X-Select\nfields from table on server',
            bg='tan',
            justify=LEFT,
            value='yselectplusx',
            variable=self.varColumnSelect,
            command=self.handlerUpdateFieldSelectValues,
            )
        radiobuttonSelectYSelect.grid(
            row=2,
            column=0,
            padx=5,
            pady=5,
            sticky=W,
            )  
        self.varColumnSelect.set('all')
        
        
# where        
        label_10_02 = Label(
            frame_10_02,
            text='WHERE',
            bg='tan',
            justify=CENTER,
            )
        label_10_02.grid(
            row=0,
            column=2,
            padx=5,
            pady=5,
            )
            
# frame_10_03: take care of columns 0, 1, and 5
# numbers
#   ... frame_10_03, column 0
        label_10_03_30 = Label(
            self.frame_10_03,
            text='1.',
            bg='tan',
            anchor=E,
            )
        label_10_03_30.grid(
            row=2,
            column=0,
            padx=0,
            pady=0,
            )
            
        label_10_03_50 = Label(
            self.frame_10_03,
            text='2.',
            bg='tan',
            anchor=E,
            )
        label_10_03_50.grid(
            row=4,
            column=0,
            padx=0,
            pady=0,
            )
         
        label_10_03_70 = Label(
            self.frame_10_03,
            text='3.',
            bg='tan',
            anchor=E,
            )
        label_10_03_70.grid(
            row=6,
            column=0,
            padx=0,
            pady=0,
            )
            
#   ... frame_10_03, column 1: radiobuttons, open parens
        self.varOpenParens = StringVar()
        self.radiobuttonParenOpen1 = Radiobutton(
            self.frame_10_03,
            text='(',
            bg='tan',
            justify=CENTER,
            value='parenOpen1',
            variable=self.varOpenParens,
            command=self.handlerSelectCloseParen2,
            )
        self.radiobuttonParenOpen1.grid(
            row=2,
            column=1,
            padx=5,
            pady=0
            )
        self.radiobuttonParenOpen2 = Radiobutton(
            self.frame_10_03,
            text='(',
            bg='tan',
            justify=CENTER,
            value='parenOpen2',
            variable=self.varOpenParens,
            command=self.handlerSelectCloseParen3,
            )
        self.radiobuttonParenOpen2.grid(
            row=4,
            column=1,
            padx=5,
            pady=0,
            ) 
#   ... frame_10_03, column 5: close parens, radiobuttons
        self.varCloseParens = StringVar()
        self.radiobuttonParenClose2 = Radiobutton(
            self.frame_10_03,
            text=')',
            bg='tan',
            justify=CENTER,
            value='parenClose2',
            variable=self.varCloseParens,
            command=self.handlerSelectOpenParen1,
            )
        self.radiobuttonParenClose2.grid(
            row=4,
            column=5,
            padx=5,
            pady=0,
            )
        self.radiobuttonParenClose3 = Radiobutton(
            self.frame_10_03,
            text=')',
            bg='tan',
            justify=CENTER,
            value='parenClose3',
            variable=self.varCloseParens,
            command=self.handlerSelectOpenParen2
            )
        self.radiobuttonParenClose3.grid(
            row=6,
            column=5,
            padx=5,
            pady=0,
            )
        self.buttonDeselectAllParens = Button(
            self.frame_10_03,
            text='^\nDeselect\nparens',
            font=self.buttonFontSmall,
            bg='white',
            fg='blue',
            relief=RAISED,
            borderwidth=3,
            command=self.handlerDeselectAllParens,
            )
        self.buttonDeselectAllParens.grid(
            row=7,
            column=5,
            padx=5,
            pady=0,
            )
            
# frame_10_03: now take care of columns 2-4, all rows     
#   ... frame_10_03, column 2: fields
        label_10_03_02 = Label(
            self.frame_10_03,
            text='Fields',
            bg='tan',
            justify=CENTER,
            )
        label_10_03_02.grid(
            row=0,
            column=2,
            padx=0,
            pady=0,
            sticky=S,
            )
        label_10_03_02 = Label(
            self.frame_10_03,
            text='Operators',
            bg='tan',
            justify=CENTER,
            )
        label_10_03_02.grid(
            row=0,
            column=3,
            padx=0,
            pady=0,
            sticky=S,
            )
        label_10_03_04 = Label(
            self.frame_10_03,
            text="string or numbers\n(do NOT use quotes)",
            bg='tan',
            justify=CENTER,
            )
        label_10_03_04.grid(
            row=0,
            column=4,
            padx=0,
            pady=0,
            sticky=S,
            )
# ... row 1
        self.varBooleanField1 = StringVar()
        self.radiobuttonNotField1 = Radiobutton(
            frame_10_03_12,
            text='NOT',
            bg='tan',
            justify=CENTER,
            value='NOT',
            variable=self.varBooleanField1,
            )
        self.radiobuttonNotField1.grid(
            row=0,
            column=0,
            padx=5,
            pady=5,
            sticky=S
            )
            
        buttonDeselectBooleanField1 = Button(
            frame_10_03_12,
            text='<-- Deselect',
            font=self.buttonFontSmall,
            bg='white',
            fg='blue',
            relief=RAISED,
            borderwidth=3,
            command=self.handlerDeselectBooleanField1,
            )
        buttonDeselectBooleanField1.grid(
            row=0,
            column=1,
            padx=5,
            pady=5,
            sticky=S,
            )
            
# ... row 2
# include all fields, even 'auto_index', to filter 
        tempMyDatabaseFields = []
        for number,field in enumerate(self.myDatabaseFields): #[0:-1]):
            tempMyDatabaseFields.append(str(number + 1) + '. ' + field)
# set up field widgets
        self.comboboxSelectField1 = Pmw.ComboBox(
            self.frame_10_03,
#            scrolledlist_items = self.myDatabaseFields_Select,
            scrolledlist_items = tempMyDatabaseFields,
            selectioncommand=self.handlerSortedColumnValuesForSelectField1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxSelectField1.grid(
            row=2,
            column=2,
            padx=5,
            pady=0,
            )
        self.comboboxSelectOperatorField1 = Pmw.ComboBox(
            self.frame_10_03,
            scrolledlist_items=self.fieldSort,
            listheight=150,
            entry_width=8,
            entry_justify=CENTER,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxSelectOperatorField1.grid(
            row=2,
            column=3,
            padx=5,
            pady=0,
            ) 
#        self.comboboxSelectOperatorField1.component('entry').configure(width=8)
#        self.comboboxSelectOperatorField1.component('entry').configure(justify=CENTER)      
        self.myColumnDataField1 = []
# the list in this field is determined in 'handlerSortedColumnValuesForSelect()'
#   ... also affects values in 'handlerDisplayOrderedFields' (line 16540 approx)

        self.widthSelectValueField = 30
        
        self.comboboxSelectValueField1 = Pmw.ComboBox(
            self.frame_10_03,
            scrolledlist_items=self.myColumnDataField1,
            listheight=120,
            entry_width=self.widthSelectValueField,
#            entry_justify=LEFT,
            scrolledlist_hull_width=500,
            )
        self.comboboxSelectValueField1.grid(
            row=2,
            column=4,
            padx=0,
            pady=0,
            )
        '''
        self.varSelectField1 = StringVar()
        self.entrySelectField1 = Entry(
            frame_10_03,
            width=10,
            textvariable=self.varSelectField1,
            )
        self.entrySelectField1.grid(
            row=2,
            column=4,
            padx=0,
            pady=0,
            )
        '''
# ... row 3
        self.varBooleanField2 = StringVar()
        self.radiobuttonOrField2 = Radiobutton(
            frame_10_03_32,
            text='OR',
            bg='tan',
            justify=CENTER,
            value='OR',
            variable=self.varBooleanField2,
            )
        self.radiobuttonOrField2.grid(
            row=0,
            column=0,
            padx=5,
            pady=5,
            sticky=S
            )
        self.radiobuttonAndField2 = Radiobutton(
            frame_10_03_32,
            text='AND',
            bg='tan',
            justify=CENTER,
            value='AND',
            variable=self.varBooleanField2,
            )
        self.radiobuttonAndField2.grid(
            row=0,
            column=1,
            padx=5,
            pady=5,
            sticky=S,
            )
        self.radiobuttonAndNotField2 = Radiobutton(
            frame_10_03_32,
            text='AND NOT',
            bg='tan',
            justify=CENTER,
            value='AND NOT',
            variable=self.varBooleanField2,
            )
        self.radiobuttonAndNotField2.grid(
            row=0,
            column=2,
            padx=5,
            pady=5,
            sticky=S,
            )
        self.radiobuttonXorField2 = Radiobutton(
            frame_10_03_32,
            text='XOR',
            bg='tan',
            justify=CENTER,
            value='XOR',
            variable=self.varBooleanField2,
            )
        self.radiobuttonXorField2.grid(
            row=0,
            column=3,
            padx=5,
            pady=5,
            sticky=S,
            )
        self.buttonDeselectBooleanField2 = Button(
            frame_10_03_32,
            text='<-- Deselect',
            font=self.buttonFontSmall,
            bg='white',
            fg='blue',
            relief=RAISED,
            borderwidth=3,
            command=self.handlerDeselectBooleanField2,
            )
        self.buttonDeselectBooleanField2.grid(
            row=0,
            column=4,
            padx=5,
            pady=5,
            sticky=S,
            )
            
# ... row 4
        self.comboboxSelectField2 = Pmw.ComboBox(
            self.frame_10_03,
            scrolledlist_items = tempMyDatabaseFields,
            selectioncommand=self.handlerSortedColumnValuesForSelectField2,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxSelectField2.grid(
            row=4,
            column=2,
            padx=0,
            pady=0,
            )
        self.comboboxSelectOperatorField2 = Pmw.ComboBox(
            self.frame_10_03,
            scrolledlist_items = self.fieldSort,
            listheight=150,
            entry_width=8,
            entry_justify=CENTER,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxSelectOperatorField2.grid(
            row=4,
            column=3,
            padx=0,
            pady=0,
            ) 
#        self.comboboxSelectOperatorField2.component('entry').configure(width=8)
#        self.comboboxSelectOperatorField2.component('entry').configure(justify=CENTER)
        self.myColumnDataField2 = []
# the list in this field is determined in 'handlerSortedColumnValuesForSelect()'
#   ... also affects values in 'handlerDisplayOrderedFields' (line 16540 approx)
        self.comboboxSelectValueField2 = Pmw.ComboBox(
            self.frame_10_03,
            scrolledlist_items=self.myColumnDataField2,
            listheight=120,
            entry_width=self.widthSelectValueField,
#            entry_justify=CENTER,
            scrolledlist_hull_width=500,
            )
        self.comboboxSelectValueField2.grid(
            row=4,
            column=4,
            padx=0,
            pady=0,
            )
        '''
        self.varSelectField2 = StringVar()
        self.entrySelectField2 = Entry(
            self.frame_10_03,
            width=10,
            textvariable=self.varSelectField2,
            )
        self.entrySelectField2.grid(
            row=4,
            column=4,
            padx=0,
            pady=0,
            )
        '''
# ... row 5
        self.varBooleanField3 = StringVar()
        self.radiobuttonOrField3 = Radiobutton(
            frame_10_03_52,
            text='OR',
            bg='tan',
            justify=CENTER,
            value='OR',
            variable=self.varBooleanField3
            )
        self.radiobuttonOrField3.grid(
            row=0,
            column=0,
            padx=5,
            pady=5,
            sticky=S,
            )
        self.radiobuttonAndField3 = Radiobutton(
            frame_10_03_52,
            text='AND',
            bg='tan',
            justify=CENTER,
            value='AND',
            variable=self.varBooleanField3,
            )
        self.radiobuttonAndField3.grid(
            row=0,
            column=1,
            padx=5,
            pady=5,
            sticky=S
            )
        self.radiobuttonAndNotField3 = Radiobutton(
            frame_10_03_52,
            text='AND NOT',
            bg='tan',
            justify=CENTER,
            value='AND NOT',
            variable=self.varBooleanField3,
            )
        self.radiobuttonAndNotField3.grid(
            row=0,
            column=2,
            padx=5,
            pady=5,
            sticky=S,
            )
        self.radiobuttonXorField3 = Radiobutton(
            frame_10_03_52,
            text='XOR',
            bg='tan',
            justify=CENTER,
            value='XOR',
            variable=self.varBooleanField3,
            )
        self.radiobuttonXorField3.grid(
            row=0,
            column=3,
            padx=5,
            pady=5,
            sticky=S,
            )
        buttonDeselectBooleanField3 = Button(
            frame_10_03_52,
            text='<-- Deselect',
            font=self.buttonFontSmall,
            bg='white',
            fg='blue',
            relief=RAISED,
            borderwidth=3,
            command=self.handlerDeselectBooleanField3,
            )
        buttonDeselectBooleanField3.grid(
            row=0,
            column=4,
            padx=5,
            pady=5,
            sticky=S
            )
            
# ... row 6
        self.comboboxSelectField3 = Pmw.ComboBox(
            self.frame_10_03,
            scrolledlist_items = tempMyDatabaseFields,
            selectioncommand=self.handlerSortedColumnValuesForSelectField3,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxSelectField3.grid(
            row=6,
            column=2,
            padx=0,
            pady=0,
            )
        self.comboboxSelectOperatorField3 = Pmw.ComboBox(
            self.frame_10_03,
            scrolledlist_items = self.fieldSort,
            listheight=150,
            entry_width=8,
            entry_justify=CENTER,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxSelectOperatorField3.grid(
            row=6,
            column=3,
            padx=0,
            pady=0,
            )
#        self.comboboxSelectOperatorField3.component('entry').configure(width=8)
#        self.comboboxSelectOperatorField3.component('entry').configure(justify=CENTER)
        self.myColumnDataField3 = []
# the list in this field is determined in 'handlerSortedColumnValuesForSelect()'
#   ... also affects values in 'handlerDisplayOrderedFields' (line 16540 approx)
        self.comboboxSelectValueField3 = Pmw.ComboBox(
            self.frame_10_03,
            scrolledlist_items=self.myColumnDataField3,
            listheight=120,
            entry_width=self.widthSelectValueField,
#            entry_justify=CENTER,
            scrolledlist_hull_width=500,
            )
        self.comboboxSelectValueField3.grid(
            row=6,
            column=4,
            padx=0,
            pady=0,
            )
        '''
        self.varSelectField3 = StringVar()
        self.entrySelectField3 = Entry(
            self.frame_10_03,
            width=10,
            textvariable=self.varSelectField3,
            )
        self.entrySelectField3.grid(
            row=6,
            column=4,
            padx=0,
            pady=0,
            )
        '''

# ... row 7: 'clear all' button
        self.buttonClearAllEntries = Button(
            self.frame_10_03,
            text='Clear all',
            font=self.buttonFontSmall,
            borderwidth=5,
            relief=RAISED,
            bg='white',
            fg='blue',
            justify=CENTER,
            command=self.handlerClearAllEntriesForSelectAndDisplay,
            )
        self.buttonClearAllEntries.grid(
            row=7,
            column=2,
            columnspan=2,
            padx=0,
            pady=5,
            sticky=N
            )
# ... row 7: help button for entry input
        self.buttonHelpWithStringOrNumber = Button(
            self.frame_10_03,
            text='^\nHelp',
            font=self.buttonFontSmall,
            borderwidth=5,
            relief=RAISED,
            bg='white',
            fg='blue',
            command=self.handlerHelpWithStringOrNumber,
            )
        self.buttonHelpWithStringOrNumber.grid(
            row=7,
            column=4,
            padx=0,
            pady=5,
            sticky=N,
            )
            
# Frame_10_04                        
        label_10_04 = Label(
            frame_10_04,
            text='ORDER BY',
            bg='tan',
            justify=CENTER,
            )
        label_10_04.grid(
            row=0,
            column=0,
            padx=5,
            pady=5,
            )
            
# Frame_10_05
        label_10_05_10 = Label(
            self.frame_10_05,
            text='Fields',
            bg='tan',
            justify=CENTER,
            )
        label_10_05_10.grid(
            row=0,
            column=0,
            padx=5,
            pady=5,
            )
        label_10_05_11 = Label(
            self.frame_10_05,
            text='Sort Order',
            bg='tan',
            justify=CENTER,
            )
        label_10_05_11.grid(
            row=0,
            column=1,
            padx=5,
            pady=5,
            )
            
# ... field 1
        self.comboboxOrderByField1 = Pmw.ComboBox(
            self.frame_10_05,
#            scrolledlist_items = self.myDatabaseFields_Select,
            scrolledlist_items = tempMyDatabaseFields,
            label_text='1. ',
            labelpos='w',
            listheight=150,
            scrolledlist_hull_width=500,
            )
        self.comboboxOrderByField1.grid(
            row=1,
            column=0,
            rowspan=2,
            padx=5,
            pady=5,
            )
        self.comboboxOrderByField1.component('label').configure(bg='tan')
# ASC/DESC radiobuttons
        self.varAscDescField1 = StringVar()
        radiobuttonAscField1 = Radiobutton(
            self.frame_10_05,
            bg='tan',
            justify=LEFT,
            anchor=W,
            text='Ascending',
            value='ASC',
            width=12,
            variable=self.varAscDescField1,
            )
        radiobuttonAscField1.grid(
            row=1,
            column=1,
            padx=2,
            pady=0,
            sticky=S,
            )
        radiobuttonDescField1 = Radiobutton(
            self.frame_10_05,
            bg='tan',
            justify=LEFT,
            anchor=W,
            text='Descending',
            value='DESC',
            width=12,
            variable=self.varAscDescField1,
            )
        radiobuttonDescField1.grid(
            row=2,
            column=1,
            padx=2,
            pady=0,
            sticky=N,
            )
        self.varAscDescField1.set('ASC')
        
# ... field 2        
        label_10_05_20 = Label(
            self.frame_10_05,
            text='then by',
            bg='tan',
            justify=CENTER,
            )
        label_10_05_20.grid(
            row=3,
            column=0,
            padx=5,
            pady=5,
            sticky=S,
            )
        self.comboboxOrderByField2 = Pmw.ComboBox(
            self.frame_10_05,
#            scrolledlist_items = self.myDatabaseFields_Select,
            scrolledlist_items = tempMyDatabaseFields,
            label_text='2. ',
            labelpos='w',
            listheight=150,
            scrolledlist_hull_width=500,
            )
        self.comboboxOrderByField2.grid(
            row=4,
            column=0,
            rowspan=2,
            padx=5,
            pady=5,
            ) 
        self.comboboxOrderByField2.component('label').configure(bg='tan')
# ASC/DESC radiobuttons
        self.varAscDescField2 = StringVar()
        radiobuttonAscField2 = Radiobutton(
            self.frame_10_05,
            bg='tan',
            justify=LEFT,
            anchor=W,
            text='Ascending',
            value='ASC',
            width=12,
            variable=self.varAscDescField2,
            )
        radiobuttonAscField2.grid(
            row=4,
            column=1,
            padx=2,
            pady=0,
            sticky=S,
            )
        radiobuttonDescField2 = Radiobutton(
            self.frame_10_05,
            bg='tan',
            justify=LEFT,
            anchor=W,
            text='Descending',
            value='DESC',
            width=12,
            variable=self.varAscDescField2,
            )
        radiobuttonDescField2.grid(
            row=5,
            column=1,
            padx=2,
            pady=0,
            sticky=N,
            )
        self.varAscDescField2.set('ASC')
        
# ... field 3        
        label_10_05_40 = Label(
            self.frame_10_05,
            text='then by',
            bg='tan',
            justify=CENTER,
            )
        label_10_05_40.grid(
            row=6,
            column=0,
            padx=5,
            pady=5,
            sticky=S,
            )
        self.comboboxOrderByField3 = Pmw.ComboBox(
            self.frame_10_05,
#            scrolledlist_items = self.myDatabaseFields_Select,
            scrolledlist_items = tempMyDatabaseFields,
            label_text='3. ',
            labelpos='w',
            listheight=150,
            scrolledlist_hull_width=500,
            )
        self.comboboxOrderByField3.grid(
            row=7,
            column=0,
            rowspan=2,
            padx=5,
            pady=5,
            )
        self.comboboxOrderByField3.component('label').configure(bg='tan')
# ASC/DESC radiobuttons
        self.varAscDescField3 = StringVar()
        radiobuttonAscField3 = Radiobutton(
            self.frame_10_05,
            bg='tan',
            justify=LEFT,
            anchor=W,
            text='Ascending',
            value='ASC',
            width=12,
            variable=self.varAscDescField3,
            )
        radiobuttonAscField3.grid(
            row=7,
            column=1,
            padx=2,
            pady=0,
            sticky=S,
            )
        radiobuttonDescField3 = Radiobutton(
            self.frame_10_05,
            bg='tan',
            justify=LEFT,
            anchor=W,
            text='Descending',
            value='DESC',
            width=12,
            variable=self.varAscDescField3,
            )
        radiobuttonDescField3.grid(
            row=8,
            column=1,
            padx=2,
            pady=0,
            sticky=N,
            )
        self.varAscDescField3.set('ASC')
# ... clear all
        self.buttonClearAllFieldsSortOrder = Button(
            self.frame_10_05,
            text='Clear all',
            font=self.buttonFontSmall,
            bg='white',
            fg='blue',
            borderwidth=5,
            relief=RAISED,
            justify=CENTER,
            command=self.handlerClearAllFieldsSortOrder,
            )
        self.buttonClearAllFieldsSortOrder.grid(
            row=9,
            column=0,
            columnspan=2,
            padx=5,
            pady=5,
            )
            
# Frame_20
#   ... display
        self.buttonCancelSelectDisplayOrderedFields = Button(
            frame_20_01,
            text='Display',
            background='white',
            foreground='blue',
            borderwidth=5,
            relief=RAISED,
            justify=CENTER,
            width=25,
            command=self.handlerDisplayOrderedFields,
            )
        self.buttonCancelSelectDisplayOrderedFields.grid(
            row=0,
            column=0,
            padx=10,
            pady=20,
            sticky=E,
            )    
#   ... cancel
        self.buttonCancelSelectDisplayOrderedFields = Button(
            frame_20_01,
            text='Cancel',
            borderwidth=5,
            relief=RAISED,
            justify=CENTER,
            width=25,
            command=self.handlerToplevelSelectDisplayOrderedFieldsDestroy,
            )
        self.buttonCancelSelectDisplayOrderedFields.grid(
            row=0,
            column=1,
            padx=10,
            pady=20,
            sticky=W,
            ) 
#   ... more options
        self.buttonOptionsTableManagement = Button(
            frame_20_02,
            text='Delete displayed rows ...',
            borderwidth=5,
            relief=RAISED,
            justify=CENTER,
            width=25,
            disabledforeground='darkgray',
            command=self.handlerOptionsTableManagement,
            )
        self.buttonOptionsTableManagement.grid(
            row=0,
            column=0,
            padx=10,
            pady=20,
            sticky=W,
            )
# this button is enabled in self.handlerDisplayOrderedFields
        self.buttonOptionsTableManagement.configure(state='disabled')

        
        return
        
        
    def handlerSelectDisplayOrderedFields_Update(self):
        '''
        updates 'Table Filters Select & Display Ordered Fields' window by
            updating widgets, not by destroying and reconstructing the window;
            
        Called by:
            called every time the main table window is updated since new fields can be
            added at any time at the discretion of the user
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerSelectDisplayOrderedFieldsUpdate')
            
# check if toplevel is mapped; if not, just return
        try:
            mapped = self.toplevelSelectDisplayOrderedFields.winfo_exists()
        except:
            mapped = False
            
        if not mapped: 
            return
            
# update database fields from the server, not the displayed table
# get tables that go with database selection; error check
        try:
            stringDescribe = (
                'DESCRIBE' + ' ' + self.myDatabase + '.' + self.myTable
                )
            self.MySQL_Commands(
                1,
                'self.cursorHandleMySQL.execute("' + stringDescribe + '")'
                )
# execute command
            start = time.time()
            self.cursorHandleMySQL.execute(
                stringDescribe
                )
            finish = time.time()
            delta_t = finish - start
# print elapsed time
            self.MySQL_Commands(
                0,
                '  (Time: %-7.4f secs)' % delta_t
                )

        except:
            stringCannotShowContents = (
                'Cannot show contents of table\n' +
                '   %s\n\n' +
                'in database\n\n' +
                '   %s\n\n' +
                'This may be due to\n\n' + 
                '   1. lost server connection\n' +
                '   2. a MySQL-command syntax problem\n' + 
                '   3. lack of proper permissions to show this table,\n' +
                '   4. an empty table\n\n' +
                'It is not exactly known what caused this problem.\n' +
                'Contact the database sys-admin for further guidance,\n' +
                'if necessary.'
                ) % (
                self.myTable, 
                self.myDatabase
                )
            self.MySQL_Output(
                1,
                stringCannotShowContents
                )
            showerror(
                'ERROR: cannot show table contents',
                stringCannotShowContents
                )
                
            return

                
        fields = self.cursorHandleMySQL.fetchall()

# re-define database fields
        self.myDatabaseFields = [field[0] for field in fields]
        
# show fields in Fields combobox        
        self.mysql_ComboDatabaseFields() 

#add field number to updated database fields
        tempMyDatabaseFields = []
        for number,field in enumerate(self.myDatabaseFields): #[0:-1]):
            tempMyDatabaseFields.append(str(number + 1) + '. ' + field)
            
# save current values, but make sure these values are in updated lists before restoring;
#   if not, clear all fields in frame and set to default values

# WHERE fields

# ... boolean operator radiobuttons
        saveBooleanField1 = self.varBooleanField1.get()
        saveBooleanField2 = self.varBooleanField2.get()
        saveBooleanField3 = self.varBooleanField3.get()
# ... select fields
        saveSelectField1 = self.comboboxSelectField1.get()
        saveSelectField2 = self.comboboxSelectField2.get()
        saveSelectField3 = self.comboboxSelectField3.get()
# ... operator fields
        saveOperatorField1 = self.comboboxSelectOperatorField1.get()
        saveOperatorField2 = self.comboboxSelectOperatorField2.get()
        saveOperatorField3 = self.comboboxSelectOperatorField3.get()
# ... value fields
        saveValueField1 = self.comboboxSelectValueField1.get()
        saveValueField2 = self.comboboxSelectValueField2.get()
        saveValueField3 = self.comboboxSelectValueField3.get()
# ... left parens (values: parenOpen1, parenOpen2)
        saveOpenParen = self.varOpenParens.get()
# ... right parens (values:parenClose1, parenClose2)
        saveCloseParen = self.varCloseParens.get()
        
# ORDER BY fields

# ... select fields
        saveOrderByField1 = self.comboboxOrderByField1.get()
        saveOrderByField2 = self.comboboxOrderByField2.get()
        saveOrderByField3 = self.comboboxOrderByField3.get()
# ... ASC or DESC sort order radiobuttons
        saveSortOrder1 = self.varAscDescField1.get()
        saveSortOrder2 = self.varAscDescField2.get()
        saveSortOrder3 = self.varAscDescField3.get()

# update title in window heading at top
        self.toplevelSelectDisplayOrderedFields.title(
            'Server: ' + self.comboServerMySQL.get() + '     ' +
            'Database: ' + self.varTableFunctionsSelectDatabase.get() + '     ' +
            'Table: ' + self.varEntryTableFunctionsSelectTable.get().strip()
            )

# update widgets since they may have a new drop down menu list

# WHERE fields

# ... select field 1
        self.comboboxSelectField1 = Pmw.ComboBox(
            self.frame_10_03,
#            scrolledlist_items = self.myDatabaseFields_Select,
            scrolledlist_items = tempMyDatabaseFields,
            selectioncommand=self.handlerSortedColumnValuesForSelectField1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxSelectField1.grid(
            row=2,
            column=2,
            padx=5,
            pady=0,
            )

# ... select field 2
        self.comboboxSelectField2 = Pmw.ComboBox(
            self.frame_10_03,
            scrolledlist_items = tempMyDatabaseFields,
            selectioncommand=self.handlerSortedColumnValuesForSelectField2,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxSelectField2.grid(
            row=4,
            column=2,
            padx=0,
            pady=0,
            )

# ... select field 3
        self.comboboxSelectField3 = Pmw.ComboBox(
            self.frame_10_03,
            scrolledlist_items = tempMyDatabaseFields,
            selectioncommand=self.handlerSortedColumnValuesForSelectField3,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxSelectField3.grid(
            row=6,
            column=2,
            padx=0,
            pady=0,
            )
            
# ORDER BY fields

# ... order by field 1
        self.comboboxOrderByField1 = Pmw.ComboBox(
            self.frame_10_05,
#            scrolledlist_items = self.myDatabaseFields_Select,
            scrolledlist_items = tempMyDatabaseFields,
            label_text='1. ',
            labelpos='w',
            listheight=150,
            scrolledlist_hull_width=500,
            )
        self.comboboxOrderByField1.grid(
            row=1,
            column=0,
            rowspan=2,
            padx=5,
            pady=5,
            )
        self.comboboxOrderByField1.component('label').configure(bg='tan')
        
# ... order by field 2
        self.comboboxOrderByField2 = Pmw.ComboBox(
            self.frame_10_05,
#            scrolledlist_items = self.myDatabaseFields_Select,
            scrolledlist_items = tempMyDatabaseFields,
            label_text='2. ',
            labelpos='w',
            listheight=150,
            scrolledlist_hull_width=500,
            )
        self.comboboxOrderByField2.grid(
            row=4,
            column=0,
            rowspan=2,
            padx=5,
            pady=5,
            ) 
        self.comboboxOrderByField2.component('label').configure(bg='tan')
        
# ... order by field 3
        self.comboboxOrderByField3 = Pmw.ComboBox(
            self.frame_10_05,
#            scrolledlist_items = self.myDatabaseFields_Select,
            scrolledlist_items = tempMyDatabaseFields,
            label_text='3. ',
            labelpos='w',
            listheight=150,
            scrolledlist_hull_width=500,
            )
        self.comboboxOrderByField3.grid(
            row=7,
            column=0,
            rowspan=2,
            padx=5,
            pady=5,
            )
        self.comboboxOrderByField3.component('label').configure(bg='tan')          

# restore values if appropriate

# ... WHERE fields 1
        try:
            saveSelectField1_NoNumber = saveSelectField1.split()[1].strip()
        except:
            saveSelectField1_NoNumber = ''
        if saveSelectField1_NoNumber <> '':
            if saveSelectField1_NoNumber in self.myDatabaseFields:
                index = self.myDatabaseFields.index(saveSelectField1_NoNumber)
                self.comboboxSelectField1.setentry(tempMyDatabaseFields[index])
            else:
                self.comboboxSelectField1.setentry('')
                self.comboboxSelectOperator1.setentry('')
                self.comboboxSelectValueField1.setentry('')
        else:
            try:
                self.comboboxSelectField1.setentry('')
                self.comboboxSelectOperator1.setentry('')
                self.comboboxSelectValueField1.setentry('')
            except:
                pass
            
# ... ORDER BY fields 1
        try:
            saveOrderByField1_NoNumber = saveOrderByField1.split()[1].strip()
        except:
            saveOrderByField1_NoNumber = ''
        if saveOrderByField1_NoNumber <> '':
            if saveOrderByField1_NoNumber in self.myDatabaseFields:
                index = self.myDatabaseFields.index(saveOrderByField1_NoNumber)
                self.comboboxOrderByField1.setentry(tempMyDatabaseFields[index])
            else:
                self.comboboxOrderByField1.setentry('')
        else:
            try:
                self.comboboxOrderByField1.setentry('')
            except:
                pass
            
# ... WHERE fields 2
        try:
            saveSelectField2_NoNumber = saveSelectField2.split()[1].strip()
        except:
            saveSelectField2_NoNumber = ''
        if saveSelectField2_NoNumber <> '':
            if saveSelectField2_NoNumber in self.myDatabaseFields:
                index = self.myDatabaseFields.index(saveSelectField2_NoNumber)
                self.comboboxSelectField2.setentry(tempMyDatabaseFields[index])
            else:
                self.comboboxSelectField2.setentry('')
                self.comboboxSelectOperator2.setentry('')
                self.comboboxSelectValueField2.setentry('')
        else:
            try:
                self.comboboxSelectField2.setentry('')
                self.comboboxSelectOperator2.setentry('')
                self.comboboxSelectValueField2.setentry('')
            except:
                pass
            
# ... ORDER BY fields 2
        try:
            saveOrderByField2_NoNumber = saveOrderByField2.split()[1].strip()
        except:
            saveOrderByField2_NoNumber = ''
        if saveOrderByField2_NoNumber <> '':
            if saveOrderByField2_NoNumber in self.myDatabaseFields:
                index = self.myDatabaseFields.index(saveOrderByField2_NoNumber)
                self.comboboxOrderByField2.setentry(tempMyDatabaseFields[index])
            else:
                self.comboboxOrderByField2.setentry('')
        else:
            try:
                self.comboboxOrderByField2.setentry('')
            except:
                pass

# ... WHERE fields 3
        try:
            saveSelectField3_NoNumber = saveSelectField3.split()[1].strip()
        except:
            saveSelectField3_NoNumber = ''
        if saveSelectField3_NoNumber <> '':
            if saveSelectField3_NoNumber in self.myDatabaseFields:
                index = self.myDatabaseFields.index(saveSelectField3_NoNumber)
                self.comboboxSelectField3.setentry(tempMyDatabaseFields[index])
            else:
                self.comboboxSelectField3.setentry('')
                self.comboboxSelectOperator3.setentry('')
                self.comboboxSelectValueField3.setentry('')
        else:
            try:
                self.comboboxSelectField3.setentry('')
                self.comboboxSelectOperator3.setentry('')
                self.comboboxSelectValueField3.setentry('')
            except:
                pass
            
# ... ORDER BY fields 3
        try:
            saveOrderByField3_NoNumber = saveOrderByField3.split()[1].strip()
        except:
            saveOrderByField3_NoNumber = ''
        if saveOrderByField3_NoNumber <> '':
            if saveOrderByField3_NoNumber in self.myDatabaseFields:
                index = self.myDatabaseFields.index(saveOrderByField3_NoNumber)
                self.comboboxOrderByField3.setentry(tempMyDatabaseFields[index])
            else:
                self.comboboxOrderByField3.setentry('')
        else:
            try:
                self.comboboxOrderByField3.setentry('')
            except:
                pass
             
        return
        
        
    def handlerToplevelSelectDisplayOrderedFieldsDestroy(self):
        '''
        Purpose:
            destroy 'Table Filters Select & Display Ordered Fields' window
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerToplevelSelectDisplayOrderedFieldsDestroy')

# save location for next time window is opened
        self.displayOrderedFields_xWindowLocation = \
            self.toplevelSelectDisplayOrderedFields.winfo_rootx() - self.offsetWindowX
        self.displayOrderedFields_yWindowLocation = \
            self.toplevelSelectDisplayOrderedFields.winfo_rooty() - self.offsetWindowY

# destroy current toplevel            
        self.toplevelSelectDisplayOrderedFields.destroy()
        
        return
            
            
    def handlerClearAllFieldsSortOrder(self):
        '''
        clears all entries in the 'order by' box
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerClearAllFieldsSortOrder')

# check if connected to a MySQL server
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return  

# clear fields
        self.comboboxOrderByField1.component('entryfield').setvalue('')
        self.comboboxOrderByField2.component('entryfield').setvalue('')
        self.comboboxOrderByField3.component('entryfield').setvalue('')
# set all sort orders to 'ascending'  
        self.varAscDescField1.set('ASC')
        self.varAscDescField2.set('ASC')
        self.varAscDescField3.set('ASC')
        
        return
        
            
    def handlerClearAllEntriesForSelectAndDisplay(self):
        '''
        clears all entries in the 'where' sort box
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerClearAllEntriesForSelectAndDisplay')
        
# clear all parens
        self.radiobuttonParenOpen1.deselect()
        self.radiobuttonParenOpen2.deselect()
        self.radiobuttonParenClose2.deselect()
        self.radiobuttonParenClose3.deselect()
        
# clear all booleans
        self.radiobuttonNotField1.deselect()
        self.radiobuttonOrField2.deselect()
        self.radiobuttonAndField2.deselect()
        self.radiobuttonAndNotField2.deselect()
        self.radiobuttonXorField2.deselect()
        self.radiobuttonOrField3.deselect()
        self.radiobuttonAndField3.deselect()
        self.radiobuttonAndNotField3.deselect()
        self.radiobuttonXorField3.deselect()

# clear all comboboxes
        self.comboboxSelectField1.component('entryfield').setvalue('')
        self.comboboxSelectField2.component('entryfield').setvalue('')
        self.comboboxSelectField3.component('entryfield').setvalue('')
        self.comboboxSelectOperatorField1.component('entryfield').setvalue('')
        self.comboboxSelectOperatorField2.component('entryfield').setvalue('')
        self.comboboxSelectOperatorField3.component('entryfield').setvalue('')

# clear all 'string' combobox
        self.comboboxSelectValueField1.clear()
        self.comboboxSelectValueField2.clear()
        self.comboboxSelectValueField3.clear()
        
        return

        
            
    def handlerDeselectAllParens(self):
        '''
        deselects all parens
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerDeselectAllParens')
            
        self.radiobuttonParenOpen1.deselect()
        self.radiobuttonParenOpen2.deselect()
        self.radiobuttonParenClose2.deselect()
        self.radiobuttonParenClose3.deselect()
        
        return
        
            
    def handlerSelectCloseParen2(self):
        '''
        selects closeParen2 when openParen1 is selected
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerSelectCloseParen2')
            
        self.radiobuttonParenClose2.select()
        
        return
        
        
    def handlerSelectCloseParen3(self):
        '''
        selects closeParen3 when openParen2 is selected
        '''
        self.radiobuttonParenClose3.select()
        
        return
        
        
    def handlerSelectOpenParen1(self):
        '''
        selects closeParen2 when openParen1 is selected
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerSelectOpenParen1')
        
        self.radiobuttonParenOpen1.select()
        
        return
        
        
    def handlerSelectOpenParen2(self):
        '''
        selects closeParen2 when openParen1 is selected
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerSelectOpenParen2')
        
        self.radiobuttonParenOpen2.select()
        
        return
        

    def handlerDeselectBooleanField1(self):
        '''
        deselects boolean radiobutton for field1
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerDeselectBooleanField1')
        
        self.radiobuttonNotField1.deselect()
        
        return
        
        
    def handlerDeselectBooleanField2(self):
        '''
        deselects boolean radiobuttons for field2
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerDeselectBooleanField2')
        
        self.radiobuttonOrField2.deselect()
        self.radiobuttonAndField2.deselect()
        self.radiobuttonAndNotField2.deselect()
        self.radiobuttonXorField2.deselect()
        
        return
        
        
    def handlerDeselectBooleanField3(self):
        '''
        deselects boolean radiobuttons for field3
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerDeselectBooleanField3')
            
        self.radiobuttonOrField3.deselect()
        self.radiobuttonAndField3.deselect()
        self.radiobuttonAndNotField3.deselect()
        self.radiobuttonXorField3.deselect()
        
        return
        
            
    def handlerHelpWithStringOrNumber(self):
        '''
        lists the options available with toplevel 'Select & Display Fields'
        and the 'string or number' options
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerHelpWithStringOrNumber')
            
# toplevel for these widgets
# check if connected to a MySQL server
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return
        
# show helps
        showinfo(
            'Help for string or number input',
            '\nThe following options are available, where % is the' + '\n' +
            'wildcard character and the underbar "_" matches exactly' + '\n' +
            'one wildcard character:' + '\n\n' +
            'John%\t\tMatch all strings starting with "John"' + '\n\n' +
            '%Paul\t\tMatch all strings ending with "Paul"' + '\n\n' +
            '%Paul%\t\tMatch all strings that have' + '\n' +
            '\t\t"Paul" in them, including at the' + '\n' +
            '\t\tstart or at the end' + '\n\n' +
            'R__ %\t\tMatch all strings beginning with a three-letter' + '\n'
            '\t\tword that starts with "R", followed by a space,' + '\n' +
            '\t\tthen any string' + '\n\n'
            )
            
        return
            
    
    def handlerSummarizeField(self):
        '''
        Purpose:
         determine summary of occurrences in a particular field (i.e., a column)
         and display some statistics.
         
         Called by:
         
         Calls:
          handlerTableFunctionsShowValues
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerSummarizeField')
        
        if DEBUG_STATISTICS:
            print('\n  ***** STATISTICAL DATA AND INFO *****')
            
# set last button pressed
        self.lastButtonPressed(
            BUTTONLABEL_STATS
            )
            
# check if connected to a MySQL server
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return
        
# check if a table has even been read in 
        emptyTableCheck = self.checkIfEmptyTable()
        if emptyTableCheck:
            return
            
# check whether an X-Select value has been selected in table
        if DEBUG_STATISTICS:
            print(
                '\n>> self.varXSelect.get() = %s' % (self.varXSelect.get())
                )

# column number of X-select                
        numField = self.varXSelect.get()
        
        if numField == 0:
            print('\nError: no X-Select value has been selected.')
            self.MySQL_Output(
                1,
                'Error: no X-Select value has been selected.'
                )
            showerror(
                'Error: no value selected',
                '\nNo X-Select value has been selected.' + '\n\n' +
                'Select a field (column) and try again.' + '\n'
                )
            return
            
# determine key that goes with value=numField
        varField=''
        iflag=0
        if DEBUG_STATISTICS:
            print('\nself.dictColumnHeaders:\n')
            print(self.dictColumnHeaders)
            
        for key,value in self.dictColumnHeaders.iteritems():
            if DEBUG_STATISTICS:
                print('in for loop, key = %s, value = %s, numField = %s' % (key,value,numField))
            if value == numField:
                iflag=1
                varField = key
                varFieldNumber = value
                break
                
        if DEBUG_STATISTICS:
            print('\nself.tableStructure:\n')
            print(self.tableStructure)
            print('numField: %s    varField: %s' % (numField,varField))
            
# determine datatype of the field value
        varDatatype = ''
        for struct in self.tableStructure:
            if DEBUG_STATISTICS:
                print('\nstruct[0] in for loop: %s   varField = %s' % (struct[0],varField))
            if struct[0] == varField:
                varDatatype = struct[1]
                break
                
        if varDatatype == '':
            print '\nError: varDatatype not found in search thru self.tableStructure'
            self.MySQL_Output(
                1,
                'Error: varDatatype not found in search thru self.tableStructure'
                )
            showerror(
                'Error: varDatatype not found',
                '\nvarDatatype not found in search thru self.tableStructure.' + '\n' +
                '  This should not have happened, so cause is unknown.' + '\n\n' + 
                '  Look in ' + MODULE + ' for cause.' + '\n\n'
                )
            return
            
        if DEBUG_STATISTICS:
            print('varDatatype (same as struct[1]): %s' % varDatatype)                
        
        if iflag == 0:
            stringError = (
                'Error: numField and header value do not match; ' + '\n' +  
                'indicates coding error in handlerSummarizeField.'
                )
            print(stringError)
            self.MySQL_Output(
                1,
                '\n' + stringError
                )
            showerror(
                'Error: no match',
                '\n' + stringError
                )
            return

# define current database and table
        myDatabase = self.myDatabase
        myTable = self.myTable
        
# look for auto_index field
        flagAutoIndex = False
        for eachItem in self.tableStructureOriginal:
            if 'auto_index' in eachItem:
                flagAutoIndex = True
                break

# use for "table on server" selection
        if flagAutoIndex:
            stringExtractFieldValue = (
                'SELECT ' + varField + ' FROM ' + self.myDatabase + '.' + self.myTable
                + ' order by auto_index'
                )
        else:
            stringExtractFieldValue = (
                'SELECT ' + varField + ' FROM ' + self.myDatabase + '.' + self.myTable
                )
            
        self.MySQL_Commands(
            1,
            stringExtractFieldValue
            )
        start = time.time()
        self.cursorHandleMySQL.execute(
            stringExtractFieldValue
            )
        listTemp = self.cursorHandleMySQL.fetchall() # output is type tuple
        finish = time.time()
        delta_t = finish - start
        self.MySQL_Commands(
            0,
            '  (Time: %-7.4f secs)' % delta_t
            )
            
# form tuple 'listTemp' into a dictionary
        dictSummary = {}
        for num,value in enumerate(listTemp):
            if DEBUG_STATISTICS:    
                print('num, value[0], type(value[0]) = %s. %s, %s' % (num, value[0], type(value[0])))
            
            if value[0] in dictSummary:
                tempVal = dictSummary.get(value[0])
                tempVal += 1
                if value[0] == '' or value[0] == None:
                    dictSummary['<blank>'] = tempVal
                else:
                    dictSummary[value[0]] = tempVal
            else:
                if value[0] == '' or value[0] == None:
                    dictSummary['<blank>'] = 1
                else:   
                    dictSummary[value[0]] = 1  

        if DEBUG_STATISTICS:
            print('\nOn server, dictSummary = ')
            print(dictSummary)
            print('')
# --- end for "table on sever" selection        
                
# print results
        printString = (
            'Number of occurrences and variables in table ' + myTable + '\n' +
            '(listed in alphabetical order):'
            )
            
        if DEBUG_STATISTICS:
            print('\n' +printString)
            
        self.MySQL_Output(
            1,
            printString
            )
            
        self.countTotalBarChart = 0
        listKeys = dictSummary.keys()
        listKeys.sort()
        
        for key in listKeys:
            dictSummaryGet = dictSummary.get(key)
            self.countTotalBarChart += dictSummaryGet
            if DEBUG_STATISTICS:
                print('  %5s: %s' % (dictSummaryGet,key))
            self.MySQL_Output(
                0,
                ('  %5s: %s' % (dictSummaryGet,key))
                )
                
# display results in scrollable text box
# ... open toplevel frame for displaying results


# destroy any old toplevel frames
        try:
            self.toplevelSummarize.destroy()
            self.MySQL_Output(
                1,
                'Previous toplevel widget removed from screen.'
                )
        except: 
            self.MySQL_Output(
                1,
                'No previous toplevel widget to remove from screen.'
                )
                
        colorbg = 'lightgreen'

        self.toplevelSummarize = Toplevel(
            self.toplevelTableValues,
            bg=colorbg,
            )
        self.toplevelSummarize.title(
#            'Summarize field values'
            'Server: ' + self.comboServerMySQL.get() + '     ' +
            'Database: ' + self.varTableFunctionsSelectDatabase.get() + '     ' +
            'Table: ' + self.varEntryTableFunctionsSelectTable.get().strip()
            )
        self.toplevelSummarize.transient(
            self.toplevelTableValues
            )
# place the window
        x_Windows = self.summarizeField_xWindowLocation
        y_Windows = self.summarizeField_yWindowLocation
        self.toplevelSummarize.geometry(
            '+%d+%d' % (x_Windows, y_Windows)
            )
            
# Row 0
# ... title frame

        self.frame_00_SummaryAndStats = Frame(
            self.toplevelSummarize,
            bg=colorbg,
            )
        self.frame_00_SummaryAndStats.grid(
            row=0,
            column=0,
            columnspan=99,
            padx=0,
            pady=10,
            )
# ... a) for title and header
        self.frame_00_SummaryAndStats_a = Frame(
            self.frame_00_SummaryAndStats,
            bg=colorbg,
            )
        self.frame_00_SummaryAndStats_a.grid(
            row=0,
            column=0,
            padx=0,
            pady=5,
            )
# ... b) for radiobuttons
        self.frame_00_SummaryAndStats_b = Frame(
            self.frame_00_SummaryAndStats,
            bg=colorbg,
            )
        self.frame_00_SummaryAndStats_b.grid(
            row=1,
            column=0,
            padx=0,
            pady=5,
            )
# ... c) for title of table
        self.frame_00_SummaryAndStats_c = Frame(
            self.frame_00_SummaryAndStats,
            bg=colorbg,
            )
        self.frame_00_SummaryAndStats_c.grid(
            row=2,
            column=0,
            padx=0,
            pady=5,
            )

# Row 1
# ... scrolling text box
        self.frame_10_SummaryAndStats = Frame(
            self.toplevelSummarize,
            bg=colorbg,
            )
        self.frame_10_SummaryAndStats.grid(
            row=1,
            column=0,
            padx=5,
            pady=2,
            )
# Row 2
# ... statistics label
        self.frame_20_SummaryAndStats = Frame(
            self.toplevelSummarize,
            bg=colorbg,
            )
        self.frame_20_SummaryAndStats.grid(
            row=2,
            column=0,
            padx=5,
            pady=2,
            ) 
# Row 3
# ... statistics go in two frames
        self.frame_30_SummaryAndStats = Frame(
            self.toplevelSummarize,
            bg=colorbg,
            )
        self.frame_30_SummaryAndStats.grid(
            row=3,
            column=0,
            padx=5,
            pady=2,
            )
        self.frame_30_00_SummaryAndStats = Frame(
            self.frame_30_SummaryAndStats,
            bg=colorbg,
            )
        self.frame_30_00_SummaryAndStats.grid(
            row=0,
            column=0,
            columnspan=99,
            padx=5,
            pady=0,
            )
        self.frame_30_10_SummaryAndStats = Frame(
            self.frame_30_SummaryAndStats,
            bg=colorbg,
            )
        self.frame_30_10_SummaryAndStats.grid(
            row=1,
            column=0,
            padx=5,
            pady=0,
            )
        self.frame_30_11_SummaryAndStats = Frame(
            self.frame_30_SummaryAndStats,
            bg=colorbg,
            )
        self.frame_30_11_SummaryAndStats.grid(
            row=1,
            column=1,
            padx=5,
            pady=0,
            )
        self.frame_30_20_SummaryAndStats = Frame(
            self.frame_30_SummaryAndStats,
            bg=colorbg,
            )
        self.frame_30_20_SummaryAndStats.grid(
            row=2,
            column=0,
            columnspan=99,
            padx=5,
            pady=0,
            )
        self.frame_30_30_SummaryAndStats = Frame(
            self.frame_30_SummaryAndStats,
            bg=colorbg,
            )
        self.frame_30_30_SummaryAndStats.grid(
            row=3,
            column=0,
            columnspan=99,
            padx=5,
            pady=0,
            )
# Row 4
# ... buttons for bar chart, pie chart, cancel, etc.
        self.frame_40_SummaryAndStats = Frame(
            self.toplevelSummarize,
            bg=colorbg,
            )
        self.frame_40_SummaryAndStats.grid(
            row=4,
            column=0,
            padx=5,
            pady=2,
            sticky=N,
            )

# WIDGETS
            
# radiobuttons to pick whether data comes from table values in memory
#   or table values in complete table on server

# ... for table on server
        self.varRadiobuttonTableValuesInMemoryOrOnServer = StringVar()
        radiobuttonTableValuesOnServer = Radiobutton(
            self.frame_00_SummaryAndStats_b,
            variable=self.varRadiobuttonTableValuesInMemoryOrOnServer,
            value='tableOnServer',
            text='Use complete table on server\n(click to refresh for new field)',
            justify=LEFT,
            bg=colorbg,
            font=self.buttonFont,
            command=self.handlerSummaryAndStatsForTableOnServerOrInMemory,
            )
        radiobuttonTableValuesOnServer.grid(
            row=0,
            column=0,
            padx=10,
            pady=0,
            sticky=W,
            )  
            
# ... for table in memory
        radiobuttonTableValuesInMemory = Radiobutton(
            self.frame_00_SummaryAndStats_b,
            variable=self.varRadiobuttonTableValuesInMemoryOrOnServer,
            value='tableInMemory',
            text='Use table in memory\n(click to refresh for new field)',
            justify=LEFT,
            bg=colorbg,
            font=self.buttonFont,
            command=self.handlerSummaryAndStatsForTableOnServerOrInMemory,
            )
        radiobuttonTableValuesInMemory.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            sticky=E,
            )   

# ... set default to table on server
        self.varRadiobuttonTableValuesInMemoryOrOnServer.set(
            'tableOnServer'
            )
            
# ... summary            
        label2 = Label(
            self.frame_00_SummaryAndStats_c,
            text='SUMMARY',
            font=self.titleFont,
            bg=colorbg,
            )
        label2.grid(
            row=1,
            column=0,
            pady=0,
            )

# bar chart
        buttonStatsBarChart = Button(
            self.frame_40_SummaryAndStats,
            text='Bar Chart',
            borderwidth=5,
            relief=RAISED,
            justify=CENTER,
            width=12,
            command=self.handlerPlotBarChart,
            )
        buttonStatsBarChart.grid(
            row=0,
            column=0,
            padx=5,
            pady=5,
            )
            
# pie chart
        buttonStatsPieChart = Button(
            self.frame_40_SummaryAndStats,
            text='Pie Chart',
            borderwidth=5,
            relief=RAISED,
            justify=CENTER,
            width=12,
            command=self.handlerPlotPieChart,
            )
        buttonStatsPieChart.grid(
            row=0,
            column=1,
            padx=5,
            pady=5,
            )
            
# Close charts button      
        buttonCloseBarChart = Button(
            self.frame_40_SummaryAndStats,
            text='Close chart(s)',
            borderwidth=5,
            width=12,
            relief=RAISED,
            command=self.handlerCloseBarAndPiePlots,
            )
        buttonCloseBarChart.grid(
            row=0,
            column=2,
            padx=5,
            pady=5,
            )     
            
# adjust bar chart button
        self.buttonBarChartAdjust = Button(
            self.frame_40_SummaryAndStats,
            text='adjust bar chart',
            font=self.buttonFontSmallest,
            borderwidth=3,
            relief=RAISED,
            justify=CENTER,
            width=18,
            command=self.handlerChartBarAdjust,
            )
        self.buttonBarChartAdjust.grid(
            row=1,
            column=0,
            padx=5,
            pady=0,
            )
        self.buttonBarChartAdjust.configure(state=DISABLED)
        
# adjust pie chart button
        self.buttonPieChartAdjust = Button(
            self.frame_40_SummaryAndStats,
            text='adjust pie chart',
            font=self.buttonFontSmallest,
            borderwidth=3,
            relief=RAISED,
            justify=CENTER,
            width=18,
            command=self.handlerChartPieAdjust,
            )
        self.buttonPieChartAdjust.grid(
            row=1,
            column=1,
            padx=5,
            pady=0,
            )
        self.buttonPieChartAdjust.configure(state=DISABLED)
        
# close 'adjust' windows
        buttonCloseAdjust = Button(
            self.frame_40_SummaryAndStats,
            text="close 'adjust' windows",
            font=self.buttonFontSmallest,
            borderwidth=3,
            relief=RAISED,
            justify=CENTER,
            width=18,
            command=self.handlerCloseAdjustWindows,
            )
        buttonCloseAdjust.grid(
            row=1,
            column=2,
            padx=5,
            pady=0,
            )
# Cancel button
        buttonCancelSummary = Button(
            self.frame_40_SummaryAndStats,
            text='Cancel',
            borderwidth=5,
            relief=RAISED,
            justify=CENTER,
            width=12,
            command=self.handlerToplevelSummarizeDestroy,
            )
        buttonCancelSummary.grid(
            row=2,
            column=0,
            columnspan=3,
            padx=5,
            pady=5,
            )
            

# start the process by invoking the following radiobutton            
        radiobuttonTableValuesOnServer.invoke()
            
        return
    
        
    def handlerSummaryAndStatsForTableOnServerOrInMemory(self):
        '''
        Purpose:
            display stats for field selected from table on server or in memory
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerSummaryAndStatsForTableOnServerOrInMemory')
                
        # background color
        colorbg = 'lightgreen'
        
# current table
        myTable = self.myTable
        
# get X header for plots
        index_X = self.varXSelect.get()
        for key,value in self.dictColumnHeaders.iteritems():
            if value == index_X:
                headerNameX = key
                break
        if DEBUG_STATISTICS:
            print(
                '\n>> self.varXSelect.get() = %s' % (self.varXSelect.get())
                )
                
# field (column) number of X-select                
        numField = self.varXSelect.get()
 
# get the field name for self.varXSelect.get() field number 
        varField = ''
        for key,value in self.dictColumnHeaders.iteritems():
            if DEBUG_STATISTICS:
                print('in for loop, key = %s, value = %s, numField = %s' % (key,value,numField))
            if value == numField:
                iflag=1
                varField = key
                varFieldNumber = value
                break
                
# determine datatype of the field value
        varDatatype = ''
        for struct in self.tableStructure:
            if DEBUG_STATISTICS:
                print('\nstruct[0] in for loop: %s   varField = %s' % (struct[0],varField))
            if struct[0] == varField:
                varDatatype = struct[1]
                break
                
# table is either on server or in memory
        tableLocation = self.varRadiobuttonTableValuesInMemoryOrOnServer.get()

# define empty dictionary  
# ... keys: the number in the table's field
# ... values: number of occurrences of the key       
        dictSummary = {}
        
        if tableLocation == 'tableOnServer':

# look for auto_index field
            flagAutoIndex = False
            for eachItem in self.tableStructureOriginal:
                if 'auto_index' in eachItem:
                    flagAutoIndex = True
                    break
# On server     
# ... extract information from table on server
            if flagAutoIndex:
                stringExtractFieldValue = (
                    'SELECT ' + varField + ' FROM ' + self.myDatabase + '.' + self.myTable
                    + ' order by auto_index'
                    )
            else:
                stringExtractFieldValue = (
                    'SELECT ' + varField + ' FROM ' + self.myDatabase + '.' + self.myTable
                    )
                
            self.MySQL_Commands(
                1,
                stringExtractFieldValue
                )
            start = time.time()
            self.cursorHandleMySQL.execute(
                stringExtractFieldValue
                )
            listTemp = self.cursorHandleMySQL.fetchall() # output is type tuple
            finish = time.time()
            delta_t = finish - start
            self.MySQL_Commands(
                0,
                '  (Time: %-7.4f secs)' % delta_t
                )         
# ... form tuple 'listTemp' into a dictionary
            for num,value in enumerate(listTemp):
                if DEBUG_STATISTICS:    
                    print('num, value[0], type(value[0]) = %s. %s, %s' % 
                        (num, value[0], type(value[0]))
                          )
                if value[0] in dictSummary:
                    tempVal = dictSummary.get(value[0])
                    tempVal += 1
                    if value[0] == '' or value[0] == None:
                        dictSummary['<blank>'] = tempVal
                    else:
                        dictSummary[value[0]] = tempVal
                else:
                    if value[0] == '' or value[0] == None:
                        dictSummary['<blank>'] = 1
                    else:   
                        dictSummary[value[0]] = 1  
                    
# ... get number of rows in table
            numberRowsInTable = self.totalRowsInTable() 
            
            if DEBUG_STATISTICS:
                print('\nOn server, dictSummary =')
                print(dictSummary)
                print('')
        
        else:
# In memory
      
# ... search thru column to calculate the different values and their occurrences
#        print('length of tableValues = %s' % len(self.tableValues))
#        print ('numField = %s' % numField)
            for row in range(len(self.tableValues)):
                fieldKey = self.tableValues[row][numField - 1]
#            print('row: %s   fieldKey: %s' % (row+1,fieldKey))
                if fieldKey in dictSummary:
                    tempVal = dictSummary.get(fieldKey)
                    tempVal += 1
                    if fieldKey == '' or fieldKey == None:
                        dictSummary['<blank>'] = tempVal
                    else:
                        dictSummary[fieldKey] = tempVal
                else:
                    if fieldKey == '' or fieldKey == None:
                        dictSummary['<blank>'] = 1
                    else:
                        dictSummary[fieldKey] = 1
        
# ... get number of rows in table
            numberRowsInTable = len(self.tableValues)
            
            if DEBUG_STATISTICS:
                print('\nIn memory, dictSummary =')
                print(dictSummary)
                print('')
        
# ----- End of 'if tableLocation:'
            
        self.countTotalBarChart = 0
        listKeys = dictSummary.keys()
        listKeys.sort()     
           
        for key in listKeys:
            dictSummaryGet = dictSummary.get(key)
            self.countTotalBarChart += dictSummaryGet
            if DEBUG_STATISTICS:
                print('%5s  %s' % (dictSummaryGet,key))
            self.MySQL_Output(
                0,
                ('%5s  %s' % (dictSummaryGet,key))
                ) 

        if self.countTotalBarChart == numberRowsInTable:
            if tableLocation == 'tableOnServer':
                printString = (
                    '-------------------' + '\n' + 
                    '%5s  Total count (on server)\n'
                    ) % self.countTotalBarChart
            else:
                printString = (
                    '-------------------' + '\n' + 
                    '%5s  Total count (in memory)\n'
                    ) % self.countTotalBarChart
            if DEBUG_STATISTICS:
                print(printString)
            self.MySQL_Output(
                0,
                printString
                )
        else:
            stringError = (
                'Error: total number of variables does not match ' +
                'number of table rows.\n\n' +
                'self.countTotalBarChart = %s\n\n' +
                'numberRowsInTable = %s\n\n' +
                'Reason for this mistmatch is unknown.'
                ) % (self.countTotalBarChart, numberRowsInTable)
            print('\n' + stringError)
            self.MySQL_Output(
                0,
                stringError
                )
            showerror(
                'Error: mismatch',
                stringError
                )
            return
            

# title and Y-label for bar and pie charts
        if tableLocation == 'tableOnServer':
            stringDefaultTitleForBarOrPieChart = (
                'Field: ' + headerNameX + '\n' +
                'Table: ' + myTable + ' (on server)\n' +
                '(total item count = ' + str(int(self.countTotalBarChart)) + ')'
                )
        else:
            stringDefaultTitleForBarOrPieChart = (
                'Field: ' + headerNameX + '\n' +
                'Table: ' + myTable + ' (in memory)\n' +
                '(total item count = ' + str(int(self.countTotalBarChart)) + ')'
                )
        self.defaultTitleBarChart = stringDefaultTitleForBarOrPieChart
        self.defaultLabelYBarChart = ('Number of Occurrences')
        self.defaultTitlePieChart = stringDefaultTitleForBarOrPieChart
        
# set values in default dict
# ... bar
        self.dictBarChartPlotParams_Defaults['titleBarChart'] = self.defaultTitleBarChart
        self.dictBarChartPlotParams_Defaults['labelYBarChart'] = self.defaultLabelYBarChart
# ... pie
        self.dictPieChartPlotParams_Defaults['titlePieChart'] = self.defaultTitlePieChart
# default values
# ... bar
        self.adjustPlotBarChartParams = False
        self.dictBarChartPlotParams = copy.deepcopy(self.dictBarChartPlotParams_Defaults)
# ... pie
        self.adjustPlotPieChartParams = False
        self.dictPieChartPlotParams = copy.deepcopy(self.dictPieChartPlotParams_Defaults)
 
 
# re-grid title and label
        self.clear_grid(self.frame_00_SummaryAndStats_a)

        label1 = Label(
            self.frame_00_SummaryAndStats_a,
            text=(
                'SORTED SUMMARY AND STATISTICS\n' +
                'Table: ' + myTable + '\n' +
                'Field: ' + varField + '\n' +
                'Field number: ' + str(varFieldNumber)
                ),
            font=self.titleFontBig,
            bg=colorbg
            )
        label1.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
            
 # re-grid widget 
        fixedFont = Pmw.logicalfont('Fixed'),
        self.scrolledtextSummary = Pmw.ScrolledText(
            self.frame_10_SummaryAndStats,
#            labelpos='n',
#            label_text='Summary of field "' + varField + '"\n' +
#               'from table "' + myTable + '"',
#            label_font=self.titleFont,
#            label_background=colorbg,
            columnheader=1,
            rowheader=1,
            rowcolumnheader=1,
            usehullsize=1,
            hull_width=400,
            hull_height=300,
            text_wrap='none',
            text_font=fixedFont,
            Header_font=fixedFont,
            Header_foreground='black',
            Header_background=colorbg,
            rowheader_width=3,
            rowcolumnheader_width=3,
            text_padx=3,
            text_pady=3,
            Header_padx=3,
            rowheader_pady=3,
            )
        self.scrolledtextSummary.grid(
            row=0,
            column=0,
            sticky='e' + 'w',
            )
            
# create row header from list of field names
        self.scrolledtextSummary.component('rowcolumnheader').insert('end','No.')
        
# create column headers
        headerLine = '%5s  %s' % ('Count','Field_Value') 
        self.scrolledtextSummary.component('columnheader').insert('0.0',headerLine)
        
# save values for plots
        self.plot_X_BarChart = []
        self.plot_Y_BarChart = []

# insert (Count, Field_Value) in scrollable window
        for key in listKeys:
            dictSummaryGet = dictSummary.get(key)
            dataLine = '%5u  %s\n' % (dictSummaryGet,key)
            if DEBUG_STATISTICS:
                print('on server: %s' % dataLine)
            self.scrolledtextSummary.insert('end',dataLine)
            self.plot_X_BarChart.append(key)
            self.plot_Y_BarChart.append(dictSummaryGet) 
            
# insert totals
        self.scrolledtextSummary.insert('end',printString)
        
# simple check for errors
        if DEBUG_STATISTICS:
            print ('>> countTotal=%s, numberRowsInTable=%s' % (
                self.countTotalBarChart,numberRowsInTable)
                )
                
# on LEFT side of table:
# ... count number of entries; put in far left column
        for count in range(len(listKeys)):
            self.scrolledtextSummary.component('rowheader').insert('end','%3u\n' % int(count + 1))
            
# ... have to put two more rows in far left column for everything to scroll correctly
#       (that's just the way it is)
        for i in range(2):
            self.scrolledtextSummary.component('rowheader').insert('end',' - \n')
            
# disable text box from receiving text
        self.scrolledtextSummary.configure(
            text_state='disabled',
            Header_state='disabled',
            ) 
            
# if column is numerical, compute statistics; if not, skip and print 'statistics not available' 
        stringStatisticsNotAvailable = ''
        varfirst2 = varDatatype[0:2]
        fieldIsNumerical = self.checkIsFieldNumerical(varfirst2)
        
        if fieldIsNumerical:
            dataSum = 0
            dataSumSquared = 0
            totalOccurrences = 0
            if DEBUG_STATISTICS:
                print('\nlistKeys = %s\n' % listKeys)

            for key in listKeys:
# multiply 'value' * 'number of occurrences'
# ... empty entries in table register as None or '<blank>'; set to zero for statistics
# ...   user can always display table without the empty fields to get
# ...   different representations of statistics
                if key <> None and key <> '<blank>':
                    dataValue = float(key)
                else:
                    dataValue = 0
                countOccurrences = int(dictSummary.get(key))
                dataSum += dataValue * countOccurrences
#                dataSumSquared += (dataValue * dataValue) * countOccurrences
                totalOccurrences += countOccurrences                
                
# total count
            nTotal = float(int(self.countTotalBarChart))
            
            if DEBUG_STATISTICS:
                print('\ndataSum = %s' % dataSum)
                print('totalOccurrences = %s' % totalOccurrences)
                print('nTotal = %s' % nTotal)
                
# ... check
            if nTotal <> totalOccurrences:
                stringErrorCount = (
                    'The number of field values counted does not match\n' +
                    '  the number of entries.\n\n' +
                    'nTotal = %s\n\n' +
                    'totalOccurrences = %s\n\n' +
                    'This error should not have occurred and indicates\n' +
                    '  a problem in code logic. Contact code administrator\n' +
                    '  for resolution.\n\n' +
                    'Module: ' + MODULE + '\n' + 
                    'Method: handlerSummarizeField\n\n'
                    ) % (nTotal, totalOccurrences)
                print(
                    stringErrorCount
                    )
                showerror(
                    'Error: count mismatch',
                    stringErrorCount
                    )
                return
                
# compute dataAverage
            dataAverage=dataSum/nTotal
            
# calculate numerator for standard deviation
            sdNumerator = 0
            for key in listKeys:
                if key <> None and key <> '<blank>':
                    dataValue = float(key)
                else:
                    dataValue = 0
                countOccurrences = int(dictSummary.get(key))
                sdNumerator += ((dataValue - dataAverage)**2) * countOccurrences
        
            if DEBUG_STATISTICS:
                print ('dataAverage = %s' % dataAverage)
                
# for 'sample standard deviation':
            sampleStdDeviation = (
               sqrt( 
               1./(nTotal-1.)*
               sdNumerator
                )
                )
                
# for 'sample standard error'
            stdError = sampleStdDeviation/sqrt(nTotal)
            
# confidence intervals
# ... 90% confidence interval
            confInterval90_Lower = dataAverage - 1.65*stdError
            confInterval90_Upper = dataAverage + 1.65*stdError
# ... 95% confidence interval
            confInterval95_Lower = dataAverage - 1.96*stdError
            confInterval95_Upper = dataAverage + 1.96*stdError
# ... 99% confidence interval
            confInterval99_Lower = dataAverage - 2.58*stdError
            confInterval99_Upper = dataAverage + 2.58*stdError
            
            if DEBUG_STATISTICS:
                print('sampleStdDeviation = %s' % sampleStdDeviation)
                print('stdError = %s' % stdError)
                print('confInterval90_Lower = %s' % confInterval90_Lower)
                print('confInterval90_Upper = %s' % confInterval90_Upper)
                print('confInterval95_Lower = %s' % confInterval95_Lower)
                print('confInterval95_Upper = %s' % confInterval95_Upper)
                print('confInterval99_Lower = %s' % confInterval99_Lower)
                print('confInterval99_Upper = %s' % confInterval99_Upper)
                
# find min and max values
            listKeysTemp = copy.deepcopy(listKeys)
            try:
                listKeysTemp.remove('<blank>')
            except:
                try:
                    listKeysTemp.remove(None)
                except:
                    pass
                    
# ... min value
            try:
                dataMin = min(listKeysTemp)
            except:
                dataMin = 'n/a'
                
# ... max value
            try:
                dataMax = max(listKeysTemp)
            except:
                dataMax = 'n/a'
                
# ... median; cannot compute if just one number
            errorStringMedian = ''
# ... following accounts for multiple occurrences of any number
            dataMedian = 0
            if nTotal >= 2:
                indexMedian = int(nTotal/2) + 1 # results in ints only, so rounds decimal values downward
                countTotal = 0
                for key_1 in listKeys:
                    if key_1 == None or key_1 == '<blank>':
                        key = 0
                    else:
                        key = key_1
                    if DEBUG_STATISTICS:
                        print '\nkey = %s' % key
                    if key_1 == None or key_1 == '<blank>':
                        numOccurrences = 0
                    else:
                        numOccurrences = int(dictSummary.get(key))
                    if DEBUG_STATISTICS:
                        print('numOccurrences of this key = %s' % numOccurrences)
                    for num in range(numOccurrences):
                        countTotal += 1
                        if DEBUG_STATISTICS:
                            print('countTotal, indexMedian = %s, %s' % (countTotal, indexMedian))
                        if countTotal == indexMedian:
                            if nTotal % 2 == 1:                # odd
                                dataMedian = float(key)
                                if DEBUG_STATISTICS:
                                    print('\nFor odd:')
                                    print('...key = %s' % key)
                                    print('...keyPrevious = %s' % keyPrevious)
                                    print('...dataMedian = %s' % dataMedian)
                                break
                            elif nTotal % 2 == 0:               #even
                                if num > 1:                     # key is same as before, no average needed
                                    dataMedian = float(key)
                                else:                           # key previous is different; must average
                                    dataMedian = (float(key) + float(keyPrevious)) / 2.
                                if DEBUG_STATISTICS:
                                    print('\nFor even:')
                                    print('...key = %s' % key)
                                    print('...keyPrevious = %s' % keyPrevious)
                                    print('...dataMedian = %s' % dataMedian)
                                break
                            else:
                                errorTotalMod2 = (
                                    'nTotal % 2 = %s' + '\n\n' +
                                    'Above result must be 0 or 1 for code logic\n' +
                                    '  to work properly.\n\n' + 
                                    'Check with code administrator.\n\n' +
                                    'Module: ' + MODULE
                                    ) % (
                                    nTotal % 2
                                    )
                                print(
                                    '\n' + errorTotalMod2
                                    )
                                showerror(
                                    'Error: invalid mod2 value',
                                    errorTotalMod2
                                    )
                    if countTotal == indexMedian:
                        break
                    keyPrevious = key                
            else:
                errorStringMedian = 'not available'
                
# ... field is text               
        elif not fieldIsNumerical:
            stringStatisticsNotAvailable='(Statistics not available for non-numeric fields)'
            
        else:
            stringErrorInDatatype = (
                '\nError in datatype:' + '\n' +
                '  Datatype has been specified as "' + varfirst2 + '". ' + '\n' +
                '  This value is not in the list of valid datatypes in' + '\n' +
                '  module "' + MODULE + '".' + '\n\n' + 
                '  This task has been canceled.\n\n'
                )
            print (stringErrorInDatatype)
            self.MySQL_Output(
                1,
                stringErrorInDatatype
                )
            showerror(
                'Error: datatype not found',
                stringErrorInDatatype
                )
            return  
        
        widthEntryField = 15
        
        labelStatistics = Label(
            self.frame_20_SummaryAndStats,
            text=(
                'Statistics for Field_Value\n' +
                '(assumes data are normally distributed)'
                ),
            font=self.titleFont,
            bg=colorbg,
            )
        labelStatistics.grid(
            row=0,
            column=0,
            columnspan=99,
            pady=5
            )  
        
# clear previous items in bottom frames for re-plotting
        self.clear_grid(self.frame_30_SummaryAndStats)
        
# reconstruct frame
# ... statistics go in two frames
        self.frame_30_SummaryAndStats = Frame(
            self.toplevelSummarize,
            bg=colorbg,
            )
        self.frame_30_SummaryAndStats.grid(
            row=3,
            column=0,
            padx=5,
            pady=2,
            sticky=N,
            )
        
        self.frame_30_00_SummaryAndStats = Frame(
            self.frame_30_SummaryAndStats,
            bg=colorbg,
            )
        self.frame_30_00_SummaryAndStats.grid(
            row=0,
            column=0,
            columnspan=99,
            padx=5,
            pady=0,
            )
            
# FRAME 30_00            
# ... total count (valid for both numerical and non-numerical fields
        labelCount = Label(
            self.frame_30_00_SummaryAndStats,
            text='Total entries:',
            bg=colorbg,
            justify=RIGHT,
            )
        labelCount.grid(
            row=0,
            column=0,
            padx=5,
            pady=5,
            )
            
        self.varEntryCount = StringVar()
        entryCount = Entry(
            self.frame_30_00_SummaryAndStats,
            textvariable=self.varEntryCount,
            disabledforeground='black',
            disabledbackground='white',
            width=widthEntryField,
            )
        entryCount.grid(
            row=0,
            column=1,
            padx=0,
            pady=5,
            )
#        entryCount.configure(state='normal')
        self.varEntryCount.set(self.countTotalBarChart)
        entryCount.configure(state='disabled')
        
        if fieldIsNumerical:
# display statistics
# ... min field value 
            self.frame_30_10_SummaryAndStats = Frame(
                self.frame_30_SummaryAndStats,
                bg=colorbg,
                )
            self.frame_30_10_SummaryAndStats.grid(
                row=1,
                column=0,
                padx=5,
                pady=0,
                )
            self.frame_30_11_SummaryAndStats = Frame(
                self.frame_30_SummaryAndStats,
                bg=colorbg,
                )
            self.frame_30_11_SummaryAndStats.grid(
                row=1,
                column=1,
                padx=5,
                pady=0,
                )
            self.frame_30_20_SummaryAndStats = Frame(
                self.frame_30_SummaryAndStats,
                bg=colorbg,
                )
            self.frame_30_20_SummaryAndStats.grid(
                row=2,
                column=0,
                columnspan=99,
                padx=5,
                pady=0,
                )
            self.frame_30_30_SummaryAndStats = Frame(
                self.frame_30_SummaryAndStats,
                bg=colorbg,
                )
            self.frame_30_30_SummaryAndStats.grid(
                row=3,
                column=0,
                columnspan=99,
                padx=5,
                pady=0,
                )
            
# display statistics
# FRAME 30_10
# ... min field value
            labelMin = Label(
                self.frame_30_10_SummaryAndStats,
                text='Minimum:',
                bg=colorbg,
                justify=RIGHT,
                )
            labelMin.grid(
                row=0,
                column=0,
                padx=5,
                pady=5,
                ) 
            varEntryMin = StringVar()
            entryMin = Entry(
                self.frame_30_10_SummaryAndStats,
                textvariable=varEntryMin,
                disabledforeground='black',
                disabledbackground='white',
                width=widthEntryField,
                )
            entryMin.grid(
                row=0,
                column=1,
                padx=0,
                pady=5,
                )
#            entryMin.configure(state='normal')
            varEntryMin.set(dataMin)
            entryMin.configure(state='disabled')
# ... average field value
            labelAverage = Label(
                self.frame_30_10_SummaryAndStats,
                text='Mean:',
                bg=colorbg,
                justify=RIGHT,
                )
            labelAverage.grid(
                row=1,
                column=0,
                padx=5,
                pady=5,
                )
            varEntryAverage = StringVar()
            entryAverage = Entry(
                self.frame_30_10_SummaryAndStats,
                textvariable=varEntryAverage,
                disabledforeground='black',
                disabledbackground='white',
                width=widthEntryField,
                )
            entryAverage.grid(
                row=1,
                column=1,
                padx=0,
                pady=5,
                )
#            entryAverage.configure(state='normal')
            if dataAverage > -1.0 and dataAverage < 1.0:
                varEntryAverage.set('%.3e' % dataAverage)
            else:
                varEntryAverage.set('%.3f' % dataAverage)
            entryAverage.configure(state='disabled')
# ... standard deviation
            labelStdDeviation = Label(
                self.frame_30_10_SummaryAndStats,
                text='Sample Std Dev\'n:',
                bg=colorbg,
                justify=RIGHT,
                )
            labelStdDeviation.grid(
                row=2,
                column=0,
                padx=5,
                pady=5,
                )
            varEntryStdDeviation = StringVar()
            entryStdDeviation = Entry(
                self.frame_30_10_SummaryAndStats,
                textvariable=varEntryStdDeviation,
                disabledforeground='black',
                disabledbackground='white',
                width=widthEntryField,
                )
            entryStdDeviation.grid(
                row=2,
                column=1,
                padx=0,
                pady=5,
                )
#            entryStdDeviation.configure(state='normal')
            if sampleStdDeviation > -1.0 and sampleStdDeviation < 1.0:
                varEntryStdDeviation.set('%.3e' % sampleStdDeviation)
            else:
                varEntryStdDeviation.set('%.3f' % sampleStdDeviation)
            entryStdDeviation.configure(state='disabled')
# FRAME 30_11
# ... max field value
            labelMax = Label(
                self.frame_30_11_SummaryAndStats,
                text='Maximum:',
                bg=colorbg,
                justify=RIGHT,
                )
            labelMax.grid(
                row=0,
                column=0,
                padx=5,
                pady=5,
                )
            varEntryMax = StringVar()
            entryMax = Entry(
                self.frame_30_11_SummaryAndStats,
                textvariable=varEntryMax,
                disabledforeground='black',
                disabledbackground='white',
                width=widthEntryField,
                )
            entryMax.grid(
                row=0,
                column=1,
                padx=0,
                pady=5,
                )
#            entryMax.configure(state='normal')
            varEntryMax.set(dataMax)
            entryMax.configure(state='disabled')
# ... mean field value
            labelMedian = Label(
                self.frame_30_11_SummaryAndStats,
                text='Median:',
                bg=colorbg,
                justify=RIGHT,
                )
            labelMedian.grid(
                row=1,
                column=0,
                padx=5,
                pady=5,
                )
            varEntryMedian = StringVar()
            entryMedian = Entry(
                self.frame_30_11_SummaryAndStats,
                textvariable=varEntryMedian,
                disabledforeground='black',
                disabledbackground='white',
                width=widthEntryField,
                state='disabled',
                )
            entryMedian.grid(
                row=1,
                column=1,
                padx=5,
                pady=5,
                )
            
            if errorStringMedian != '':
                varEntryMedian.set(errorStringMedian)
            else:
                if dataMedian > -1.0 and dataMedian < 1.0:
                    varEntryMedian.set('%.3e' % dataMedian)
                else:
                    varEntryMedian.set('%.3f' % dataMedian)
            
# ... standard error
            labelStdError = Label(
                self.frame_30_11_SummaryAndStats,
                text='Std Error:',
                bg=colorbg,
                justify=RIGHT,
                )
            labelStdError.grid(
                row=2,
                column=0,
                padx=5,
                pady=5,
                )
            varEntryStdError = StringVar()
            entryStdError = Entry(
                self.frame_30_11_SummaryAndStats,
                textvariable=varEntryStdError,
                disabledforeground='black',
                disabledbackground='white',
                width=widthEntryField,
                )
            entryStdError.grid(
                row=2,
                column=1,
                padx=0,
                pady=5,
                )
#            entryStdDeviation.configure(state='normal')
            if stdError > -1.0 and stdError < 1.0:
                varEntryStdError.set('%.3e' % stdError)
            else:
                varEntryStdError.set('%.3f' % stdError)
            entryStdError.configure(state='disabled')
            
# 90% confidence interval
# ... lower limit of interval
            label90ConfidenceInterval = Label(
                self.frame_30_20_SummaryAndStats,
                text='90% Confidence Interval:',
                bg=colorbg,
                justify=RIGHT,
                )
            label90ConfidenceInterval.grid(
                row=0,
                column=0,
                padx=5,
                pady=5,
                sticky=E,
                )
            varEntry90ConfidenceInterval_Lower = StringVar()
            entry90ConfidenceInterval_Lower = Entry(
                self.frame_30_20_SummaryAndStats,
                textvariable=varEntry90ConfidenceInterval_Lower,
                disabledforeground='black',
                disabledbackground='white',
#                width=widthEntryField,
                width=10,
                state='disabled',
                )
            entry90ConfidenceInterval_Lower.grid(
                row=0,
                column=1,
                padx=0,
                pady=5,
                )
            if confInterval90_Lower > -1.0 and confInterval90_Lower < 1.0:
                varEntry90ConfidenceInterval_Lower.set('%.3e' % confInterval90_Lower)
            else:
                varEntry90ConfidenceInterval_Lower.set('%.3f' % confInterval90_Lower)

# ... upper limit of interval
            label90ConfidenceInterval_To = Label(
                self.frame_30_20_SummaryAndStats,
                text=' to ',
                bg=colorbg,
                justify=RIGHT,
                )
            label90ConfidenceInterval_To.grid(
                row=0,
                column=2,
                padx=5,
                pady=5,
                sticky=E,
                )
            varEntry90ConfidenceInterval_Upper = StringVar()
            entry90ConfidenceInterval_Upper = Entry(
                self.frame_30_20_SummaryAndStats,
                textvariable=varEntry90ConfidenceInterval_Upper,
                disabledforeground='black',
                disabledbackground='white',
#                width=widthEntryField,
                width=10,
                state='disabled',
                )
            entry90ConfidenceInterval_Upper.grid(
                row=0,
                column=3,
                padx=0,
                pady=5,
                )
            if confInterval90_Upper > -1.0 and confInterval90_Upper < 1.0:
                varEntry90ConfidenceInterval_Upper.set('%.3e' % confInterval90_Upper)
            else:
                varEntry90ConfidenceInterval_Upper.set('%.3f' % confInterval90_Upper)
            
# 95% confidence interval
# ... lower limit of interval
            label95ConfidenceInterval = Label(
                self.frame_30_20_SummaryAndStats,
                text='95% Confidence Interval:',
                bg=colorbg,
                justify=RIGHT,
                )
            label95ConfidenceInterval.grid(
                row=1,
                column=0,
                padx=5,
                pady=5,
                sticky=E,
                )
            varEntry95ConfidenceInterval_Lower = StringVar()
            entry95ConfidenceInterval_Lower = Entry(
                self.frame_30_20_SummaryAndStats,
                textvariable=varEntry95ConfidenceInterval_Lower,
                disabledforeground='black',
                disabledbackground='white',
#                width=widthEntryField,
                width=10,
                state='disabled',
                )
            entry95ConfidenceInterval_Lower.grid(
                row=1,
                column=1,
                padx=0,
                pady=5,
                )
            if confInterval95_Lower > -1.0 and confInterval95_Lower < 1.0:
                varEntry95ConfidenceInterval_Lower.set('%.3e' % confInterval95_Lower)
            else:
                varEntry95ConfidenceInterval_Lower.set('%.3f' % confInterval95_Lower)

# ... upper limit of interval
            label95ConfidenceInterval_To = Label(
                self.frame_30_20_SummaryAndStats,
                text=' to ',
                bg=colorbg,
                justify=RIGHT,
                )
            label95ConfidenceInterval_To.grid(
                row=1,
                column=2,
                padx=5,
                pady=5,
                sticky=E,
                )
            varEntry95ConfidenceInterval_Upper = StringVar()
            entry95ConfidenceInterval_Upper = Entry(
                self.frame_30_20_SummaryAndStats,
                textvariable=varEntry95ConfidenceInterval_Upper,
                disabledforeground='black',
                disabledbackground='white',
#                width=widthEntryField,
                width=10,
                state='disabled',
                )
            entry95ConfidenceInterval_Upper.grid(
                row=1,
                column=3,
                padx=0,
                pady=5,
                )
            if confInterval95_Upper > -1.0 and confInterval95_Upper < 1.0:
                varEntry95ConfidenceInterval_Upper.set('%.3e' % confInterval95_Upper)
            else:
                varEntry95ConfidenceInterval_Upper.set('%.3f' % confInterval95_Upper)
                
# 99% confidence interval
# ... lower limit of interval
            label99ConfidenceInterval = Label(
                self.frame_30_20_SummaryAndStats,
                text='99% Confidence Interval:',
                bg=colorbg,
                justify=RIGHT,
                )
            label99ConfidenceInterval.grid(
                row=2,
                column=0,
                padx=5,
                pady=5,
                sticky=E,
                )
            varEntry99ConfidenceInterval_Lower = StringVar()
            entry99ConfidenceInterval_Lower = Entry(
                self.frame_30_20_SummaryAndStats,
                textvariable=varEntry99ConfidenceInterval_Lower,
                disabledforeground='black',
                disabledbackground='white',
#                width=widthEntryField,
                width=10,
                state='disabled',
                )
            entry99ConfidenceInterval_Lower.grid(
                row=2,
                column=1,
                padx=0,
                pady=5,
                )
            if confInterval99_Lower > -1.0 and confInterval99_Lower < 1.0:
                varEntry99ConfidenceInterval_Lower.set('%.3e' % confInterval99_Lower)
            else:
                varEntry99ConfidenceInterval_Lower.set('%.3f' % confInterval99_Lower)
# ... upper limit of interval
            label99ConfidenceInterval_To = Label(
                self.frame_30_20_SummaryAndStats,
                text=' to ',
                bg=colorbg,
                justify=RIGHT,
                )
            label99ConfidenceInterval_To.grid(
                row=2,
                column=2,
                padx=5,
                pady=5,
                sticky=E,
                )
            varEntry99ConfidenceInterval_Upper = StringVar()
            entry99ConfidenceInterval_Upper = Entry(
                self.frame_30_20_SummaryAndStats,
                textvariable=varEntry99ConfidenceInterval_Upper,
                disabledforeground='black',
                disabledbackground='white',
#                width=widthEntryField,
                width=10,
                state='disabled',
                )
            entry99ConfidenceInterval_Upper.grid(
                row=2,
                column=3,
                padx=0,
                pady=5,
                )
            if confInterval99_Upper > -1.0 and confInterval99_Upper < 1.0:
                varEntry99ConfidenceInterval_Upper.set('%.3e' % confInterval99_Upper)
            else:
                varEntry99ConfidenceInterval_Upper.set('%.3f' % confInterval99_Upper)
                
# self.frame_30_30_SummaryAndStats
            labelWebHelpStatistics = Label(
                self.frame_30_30_SummaryAndStats,
                text='Statistics help from web: ',
                bg=colorbg,
                justify=RIGHT,
                )
            labelWebHelpStatistics.grid(
                row=0,
                column=0,
                padx=5,
                pady=5,
                sticky=E,
                )
            buttonWebHelpStatistics_Ref1 = Button(
                self.frame_30_30_SummaryAndStats,
                text='Ref 1 - Streiner',
                borderwidth=5,
                relief=RAISED,
                justify=CENTER,
                background='white',
                foreground='blue',
                font=self.buttonFontSmall,
                width=15,
                command=self.handlerOpenBrowserToPDF1,
                )
            buttonWebHelpStatistics_Ref1.grid(
                row=0,
                column=1,
                padx=0,
                pady=5,
                )
            buttonWebHelpStatistics_Ref2 = Button(
                self.frame_30_30_SummaryAndStats,
                text='Ref 2 - wiki',
                borderwidth=5,
                relief=RAISED,
                justify=CENTER,
                background='white',
                foreground='blue',
                font=self.buttonFontSmall,
                width=15,
                command=self.handlerOpenBrowserToStandardDeviationReference,
                )
            buttonWebHelpStatistics_Ref2.grid(
                row=0,
                column=2,
                padx=5,
                pady=5,
                )
            
        else:

            labelNoStatistics = Label(
                self.frame_30_SummaryAndStats,
                text=stringStatisticsNotAvailable,
                bg=colorbg,
                justify=RIGHT,
                )
            labelNoStatistics.grid(
                row=1,
                column=0,
                columnspan=99,
                padx=5,
                pady=0,
                ) 
              
        return
        
        
    def handlerToplevelSummarizeDestroy(self):
        '''
        Purpose:
            destroy 'Summary' window
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerToplevelSummarizeDestroy')

# save location for next time window is opened
        self.summarizeField_xWindowLocation = \
            self.toplevelSummarize.winfo_rootx() - self.offsetWindowX
        self.summarizeField_yWindowLocation = \
            self.toplevelSummarize.winfo_rooty() - self.offsetWindowY

# destroy current toplevel            
        self.toplevelSummarize.destroy()
        
        return
        
        
    def handlerOpenBrowserToStandardDeviationReference(self):
        '''
        Purpose:
            open web site to reference for standard deviation explanation
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerOpenBrowserToStandardDeviationReference')
                
        webbrowser.open_new(
            "http://en.wikipedia.org/wiki/Standard_deviation"
            ) 

        return
        
        
    def handlerOpenBrowserToPDF1(self):
        '''
        Purpose:
            open web site to pdf document
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerOpenBrowserToPDF1')
            
        webbrowser.open_new(
            "http://ww1.cpa-apc.org:8080/Publications/Archives/PDF/1996/Oct/strein2.pdf"
            )
            
        return        
            
            
    def handlerCloseAdjustWindows(self):
        '''
        Purpose:
            closed the windows used to adjust the bar and pie charts
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerCloseAdjustWindows')
        
        try:
            self.toplevelChartBarAdjust.destroy()
        except:
            pass
            
        try:
            self.toplevelChartPieAdjust.destroy()
        except:
            pass
            
        return
            
          
    def handlerDisplayOrderedFields(self):
        '''
        Purpose:
        display ordered fields
        
        Called by:
            handlerSelectDisplayOrderedFields
            
        Calls:
            optionsTableManagement
        
        Input variables:
        myDatabase          Current database in use
            - taken from self.comboboxDbSelect.get()
        myTable             Current database table in use
            - taken from self.comboboxDbTableSelect.get()
        -----
        SELECT
        -----
        self.varColumnSelect        Selects either All or Y-Selected columns
            values: 'all', 'yselect'
                1. self.varRadioButtonY - 'yselect' values come from self.varRadioButtonY
                2. self.headers - table headers    
        -----
        WHERE
        -----
        self.varOpenParens          Selects open parens
            values: parenOpen1, parenOpen2, None
        -----
        Field 1
        -----
        self.varBooleanField1       Selects boolean operators for field 1
            values: 'NOT', None
        self.comboboxSelectField1   Select first field to operate on
            values: list of all fields, chosen by 'self.myDatabaseFields'
        self.comboboxSelectOperatorField1     Selects operator
            values: =, <, >, <=, >=, !=, LIKE, NOT LIKE
        self.entrySelectField1      Enter string or number
            values: user input
        -----
        Field 2
        -----
        self.varBooleanField2       Selects boolean operators for field 2
            values: 'OR', 'AND', 'AND NOT', 'XOR', None
        self.comboboxSelectField2   Select second field to operate on
            values: list of all fields, chosen by 'self.myDatabaseFields'
        self.comboboxSelectOperatorField2     Selects operator
            values: =, <, >, <=, >=, !=, LIKE, NOT LIKE
        self.entrySelectField2      Enter string or number
            values: user input
        -----
        Field 3
        -----
        self.varBooleanField3       Selects boolean operators for field 3
            values: 'OR', 'AND', 'AND NOT', 'XOR', None
        self.comboboxSelectField3   Select third field to operate on
            values: list of all fields, chosen by 'self.myDatabaseFields'
        self.comboboxSelectOperatorField3     Selects operator
            values: =, <, >, <=, >=, !=, LIKE, NOT LIKE
        self.entrySelectField3      Enter string or number
            values: user input
        
        -----
        self.varCloseParens         Selects close parens
            values: parenClose2, parenClose3, None
        -----
        ORDER BY
        -----
        FIELD 1:
        self.comboboxOrderByField1  Determines priority of fields to sort by
            values: list of all fields, chosen by 'self.myDatabaseFields'
        self.varAscDescField1       Determines if sort order is Ascending or Descending
            values: 'ASC' or 'DESC'
        FIELD 2:
        self.comboboxOrderByField2  Determines priority of fields to sort by
            values: list of all fields, chosen by 'self.myDatabaseFields'
        self.varAscDescField2       Determines if sort order is Ascending or Descending
            values: 'ASC' or 'DESC'
        FIELD 3:
        self.comboboxOrderByField3  Determines priority of fields to sort by
            values: list of all fields, chosen by 'self.myDatabaseFields'
        self.varAscDescField3       Determines if sort order is Ascending or Descending
            values: 'ASC' or 'DESC'
            
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerDisplayOrderedFields')
            
# check if connected to a MySQL server
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return
        
# check if table has any values in it
        emptyTable = False
        try:
            if len(self.tableValues) == 0:
                emptyTable = True
        except:
            emptyTable = True

        if emptyTable:    
            stringEmptyTable = (
                'Table is empty!'
                )
            self.MySQL_Output(
               0,
               stringEmptyTable
               )
            showinfo(
                'Info: empty table',
                stringEmptyTable,
                parent=self.toplevelSelectDisplayOrderedFields
                )
            return

# destroy any old toplevel frames related to Table Management Options
        try:
            self.toplevelOptionsTableManagement.destroy()
            self.MySQL_Output(
            1,
            'Previous "Options" toplevel widget removed from screen.'
            )
        except: 
            self.MySQL_Output(
            1,
            'No previous "Options" toplevel widget to remove from screen.'
            )
            
# make sure self.toplevelTableValues is mapped; if not, say so and return
        try:
            mapped = self.toplevelTableValues.winfo_exists()
        except:
            mapped = False
            
        if not mapped:
            stringNotMapped = (
                'There is no table currently displayed!\n\n' +
                'To display desired table, go to "Table Functions" window\n' +
                'and click on "Show table", or go back to "MySQL Access" tab\n' +
                'in main window and select a table from there.'
                )
            print('\n' + stringNotMapped)
            showinfo(
                'Info: no table displayed',
                stringNotMapped,
                parent=self.toplevelSelectDisplayOrderedFields
                )
            return
            
# inform user if rows are checked; continuing will not carry checked boxes over
#    to new display
        numRowsSelected = self.varEntryNumberOfRowsSelected.get()
        if numRowsSelected > 0:
            stringRowsSelected = (
                '%s rows are selected in the current window.\n\n' +
                'Checked rows will not carry over to the next display.\n\n' +
                'Continue?'
                ) % numRowsSelected
#            print('\n' + stringRowsSelected)
            self.MySQL_Output(
                0,
                stringRowsSelected
                )
            ans = askyesno(
                'Question',
                stringRowsSelected,
                parent=self.toplevelSelectDisplayOrderedFields
                )
            if not ans:
                return
            else:
                self.varEntryNumberOfRowsSelected.set(0)
        
# define current database and table
#        myDatabase = self.comboboxDbSelect.get()
#        myTable = self.comboboxDbTableSelect.get()
        myDatabase = self.myDatabase
        myTable = self.myTable
        
# set flags 
        flag_WhereEmpty = 0
        flag_OrderByEmpty = 0
        
# save X-Select and Y-Select field names that have been checked
#   (uses field names, not indices, to make it easier to track which fields
#    have been checked, so they can be re-checked after display is refreshed)
        self.saveCheckedFieldNames()
        
# put together the SELECT-WHERE-ORDER BY command
# ... start with SELECT and beginning paren to enclose parameter list
        stringCommand = 'SELECT '
      
# save the table structure coming in, just in case we have to bail prematurely and we have to reset values
        temp_tableStructureOriginal = self.tableStructure
        temp_tableValuesOriginal = self.tableValues
        temp_dictColumnHeadersOriginal = copy.deepcopy(self.dictColumnHeaders)
# end of Check this
        
# select columns 
        if self.varColumnSelect.get().strip() == 'all':
            stringCommand += '* '
            self.tableStructure = self.tableStructureOriginal
            self.tableValues = self.tableValuesOriginal
            self.dictColumnHeaders = copy.deepcopy(self.dictColumnHeadersOriginal)

        elif (
            self.varColumnSelect.get() == 'yselect'
            or
            self.varColumnSelect.get() == 'yselectplusx'
            ):
            stringTemp = ''
            valueForX = 0
# temporary empty list for constructing new header columns
            tableStructureTemp = []
           
# get X-Select field first
            if self.varColumnSelect.get() == 'yselectplusx':
                try:
                    valueForX = self.varXSelect.get()
                except:
                    valueForX = 0
                if DEBUG_COLUMN_HEADERS:
                    print('\nvalueForX = %s' % valueForX)
                
# match valueForX with a (key,value) pair in self.dictColumnHeaders
                foundIt = False
                for (key,value) in self.dictColumnHeaders.iteritems():
                    if DEBUG_COLUMN_HEADERS:
                        print('key, value = %s. %s' % (key,value))
                    if value == valueForX:
                        foundIt = True
# duplicates not allowed, but add key if not in stringTemp
                        if key not in stringTemp:
                            if stringTemp == '':
                                stringTemp = self.tableStructure[valueForX - 1][0]
                            else:
                                stringTemp += ',' + self.tableStructure[valueForX - 1][0]
                            tableStructureTemp.append(self.tableStructure[valueForX - 1])
                        if DEBUG_COLUMN_HEADERS:
                            print('stringTemp = %s' % stringTemp)
                        break
                        
                if (valueForX == 0 or foundIt == False):
                    stringNoFindX = (
                        'No X-Select value has been found.\n\n' +
                        'Select a value for X in table header and try again.'
                        )
                    self.MySQL_Output(
                        0,
                        stringNoFindX
                        )
                    showerror(
                        'No X-Select value found',
                        stringNoFindX,
                        parent=self.toplevelSelectDisplayOrderedFields
                        )
                    return
                
# get Y-Select fields  
            if DEBUG_COLUMN_HEADERS:
                print('\nfor self.varYSelect:')
                for (num,var) in enumerate(self.varYSelect):
                    print(' %s. %s' % (num+1, var.get()))
                print ('\n ----- self.tableStructure =\n')
                icount_its = 1
                for its in range(len(self.tableStructure)):
                    print('%s. %s' % (icount_its, self.tableStructure[its]))
                    icount_its+=1
                print ('-----')
                print
                print ' %%% header count:'    
                
            icount = 0
            for (numHeader,var) in enumerate(self.varYSelect):
                if DEBUG_COLUMN_HEADERS:
                    print(
                        '%s. var.get() = %s' % (numHeader,var.get())
                        )
                if var.get():
                    fieldHeader = self.tableStructure[numHeader][0]
# add fieldHeader to stringTemp only if it is not already there
                    if fieldHeader not in stringTemp:
                        icount+=1
                        if icount > 1:
                            stringTemp += ',' + fieldHeader
                        elif icount == 1 and valueForX == 0:
                            stringTemp += fieldHeader
                        else:
                            stringTemp += ',' + fieldHeader
                        tableStructureTemp.append(self.tableStructure[numHeader])
 
            if icount == 0:
                stringNoFindY = (
                    'No Y-Select values have been found.\n\n' +
                    'Select values for Y in table header and try again.'
                    )
                self.MySQL_Output(
                    0,
                    stringNoFindY
                    )
                showerror(
                    'No Y-Select value found',
                    stringNoFindY,
                    parent=self.toplevelSelectDisplayOrderedFields
                    )
                return

# add space after SELECT parameters                
            stringCommand += stringTemp + ' '
            
            if DEBUG_COLUMN_HEADERS:
                print('stringCommand (after select) = %s' % stringCommand)
                
# redefine tableStructure to reflect fact that data has been thinned
            self.tableStructure = tableStructureTemp
            
            if DEBUG_COLUMN_HEADERS:
                print ('\nself.tableStructure after decimation:\n %s \n' % self.tableStructure)
            
# redefine dictColumnHeaders
            self.dictColumnHeaders = {}
            icount=0
            for i in range(len(self.tableStructure)):
                icount += 1
                self.dictColumnHeaders[self.tableStructure[i][0]] = icount
                if DEBUG_COLUMN_HEADERS:
                    print '\n>> Dictionary of Column Headers'
                    print self.dictColumnHeaders
                    self.MySQL_Output(
                        1,
                        '\nDictionary of column headers:'
                        )
                    self.MySQL_Output(
                        0,
                        self.dictColumnHeadersOriginal
                        )
            
            if DEBUG_COLUMN_HEADERS:
                print '**************************'
                print '\nself.dictColumnHeaders:\n',self.dictColumnHeaders
           
# add FROM 
        stringCommand += 'FROM '

# specify the database and table
        stringCommand += myDatabase + '.' + myTable + ' '

# select fields, operators, strings or numbers, and parens
# ... field1 vars
        vBF1 = self.varBooleanField1.get().strip()
        cSF1 = self.comboboxSelectField1.get()
        if cSF1 <> '':
            cSF1 = cSF1.split()[1].strip()
        cSOF1 = self.comboboxSelectOperatorField1.get().strip()
        eSF1 = self.comboboxSelectValueField1.get().strip()
# ... field2 vars
        vBF2 = self.varBooleanField2.get().strip()
        cSF2 = self.comboboxSelectField2.get()
        if cSF2 <> '':
            cSF2 = cSF2.split()[1].strip()
        cSOF2 = self.comboboxSelectOperatorField2.get().strip()
        eSF2 = self.comboboxSelectValueField2.get().strip()
# ... field3 vars
        vBF3 = self.varBooleanField3.get().strip()
        cSF3 = self.comboboxSelectField3.get()
        if cSF3 <> '':
            cSF3 = cSF3.split()[1].strip()
        cSOF3 = self.comboboxSelectOperatorField3.get().strip()
        eSF3 = self.comboboxSelectValueField3.get().strip()
        
# assemble WHERE field
        stringCommandWhere = ''

        if cSF1:
# add WHERE; keep string separate and join to stringCommand at the end of this sections logic
            stringCommandWhere = 'WHERE '
          
# add booleans, operators, etc.
            if vBF1 == 'NOT':
                stringCommandWhere += 'NOT '
            if self.varOpenParens.get().strip() == 'parenOpen1':
                stringCommandWhere += '('
            stringCommandWhere += cSF1 + ' '
            if cSOF1:
                stringCommandWhere += cSOF1 + ' '
            else:
                self.MySQL_Output(
                    1,
                    'Error: No Operator value has been selected\n' +
                    'for Field 1. Please select a value and\n' +
                    'try again.\n\n'
                    )
                showerror(
                    'Error: no operator value',
                    '\nNo Operator value has been selected\n' +
                    'for Field 1.\n\n'
                    'Please select a value and try again.\n\n'
                    )
# reset to previous values
                self.tableStructure = temp_tableStructureOriginal
                self.tableValues = temp_tableValuesOriginal
                self.dictColumnHeaders = temp_dictColumnHeadersOriginal  
                
                return
                
            if eSF1:
                try:
                    float(eSF1)
                except ValueError:
                    eSF1 = "'" + eSF1 + "'"
                stringCommandWhere += eSF1 + ' '
            else:
                self.MySQL_Output(
                    1,
                    'Error: No User-Entry value has been entered\n' +
                    'for Field 1. Please enter a value and\n' +
                    'try again.\n\n'
                    )
                showerror(
                    'Error: no entry',
                    '\nNo User-Entry value has been entered\n' +
                    'for Field 1.\n\n' +
                    'Please enter a value and try again.\n\n'
                    )
# reset to previous values
                self.tableStructure = temp_tableStructureOriginal
                self.tableValues = temp_tableValuesOriginal
                self.dictColumnHeaders = temp_dictColumnHeadersOriginal  
                
                return  
                
# ... Field 2
            if cSF2:
                if vBF2 <> '' and vBF2 <> None:
                    stringCommandWhere += vBF2 + ' '
                else:
                    stringNoBooleanField2 = (
                        'No Boolean value (OR, AND, ...) has been selected\n' +
                        'for Field 2\n\n' +
                        'Select a Boolean value (above Field 2) and try again.'
                        )
                    self.MySQL_Output(
                        1,
                        stringNoBooleanField2
                        )
                    showerror(
                        'Error: no boolean value',
                        stringNoBooleanField2
                        )
# reset to previous values
                    self.tableStructure = temp_tableStructureOriginal
                    self.tableValues = temp_tableValuesOriginal
                    self.dictColumnHeaders = temp_dictColumnHeadersOriginal  
                
                    return
                    
                if self.varOpenParens.get().strip() == 'parenOpen2':
                    stringCommandWhere += '('
                stringCommandWhere += cSF2 + ' '
                if cSOF2:
                    stringCommandWhere += cSOF2 + ' '
                else:
                    self.MySQL_Output(
                        1,
                        'Error: No Operator value has been selected\n' +
                        'for Field 2. Please select a value and\n' +
                        'try again.\n\n'
                        )
                    showerror(
                        'Error: no operator value',
                        '\nNo Operator value has been selected\n' +
                        'for Field 2.\n\n' +
                        'Please select a value and try again.\n\n'
                        )
# reset to previous values
                    self.tableStructure = temp_tableStructureOriginal
                    self.tableValues = temp_tableValuesOriginal
                    self.dictColumnHeaders = temp_dictColumnHeadersOriginal  
                
                    return
                    
                if eSF2:
                    try:
                        float(eSF2)
                    except ValueError:
                        eSF2 = "'" + eSF2 + "'"
                    stringCommandWhere += eSF2 + ' '
                else:
                    self.MySQL_Output(
                        1,
                        'Error: No Entry value has been selected\n' +
                        'for Field 2. Please enter a string or number value\n' +
                        'and try again.\n\n'
                        )
                    showerror(
                        'Error: no operator value',
                        '\nNo Operator value has been selected\n' +
                        'for Field 2.\n\n' +
                        'Please select a value and try again.\n\n'
                        )
# reset to previous values
                    self.tableStructure = temp_tableStructureOriginal
                    self.tableValues = temp_tableValuesOriginal
                    self.dictColumnHeaders = temp_dictColumnHeadersOriginal  
                
                    return
                    
                if self.varCloseParens.get().strip() == 'parenClose2':
                    stringCommandWhere += ') '
# ... Field 3
                if cSF3:
                    if vBF3 <> '' and vBF3 <> None:
                        stringCommandWhere += vBF3 + ' '
                    else:
                        stringNoBooleanField3 = (
                        'No Boolean value (OR, AND, ...) has been selected\n' +
                        'for Field 3\n\n' +
                        'Select a Boolean value (above Field 3) and try again.'
                        )
                        self.MySQL_Output(
                            1,
                            stringNoBooleanField3 
                            )
                        showerror(
                            'Error: no boolean value',
                            stringNoBooleanField3
                            )
                            
# reset to previous values
                        self.tableStructure = temp_tableStructureOriginal
                        self.tableValues = temp_tableValuesOriginal
                        self.dictColumnHeaders = temp_dictColumnHeadersOriginal  
                
                        return
                        
                    stringCommandWhere += cSF3 + ' '
                    if cSOF3:
                        stringCommandWhere += cSOF3 + ' '
                    else:
                        self.MySQL_Output(
                            1,
                            'Error: No Operator value has been selected\n' +
                            'for Field 3. Please select a value and\n' +
                            'try again.\n\n'
                            )
                        showerror(
                            'Error: no operator value',
                            '\nNo Operator value has been selected\n' +
                            'for Field 3.\n\n' +
                            'Please select a value and try again.\n\n'
                            )
                            
# reset to previous values
                        self.tableStructure = temp_tableStructureOriginal
                        self.tableValues = temp_tableValuesOriginal
                        self.dictColumnHeaders = temp_dictColumnHeadersOriginal  
                
                        return
                        
                    if eSF3:
                        try:
                            float(eSF3)
                        except ValueError:
                            eSF3 = "'" + eSF3 + "'"
                        stringCommandWhere += eSF3 + ' '
                    else:
                        self.MySQL_Output(
                            1,
                            'Error: No Entry value has been selected\n' +
                            'for Field 3. Please enter a string or number value\n' +
                            'and try again.\n\n'
                            )
                        showerror(
                            'Error: no operator value',
                            '\nNo Operator value has been selected\n' +
                            'for Field 3.\n\n' +
                            'Please select a value and try again.\n\n'
                            )
                            
# reset to previous values
                        self.tableStructure = temp_tableStructureOriginal
                        self.tableValues = temp_tableValuesOriginal
                        self.dictColumnHeaders = temp_dictColumnHeadersOriginal  
                
                        return
                        
                    if self.varCloseParens.get().strip() == 'parenClose3':
                        stringCommandWhere += ') '
                        
# if no value in first field, do not continue
        else:
        
# check entry in field 2; should be in field 1 first
            if cSF2:
# if cSF2 is empty, but others are not, print error and return
                print(
                    'Error: "WHERE" field #1 empty.\n' +
                    '  Enter a value in field 1 before\n' +
                    '  selecting field 2.\n'
                    )
                showerror(
                    'Error: "WHERE" field #1 empty',
                    '\nEnter a value in field 1 before selecting field 2.\n\n'
                    )
                    
# reset to previous values
                self.tableStructure = temp_tableStructureOriginal
                self.tableValues = temp_tableValuesOriginal
                self.dictColumnHeaders = temp_dictColumnHeadersOriginal  
                
                return
                
# check entry in field 3; should be in field 2 first            
            if cSF3:
                print(
                    'Error: "WHERE" field #2 empty.\n' +
                    '  Enter values in fields 1 and 2 before\n' +
                    '  selecting field 3.\n'
                    )
                showerror(
                    'Error: "WHERE" field #2 empty',
                    '\nEnter a value in field 2 before selecting field 3.\n\n'
                    )
                    
# reset to previous values
                self.tableStructure = temp_tableStructureOriginal
                self.tableValues = temp_tableValuesOriginal
                self.dictColumnHeaders = temp_dictColumnHeadersOriginal  
                
                return   
                
# if all blank, just skip 'WHERE' part of command, but flag in case all fields are empty
            flag_WhereEmpty = 1
            
        stringCommand += stringCommandWhere
        
# following string used in handlerDisplayedRowsDelete
        if stringCommandWhere:
            self.stringCommandWhere = stringCommandWhere
        else:
            self.stringCommandWhere = ''
        
# select fields to order by, but do not include if nothing is selected
        if self.comboboxOrderByField1.get():
            cOBF1 = self.comboboxOrderByField1.get().split()[1].strip()
        else:
            cOBF1 = ''
        vADF1 = self.varAscDescField1.get()
        if self.comboboxOrderByField2.get():
            cOBF2 = self.comboboxOrderByField2.get().split()[1].strip()
        else:
            cOBF2 = ''
        vADF2 = self.varAscDescField2.get()
        if self.comboboxOrderByField3.get():
            cOBF3 = self.comboboxOrderByField3.get().split()[1].strip()
        else:
            cOBF3 = ''
        vADF3 = self.varAscDescField3.get()
        
        if cOBF1:
            stringCommandOrderBy = cOBF1
            stringCommandOrderBy += ' ' + vADF1
            if cOBF2:  
                stringCommandOrderBy += ', ' + cOBF2
                stringCommandOrderBy += ' ' + vADF2
                if cOBF3:
                    stringCommandOrderBy += ', ' + cOBF3
                    stringCommandOrderBy += ' ' + vADF3
                stringCommand += ' ORDER BY ' + stringCommandOrderBy
            else:
                if cOBF3:
                    print '# 1 cobf3'
                    print(
                        'Error: "ORDER BY" fields empty.\n' +
                        '  Enter a value in Fields 1 and 2 before\n' +
                        '  selecting field 3.\n'
                        )
                    showerror(
                        'Error: "ORDER BY" fields empty',
                        '\nEnter a value in fields 1 and 2 before\n' +
                        '  selecting field 3.\n\n'
                        )
                        
# reset to previous values
                    self.tableStructure = temp_tableStructureOriginal
                    self.tableValues = temp_tableValuesOriginal
                    self.dictColumnHeaders = temp_dictColumnHeadersOriginal  
                
                    return
                    
                else:
                    if DEBUG_COLUMN_HEADERS:
                        print '>> "ORDER BY" stringCommand:'
                        print stringCommandOrderBy
                    stringCommand += ' ORDER BY ' + stringCommandOrderBy
                
        else:
        
# if cOBF1 is empty, but others are not, print error and return
            if cOBF2:
                print(
                    'Error: "ORDER BY" field empty.\n' +
                    '  Enter a value in field 1 before\n' +
                    '  selecting field 2.\n'
                    )
                showerror(
                    'Error: "ORDER BY" field empty',
                    '\nEnter a value in field 1 before selecting field 2.\n\n'
                    )
                    
# reset to previous values
                self.tableStructure = temp_tableStructureOriginal
                self.tableValues = temp_tableValuesOriginal
                self.dictColumnHeaders = temp_dictColumnHeadersOriginal  
                
                return
                
            if cOBF3:
                print '# 2 cobf3'
                print(
                    'Error: "ORDER BY" fields empty.\n' +
                    '  Enter a value in Fields 1 and 2 before selecting field 3.\n'
                    )
                showerror(
                    'Error: "ORDER BY" fields empty',
                    '\nEnter a value in fields 1 and 2 before selecting field 3.\n\n'
                    )
                    
# reset to previous values
                self.tableStructure = temp_tableStructureOriginal
                self.tableValues = temp_tableValuesOriginal
                self.dictColumnHeaders = temp_dictColumnHeadersOriginal  
                
                return
                
# if all blank, just skip 'WHERE' part of command, but flag in case all fields are empty
            flag_OrderByEmpty = 1
            
# check if all fields empty; if so, print info and return
        if flag_WhereEmpty and flag_OrderByEmpty:
            print(
                'All DISPLAY options are empty.' + '\n' + 
                '  No change made to Table.' + '\n'
                )
            self.MySQL_Output(
                1,
                'All "DISPLAY" options are empty.' + '\n' +
                '  No change made to Table.' + '\n'
                )
            showinfo(
                'Info: empty "DISPLAY" options',
                '\nAll "DISPLAY" options are empty.' + '\n\n' +
                'No change made to Table' + '\n\n'
                )
                
# reset to previous values
            self.tableStructure = temp_tableStructureOriginal
            self.tableValues = temp_tableValuesOriginal
            self.dictColumnHeaders = temp_dictColumnHeadersOriginal
# endof Check this

            return
        
# print entire string
        if DEBUG_COLUMN_HEADERS:
                print('\nstringCommand to execute = %s' % stringCommand)
                print('\nlen(stringCommand) = %s' % len(stringCommand))
                
        self.MySQL_Commands(
            1,
            '\nself.cursorHandleMySQL.execute("' + stringCommand + '")' +
            '\nlen(stringCommand) = ' + str(len(stringCommand))
            )

# execute command
        start = time.time()
        try:
            self.cursorHandleMySQL.execute(stringCommand)
            if DEBUG_COLUMN_HEADERS:
                print('\n*** stringCommand successfully executed')
                showinfo(
                    'Success',
                    '*** stringCommand successfully executed',
                    parent=self.toplevelSelectDisplayOrderedFields
                    )
        except:
            print(
                '\nError in MySQL command string.\n' +
                ' Examine following command string for errors and try again.\n' +
                ' Command string:\n' +
                '   ' + stringCommand
                )
            showerror(
                'Error: bad MySQL command string',
                '\nExamine following command string for errors and try again.\n\n' +
                'Command string:\n\n' +
                stringCommand
                )
            return

        self.tableValues = self.cursorHandleMySQL.fetchall()
        finish=time.time()
        delta_t = finish - start
        self.MySQL_Commands(
            0,
            '  (Time: %-7.4f secs)' % delta_t
            )
            
        self.valuesDisplayRowDecimate(self.tableStructure,self.tableValues)
        
# recheck all fields that were originally checked
        if mapped:  
            self.restoreCheckedFieldNames()
            if DEBUG_CHECKMARKS_RESTORED:
                showinfo(
                    'restore',
                    'checkmarks have been restored - 2'
                    )
                    
# offer up other table management options: delete, update
        self.buttonOptionsTableManagement.configure(state='normal')
        
# update status line
        maxLinesDisplay = int(self.comboboxMaxLinesToDisplay.get())
        if maxLinesDisplay == 0 or maxLinesDisplay > len(self.tableValues):
            maxLinesDisplay = len(self.tableValues)

        self.handlerStatusLineRefresh(maxLinesDisplay)
        
# update selectable field values in Table Filters window
        self.handlerUpdateFieldSelectValues()
                
        return
                
        
    def handlerOptionsTableManagement(self):
        '''
        Purpose:
            after table is displayed using select fields, display
            window to offer table management options such as
            delete and update
            
        Called by:
        
        Calls:
        
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerOptionsTableManagement')
            
# toplevel for these widgets
# check if connected to a MySQL server
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return
        
# parent frame
        frameParent = self.toplevelSelectDisplayOrderedFields
        
# background color
        colorBG = 'lightgreen'
        
# if main window is mapped, uncheck any checked rows; not needed here
        try:
            mappedMainWindow = self.toplevelTableValues.winfo_exists()
        except:
            mappedMainWindow = False
        if mappedMainWindow:
            for var in self.varSelectAnyRow:
                var.set(0)
            
# destroy any old toplevel frames
        try:
            self.toplevelOptionsTableManagement.destroy()
            self.MySQL_Output(
            1,
            'Previous toplevel widget removed from screen.'
            )
        except: 
            self.MySQL_Output(
            1,
            'No previous toplevel widget to remove from screen.'
            )
                    
# open Toplevel frame for entering database name
        self.toplevelOptionsTableManagement = Toplevel(
            frameParent,
            bg=colorBG,
            )
        self.toplevelOptionsTableManagement.title(
#            'Table management options'
            'Server: ' + self.comboServerMySQL.get() + '     ' +
            'Database: ' + self.varTableFunctionsSelectDatabase.get() + '     ' +
            'Table: ' + self.varEntryTableFunctionsSelectTable.get().strip() 
            )
            
        self.toplevelOptionsTableManagement.transient(frameParent)

# place the top window
#        x_Windows=100
#        y_Windows=500
        x_Windows = self.displayOptionsTableManagement_xWindowLocation
        y_Windows = self.displayOptionsTableManagement_yWindowLocation

        self.toplevelOptionsTableManagement.geometry(
            '+%d+%d' % (x_Windows, y_Windows)
            )

# define current database and table
#        myDatabase = self.comboboxDbSelect.get()
#        myTable = self.comboboxDbTableSelect.get().strip()       
        myDatabase = self.myDatabase
        myTable = self.myTable

# define frames
# ... frame_00, for label
        frame_00 = Frame(
            self.toplevelOptionsTableManagement,
            bg=colorBG,
            )
        frame_00.grid(
            row=0,
            column=0,
            )
            
# ... frame_10, for widgets
        frame_10 = Frame(
            self.toplevelOptionsTableManagement,
            bg=colorBG,
            )
        frame_10.grid(
            row=1,
            column=0,
            )            
            
# ... frame_20, for cancel
        frame_20 = Frame(
            self.toplevelOptionsTableManagement,
            bg=colorBG,
            )
        frame_20.grid(
            row=2,
            column=0,
            )  

# ------ Add widgets -----
# Frame_00
        labelTitle = Label(
            frame_00,
            text=(
#                'Table Management Options' + '\n\n' +
                'DELETE DISPLAYED ROWS' + '\n\n' +
                'WARNING: this command permanently alters\n' +
                'original table and cannot be undone!'
                ),
            font=self.titleFontBig,
            bg=colorBG,
            )
        labelTitle.grid(
            row=0,
            column=0,
            columnspan=2,
            padx=10,
            pady=5,
            )
# ... rows affected
        rowsAffected = len(self.tableValues)
        labelRowsAffected = Label(
            frame_00,
            text='Number of rows that will be affected:',
            bg=colorBG,
            )
        labelRowsAffected.grid(
            row=1,
            column=0,
            padx=5,
            pady=0,
            sticky=E,
            )
        varRowsAffected = IntVar()
        entryRowsAffected = Entry(
            frame_00,
            textvariable=varRowsAffected,
            relief=FLAT,
            width=5,
            bg=colorBG,
            disabledforeground='black',
            disabledbackground=colorBG
            )
        entryRowsAffected.grid(
            row=1,
            column=1,
            padx=0,
            pady=0,
            sticky=W,
            )
        entryRowsAffected.configure(state='normal')
        varRowsAffected.set(rowsAffected)
        entryRowsAffected.configure(state='disabled')
        
            
# Frame_10
# ... checkbox for re-sequencing auto_index
        self.varCheckbuttonResequenceAutoIndex = IntVar()
        self.checkbuttonResequenceAutoIndex = Checkbutton(
            frame_10,
            bg=colorBG,
            text='Resequence auto_index field after Delete',
            variable=self.varCheckbuttonResequenceAutoIndex,
            )
        self.checkbuttonResequenceAutoIndex.grid(
            row=0,
            column=0,
            padx=0,
            pady=5,
            )
        self.varCheckbuttonResequenceAutoIndex.set('1')
# ... delete displayed rows
        buttonDeleteDisplayedRows = Button(
            frame_10,
            text='Delete\nDisplayed Rows',
            relief=RAISED,
            borderwidth=5,
            bg='white',
            fg='blue',
            width=20,
            command=self.handlerDisplayedRowsDelete,
            )
        buttonDeleteDisplayedRows.grid(
            row=1,
            column=0,
            padx=5,
            pady=10,
            )
        '''
# ... update displayed rows
        buttonUpdateDisplayedRows = Button(
            frame_10,
            text='Update\nDisplayed Rows',
            relief=RAISED,
            borderwidth=5,
            command=self.handlerDisplayedRowsUpdate,
            )
        buttonUpdateDisplayedRows.grid(
            row=0,
            column=1,
            padx=5,
            pady=5,
            )
        '''
# Frame_20            
        buttonOptionsCancel = Button(
            frame_20,
            text='Cancel',
            relief=RAISED,
            borderwidth=5,
            command=self.handlerDestroyToplevelOptionsTableManagement,
            )
        buttonOptionsCancel.grid(
            row=0,
            column=0,
            padx=0,
            pady=5,
            )
            
        return
        
        
    def handlerDestroyToplevelOptionsTableManagement(self):
        '''
        Purpose:
            destroy the toplevel window associated with Table Management Options
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerDestroyToplevelOptionsTableManagement')
        
# save window location
        self.displayOptionsTableManagement_xWindowLocation = \
           self.toplevelOptionsTableManagement.winfo_rootx() - self.offsetWindowX
        self.displayOptionsTableManagement_yWindowLocation = \
           self.toplevelOptionsTableManagement.winfo_rooty() - self.offsetWindowY

        self.toplevelOptionsTableManagement.destroy()
        
        return
            
            
    def handlerDisplayLimitedRows(self):
        '''
        Purpose:
            display partial table as freshly retrieved from database; necessary for accessing
            large tables since only a portion of the table is loaded.
            It is assumed the next step will be to filter the table, which will also display
            only a portion of the original table.
            This keeps PylotDB from becoming overloaded with a huge table
        
        Called by: 
            self.handlerTableFunctionsShowValues(), and others
        
        Calls:
            self.valuesDisplay()
        
        Inputs:
        
        Primary variables:
            self.tableValues
            self.tableStructure
            
        Outputs:
            None
                    
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerDisplayLimitedRows')
            
# set last button pressed
        self.lastButtonPressed(
            BUTTONLABEL_PEEK
            )
            
# save checked fields
        self.saveCheckedFieldNames()  
            
# if plot windows are open, give user chance to cancel
        try:
            mappedXYPlot = self.toplevelXYPlotPreprocess.winfo_exists()
        except:
            mappedXYPlot = 0
            
        try:
            mappedKiviatPlot = self.toplevelKiviatPlotPreprocess.winfo_exists()
        except:
            mappedKiviatPlot = 0
            
        try:
            mappedScatterPlot = self.toplevelScatterPlotPreprocess.winfo_exists()
        except:
            mappedScatterPlot = 0
            
        if mappedXYPlot or mappedKiviatPlot or mappedScatterPlot:
            stringMapped = (
                'Refreshing table can cause columns to be re-numbered.' + '\n\n' +
                'Hence, pressing OK will cause open plot windows to be' + '\n' + 
                'closed and the table refreshed.' + '\n\n' +
                'Do you wish to continue?' + '\n\n'
                )
            okay = askokcancel(
                'Warning: plot window',
                stringMapped
                )
            if okay:
# store current locations of open windows to plot later in the same position
                if mappedXYPlot:
                    self.plottingspecs_xWindowLocation_XY= self.toplevelXYPlotPreprocess.winfo_rootx() - self.offsetWindowX
                    self.plottingspecs_yWindowLocation_XY= self.toplevelXYPlotPreprocess.winfo_rooty() - self.offsetWindowY
                    self.toplevelXYPlotPreprocess.destroy()
                if mappedKiviatPlot:
                    self.plottingspecs_xWindowLocation_Kiviat= self.toplevelKiviatPlotPreprocess.winfo_rootx() - self.offsetWindowX
                    self.plottingspecs_yWindowLocation_Kiviat= self.toplevelKiviatPlotPreprocess.winfo_rooty() - self.offsetWindowY
                    self.toplevelKiviatPlotPreprocess.destroy()
                if mappedScatterPlot:
                    self.plottingspecs_xWindowLocation_Scatter = self.toplevelScatterPlotPreprocess.winfo_rootx() - self.offsetWindowX
                    self.plottingspecs_yWindowLocation_Scatter = self.toplevelScatterPlotPreprocess.winfo_rooty() - self.offsetWindowY
                    self.toplevelScatterPlotPreprocess.destory()
            else:
                return
            
# check if connected to a MySQL server
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return 

# get table and database names
        '''
        self.myTable = self.comboboxTableFunctionsSelectTable.get()
        '''
        self.myTable = self.comboboxDbTableSelect.get().strip()
        self.myDatabase = self.comboboxDbSelect.get().strip()
        
# shorten names for local use        
        myTable = self.myTable
        myDatabase = self.myDatabase

        stringTableStructure = (
            "SHOW COLUMNS FROM " + myDatabase + "." + myTable
            )
            
        self.MySQL_Commands(
            1,
            'self.cursorHandleMySQL.execute("' + stringTableStructure + '")'
            )
            
# execute the command
        start=time.time()
        
        try:
            self.cursorHandleMySQL.execute(
                stringTableStructure
                )
        except:
            stringTableError = (
                'Table %s cannot be displayed.\n\n' + 
                'The table may have been deleted or moved.'
                ) % myTable
            print stringTableError
            self.MySQL_Commands(
                1,
                stringTableError
                )
            showerror(
                'Error: no table to display',
                stringTableError
                )
            return
            
        self.tableStructureOriginal = self.cursorHandleMySQL.fetchall()
        
        finish=time.time()
        delta_t = finish - start
        self.MySQL_Commands(
            0,
            '  (Time: %-7.4f secs)' % delta_t
            )
            
        self.MySQL_Output(
            1,
            'Structure for table "' + myTable + '":'
            )
        self.MySQL_Output(
            0,
            self.tableStructureOriginal
            )
        self.MySQL_Output(
            0,
            ''
            )
            
# look for auto_index field
        flagAutoIndex = False
        for eachItem in self.tableStructureOriginal:
            if 'auto_index' in eachItem:
                flagAutoIndex = True
                break

# to limit display, determine number of rows to display AND starting row number
        numberOfRowsToDisplay = self.comboboxMaxLinesToDisplay.get()
        
        if numberOfRowsToDisplay == '0':
            stringCannotUsePeekFunction = (
                'The value for "Max lines to display" must be non-zero\n' +
                'for the PEEK function to work.\n\n' +
                'Specify a non-zero value and try again.'
                )
            print(stringCannotUsePeekFunction)
            self.MySQL_Output(
                0,
                stringCannotUsePeekFunction
                )
            showerror(
                'Error: must be non-zero value',
                stringCannotUsePeekFunction,
                parent=self.toplevelTableValues
                )
            return
            
        startAtRow = 0
# assemble string to get field values
        if flagAutoIndex:
            stringTableValues = (
                "SELECT * FROM " + myDatabase + "." + myTable + 
                ' order by auto_index' +
                " LIMIT " + str(startAtRow) + "," + str(numberOfRowsToDisplay)
                )
        else:
            stringTableValues = (
                "SELECT * FROM " + myDatabase + "." + myTable
                + " LIMIT " + str(startAtRow) + "," + str(numberOfRowsToDisplay)
                )
                
        self.MySQL_Commands(
            1,
            'self.cursorHandleMySQL.execute("' + stringTableValues + '")'
            )
            
# execute the command
        start = time.time()
        self.cursorHandleMySQL.execute(
            stringTableValues
            )
        self.tableValuesOriginal = self.cursorHandleMySQL.fetchall()
        finish = time.time()
        delta_t = finish - start
        self.MySQL_Commands(
            0,
            '  (Time: %-7.4f secs)' % delta_t
            )
            
        if DEBUG_TABLE_VALUES:
            self.MySQL_Output(
                1,
                'Values for table "' + myTable + '":'
                )
            self.MySQL_Output(
                0,
                self.tableValuesOriginal
                )
            self.MySQL_Output(
                0,
                ''
                )
            
# define dictionary for column headers
        self.dictColumnHeadersOriginal = {}
        icount=0
        for i in range(len(self.tableStructureOriginal)):
            icount+=1
            self.dictColumnHeadersOriginal[self.tableStructureOriginal[i][0]]=icount
        if DEBUG_COLUMN_HEADERS:
            print('\n>> Dictionary of new column headers:')
            print(self.dictColumnHeadersOriginal)
            self.MySQL_Output(
                1,
                ' Dictionary of column headers:'
                )
            self.MySQL_Output(
                0,
                self.dictColumnHeadersOriginal
                )
         
        self.tableStructure = self.tableStructureOriginal
        self.tableValues = self.tableValuesOriginal
        self.dictColumnHeaders = copy.deepcopy(self.dictColumnHeadersOriginal)

# re-set indices for X-Select and Y-Select checked values for new column headers, but
#   only if the old header names exist in the new header listd
#        self.resetVarXYSelect()

#  self.valuesDisplayRowDecimate(self.tableStructureOriginal, self.tableValuesOriginal)
        self.handlerTableFunctionsShowValues(0,'limit')

        self.resetVarXYSelect()
        
# display new total in main table window for Storage Buffer
        self.countDisplayStorageBuffer.set(
                            'BUFFER: Display (' +
                            str(self.bufferRowStore_NumRows) + 
                            ' rows)'
                            )
                            
# update status line
        maxLinesDisplay = int(self.comboboxMaxLinesToDisplay.get())
        if maxLinesDisplay == 0 or maxLinesDisplay > len(self.tableValues):
            maxLinesDisplay = len(self.tableValues)

        self.handlerStatusLineRefresh(maxLinesDisplay)
        
# refresh fields combobox in main window
        self.refreshFields()
        
# restore checked fields
        self.restoreCheckedFieldNames()  
        
        return
        
        
    def handlerDisplayAllFields(self):
        '''
        Purpose:
            display the full table as freshly retrieved from database
        
        Called by: 
            self.handlerTableFunctionsShowValues()
        
        Calls:
            self.valuesDisplay()
        
        Inputs:
            self.tableValues
            self.tableStructure
            
        Outputs:
            None
                    
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerDisplayAllFields')
            
# set last button pressed
        self.lastButtonPressed(
            BUTTONLABEL_LOAD
            )
            
# if plot windows are open (mapped), give user chance to cancel
        try:
            mappedXYPlot = self.toplevelXYPlotPreprocess.winfo_exists()
        except:
            mappedXYPlot = False
            
        try:
            mappedKiviatPlot = self.toplevelKiviatPlotPreprocess.winfo_exists()
        except:
            mappedKiviatPlot = False
            
        try:
            mappedScatterPlot = self.toplevelScatterPlotPreprocess.winfo_exists()
        except:
            mappedScatterPlot = False
            
        if mappedXYPlot or mappedKiviatPlot or mappedScatterPlot:
            stringMapped = (
                'Refreshing table can cause columns to be re-numbered.' + '\n\n' +
                'Hence, pressing OK will cause open plot windows to be' + '\n' + 
                'closed and the table refreshed.' + '\n\n' +
                'Do you wish to continue?' + '\n\n'
                )
            okay = askokcancel(
                'Warning: plot window',
                stringMapped
                )
            if okay:
# store current locations of open windows to plot later in the same position
                if mappedXYPlot:
                    self.plottingspecs_xWindowLocation_XY= self.toplevelXYPlotPreprocess.winfo_rootx() - self.offsetWindowX
                    self.plottingspecs_yWindowLocation_XY= self.toplevelXYPlotPreprocess.winfo_rooty() - self.offsetWindowY
                    self.toplevelXYPlotPreprocess.destroy()
                if mappedKiviatPlot:
                    self.plottingspecs_xWindowLocation_Kiviat= self.toplevelKiviatPlotPreprocess.winfo_rootx() - self.offsetWindowX
                    self.plottingspecs_yWindowLocation_Kiviat= self.toplevelKiviatPlotPreprocess.winfo_rooty() - self.offsetWindowY
                    self.toplevelKiviatPlotPreprocess.destroy()
                if mappedScatterPlot:
                    self.plottingspecs_xWindowLocation_Scatter = self.toplevelScatterPlotPreprocess.winfo_rootx() - self.offsetWindowX
                    self.plottingspecs_yWindowLocation_Scatter = self.toplevelScatterPlotPreprocess.winfo_rooty() - self.offsetWindowY
                    self.toplevelScatterPlotPreprocess.destory()
            else:
                return
            

# check if connected to a MySQL server
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return 

# get table and database names
        '''
        self.myTable = self.comboboxTableFunctionsSelectTable.get()
        '''
        self.myTable = self.comboboxDbTableSelect.get().strip()
        self.myDatabase = self.comboboxDbSelect.get().strip()
# shorten names for local use        
        myTable = self.myTable
        myDatabase = self.myDatabase

        stringTableStructure = (
            "SHOW COLUMNS FROM " + myDatabase + "." + myTable
            )
        self.MySQL_Commands(
            1,
            'self.cursorHandleMySQL.execute("' + stringTableStructure + '")'
            )
# execute the command
        start=time.time()
        try:
            self.cursorHandleMySQL.execute(
                stringTableStructure
                )
        except:
            stringTableError = (
                'Table %s cannot be displayed.\n\n' + 
                'The table may have been deleted or moved.'
                ) % myTable
            print stringTableError
            self.MySQL_Commands(
                1,
                stringTableError
                )
            showerror(
                'Error: no table to display',
                stringTableError
                )
            return
        self.tableStructureOriginal = self.cursorHandleMySQL.fetchall()
        finish=time.time()
        delta_t = finish - start
        self.MySQL_Commands(
            0,
            '  (Time: %-7.4f secs)' % delta_t
            )
            
        self.MySQL_Output(
            1,
            'Structure for table "' + myTable + '":'
            )
        self.MySQL_Output(
            0,
            self.tableStructureOriginal
            )
        self.MySQL_Output(
            0,
            ''
            )
            
# look for auto_index field
        flagAutoIndex = False
        for eachItem in self.tableStructureOriginal:
            if 'auto_index' in eachItem:
                flagAutoIndex = True
                break

# assemble string to get field values
        if flagAutoIndex:
            stringTableValues = (
                "SELECT * FROM " + myDatabase + "." + myTable 
                + ' order by auto_index'
                )
        else:
            stringTableValues = (
                "SELECT * FROM " + myDatabase + "." + myTable
                )
                
        self.MySQL_Commands(
            1,
            'self.cursorHandleMySQL.execute("' + stringTableValues + '")'
            )
            
# execute the command
        start=time.time()
        self.cursorHandleMySQL.execute(
            stringTableValues
            )
        self.tableValuesOriginal = self.cursorHandleMySQL.fetchall()
        finish=time.time()
        delta_t = finish - start
        self.MySQL_Commands(
            0,
            '  (Time: %-7.4f secs)' % delta_t
            )
            
        if DEBUG_TABLE_VALUES:
            self.MySQL_Output(
                1,
                'Values for table "' + myTable + '":'
                )
            self.MySQL_Output(
                0,
                self.tableValuesOriginal
                )
            self.MySQL_Output(
                0,
                ''
            )
            
# save checked field names before re-defining self.dictColumnHeadersOriginal
        self.saveCheckedFieldNames()
            
# define dictionary for column headers
        self.dictColumnHeadersOriginal = {}
        icount=0
        for i in range(len(self.tableStructureOriginal)):
            icount+=1
            self.dictColumnHeadersOriginal[self.tableStructureOriginal[i][0]]=icount
        if DEBUG_COLUMN_HEADERS:
            print '\n>> Dictionary of Column Headers'
            print self.dictColumnHeadersOriginal
            self.MySQL_Output(
                1,
                ' Dictionary of column headers:'
                )
            self.MySQL_Output(
                0,
                self.dictColumnHeadersOriginal
                )
         
        self.tableStructure = self.tableStructureOriginal
        self.tableValues = self.tableValuesOriginal
        self.dictColumnHeaders = copy.deepcopy(self.dictColumnHeadersOriginal)

#        self.valuesDisplayRowDecimate(self.tableStructureOriginal, self.tableValuesOriginal)
        self.handlerTableFunctionsShowValues(0,'all')
        
# display new total in main table window for Storage Buffer
        self.countDisplayStorageBuffer.set(
                            'BUFFER: Display (' +
                            str(self.bufferRowStore_NumRows) + 
                            ' rows)'
                            )
# update status line
        maxLinesDisplay = int(self.comboboxMaxLinesToDisplay.get())
        if maxLinesDisplay == 0 or maxLinesDisplay > len(self.tableValues):
            maxLinesDisplay = len(self.tableValues)

        self.handlerStatusLineRefresh(maxLinesDisplay)
            
# refresh fields in main window
        self.refreshFields()
        
# restore checked fields
        self.restoreCheckedFieldNames()   
        
        return
        
        
    def lastButtonPressed(self,lastButtonPressed):
        '''
        Purpose:
            display the last button pressed in the main window even if there's an error displayed; 
            helps users remember what led up to whatever is displayed at present
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'lastButtonPressed')
            
        try:
# first, remove any 'newline' characters
            lastButtonPressed = lastButtonPressed.replace('\n',' ')
# remove any double spaces caused by replace 'newline' characters
            lastButtonPressed = lastButtonPressed.replace('  ',' ')
# remove any leading or trailing white space
            lastButtonPressed = lastButtonPressed.strip()
# place in entry widget
            self.entryLastButtonPressed.configure(state='normal')
            self.varEntryLastButtonPressed.set(lastButtonPressed)
            self.entryLastButtonPressed.configure(state='disabled')
        except:
            pass
            '''
            stringNoDisplay = (
                'Unable to display last button pressed.\n\n' +
                'Reason is unknown.'
                )
            print('\n' + stringNoDisplay)
            self.MySQL_Output(
                0,
                stringNoDisplay
                )
            try:
                showerror(
                    'Error: unable to display last button pressed',
                    stringNoDisplay,
                    parent=self.toplevelTableValues
                    )
            except:
                showerror(
                    'Error: unable to display last button pressed',
                    stringNoDisplay
                    )
            '''
            
        return

        
    def displayMessage(self,event,msg):
        '''
        Purpose:
            display msg in text box; used for mouse-overs on widgets to display
            help messages in text box
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'displayMessage')
            
        if DEBUG_DISPLAYMESSAGE:
            print('\nMessage to display: %s' % (msg))
            
# do not display if freeze button is checked
        try:
            if (
            self.varCheckbuttonFreezeTextMessageToUser.get()
            ):
                if DEBUG_SHOWWHENDISPLAYISFROZEN:
                    print('\n"Freeze display" is set; new messages will not display.')
                return
        except:
# display may not yet be constructed
            return
            
#        self.textMessagesToUser.tag_config('tag',foreground='black',font=self.dataFont)

# enable text box; has to be done for this widget
        self.textMessagesToUser.configure(state='normal')
        
# clear out text box
        self.textMessagesToUser.delete(1.0,END)  
        
        if DEBUG_DISPLAYMESSAGE:
            print('')
            print '++++++++++++ inserting msg into text box +++++++++++++++++'
            print('')
            print('msg = %s' % msg)
            print('')
            
# insert msg 
        self.textMessagesToUser.insert(1.0,msg)
                  
# move cursor to end
#        self.textMessagesToUser.see(END)

# disable text box     
        self.textMessagesToUser.configure(state='disabled') 
        
        return
        
        
    def checkIfEmptyTable(self):
        '''
        Purpose:
            check if a table has been read; if not, 
            return 1 (empty=True)
            else, 0 (empty=False)
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'checkIfEmptyTable')
            
        if len(self.tableValuesOriginal) == 0:
            stringNoTable = (
                'There is nothing to display:\n\n' +
                ' - table "%s" is empty'
                ) % self.myTable
            print('\n' + stringNoTable)
            self.MySQL_Output(
                0,
                stringNoTable
                )
            try:
                showinfo(
                    'Info: Nothing to display',
                    stringNoTable,
                    parent=self.toplevelTableValues
                    )
            except:
                showinfo(
                    'Info: Nothing to display',
                    stringNoTable
                    )
# if table is empty, kill filter window since it won't be needed
            try:
                mapped = self.toplevelSelectDisplayOrderedFields.winfo_exists()
            except:
                mapped = False
            if mapped:
                self.toplevelSelectDisplayOrderedFields.destroy()
                
            return 1
            
        else:
        
            return 0
        
   
    def handlerBeginning(self):
        '''
        Purpose:
            determine range to display beginning of table
            
        Called by:
            handlerTableFunctionsShowValues
            
        Calls:
            valuesDisplayRowDecimate_Range
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerBeginning')
            
# set last button pressed
        self.lastButtonPressed(
            BUTTONLABEL_TOP
            )
            
# check if a table has even been read in 
        emptyTableCheck = self.checkIfEmptyTable()
        if emptyTableCheck:
            return
            
# save checked fields
        self.saveCheckedFieldNames()

# inform user if rows are checked; continuing will not carry checked boxes over
#    to new display
        numRowsSelected = self.varEntryNumberOfRowsSelected.get()
        if numRowsSelected > 0:
            stringRowsSelected = (
                '%s rows are selected in the current window.\n\n' +
                'Checked rows will not carry over to the next display.\n\n' +
                'Continue?'
                ) % numRowsSelected
#            print('\n' + stringRowsSelected)
            self.MySQL_Output(
                0,
                stringRowsSelected
                )
            ans = askyesno(
                'Question',
                stringRowsSelected,
                parent=self.toplevelTableValues
                )
            if not ans:
                return
            else:
                self.varEntryNumberOfRowsSelected.set(0)       
        
# max lines to display
#        try:
        maxLinesDisplay = int(self.comboboxMaxLinesToDisplay.get())
        if maxLinesDisplay == 0 or maxLinesDisplay > len(self.tableValues):
            maxLinesDisplay = len(self.tableValues)

# max lines of table
        maxLinesTable = len(self.tableValues)
        
# bounds check on maxLinesDisplay
        if maxLinesDisplay < 0 or maxLinesDisplay > maxLinesTable:
            stringOutOfBounds = (
                ('maxLinesDisplay is out of bounds. Value must be\n\n' +
                '  0 <= maxLinesDisplay <= %s\n\n' +
                'Current value is %s\n\n' + 
                'Re-enter value and try again.\n') % (maxLinesTable,maxLinesDisplay) 
                )
            print(
                stringOutOfBounds
                )
            self.MySQL_Output(
                0,
                stringOutOfBounds
                )
            showerror(
                'Error: out of bounds',
                '\n' + stringOutOfBounds
                )
            return
            
# minRange
        minRange = 0
        
# maxRange
        if maxLinesTable <= maxLinesDisplay:
            maxRange = maxLinesTable
            if DEBUG_MAXLINESTODISPLAY:
                print ' maxLinesTable, maxLinesDisplay (maxRange=maxLinesTable) =',maxLinesTable, maxLinesDisplay
        else:
            maxRange = maxLinesDisplay
            if DEBUG_MAXLINESTODISPLAY:
                print ' maxRange,maxLinesDisplay (maxRange = maxLinesDisplay)',maxRange, maxLinesDisplay

        self.MySQL_Output(
            0,
            (
            '  maxLinesDisplay = %s\n  maxLinesTable = %s\n  minRange = %s\n  maxRange = %s\n' %
            (maxLinesDisplay, maxLinesTable, minRange, maxRange)
            )
            )

# display table
        self.valuesDisplayRowDecimate_Range(
            self.tableStructure,self.tableValues,minRange,maxRange
            )
            
# update status line
        self.handlerStatusLineRefresh_Range(maxRange - minRange)
        
        
# restore checked field names
        self.restoreCheckedFieldNames()

        return
        
        
    def handlerMiddle(self):
        '''
        Purpose:
            determine range to display middle of table
            
        Called by:
            handlerTableFunctionsShowValues
            
        Calls:
            valuesDisplayRowDecimate_Range
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerMiddle')
            
# set last button pressed
        self.lastButtonPressed(
            BUTTONLABEL_MIDDLE
            )
            
# check if a table has even been read in 
        emptyTableCheck = self.checkIfEmptyTable()
        if emptyTableCheck:
            return
            
# save checked fields
        self.saveCheckedFieldNames()
            
# inform user if rows are checked; continuing will not carry checked boxes over
#    to new display
        numRowsSelected = self.varEntryNumberOfRowsSelected.get()
        if numRowsSelected > 0:
            stringRowsSelected = (
                '%s rows are selected in the current window.\n\n' +
                'Checked rows will not carry over to the next display.\n\n' +
                'Continue?'
                ) % numRowsSelected
#            print('\n' + stringRowsSelected)
            self.MySQL_Output(
                0,
                stringRowsSelected
                )
            ans = askyesno(
                'Question',
                stringRowsSelected,
                parent=self.toplevelTableValues
                )
            if not ans:
                return
            else:
                self.varEntryNumberOfRowsSelected.set(0)
            
# max lines to display
        maxLinesDisplay = int(self.comboboxMaxLinesToDisplay.get())
        if maxLinesDisplay == 0 or maxLinesDisplay > len(self.tableValues):
            maxLinesDisplay = len(self.tableValues)

# max lines of table
        maxLinesTable = len(self.tableValues)
        
# bounds check on maxLinesDisplay
        if maxLinesDisplay < 0 or maxLinesDisplay > maxLinesTable:
            stringOutOfBounds = (
                ('maxLinesDisplay is out of bounds. Value must be\n\n' +
                '  0 <= maxLinesDisplay <= %s\n\n' +
                'Current value is %s\n\n' + 
                'Re-enter value and try again.\n') % (maxLinesTable,maxLinesDisplay) 
                )
            print(
                stringOutOfBounds
                )
            self.MySQL_Output(
                0,
                stringOutOfBounds
                )
            showerror(
                'Error: out of bounds',
                '\n' + stringOutOfBounds
                )
            return        

# midPoint
        midPoint = int((maxLinesTable+1)/2)
        
# minRange
        minRange = midPoint - int((maxLinesDisplay+1)/2)
        
# maxRange
        maxRange = midPoint + int(maxLinesDisplay/2)
        
# minRange check
        if minRange < 0:
            minRange = 0
            
# maxRange
        if maxLinesTable < maxRange:
            maxRange = maxLinesTable 
            
# print
        self.MySQL_Output(
            0,
            (
            '  maxLinesDisplay = %s\n  maxLinesTable = %s\n  midPoint = %s\n  minRange = %s\n  maxRange = %s\n' %
            (maxLinesDisplay, maxLinesTable, midPoint, minRange, maxRange)
            )
            )
            
# display table
        self.valuesDisplayRowDecimate_Range(self.tableStructure, self.tableValues, minRange,maxRange)

# update status line
        self.handlerStatusLineRefresh_Range(maxRange - minRange)
        
# restore checked fields
        self.restoreCheckedFieldNames() 

        return
        
    
    def handlerEnd(self):
        '''
        Purpose:
            determine range to display end of table
            
        Called by:
            handlerTableFunctionsShowValues
            
        Calls:
            valuesDisplayRowDecimate_Range
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerEnd') 
            
# set last button pressed
        self.lastButtonPressed(
            BUTTONLABEL_BOTTOM
            )

# check if a table has even been read in 
        emptyTableCheck = self.checkIfEmptyTable()
        if emptyTableCheck:
            return   

# save checked fields
        self.saveCheckedFieldNames()             

# inform user if rows are checked; continuing will not carry checked boxes over
#    to new display
        numRowsSelected = self.varEntryNumberOfRowsSelected.get()
        if numRowsSelected > 0:
            stringRowsSelected = (
                '%s rows are selected in the current window.\n\n' +
                'Checked rows will not carry over to the next display.\n\n' +
                'Continue?'
                ) % numRowsSelected
#            print('\n' + stringRowsSelected)
            self.MySQL_Output(
                0,
                stringRowsSelected
                )
            ans = askyesno(
                'Question',
                stringRowsSelected,
                parent=self.toplevelTableValues
                )
            if not ans:
                return
            else:
                self.varEntryNumberOfRowsSelected.set(0) 

# max lines of table
        maxLinesTable = len(self.tableValues)
        
# max lines to display
        maxLinesDisplay = int(self.comboboxMaxLinesToDisplay.get())
        if maxLinesDisplay == 0 or maxLinesDisplay > len(self.tableValues):
            maxLinesDisplay = len(self.tableValues)
        
# bounds check on maxLinesDisplay
        if maxLinesDisplay < 0 or maxLinesDisplay > maxLinesTable:
            stringOutOfBounds = (
                ('maxLinesDisplay is out of bounds. Value must be\n\n' +
                '  0 <= maxLinesDisplay <= %s\n\n' +
                'Current value is %s\n\n' + 
                'Re-enter value and try again.\n') % (maxLinesTable,maxLinesDisplay) 
                )
            print(
                stringOutOfBounds
                )
            self.MySQL_Output(
                0,
                stringOutOfBounds
                )
            showerror(
                'Error: out of bounds',
                '\n' + stringOutOfBounds
                )
            return        
        
# minRange
        minRange = maxLinesTable - maxLinesDisplay
        
# maxRange
        maxRange = maxLinesTable
        
# minRange check
        if minRange < 0:
            minRange = 0 
            
# print
        self.MySQL_Output(
            0,
            (
            '  maxLinesDisplay = %s\n  maxLinesTable = %s\n  minRange = %s\n  maxRange = %s\n' %
            (maxLinesDisplay, maxLinesTable, minRange, maxRange)
            )
            )
            
# display table
        self.valuesDisplayRowDecimate_Range(self.tableStructure, self.tableValues, minRange,maxRange)

# update status line
        self.handlerStatusLineRefresh_Range(maxRange - minRange)  
        
# restore checked fields
        self.restoreCheckedFieldNames()

        return

        
    def handlerRange(self):
        '''
        Purpose:
            determine range to display arbitrary section of table
            
        Called by:
            handlerTableFunctionsShowValues
            
        Calls:
            valuesDisplayRowDecimate_Range
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerRange')
            
# set last button pressed
        self.lastButtonPressed(
            BUTTONLABEL_RANGE
            )

# check if a table has even been read in 
        emptyTableCheck = self.checkIfEmptyTable()
        if emptyTableCheck:
            return             

# inform user if rows are checked; continuing will not carry checked boxes over
#    to new display
        numRowsSelected = self.varEntryNumberOfRowsSelected.get()
        if numRowsSelected > 0:
            stringRowsSelected = (
                '%s rows are selected in the current window.\n\n' +
                'Checked rows will not carry over to the next display.\n\n' +
                'Continue?'
                ) % numRowsSelected
#            print('\n' + stringRowsSelected)
            self.MySQL_Output(
                0,
                stringRowsSelected
                )
            ans = askyesno(
                'Question',
                stringRowsSelected,
                parent=self.toplevelTableValues
                )
            if not ans:
                return
            else:
                self.varEntryNumberOfRowsSelected.set(0)            

# max lines of table
        maxLinesTable = len(self.tableValues)           

# toplevel window to get values
# destroy any old toplevel frames
        try:
            self.toplevelRangeEntry.destroy()
            self.MySQL_Output(
                1,
                'Previous toplevel widget removed from screen.'
                )
        except: 
            self.MySQL_Output(
                1,
                'No previous toplevel widget to remove from screen.'
                )
            
# open Toplevel frame for entering database name
        self.toplevelRangeEntry = Toplevel(
#            self.frameParent,
            bg='lightgreen',
            )
        self.toplevelRangeEntry.title(
#            'Display range'
            'Server: ' + self.comboServerMySQL.get() + '     ' +
            'Database: ' + self.varTableFunctionsSelectDatabase.get() + '     ' +
            'Table: ' + self.varEntryTableFunctionsSelectTable.get().strip()
            )
        self.toplevelRangeEntry.transient(self.toplevelTableValues)
# place the top window
        x_Windows = self.rangeEntry_xWindowLocation
        y_Windows = self.rangeEntry_yWindowLocation
        self.toplevelRangeEntry.geometry(
            '+%d+%d' % (x_Windows, y_Windows)
            )
# frames
        frame_00 = Frame(
            self.toplevelRangeEntry,
            bg='lightgreen'
            )
        frame_00.grid(
            row=0,
            column=0,
            padx=2,
            pady=2,
            sticky=N+S+E+W,
            )
# ----------
# widgets
# ... title
        labelTitle = Label(
            frame_00,
            text='Display Range of Line Numbers',
            bg='lightgreen',
            font=self.titleFont,
            justify=CENTER,
            )
        labelTitle.grid(
            row=0,
            column=0,
            columnspan=2,
            padx=0,
            pady=2,
            )
        labelTitleSub = Label(
            frame_00,
            text='(ignores "Max lines to display" value)',
            bg='lightgreen',
            justify=CENTER,
            )
        labelTitleSub.grid( 
            row=1,
            column=0,
            columnspan=2,
            padx=0,
            pady=2,
            )
        labelMinRange = Label(
            frame_00,
            text='Min line number:',
            bg='lightgreen',
            justify=RIGHT,
            )
        labelMinRange.grid(
            row=2,
            column=0,
            padx=2,
            pady=2,
            sticky=E,
            )
        self.entryMinRange = Pmw.EntryField(
            frame_00,
            validate={
                'validator':'integer',
                'min':1,
                'max':len(self.tableValues)-1,
                'minstrict':1,
                'maxstrict':0},
            )
        self.entryMinRange.grid(
            row=2,
            column=1,
            padx=0,
            pady=2,
            sticky=W,
            )
        self.entryMinRange.configure(entry_width=8)
        
        labelMaxRange = Label(
            frame_00,
            text='Max line number:',
            bg='lightgreen',
            justify=RIGHT,
            )
        labelMaxRange.grid(
            row=3,
            column=0,
            padx=2,
            pady=2,
            sticky=E,
            )
        self.entryMaxRange = Pmw.EntryField(
            frame_00,
            validate={
                'validator':'integer',
                'min':2,
                'max':len(self.tableValues),
                'minstrict':0,
                'maxstrict':0},
            )
        self.entryMaxRange.grid(
            row=3,
            column=1,
            padx=0,
            pady=2,
            sticky=W,
            )
        self.entryMaxRange.configure(entry_width=8)

# ... display button            
        buttonDisplayRange = Button(
            frame_00,
            text='Display',
            relief=RAISED,
            borderwidth=5,
            command=self.handlerDisplayRange,
            )
        buttonDisplayRange.grid(
            row=4,
            column=0,
            padx=2,
            pady=5,
            )
# ... cancel button
        buttonCancelRange = Button(
            frame_00,
            text='Cancel',
            relief=RAISED,
            borderwidth=5,
            command=self.handlerToplevelRangeEntryDestroy,
            )
        buttonCancelRange.grid(
            row=4,
            column=1,
            padx=2,
            pady=5,
            )

        return
        
        
    def handlerToplevelRangeEntryDestroy(self):
        '''
        Purpose:
            destroy 'Range Entry' window
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerToplevelRangeEntryDestroy')

# save location for next time window is opened
        self.rangeEntry_xWindowLocation = \
            self.toplevelRangeEntry.winfo_rootx() - self.offsetWindowX
        self.rangeEntry_yWindowLocation = \
            self.toplevelRangeEntry.winfo_rooty() - self.offsetWindowY

# destroy current toplevel            
        self.toplevelRangeEntry.destroy()
        
        return
        
            
    def handlerDisplayRange(self):
        '''
        Purpose:
            display user-specified range of lines for
                current table
                
        Called by:
            handlerRange
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerDisplayRange')
            
# minRange
        errFlag=0
        stringMissingValue = ''
        try:
            minRange = int(self.entryMinRange.get())
        except:
            errFlag = 1
            stringMissingValue += 'Min line number is missing or invalid.\n\n'
# maxRange
        try:
            maxRange = int(self.entryMaxRange.get())
        except:
            errFlag=1
            stringMissingValue += 'Max line number is missing or invalid.\n\n'
# check if either value is missing
        if errFlag == 1:
            stringMissingValue += 'Enter appropriate line numbers and try again.'
            print stringMissingValue
            self.MySQL_Output(
                0,
                stringMissingValue
                )
            showerror(
                'Error: missing value',
                '\n' + stringMissingValue + '\n\n'
                )
            return
# check if maxRange > minRange
        if maxRange < minRange:
            stringInvalidRange = (
                (
                'Max line number is less than Min line number' + '\n\n' +
                '  Max line number = %s' + '\n' +
                '  Min line number = %s' + '\n\n' +
                'Enter appropriate line numbers and try again.' + '\n') 
                % (maxRange,minRange)
                )
            print(
                stringInvalidRange
                )
            self.MySQL_Output(
                0,
                stringInvalidRange
                )
            showerror(
                'Error: invalid line numbers',
                '\n' + stringInvalidRange
                )
            return
# check if minRange or maxRange is out of bounds
        if ( (minRange < 1 or minRange > len(self.tableValues)) or 
            (maxRange < 1 or maxRange > len(self.tableValues)) ):
            errorString = ''
            if (minRange < 1 or minRange > len(self.tableValues)):
                errorString+='Minimum line number is out of range.\n\n'
            if (maxRange < 1 or maxRange > len(self.tableValues)):
                errorString+='Maximum line number is out of range.\n\n'
            print errorString
            self.MySQL_Output(
                1,
                errorString
                )
            showerror(
                'Error: out of range',
                '\n' + errorString
                )
            return
# print
        self.MySQL_Output(
            0,
            (
            '  minRange = %s\n  maxRange = %s\n' %
            (minRange, maxRange)
            )
            )  

# save checked fields
        self.saveCheckedFieldNames()   
        
# display table
        self.valuesDisplayRowDecimate_Range(self.tableStructure,self.tableValues,minRange-1,maxRange)

# update status line
        self.handlerStatusLineRefresh_Range(maxRange - minRange + 1)
        
# restore checked fields
        self.restoreCheckedFieldNames()   

        return
        
    
    def valuesDisplayRowDecimate_Range(self,tableStructure,tableValues,minRange,maxRange):
        '''
        Purpose:
            called when status line buttons 'Beginning', 'Middle', 
            'End', or 'Range' is pressed.
            
            Displays table using 'max_lines' to limit rows.
            
        Called by:
        
        
        Calls:
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'valuesDisplayRowDecimate_Range')
            
# check if connected to a MySQL server
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return
            
        try:
            lenTable = len(tableValues[0])
            emptyTable = False
        except:
            emptyTable = True
            
        if emptyTable:
# if empty table, at least show headers for columns, then return
            self.showEmptyTableWithColumnHeaders(
                tableStructure,
                width_Field,
                fontsize_Field,
                height_Field,
                )
            self.MySQL_Output(
                1,
                'There is nothing to display!'
                )
            showinfo(
                'Info: nothing to display',
                'There is nothing to display!'
                )
            return
        
# if empty table, at least show headers for columns, then return
        if emptyTable:
            self.showEmptyTableWithColumnHeaders(
                tableStructure,
                width_Field,
                fontsize_Field,
                height_Field,
                )
            if DEBUG_TABLE_VALUES:
                stringEmptyTable = 'Table is empty.'
                print('\n' + stringEmptyTable)
                showinfo(
                    'Info: empty table',
                    stringEmptyTable,
                    parent=self.toplevelTableValues
                    )
            return

        if DEBUG_TABLE_VALUES:
# print contents of first row, number of columns, and table structure
            print('\ntableValues[0] = ')
            print(tableValues[0])
            print('\nlen(tableValues[0]) = %s' % len(tableValues[0]))
            print('\ntableStructure = ')
            print(tableStructure)
            
# set index in case we wish to edit select rows in display
        self.indexEditSelectedRows_Start = minRange
        
# display headers, row numbers but not row checkboxes, table values
        self.displayHeadersRowsValues(
            tableValues, tableStructure, minRange, maxRange, False
            )
        
        '''
        
# since they will be replotted with the new format,
# ... save which X-Select field has been checked
        self.saveCheckedFieldNames()            
            
# define emtpy variable
        self.varYSelect = []
        
# grid table windows so they will be correct size for table
        self.gridTableWindows()
        
# ... table headers in 'j' columns
        for j in range(len(tableValues[0])):
            self.labelHeaderFields = Label(
                self.frame_11_canvas,
                text=tableStructure[j][0],
                width=width_Field,
                font=fontsize_Field,
                bg='white',
                fg='black',
                anchor=W,
#                borderwidth=2,
#                relief=RIDGE,
                )
            self.labelHeaderFields.grid(
                row=0,
                column=j,
                padx=2,
                pady=1,
                )           
# header checkbuttons for y select
# ... create an instance of IntVar for each Checkbutton
            varY = IntVar()
            checkbuttonYSelect = Checkbutton(
                self.frame_11_canvas,
                bg='tan',
                justify=CENTER,
                variable=varY,
                command=self.handlerDisplayNumberOfYValuesSelected,
                )
            checkbuttonYSelect.grid(
                row=1,
                column=j,
                padx=2,
                pady=0,
                )
            self.varYSelect.append(varY)
            
# header radiobuttons for x-select                           
            radiobuttonXSelect = Radiobutton(
                self.frame_11_canvas,
                bg='tan',
                justify=CENTER,
                value=j+1,
                variable=self.varXSelect,
                command=self.handlerDisplayXValueSelected,
                )
            radiobuttonXSelect.grid(
                row=2,
                column=j,
                padx=2,
                pady=0,
                )
                
            labelColumn = Label(
                self.frame_11_canvas,
                text=str(j+1),
                bg='tan',
                justify=CENTER,
                )
            labelColumn.grid(
                row=3,
                column=j,
                padx=2,
                pady=1,
                )
                                      
# define empty list
        stringTableStructure=[]

# fill table and columns
        for i in range(minRange,maxRange):
            tableRow=i
            tableColumn=0
            if DEBUG_PRINT_MISC:
                print '%s. %s' % (i,tableValues[i])
            for j in range(len(tableValues[0])):
                tableColumn+=1
# ... field 0                               
                labelFieldValues = Label(
                    self.frame_22_canvas,
                    text=tableValues[i][j],
                    background='white',
                    foreground='black',
                    width=width_Field,
                    height=height_Field,
                    font=fontsize_Field,
                    anchor=NW,
                    justify=LEFT,
#                    relief=RIDGE,
#                    borderwidth=5,
                    )
                labelFieldValues.grid(
                    row=tableRow,
                    column=tableColumn,
                    padx=2,
                    pady=1,
                    )
                    
# setup 'Select row' checkbuttons in main window:
        self.varSelectAnyRow = []
        tableColumn=0
        for i in range(minRange,maxRange):
            tableRow=i
            var = IntVar()
# checkbuttons for selecting rows
            checkbuttonSelectAnyRow = Checkbutton(
                self.frame_21_canvas,
                bg='tan',
                justify=LEFT,
                variable=var,
                font=self.buttonFontSmallest,
                borderwidth=0,
                height=height_Field
                )
# do not grid checkbuttons when displaying ranges; 
#   row numbers will not be correct for plotting or anything else
# BUT leave logic in case needed later

            checkbuttonSelectAnyRow.grid(
                row=tableRow,
                column=tableColumn,
                padx=0,
                pady=1,
                sticky=E,
                )
# use bindtags to switch binding order so that checkbuttons will be checked,
#   before being examined to see how many rows are checked;
#   normally, the first two parameters are switched below for the default value
            checkbuttonSelectAnyRow.bindtags((
                'Checkbutton',                             # class binding
                (str(checkbuttonSelectAnyRow)),  # instance binding
                'self.frame_21_canvas',
                'all'
                ))
            checkbuttonSelectAnyRow.bind(
                "<ButtonRelease-1>",
                self.displayNumberOfRowsSelected_Table
                )
            
# variable to check for on-off states
#  to check value, use:
#   for var in self.varSelectAnyRow:
#       print var.get()  # will be either 1 or 0
#            self.varSelectAnyRow.append(var)
            
# line numbers (no width_Field value here!)
            labelSelectAnyRow = Label(
                self.frame_21_canvas,
                text='%-4s' % (i+1),
                bg='tan',
                justify=RIGHT,
                height=height_Field,
                font=fontsize_Field,
#                relief=RIDGE,
                )
            labelSelectAnyRow.grid(
                row=tableRow,
                column=tableColumn+1,
                padx=0,
                pady=1,
                sticky=W,
                )
        '''
        '''
# restore checked values
        self.restoreCheckedFieldNames()
            
# reposition widgets to be gridded correctly at top of frame instead of defaulting to middle of frame
# ... frame_11
        self.frame_11_canvas.grid_rowconfigure(1,weight=1)
        self.canvas_11.create_window(
            0,
            0,
            anchor=NW,
            window=self.frame_11_canvas
            )
        self.frame_11_canvas.update_idletasks()
        self.canvas_11.config(scrollregion=self.canvas_11.bbox('all'))
# ... frame_21                        
        self.frame_21_canvas.grid_rowconfigure(1,weight=1)
        self.canvas_21.create_window(
            0,
            0,
            anchor=NW,
            window=self.frame_21_canvas
            )
        self.frame_21_canvas.update_idletasks()
        self.canvas_21.config(scrollregion=self.canvas_21.bbox('all'))
# ... frame_22                       
        self.frame_22_canvas.grid_rowconfigure(1,weight=1)
        self.canvas_22.create_window(
            0,
            0,
            anchor=NW, 
            window=self.frame_22_canvas
            )
        self.frame_22_canvas.update_idletasks()
        self.canvas_22.config(scrollregion=self.canvas_22.bbox('all'))
        '''

        return
        
        
    def displayHeadersRowsValues(
        self, tableValues, tableStructure, minRange, maxRange, displayRowCheckBoxes
        ):
        '''
        Purpose:
            display table header checkboxes and radiobutton, row checkboxes,
            and table values
            
        Called by:
            - self.valuesDisplayRowDecimate
            - self.valuesDisplayRowDecimate_Range
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'displayHeadersRowsValues')
            
# constants
        width_Field = self.comboboxWidthField.get()
        height_Field = self.comboboxHeightField.get()
        fontsize_Field = tkFont.Font(
            family='Helvetica',
            size=self.comboboxFontField.get(),
#            weight='bold'
            )
        
# since they will be replotted with the new format,
# ... save which X-Select field has been checked
# DWB: DELETE THIS
#        self.saveCheckedFieldNames()            
            
# define empty variable
        self.varYSelect = []
        
# grid table windows so they will be correct size for table
        self.gridTableWindows()
        
# ... table headers in 'j' columns
        for j in range(len(tableValues[0])):
            self.labelHeaderFields = Label(
                self.frame_11_canvas,
                text=tableStructure[j][0],
                width=width_Field,
                font=fontsize_Field,
                bg='white',
                fg='black',
                anchor=W,
#                borderwidth=2,
#                relief=RIDGE,
                )
            self.labelHeaderFields.grid(
                row=0,
                column=j,
                padx=2,
                pady=1,
                )           
# header checkbuttons for y select
# ... create an instance of IntVar for each Checkbutton
            varY = IntVar()
            checkbuttonYSelect = Checkbutton(
                self.frame_11_canvas,
                bg='tan',
                justify=CENTER,
                variable=varY,
                command=self.handlerDisplayNumberOfYValuesSelected,
                )
            checkbuttonYSelect.grid(
                row=1,
                column=j,
                padx=2,
                pady=0,
                )
# assign varY to self.varYSelect
            self.varYSelect.append(varY)
            
# header radiobuttons for x-select                           
            radiobuttonXSelect = Radiobutton(
                self.frame_11_canvas,
                bg='tan',
                justify=CENTER,
                value=j+1,
                variable=self.varXSelect,
                command=self.handlerDisplayXValueSelected,
                )
            radiobuttonXSelect.grid(
                row=2,
                column=j,
                padx=2,
                pady=0,
                )
                
            labelColumn = Label(
                self.frame_11_canvas,
                text=str(j+1),
                bg='tan',
                justify=CENTER,
                )
            labelColumn.grid(
                row=3,
                column=j,
                padx=2,
                pady=1,
                )
                                      
# define empty list
        stringTableStructure=[]

# fill table and columns
        for i in range(minRange,maxRange):
            tableRow=i
            tableColumn=0
            if DEBUG_PRINT_MISC:
                print '%s. %s' % (i,tableValues[i])
            for j in range(len(tableValues[0])):
                tableColumn+=1
# ... field 0      
                labelFieldValues = Label(
                    self.frame_22_canvas,
                    text=str(tableValues[i][j]),
                    background='white',
                    foreground='black',
                    width=width_Field,
                    height=height_Field,
                    font=fontsize_Field,
                    anchor=NW,
                    justify=LEFT,
                    )
                labelFieldValues.grid(
                    row=tableRow,
                    column=tableColumn,
                    padx=2,
                    pady=1,
                    )
                    
# setup 'Select row' checkbuttons in main window:
        self.varSelectAnyRow = []
        tableColumn=0

# do NOT graph row checkboxes if "Top", "Middle", "Bottom", or "Range ..." is being requested        
        for i in range(minRange,maxRange):
            tableRow=i
            if displayRowCheckBoxes:
                var = IntVar()
# checkbuttons for selecting rows
                checkbuttonSelectAnyRow = Checkbutton(
                    self.frame_21_canvas,
                    bg='tan',
                    justify=LEFT,
                    variable=var,
                    font=self.buttonFontSmallest,
                    borderwidth=0,
                    height=height_Field
                    )
# do not grid checkbuttons when displaying ranges; 
#   row numbers will not be correct for plotting or anything else
# BUT leave logic in case needed later
                checkbuttonSelectAnyRow.grid(
                    row=tableRow,
                    column=tableColumn,
                    padx=0,
                    pady=1,
                    sticky=E,
                    )
# use bindtags to switch binding order so that checkbuttons will be checked,
#   before being examined to see how many rows are checked;
#   normally, the first two parameters are switched below for the default value
                checkbuttonSelectAnyRow.bindtags((
                    'Checkbutton',                             # class binding
                    (str(checkbuttonSelectAnyRow)),  # instance binding
                    'self.frame_21_canvas',
                    'all'
                    ))
                checkbuttonSelectAnyRow.bind(
                    "<ButtonRelease-1>",
                    self.displayNumberOfRowsSelected_Table
                    )   
# variable to check for on-off states
#  to check value, use:
#   for var in self.varSelectAnyRow:
#       print var.get()  # will be either 1 or 0
                self.varSelectAnyRow.append(var)
            
# line numbers (no width_Field value here!)
            labelSelectAnyRow = Label(
                self.frame_21_canvas,
                text=(
                    '%-4s' % (i+1)
                    ),
                bg='tan',
                justify=RIGHT,
                height=height_Field,
                font=fontsize_Field,
#                relief=RIDGE,
                )
            labelSelectAnyRow.grid(
                row=tableRow,
                column=tableColumn+1,
                padx=0,
                pady=1,
                sticky=W,
                )

# restore checked values
        '''
        self.restoreCheckedFieldNames()
        '''
            
# reposition widgets to be gridded correctly at top of frame instead of defaulting to middle of frame
# ... frame_11
        self.frame_11_canvas.grid_rowconfigure(1,weight=1)
        self.canvas_11.create_window(
            0,
            0,
            anchor=NW,
            window=self.frame_11_canvas
            )
        self.frame_11_canvas.update_idletasks()
        self.canvas_11.config(scrollregion=self.canvas_11.bbox('all'))
# ... frame_21                        
        self.frame_21_canvas.grid_rowconfigure(1,weight=1)
        self.canvas_21.create_window(
            0,
            0,
            anchor=NW,
            window=self.frame_21_canvas
            )
        self.frame_21_canvas.update_idletasks()
        self.canvas_21.config(scrollregion=self.canvas_21.bbox('all'))
# ... frame_22                       
        self.frame_22_canvas.grid_rowconfigure(1,weight=1)
        self.canvas_22.create_window(
            0,
            0,
            anchor=NW, 
            window=self.frame_22_canvas
            )
        self.frame_22_canvas.update_idletasks()
        self.canvas_22.config(scrollregion=self.canvas_22.bbox('all'))
        
        return
        
        
    def handlerDisplayNumberOfYValuesSelected(self):
        '''
        Purpose:
            display number of y values selected in Table Values window
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerDisplayNumberOfYValuesSelected')
        
        icount = 0
        for var in self.varYSelect:
            if var.get():
                icount += 1
 
# set field in Table Values window 
        self.varEntryNumberOfYValuesSelected.set(icount)

# set field to zero in Quik Select window if mapped
        try: 
            mapped = self.toplevelQuikSelectXY.winfo_exists()
        except:
            mapped = False
            
        if mapped:
# set field to zero in Table Values window
#            self.varEntryQuikSelectNumberOfYValuesSelected.set(100)
# sync all checkboxes in Quik Select window with those in Table Values window
            for i in range(len(self.varCheckbuttonsQuikSelectY)):
                self.varCheckbuttonsQuikSelectY[i].set(
                    self.varYSelect[i].get()
                    )
# display number of values
            self.varEntryQuikSelectNumberOfYValuesSelected.set(icount)
            
        return
        
        
    def handlerDisplayXValueSelected(self):
        '''
        Purpose:
            display x value selection
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerDisplayXValueSelected')

# define values for xIndex, etc.
        xIndex = self.varXSelect.get()
        foundIt = False
        for key,value in self.dictColumnHeaders.iteritems():
            if value == xIndex:
                foundIt = True
                xHeader = key
                break
                
        if foundIt:
# display X value
            self.varEntryXValueSelected.set(
                '%s. %s' % (xIndex, xHeader)
                )
        else:
            self.varEntryXValueSelected.set('')            
                
        try:
            mappedQuikSelectWindow = self.toplevelQuikSelectXY.winfo_exists()
        except:
            mappedQuikSelectWindow = False

# set value in Quik Select window if mapped            
        if mappedQuikSelectWindow:
# ... set entry field
            self.varEntryQuikSelectXValueSelected.set(
                self.varEntryXValueSelected.get()
                )
# ... set X value
            self.varRadiobuttonsQuikSelectX.set(
                self.varXSelect.get()
                )
            
        return
        
        
    def handlerDisplayXValueSelected_Clear(self):
        '''
        Purpose:
            clear the display for the x value selection
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerDisplayXValueSelected_Clear')
            
# blank the X value display
        self.varEntryXValueSelected.set('')

        try:
            mappedQuikSelectWindow = self.toplevelQuikSelectXY.winfo_exists()
        except:
            mappedQuikSelectWindow = False

# set value in Quik Select window if mapped            
        if mappedQuikSelectWindow:
            self.varEntryQuikSelectXValueSelected.set('')
        
        return


    def handlerStatusLineRefresh_Range(self,numRows):
        '''
        Purpose: update status line; compatible with table
            display when using ranges for rows shown
            
        Called by:
            handlerBeginning
            handlerMiddle
            handlerEnd
            handlerRange
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerStatusLineRefresh_Range')
            
# check if a table has even been read in
        if len(self.tableValuesOriginal) == 0:
            return
            
# check if connected to a MySQL server
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return 

# calculate status line variables to display
#        statusLine_linesTotal = len(self.tableValuesOriginal)
        statusLine_linesTotal = self.totalRowsInTable()
        statusLine_rowsDisplayed = numRows
        statusLine_columnsTotal = len(self.tableValuesOriginal[0])
        statusLine_columnsDisplayed = len(self.tableValues[0])
# refresh variables
# ... total lines
#        self.entryTotalLines.configure(state='normal')
        self.varEntryTotalLines.set(statusLine_linesTotal)
#        self.entryTotalLines.configure(state='disabled')
# ... loaded rows
        self.varEntryLoadedRows.set(len(self.tableValues))
# ... current rows
#        self.entryDisplayedRows.configure(state='normal')
        self.varEntryDisplayedRows.set(numRows)
#        self.entryDisplayedRows.configure(state='disabled')
# ... total columns
#        self.entryTotalCols.configure(state='normal')
        self.varEntryTotalCols.set(statusLine_columnsTotal)
#        self.entryTotalCols.configure(state='disabled')
# ... current columns
#        self.entryDisplayedColumns.configure(state='normal')
        self.varEntryDisplayedColumns.set(statusLine_columnsDisplayed)
#        self.entryDisplayedColumns.configure(state='disabled')

        return


    def valuesDisplayRowDecimate(self,tableStructure,tableValues):
        '''
        general method to display either
            1. all table values
            2. table values with row decimation
            
        no widgets are regenerated in this method.
        
        Input:
            self.tableStructureTemp -> tableStructure
            self.tableValuesTemp -> tableValues
            
        Output:
            display part or all of database in window
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'valuesDisplayRowDecimate')
            
# check if connected to a MySQL server
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return  
            
        emptyTable = False

# check if table has any values in it
        try:
            lenTable = len(tableValues[0]) # number of columns
            if DEBUG_TABLE_VALUES:
                print('lenTable = %s' % lenTable)
                print('\ntableValues[0] = ')
                print(tableValues[0])
        except:
            try:
# return to original table values
                self.tableStructure = self.tableStructureOriginal
                self.tableValues = self.tableValuesOriginal
                self.dictColumnHeaders = copy.deepcopy(self.dictColumnHeadersOriginalcopy.deepcopy)
 
                self.resetVarXYSelect()
                
                lenTableOriginal = len(self.tableValuesOriginal[0])
                if DEBUG_TABLE_VALUES:
                    print('\nOriginal table values are now being used.\n')
            except:
# table is empty
                emptyTable = True
                '''
                self.MySQL_Output(
                    1,
                    'There is nothing to display:\n\n' +
                    ' - table "' + self.myTable + '" is empty\n'
                    )
                showinfo(
                    'Info: Nothing to display',
                    '\nThere is nothing to display:\n\n' +
                    ' - table "' + self.myTable + '" is empty' + '\n\n' 
                    )
                return
                '''
            else:
# sort does not match table data              
                self.MySQL_Output(
                    1,
                    'There is nothing to display:\n\n' +
                    ' - 2. sort options do not match any table data\n\n'
                    )
                showinfo(
                    'Info: Nothing to display',
                    '\nThere is nothing to display:\n\n' +
                    ' - 2. sort options do not match any table data\n\n'
                    )
                return

                
        self.headers = [] 
# X-Select radiobutton control variable
        self.varXSelect = IntVar()
        
# store instances of IntVar for Y-Select  
        try:
            temp_varYSelect = self.varYSelect
        except:
            pass
            
# constants
        width_Field = self.comboboxWidthField.get()
        height_Field = self.comboboxHeightField.get()
        fontsize_Field = tkFont.Font(
            family='Helvetica',
            size=self.comboboxFontField.get(),
#            weight='bold'
            )
        
# if empty table, at least show headers for columns, then return
        if emptyTable:
            self.clear_grid(self.frame_21_canvas)
            self.clear_grid(self.frame_22_canvas)
            self.showEmptyTableWithColumnHeaders(
                tableStructure,
                width_Field,
                fontsize_Field,
                height_Field,
                )
            if DEBUG_TABLE_VALUES:
                stringEmptyTable = 'Table is empty.'
                print('\n' + stringEmptyTable)
                showinfo(
                    'Info: empty table',
                    stringEmptyTable,
                    parent=self.toplevelTableValues
                    )
            return

        if DEBUG_TABLE_VALUES:
# print contents of first row, number of columns, and table structure
            print('\ntableValues[0] = ')
            print(tableValues[0])
            print('\nlen(tableValues[0]) = %s' % len(tableValues[0]))
            print('\ntableStructure = ')
            print(tableStructure)
            
            
# if 'Max lines to display' has a valid value in the entry field, use that to limit display;
#    otherwise, show all columns
        maxLinesDisplay = int(self.comboboxMaxLinesToDisplay.get())
        if maxLinesDisplay == 0 or maxLinesDisplay > len(self.tableValues):
            maxLinesDisplay = len(self.tableValues)

# set index in case we wish to edit select rows in display
        self.indexEditSelectedRows_Start = 0
        
# display headers, row numbers, row checkboxes, table values
        self.displayHeadersRowsValues(
            tableValues, tableStructure, 0, maxLinesDisplay, True
            )

        if self.addPrimaryKey:
# check for auto-increment primary field, but only once per table
            self.checkAutoIncrementPrimaryKeyField()
# if there was initially no PRIMARY KEY field, there is one now if the user owns the table, so refresh table
            try:
                if not self.checkPrimaryKey:
#                    self.buttonTableValuesShowAll.invoke()
                    self.handlerDisplayLimitedRows()    # PEEK handler
                    
# update filter window
                try:
                    mapped = self.toplevelSelectDisplayOrderedFields.winfo_exists()
                except:
                    mapped = False
            
                if mapped:
                    self.handlerSelectDisplayOrderedFields_Update()
                    
            except:
# user does not own the table, so pass; no need to re-display the table
                pass
        
        self.addPrimaryKey = 0
            
        return
        
        
    def valuesDisplayNewFieldWidthHeightFont(self,tableStructure,tableValues):
        '''
        general method to display either
            1. all table values
            2. table values with row decimation
        with new field width, height, or font
            
        no widgets are regenerated in this method.
        
        Input:
            self.tableStructureTemp -> tableStructure
            self.tableValuesTemp -> tableValues
            
        Output:
            display part or all of database in window, with values displayed
            under new format specified by field width, height, or font
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'valuesDisplayNewFieldWidthHeightFont')
            
# check if connected to a MySQL server
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return  
        
# constants
        width_Field = self.comboboxWidthField.get()
        height_Field = self.comboboxHeightField.get()
        fontsize_Field = tkFont.Font(
            family='Helvetica',
            size=self.comboboxFontField.get(),
#            weight='bold'
            )
            
        emptyTable = False

# check if table has any values in it
        try:
            lenTable = len(tableValues[0])
            if DEBUG_TABLE_VALUES:
                print('lenTable = %s' % lenTable)
                print('\ntableValues[0] = ')
                print(tableValues[0])
        except:
            try:
# return to original table values
                self.tableStructure = self.tableStructureOriginal
                self.tableValues = self.tableValuesOriginal
                self.dictColumnHeaders = copy.deepcopy(self.dictColumnHeadersOriginal)
# 
                lenTableOriginal = len(self.tableValuesOriginal[0])
                if DEBUG_TABLE_VALUES:
                    print('\nOriginal table values are now being used.\n')
            except:
# table is empty
                emptyTable = True           
            else:
# sort does not match table data              
                self.MySQL_Output(
                    1,
                    'There is nothing to display:\n\n' +
                    ' - 2. sort options do not match any table data\n\n'
                    )
                showinfo(
                    'Info: Nothing to display',
                    '\nThere is nothing to display:\n\n' +
                    ' - 2. sort options do not match any table data\n\n'
                    )
                return
            
# since they will be replotted with the new format,
# ... save which X-Select field has been checked
# ...   (saveXSelect = column number of X-Select)
        saveXSelect = self.varXSelect.get()
# ... save which Y-Select fields have been checked
        j_index = 0
        index_Y = []
        for var in self.varYSelect:
            if var.get():
                index_Y.append(j_index)
            j_index += 1
            
# save X-Select and Y-Select field names that have been checked
#   (uses field names, not indices, to make it easier to track which fields
#    have been checked, so they can be re-checked after display is refreshed)
        self.saveCheckedFieldNames()

# get auto_index values, the last value in each row; used to display the
#   same order of rows as displayed in table; useful if table has been filtered
        lenOfRow = len(self.tableValues[0])
        indexAutoIndex = []
        for row in self.tableValues:
            indexAutoIndex.append(int(row[lenOfRow - 1]))
 
        if DEBUG_PRINT_MISC:
            print('\n indexAutoIndex = ')
            print(indexAutoIndex)

# define empty variable, since it will be re-generated
        self.varYSelect = []
        
# grid table windows so they will be correct size for table
        self.gridTableWindows()
        
# if empty table, at least show headers for columns, then return
        if emptyTable:
            self.showEmptyTableWithColumnHeaders(
                tableStructure,
                width_Field,
                fontsize_Field,
                height_Field,
                )
            return
            
# ... table headers in 'j' columns
        for j in range(len(tableValues[0])):
            self.labelHeaderFields = Label(
                self.frame_11_canvas,
                text=tableStructure[j][0],
                bg='white',
                fg='black',
                width=width_Field,
                font=fontsize_Field,
                anchor=W,
#                borderwidth=2,
#                relief=RIDGE,
                )
            self.labelHeaderFields.grid(
                row=0,
                column=j,
                padx=2,
                pady=1,
                )  
# header checkbuttons for y-select
# ... create an instance of IntVar for each Checkbutton
            varY = IntVar()
            checkbuttonYSelect = Checkbutton(
                self.frame_11_canvas,
                bg='tan',
                justify=CENTER,
                variable=varY,
                command=self.handlerDisplayNumberOfYValuesSelected,
                )
            checkbuttonYSelect.grid(
                row=1,
                column=j,
                padx=2,
                pady=0,
                )
            self.varYSelect.append(varY)               

# header radiobuttons for x-select                                
            radiobuttonXSelect = Radiobutton(
                self.frame_11_canvas,
                bg='tan',
                justify=CENTER,
                value=j+1,
                variable=self.varXSelect,
                command=self.handlerDisplayXValueSelected,
                )
            radiobuttonXSelect.grid(
                row=2,
                column=j,
                padx=2,
                pady=0,
                )
                
            labelColumn = Label(
                self.frame_11_canvas,
                text=str(j+1),
                bg='tan',
                justify=CENTER,
                )
            labelColumn.grid(
                row=3,
                column=j,
                padx=2,
                pady=1,
                )
                                      
# define empty list
        stringTableStructure=[]
            
# if 'Max lines to display' has a valid value in the entry field, use that to limit display;
#    otherwise, show all columns
        maxLinesDisplay = int(self.comboboxMaxLinesToDisplay.get())
        if maxLinesDisplay == 0 or maxLinesDisplay > len(self.tableValues):
            maxLinesDisplay = len(self.tableValues)

# set index in case we wish to edit select rows in display
        self.indexEditSelectedRows_Start = 0
        
# fill table rows and columns
# ... use for sequential rows; this may not be how the rows are currently displayed,
# ...   since the table may have been ordered by filtering
#        for i in range(maxLinesDisplay):
# ... use to display table exactly as it appeared before resizing (BEST)
        tableRow = 0


        for (num,i) in enumerate(indexAutoIndex):
#            tableRow=i
            tableColumn=0
            if DEBUG_PRINT_MISC:
                print('\ni-1 = %s' % (i-1))
                print('tableValues[i-1] for i-1 = %s:' % (i-1) )
#                print('\n%s. %s' % (i-1,tableValues[i-1]))
                print('\n%s. %s' % (i-1,tableValues[i-1]))
            for j in range(len(tableValues[0])):
                tableColumn+=1
                if DEBUG_PRINT_MISC:
                    print('     tableValues[%s][%s] = %s' % (i-1,j,tableValues[i-1][j]))
# ... field 0      
                labelFieldValues = Label(
                    self.frame_22_canvas,
                    text=str(tableValues[i-1][j]),
                    background='white',
                    foreground='black',
                    width=width_Field,
                    height=height_Field,
                    font=fontsize_Field,
                    bg='white',
                    fg='black',
                    anchor=NW,
                    justify=LEFT,
                    )
                labelFieldValues.grid(
                    row=tableRow,
                    column=tableColumn,
                    padx=2,
                    pady=1,
                    )
# increment row based on index 'i'
            tableRow += 1
                    
# setup 'Select row' check buttons:
        self.varSelectAnyRow = []
        tableColumn=0
        tableRow = 0
        for i in range(maxLinesDisplay):
#            tableRow=i
            var = IntVar()
# checkbuttons for selecting a row
            checkbuttonSelectAnyRow = Checkbutton(
                self.frame_21_canvas,
                bg='tan',
                justify=LEFT,
                variable=var,
                font=self.buttonFontSmallest,
                borderwidth=0,
                height=height_Field,
                )
            checkbuttonSelectAnyRow.grid(
                row=tableRow,
                column=tableColumn,
                padx=0,
                pady=1,
                sticky=E,
                )
# use bindtags to switch binding order so that checkbuttons will be checked,
#   before being examined to see how many rows are checked;
#   normally, the first two parameters are switched below for the default value
            checkbuttonSelectAnyRow.bindtags((
                'Checkbutton',  # class binding
                (str(checkbuttonSelectAnyRow)), # instance binding
                'self.frame_21_canvas',
                'all'
                ))
            checkbuttonSelectAnyRow.bind(
                "<ButtonRelease-1>",
                self.displayNumberOfRowsSelected_Table
                )
# variable to check for on-off states
#  to check value, use:
#   for var in self.varSelectAnyRow:
#       print var.get()  # will be either 1 or 0
            self.varSelectAnyRow.append(var)
# line numbers
            labelSelectAnyRow = Label(
                self.frame_21_canvas,
                text='%-4s' % (i+1),
                bg='tan',
                justify=RIGHT,
                height=height_Field,
                font=fontsize_Field,
#                relief=RIDGE,
                )
            labelSelectAnyRow.grid(
                row=tableRow,
                column=tableColumn+1,
                padx=0,
                pady=1,
                sticky=W,
                )
# increment row based in index i
            tableRow += 1
            
# recheck all fields that were originally checked
        self.restoreCheckedFieldNames()
            
# reposition widgets to be gridded correctly at top of frame instead of defaulting to middle of frame
# ... frame_11
        self.frame_11_canvas.grid_rowconfigure(1,weight=1)
        self.canvas_11.create_window(
            0,
            0,
            anchor=NW,
            window=self.frame_11_canvas
            )
        self.frame_11_canvas.update_idletasks()
        self.canvas_11.config(scrollregion=self.canvas_11.bbox('all'))
# ... frame_21                        
        self.frame_21_canvas.grid_rowconfigure(1,weight=1)
        self.canvas_21.create_window(
            0,
            0,
            anchor=NW,
            window=self.frame_21_canvas
            )
        self.frame_21_canvas.update_idletasks()
        self.canvas_21.config(scrollregion=self.canvas_21.bbox('all'))
# ... frame_22                      
        self.frame_22_canvas.grid_rowconfigure(1,weight=1)
        self.canvas_22.create_window(
            0,
            0,
            anchor=NW, 
            window=self.frame_22_canvas
            )
        self.frame_22_canvas.update_idletasks()
        self.canvas_22.config(scrollregion=self.canvas_22.bbox('all'))        
            
        return
        
        
    def showEmptyTableWithColumnHeaders(self,tableStructure,width_Field,fontsize_Field,height_Field):
        '''
        Purpose:
            Show empty table with scrollable column headers
        '''
        
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'showEmptyTableWithColumnHeaders')
        
        xScroll_frame_11 = Scrollbar(
            self.toplevelTableValues,
            orient=HORIZONTAL,
            )
        xScroll_frame_11.grid(
            row=3,
            column=2,
            sticky=N+E+W,
            )
                
        self.canvas_11 = Canvas(
            self.frame_11_table_columns,
            bg='tan',
            highlightbackground='tan',
            confine=0,
#                            width=720,
#                            height=90,
            width=widthTableHeader,
            height=heightTableHeader,
            xscrollcommand=xScroll_frame_11.set
            )
        self.canvas_11.grid(
            row=1,
            column=1,
            padx=2,
            pady=2,
            sticky=N,
            )
        self.frame_11_canvas = Frame(
            self.canvas_11,
            bg='tan',
            padx=1,
            )
        xScroll_frame_11.config(
            command=self.handlerXScrollOneFrame
#            command=self.canvas_11.xview
            )
                
        for jColumn in range(len(tableStructure)):
            self.labelHeaderFields = Label(
                self.frame_11_canvas,
                text=tableStructure[jColumn][0],
                bg='white',
                fg='black',
                width=width_Field,
                font=fontsize_Field,
                anchor=W,
#               borderwidth=2,
#               relief=RIDGE,
                )
            self.labelHeaderFields.grid(
                row=0,
                column=jColumn,
                padx=2,
                pady=1,
                ) 
            labelDummyRow1 = Label(
                self.frame_11_canvas,
                text=' ',
                bg='tan',
                justify=RIGHT,
                height=height_Field,
                font=fontsize_Field,
                )
            labelDummyRow1.grid(
                row=1,
                column=jColumn,
                padx=0,
                pady=1,
                sticky=W,
                )
            labelDummyRow2 = Label(
                self.frame_11_canvas,
                text=' ',
                bg='tan',
                justify=RIGHT,
                height=height_Field,
                font=fontsize_Field,
                )
            labelDummyRow2.grid(
                row=2,
                column=jColumn,
                padx=0,
                pady=1,
               sticky=W,
                )
# line numbers
            labelColumn = Label(
                self.frame_11_canvas,
                text=str(jColumn+1),
                bg='tan',
                justify=CENTER,
                )
            labelColumn.grid(
                row=3,
                column=jColumn,
                padx=2,
                pady=1,
                )

# ... frame_11
        self.frame_11_canvas.grid_rowconfigure(1,weight=1)
        self.canvas_11.create_window(
            0,
            0,
            anchor=NW,
            window=self.frame_11_canvas
            )
        self.frame_11_canvas.update_idletasks()
        self.canvas_11.config(scrollregion=self.canvas_11.bbox('all'))
        '''
        self.MySQL_Output(
            1,
            'There is nothing to display:\n\n' +
            ' - table "' + self.myTable + '" is empty\n'
            )
        showinfo(
            'Info: Nothing to display',
            '\nThere is nothing to display:\n\n' +
            ' - table "' + self.myTable + '" is empty' + '\n\n'  +
            '\n(msg_8)'
            )
        '''
            
        emptyTableCheck = self.checkIfEmptyTable()

        return        
        
    def clear_grid(self,parent):
        '''
        This function deletes all of the objects that 
        have been gridded to the 'parent' widget.
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'clear_grid')
            
        '''
        self.MySQL_Output(
            0,
            '  Clearing ' + str(len(parent.grid_slaves())) + ' widgets\n'
            )
        '''
# check if connected to a MySQL server
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return           
     
        grid_slaves = parent.grid_slaves()
    
        if grid_slaves:
            for i in range(len(grid_slaves)):
                grid_slaves[i].destroy()
                
        return
                
                
    def handlerImportCsvData(self):
        '''
        Purpose:
            import CSV data generated by an external program
            
        Called by:
                
        Calls:
        
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerImportCsvData')
            
# set last button pressed
        self.lastButtonPressed(
            BUTTONLABEL_IMPORTCSVDATA
            )
            
        self.MySQL_Output(
            0,
            ' Imports CSV data into current table'
            )
            
# save checked fields
        self.saveCheckedFieldNames()  
            
#        import module_read_csv_file as readCsv      
        instance_csv_file = readCsv.ReadCSVFile(
            self.toplevelTableValues,
            'lightblue',
            self.MySQL_Commands,
            self.MySQL_Output,
            self.comboboxDbSelect.get(),
            self.comboboxDbTableSelect.get(),
            self.tableStructure,
            self.handlerDisplayAllFields,
            self._userMySQL_Save,
#            self._passwdMySQL_Save,    # don't need
            '',
            self._hostMySQL_Save,
            self._portMySQL_Save,
            self.myDbConnection,
            self.cursorHandleMySQL,
            )
            
# reset indices for checked fields
        self.resetVarXYSelect()
            
# restore checked fields
        self.restoreCheckedFieldNames()  
            
        return

            
    def handlerSetOrClearLengthDefaults(self):
        '''
        Purpose:
        Set length default values for datatypes specified 
          in the Datatype column of the 'New Fields for Table' 
          
        Called by:
        handlerDefineFieldsForNewTable
        
        # DATATYPES and their lengths
        # 1     BIGINT            255     opt     integer number range: -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807
        # 2     CHAR              255     req'd   max: 255 characters
        # 3     DATE              b       b       input: YYYY-MM-DD; storage format: YYY-MM-DD
        # 4     DECIMAL           255     opt     stores fixed-point numbers
        # 5     DOUBLE            b       opt     stores floating point numbers
        # 6     FLOAT             b       opt     stores floating point numbers
        # 7     INTEGER           255     opt     range: -2,147,483,648 to 2,147,483,647
        # 8     INTEGER UNSIGNED  255     opt     range: 0 to 4,294,967,295
        # 9     LONGTEXT          b       b       upto 4GB
        # 10    MEDIUMTEXT        b       b       up to 16MB
        # 11    SMALLINT          255     opt     integer number range: -32,768 to 32,767
        # 12    SMALLINT_UNSIGNED 255     opt     integer number range: 0 to 65500
        # 13    TEXT              b       b       max: 65500 bytes
        # 14    TIME              b       b       input: DD HH:MM:SS; storage format: HHH:MM:SS 
        # 15    TIMESTAMP         b       b       input: YYYY-MM-DD HH:MM:SS; storage format: YYY-MM-DD HH:MM:SS; assign NULL to set current date and time
        # 16    TINYTEXT          b       b       max: 255 bytes
        # 17    VARCHAR           65500   req'd   max: 65500 characters   
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerSetLengthDefault')
            
        self.MySQL_Output(
            0,
            ' Setting default values for Datatypes in New Fields for Tables'
            )
            
        if self.varButtonSetOrClearDefaultLength.get():
        
            stringSetOrClear = (
                'Set defaults for all datatype lengths'
                )
            print('\n' + stringSetOrClear)
            self.MySQL_Output(
                1,
                stringSetOrClear
                )
            
# clear all fields
            for numField in range(self.numFields):
                self.varFieldName_Length[numField].setvalue('')  # Pmw.EntryField

# update idletasks or else fields won't be 'observably' blanked, since these tasks aren't
#   apparently updated until the 'return' statement is encountered         
            self.toplevelDefineFieldsForNewTable.update_idletasks()
          
# define current field
            for numField in range(self.numFields):
# enable the field
#            self.varFieldName_Length[numField].configure(entry_state='normal')
# get the value
                datatype = self.varFieldName_Datatype[numField].get()
# set default values
# ... 1. bigint
                if datatype == 'BIGINT':
                    self.varFieldName_Length[numField].setvalue(
                        self.dictFieldDataTypesLength['setvalue_BIGINT']
                        ) #('255')
                    self.varFieldName_Length[numField].configure(entry_state=NORMAL)
# ... 2. char
                elif datatype == 'CHAR':
#                self.varFieldName_Length[numField].setvalue('Width: max 255 chars')
                    self.varFieldName_Length[numField].setvalue(
                        self.dictFieldDataTypesLength['setvalue_CHAR']
                        ) #('255')
                    self.varFieldName_Length[numField].configure(entry_state=NORMAL)
# ... 3. date                
                elif datatype == 'DATE':
#                self.varFieldName_Length[numField].setvalue('<\'YYYY-MM-DD\'>')
                    self.varFieldName_Length[numField].setvalue(
                        self.dictFieldDataTypesLength['setvalue_DATE']
                        ) #('')
                    self.varFieldName_Length[numField].configure(entry_state=DISABLED)
# ... 4. decimal                
                elif datatype == 'DECIMAL':
#                self.varFieldName_Length[numField].setvalue('10,5')
                    self.varFieldName_Length[numField].setvalue(
                        self.dictFieldDataTypesLength['setvalue_DECIMAL']
                        ) #('20,10')
                    self.varFieldName_Length[numField].configure(entry_state=NORMAL)
# ... 5. double               
                elif datatype == 'DOUBLE':
#                self.varFieldName_Length[numField].setvalue('20,5')
                    self.varFieldName_Length[numField].setvalue(
                        self.dictFieldDataTypesLength['setvalue_DOUBLE']
                        ) #('20,10')
                    self.varFieldName_Length[numField].configure(entry_state=DISABLED)
# ... 6. float                
                elif datatype == 'FLOAT':
#                self.varFieldName_Length[numField].setvalue('20,5')
                    self.varFieldName_Length[numField].setvalue(
                        self.dictFieldDataTypesLength['setvalue_FLOAT']
                        ) #('20')
                    self.varFieldName_Length[numField].configure(entry_state=DISABLED)
# ... 7. integer                
                elif datatype == 'INTEGER':
#                self.varFieldName_Length[numField].setvalue('5')
                    self.varFieldName_Length[numField].setvalue(
                        self.dictFieldDataTypesLength['setvalue_INTEGER']
                        ) #('255')
                    self.varFieldName_Length[numField].configure(entry_state=NORMAL)
# ... 8. integer unsigned                
                elif datatype == 'INTEGER UNSIGNED':
#                self.varFieldName_Length[numField].setvalue('10')
                    self.varFieldName_Length[numField].setvalue(
                        self.dictFieldDataTypesLength['setvalue_INTEGER_UNSIGNED']
                        ) #('255')
                    self.varFieldName_Length[numField].configure(entry_state=NORMAL)
# ... 9. longtext                
                elif datatype == 'LONGTEXT':
#                self.varFieldName_Length[numField].setvalue('<Max 4000MB>')
                    self.varFieldName_Length[numField].setvalue(
                        self.dictFieldDataTypesLength['setvalue_LONGTEXT']
                        ) #('')
                    self.varFieldName_Length[numField].configure(entry_state=DISABLED)
# ... 10. mediumtext                
                elif datatype == 'MEDIUMTEXT':
#                self.varFieldName_Length[numField].setvalue('<Max 16MB>')
                    self.varFieldName_Length[numField].setvalue(
                        self.dictFieldDataTypesLength['setvalue_MEDIUMTEXT']
                        ) #('')
                    self.varFieldName_Length[numField].configure(entry_state=DISABLED)
# ... 11. smallint               
                elif datatype == 'SMALLINT':
#                self.varFieldName_Length[numField].setvalue('6')
                    self.varFieldName_Length[numField].setvalue(
                        self.dictFieldDataTypesLength['setvalue_SMALLINT']
                        ) #('255')
                    self.varFieldName_Length[numField].configure(entry_state=NORMAL)
# ... 12. smallint unsigned                
                elif datatype == 'SMALLINT UNSIGNED':
#                self.varFieldName_Length[numField].setvalue('5')
                    self.varFieldName_Length[numField].setvalue(
                        self.dictFieldDataTypesLength['setvalue_SMALLINT_UNSIGNED']
                        ) #('255')
                    self.varFieldName_Length[numField].configure(entry_state=NORMAL)
# ... 13. text                
                elif datatype == 'TEXT':
#                self.varFieldName_Length[numField].setvalue('<Max 64KB>')
                    self.varFieldName_Length[numField].setvalue(
                        self.dictFieldDataTypesLength['setvalue_TEXT']
                        ) #('')
                    self.varFieldName_Length[numField].configure(entry_state=DISABLED)
# ... 14. time                
                elif datatype == 'TIME':
#                self.varFieldName_Length[numField].setvalue('<\'DD HH:MM:SS\'>')
                    self.varFieldName_Length[numField].setvalue(
                        self.dictFieldDataTypesLength['setvalue_TIME']
                        ) #('')
                    self.varFieldName_Length[numField].configure(entry_state=DISABLED)
# ... 15. timestamp                
                elif datatype == 'TIMESTAMP':
#                self.varFieldName_Length[numField].setvalue('<NULL, or \'YYYY-MM-DD HH:MM:SS\'>')
                    self.varFieldName_Length[numField].setvalue(
                        self.dictFieldDataTypesLength['setvalue_TIMESTAMP']
                        ) #('')
                    self.varFieldName_Length[numField].configure(entry_state=DISABLED)
# ... 16. tinytext               
                elif datatype == 'TINYTEXT':
#                self.varFieldName_Length[numField].setvalue('<Max 255B>')
                    self.varFieldName_Length[numField].setvalue(
                        self.dictFieldDataTypesLength['setvalue_TINYTEXT']
                        ) #('')
                    self.varFieldName_Length[numField].configure(entry_state=DISABLED)
# ... 17. varchar                
                elif datatype == 'VARCHAR':
#                self.varFieldName_Length[numField].setvalue('Width: Max 65500 chars')
                    self.varFieldName_Length[numField].setvalue(
                        self.dictFieldDataTypesLength['setvalue_VARCHAR']
                        ) #('65500')
                    self.varFieldName_Length[numField].configure(entry_state=NORMAL)
# ... if datatype is blank
                elif datatype == '':
                    self.varFieldName_Length[numField].setvalue('Error: No datatype!')
                    self.varFieldName_Length[numField].configure(entry_state=NORMAL)
# ... error if here
                else:
# datatype has not been specified; output error messages
                    stringNoDatatype = (
                        'The following datatype has no defined default length.\n\n' +
                        '   datatype = %s\n\n' +
                        'This is a coding error.\n\n' +
                        'Please contact code administrator to correct this problem.'
                        ) % datatype
                    print(stringNoDatatype)
                    self.MySQL_Output(
                        0,
                        '\n' + stringNoDatatype
                        )   
                    showerror(
                        'Error: no datatype',
                        stringNoDatatype
                        )
                    return
                
        else:
# clear all entries
            stringSetOrClear = (
                'Clear all datatype lengths'
                )
            print('\n' + stringSetOrClear)
            self.MySQL_Output(
                1,
                stringSetOrClear
                )
            for numField in range(self.numFields):
                self.varFieldName_Length[numField].setvalue('')
                self.varFieldName_Length[numField].configure(entry_state=NORMAL)
                
        return
        
        
    def handlerEnterDatabaseFieldAdd_Datatype(self,datatype):
        '''
        Purpose:
        Set length default values for datatypes specified 
          in the Datatype column of the 'ADD FIELD' window 
          
        Called by:
        handlerDatabaseFieldsSelect
        
        # DATATYPES and their max lengths
        # 1     BIGINT            255     opt     integer number range: -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807
        # 2     CHAR              255     req'd   max: 255 characters
        # 3     DATE              b       b       input: YYYY-MM-DD; storage format: YYY-MM-DD
        # 4     DECIMAL           255     opt     stores fixed-point numbers
        # 5     DOUBLE            b       opt     stores floating point numbers
        # 6     FLOAT             b       opt     stores floating point numbers
        # 7     INTEGER           255     opt     range: -2,147,483,648 to 2,147,483,647
        # 8     INTEGER UNSIGNED  255     opt     range: 0 to 4,294,967,295
        # 9     LONGTEXT          b       b       upto 4GB
        # 10    MEDIUMTEXT        b       b       up to 16MB
        # 11    SMALLINT          255     opt     integer number range: -32,768 to 32,767
        # 12    SMALLINT_UNSIGNED 255     opt     integer number range: 0 to 65500
        # 13    TEXT              b       b       max: 65500 bytes
        # 14    TIME              b       b       input: DD HH:MM:SS; storage format: HHH:MM:SS 
        # 15    TIMESTAMP         b       b       input: YYYY-MM-DD HH:MM:SS; storage format: YYY-MM-DD HH:MM:SS; assign NULL to set current date and time
        # 16    TINYTEXT          b       b       max: 255 bytes
        # 17    VARCHAR           65500   req'd   max: 65500 characters   
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerEnterDatabaseFieldAdd_Datatype')
            
        self.MySQL_Output(
            0,
            ' Setting default values for Datatypes in New Fields for Tables'
            )
            
# clear entry field
        self.entryEnterDatabaseFieldAdd_DatatypeLength.select_clear() # Tkinter entry field

# update idletasks or else fields won't be 'observably' blanked, since these tasks aren't
#   apparently updated until the 'return' statement is encountered         
        self.toplevelFieldAdd.update_idletasks()
        
# set field to normal in case of error finding a datatype
        self.entryEnterDatabaseFieldAdd_DatatypeLength.configure(state=NORMAL)
          
# get the value
#            datatype = self.comboboxEnterDatabaseFieldAdd_Datatype.get()
# set default values
# ... 0. bigint
        if datatype == 'BIGINT':
            self.varEntryEnterDatabaseFieldAdd_DatatypeLength.set(
                self.dictFieldDataTypesLength['setvalue_BIGINT']
                )
            self.entryEnterDatabaseFieldAdd_DatatypeLength.configure(state=NORMAL)
# ... 1. char
        elif datatype == 'CHAR':
#            self.varFieldName_Length[numField].setvalue('Width: max 255 chars')
            self.varEntryEnterDatabaseFieldAdd_DatatypeLength.set(
                self.dictFieldDataTypesLength['setvalue_CHAR']
                )
            self.entryEnterDatabaseFieldAdd_DatatypeLength.configure(state=NORMAL)
# ... 2. date                
        elif datatype == 'DATE':
#            self.varFieldName_Length[numField].setvalue('<\'YYYY-MM-DD\'>')
            self.varEntryEnterDatabaseFieldAdd_DatatypeLength.set(
                self.dictFieldDataTypesLength['setvalue_DATE']
                )
            self.entryEnterDatabaseFieldAdd_DatatypeLength.configure(state=DISABLED)
# ... 3. decimal                
        elif datatype == 'DECIMAL':
#            self.varFieldName_Length[numField].setvalue('10,5')
            self.varEntryEnterDatabaseFieldAdd_DatatypeLength.set(
                self.dictFieldDataTypesLength['setvalue_DECIMAL']
                )
            self.entryEnterDatabaseFieldAdd_DatatypeLength.configure(state=NORMAL)
# ... 4. double               
        elif datatype == 'DOUBLE':
#            self.varFieldName_Length[numField].setvalue('20,5')
            self.varEntryEnterDatabaseFieldAdd_DatatypeLength.set(
                self.dictFieldDataTypesLength['setvalue_DOUBLE']
                )
            self.entryEnterDatabaseFieldAdd_DatatypeLength.configure(state=DISABLED)
# ... 5. float                
        elif datatype == 'FLOAT':
#            self.varFieldName_Length[numField].setvalue('20,5')
            self.varEntryEnterDatabaseFieldAdd_DatatypeLength.set(
                self.dictFieldDataTypesLength['setvalue_FLOAT']
                )
            self.entryEnterDatabaseFieldAdd_DatatypeLength.configure(state=DISABLED)
# ... 6. integer                
        elif datatype == 'INTEGER':
#            self.varFieldName_Length[numField].setvalue('5')
            self.varEntryEnterDatabaseFieldAdd_DatatypeLength.set(
                self.dictFieldDataTypesLength['setvalue_INTEGER']
                )
            self.entryEnterDatabaseFieldAdd_DatatypeLength.configure(state=NORMAL)
# ... 7. integer unsigned                
        elif datatype == 'INTEGER UNSIGNED':
#            self.varFieldName_Length[numField].setvalue('10')
            self.varEntryEnterDatabaseFieldAdd_DatatypeLength.set(
                self.dictFieldDataTypesLength['setvalue_INTEGER_UNSIGNED']
                )
            self.entryEnterDatabaseFieldAdd_DatatypeLength.configure(state=NORMAL)
# ... 8. longtext                
        elif datatype == 'LONGTEXT':
            self.varEntryEnterDatabaseFieldAdd_DatatypeLength.set(
                self.dictFieldDataTypesLength['setvalue_LONGTEXT']
                )
            self.entryEnterDatabaseFieldAdd_DatatypeLength.configure(state=DISABLED)
# ... 9. mediumtext                
        elif datatype == 'MEDIUMTEXT':
            self.varEntryEnterDatabaseFieldAdd_DatatypeLength.set(
                self.dictFieldDataTypesLength['setvalue_MEDIUMTEXT']
                )
            self.entryEnterDatabaseFieldAdd_DatatypeLength.configure(state=DISABLED)
# ... 10. smallint               
        elif datatype == 'SMALLINT':
            self.varEntryEnterDatabaseFieldAdd_DatatypeLength.set(
                self.dictFieldDataTypesLength['setvalue_SMALLINT']
                )
            self.entryEnterDatabaseFieldAdd_DatatypeLength.configure(state=NORMAL)
# ... 11. smallint unsigned                
        elif datatype == 'SMALLINT UNSIGNED':
            self.varEntryEnterDatabaseFieldAdd_DatatypeLength.set(
                self.dictFieldDataTypesLength['setvalue_SMALLINT_UNSIGNED']
                )
            self.entryEnterDatabaseFieldAdd_DatatypeLength.configure(state=NORMAL)
# ... 12. text                
        elif datatype == 'TEXT':
            self.varEntryEnterDatabaseFieldAdd_DatatypeLength.set(
                self.dictFieldDataTypesLength['setvalue_TEXT']
                )
            self.entryEnterDatabaseFieldAdd_DatatypeLength.configure(state=DISABLED)
# ... 13. time                
        elif datatype == 'TIME':
            self.varEntryEnterDatabaseFieldAdd_DatatypeLength.set(
                self.dictFieldDataTypesLength['setvalue_TIME']
                )
            self.entryEnterDatabaseFieldAdd_DatatypeLength.configure(state=DISABLED)
# ... 14. timestamp                
        elif datatype == 'TIMESTAMP':
            self.varEntryEnterDatabaseFieldAdd_DatatypeLength.set(
                self.dictFieldDataTypesLength['setvalue_TIMESTAMP']
                )
            self.entryEnterDatabaseFieldAdd_DatatypeLength.configure(state=DISABLED)
# ... 15. tinytext               
        elif datatype == 'TINYTEXT':
            self.varEntryEnterDatabaseFieldAdd_DatatypeLength.set(
                self.dictFieldDataTypesLength['setvalue_TINYTEXT']
                )
            self.entryEnterDatabaseFieldAdd_DatatypeLength.configure(state=DISABLED)
# ... 16. varchar                
        elif datatype == 'VARCHAR':
            self.varEntryEnterDatabaseFieldAdd_DatatypeLength.set(
                self.dictFieldDataTypesLength['setvalue_VARCHAR']
                )
            self.entryEnterDatabaseFieldAdd_DatatypeLength.configure(state=NORMAL)
# ... error if here
        else:
# datatype has not been specified; output error messages
            stringNoDatatype = (
                'The following datatype has no defined default length.\n\n' +
                '   datatype = %s\n\n' +
                'This is a coding error.\n\n' +
                'Please contact code administrator to correct this problem.'
                ) % datatype
            print(stringNoDatatype)
            self.MySQL_Output(
                0,
                '\n' + stringNoDatatype
                )   
            showerror(
                'Error: no datatype',
                stringNoDatatype
                )
                
        return
        
        
    def handlerFieldName_Datatype(self,datatype):
        '''
        Purpose:
        Set length default values for datatypes specified 
          in the Datatype column of the 'ADD FIELD' window 
          
        Called by:
        handlerDefineFieldsForNewTable
        
        Notes:
        
        # DATATYPES and their max lengths
        # 1     BIGINT            255     opt     integer number range: -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807
        # 2     CHAR              255     req'd   max: 255 characters
        # 3     DATE              b       b       input: YYYY-MM-DD; storage format: YYY-MM-DD
        # 4     DECIMAL           255     opt     stores fixed-point numbers
        # 5     DOUBLE            b       opt     stores floating point numbers
        # 6     FLOAT             b       opt     stores floating point numbers
        # 7     INTEGER           255     opt     range: -2,147,483,648 to 2,147,483,647
        # 8     INTEGER UNSIGNED  255     opt     range: 0 to 4,294,967,295
        # 9     LONGTEXT          b       b       upto 4GB
        # 10    MEDIUMTEXT        b       b       up to 16MB
        # 11    SMALLINT          255     opt     integer number range: -32,768 to 32,767
        # 12    SMALLINT_UNSIGNED 255     opt     integer number range: 0 to 65500
        # 13    TEXT              b       b       max: 65500 bytes
        # 14    TIME              b       b       input: DD HH:MM:SS; storage format: HHH:MM:SS 
        # 15    TIMESTAMP         b       b       input: YYYY-MM-DD HH:MM:SS; storage format: YYY-MM-DD HH:MM:SS; assign NULL to set current date and time
        # 16    TINYTEXT          b       b       max: 255 bytes
        # 17    VARCHAR           65500   req'd   max: 65500 characters   
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerFieldName_Datatype')
            
        self.MySQL_Output(
            0,
            ' Setting default values for Datatypes in New Fields for Tables'
            )
            
# define which field
        numField = self.numField_Save
            
# clear entry field
        self.varFieldName_Length[numField].clear() # Pmw.EntryField

# update idletasks or else fields won't be 'observably' blanked, since these tasks aren't
#   apparently updated until the 'return' statement is encountered         
        self.toplevelDefineFieldsForNewTable.update_idletasks()
        
# set field to normal in case of error finding a datatype
        self.varFieldName_Length[numField].configure(entry_state=NORMAL)
          
# get the value
#            datatype = self.comboboxEnterDatabaseFieldAdd_Datatype.get()
# set default values
# ... 0. bigint
        if datatype == 'BIGINT':
            self.varFieldName_Length[numField].setvalue(
                self.dictFieldDataTypesLength['setvalue_BIGINT']
                )
            self.varFieldName_Length[numField].configure(entry_state=NORMAL)
# ... 1. char
        elif datatype == 'CHAR':
#            self.varFieldName_Length[numField].setvalue('Width: max 255 chars')
            self.varFieldName_Length[numField].setvalue(
                self.dictFieldDataTypesLength['setvalue_CHAR']
                )
            self.varFieldName_Length[numField].configure(entry_state=NORMAL)
# ... 2. date                
        elif datatype == 'DATE':
#            self.varFieldName_Length[numField].setvalue('<\'YYYY-MM-DD\'>')
            self.varFieldName_Length[numField].setvalue(
                self.dictFieldDataTypesLength['setvalue_DATE']
                )
            self.varFieldName_Length[numField].configure(entry_state=DISABLED)
# ... 3. decimal                
        elif datatype == 'DECIMAL':
#            self.varFieldName_Length[numField].setvalue('10,5')
            self.varFieldName_Length[numField].setvalue(
                self.dictFieldDataTypesLength['setvalue_DECIMAL']
                )
            self.varFieldName_Length[numField].configure(entry_state=NORMAL)
# ... 4. double               
        elif datatype == 'DOUBLE':
#            self.varFieldName_Length[numField].setvalue('20,5')
            self.varFieldName_Length[numField].setvalue(
                self.dictFieldDataTypesLength['setvalue_DOUBLE']
                )
            self.varFieldName_Length[numField].configure(entry_state=DISABLED)
# ... 5. float                
        elif datatype == 'FLOAT':
#            self.varFieldName_Length[numField].setvalue('20,5')
            self.varFieldName_Length[numField].setvalue(
                self.dictFieldDataTypesLength['setvalue_FLOAT']
                )
            self.varFieldName_Length[numField].configure(entry_state=DISABLED)
# ... 6. integer                
        elif datatype == 'INTEGER':
#            self.varFieldName_Length[numField].setvalue('5')
            self.varFieldName_Length[numField].setvalue(
                self.dictFieldDataTypesLength['setvalue_INTEGER']
                )
            self.varFieldName_Length[numField].configure(entry_state=NORMAL)
# ... 7. integer unsigned                
        elif datatype == 'INTEGER UNSIGNED':
#            self.varFieldName_Length[numField].setvalue('10')
            self.varFieldName_Length[numField].setvalue(
                self.dictFieldDataTypesLength['setvalue_INTEGER_UNSIGNED']
                )
            self.varFieldName_Length[numField].configure(entry_state=NORMAL)
# ... 8. longtext                
        elif datatype == 'LONGTEXT':
            self.varFieldName_Length[numField].setvalue(
                self.dictFieldDataTypesLength['setvalue_LONGTEXT']
                )
            self.varFieldName_Length[numField].configure(entry_state=DISABLED)
# ... 9. mediumtext                
        elif datatype == 'MEDIUMTEXT':
            self.varFieldName_Length[numField].setvalue(
                self.dictFieldDataTypesLength['setvalue_MEDIUMTEXT']
                )
            self.varFieldName_Length[numField].configure(entry_state=DISABLED)
# ... 10. smallint               
        elif datatype == 'SMALLINT':
            self.varFieldName_Length[numField].setvalue(
                self.dictFieldDataTypesLength['setvalue_SMALLINT']
                )
            self.varFieldName_Length[numField].configure(entry_state=NORMAL)
# ... 11. smallint unsigned                
        elif datatype == 'SMALLINT UNSIGNED':
            self.varFieldName_Length[numField].setvalue(
                self.dictFieldDataTypesLength['setvalue_SMALLINT_UNSIGNED']
                )
            self.varFieldName_Length[numField].configure(entry_state=NORMAL)
# ... 12. text                
        elif datatype == 'TEXT':
            self.varFieldName_Length[numField].setvalue(
                self.dictFieldDataTypesLength['setvalue_TEXT']
                )
            self.varFieldName_Length[numField].configure(entry_state=DISABLED)
# ... 13. time                
        elif datatype == 'TIME':
            self.varFieldName_Length[numField].setvalue(
                self.dictFieldDataTypesLength['setvalue_TIME']
                )
            self.varFieldName_Length[numField].configure(entry_state=DISABLED)
# ... 14. timestamp                
        elif datatype == 'TIMESTAMP':
            self.varFieldName_Length[numField].setvalue(
                self.dictFieldDataTypesLength['setvalue_TIMESTAMP']
                )
            self.varFieldName_Length[numField].configure(entry_state=DISABLED)
# ... 15. tinytext               
        elif datatype == 'TINYTEXT':
            self.varFieldName_Length[numField].setvalue(
                self.dictFieldDataTypesLength['setvalue_TINYTEXT']
                )
            self.varFieldName_Length[numField].configure(entry_state=DISABLED)
# ... 16. varchar                
        elif datatype == 'VARCHAR':
            self.varFieldName_Length[numField].setvalue(
                self.dictFieldDataTypesLength['setvalue_VARCHAR']
                )
            self.varFieldName_Length[numField].configure(entry_state=NORMAL)
# ... error if here
        else:
# datatype has not been specified; output error messages
            stringNoDatatype = (
                'The following datatype has no defined default length.\n\n' +
                '   datatype = %s\n\n' +
                'This is a coding error.\n\n' +
                'Please contact code administrator to correct this problem.'
                ) % datatype
            print(stringNoDatatype)
            self.MySQL_Output(
                0,
                '\n' + stringNoDatatype
                )   
            showerror(
                'Error: no datatype',
                stringNoDatatype
                )
                
        return
        
                
    def handlerTableValuesNumericalOnly(self):
        '''
        Purpose:
            display table fields that only have numerical datatypes
            
        Called by:
            handlerTableFunctionsShowValues
        
        Calls:
        
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerTableValuesNumericalOnly')
            
# set last button pressed
        self.lastButtonPressed(
            BUTTONLABEL_SHOWNUMERICALFIELDS
            )
            
# check if connected to a MySQL server
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return          

# search thru all column headers for fields that have a numerical datatype
        temp_dictColumnHeaders = {}
        temp_tableStructure = []
        temp_tableValues = []
        
        if DEBUG_SHOWNUMERICFIELDSONLY:
            print('\nself.dictColumnHeaders:')
            print(self.dictColumnHeaders)
            print('\nself.tableValues:')
            print(self.tableValues)
            print('\nself.tableStructure:')
            icount=1
            for row in self.tableStructure:
                print '  %s. %s' % (icount,row)
                icount+=1
                
# save checked field names before re-defining self.dictColumnHeadersOriginal
        self.saveCheckedFieldNames()
                
        countHeader = 0
#        for key in self.dictColumnHeaders.keys():
#            value = self.dictColumnHeaders.get(key)
        for num in range(len(self.dictColumnHeaders)):
            value=num+1
# find key for this value
            for key,valueColumnHeader in self.dictColumnHeaders.iteritems():
                if valueColumnHeader == value:
                    for struct in self.tableStructure:
                        if struct[0] == key:
                            varDatatype = struct[1]
                            varfirst2 = varDatatype[0:2]
                            fieldIsNumerical = self.checkIsFieldNumerical(varfirst2)
                            if fieldIsNumerical:
                                countHeader+=1
                                temp_dictColumnHeaders[key] = countHeader
                                temp_tableStructure.append(struct)
                                break
                    break
                    
# check for empty dict; if so, no numerical fields found, so do not change table display
        if temp_dictColumnHeaders == {}:
            print '\nNo numerical fields have been found.'
            self.MySQL_Output(
                0,
                '  No numerical fields have been found.'
                )
            showerror(
                'Error: no numerical fields found',
                '\nNo numerical fields have been found in the' + '\n' +
                'CURRENTLY DISPLAYED table fields.' + '\n\n' +
                'HINT: To search all fields, click either' + '\n' +
                '  "Peek" or "Load All" button first, then click' + '\n' +
                '  "Show Numerical Fields Only". ' + '\n\n'
                )
            return
            
# determine index values of tableValues for retrieving info
        indexColumnHeaders = []
        for key1 in temp_dictColumnHeaders.keys():
            for key2 in self.dictColumnHeaders.keys():
                if key1 == key2:
                    indexColumnHeaders.append(self.dictColumnHeaders.get(key2))
                    break
# sort
        indexColumnHeaders.sort()
        
        if DEBUG_SHOWNUMERICFIELDSONLY:
            print('\nindexColumnHeaders for numerical fields only:')
            print(indexColumnHeaders)
        
# re-form self.tableValues
        for row in self.tableValues:
            temp_list=[]
            for index in indexColumnHeaders:
                temp_list.append(row[index-1])
            temp_tableValues.append(temp_list)
        
        if DEBUG_SHOWNUMERICFIELDSONLY:
# print new tables
            print('\n\nNEW VALUES for numerical fields only:')
            print('\n  temp_dictColumnHeaders:')
            print(temp_dictColumnHeaders)
            print('\n  temp_tableValues:')
            print(temp_tableValues)
            print('\n  temp_tableStructure:')
            for (num, row) in enumerate(temp_tableStructure):
                print('  %s. %s ' % (num+1, row))

# reassign back to proper names        
        self.tableValues = ()
        self.tableStructure = ()
        self.dictColumnHeaders = {}
        self.tableValues = tuple(temp_tableValues)
        self.tableStructure = tuple(temp_tableStructure)
        self.dictColumnHeaders = temp_dictColumnHeaders
        
# display results
#        self.valuesDisplayRowDecimate(self.tableStructure,self.tableValues)
        self.handlerTableFunctionsShowValues(0,'all')
  
# update status line
        maxLinesDisplay = int(self.comboboxMaxLinesToDisplay.get())
        if maxLinesDisplay == 0 or maxLinesDisplay > len(self.tableValues):
            maxLinesDisplay = len(self.tableValues)
            
        self.handlerStatusLineRefresh(maxLinesDisplay)

# reset indices
        self.resetVarXYSelect()
        
# restore checked fields        
        self.restoreCheckedFieldNames() 
        
        return

    
    def handlerTableValuesTextOnly(self):
        '''
        Purpose:
            display table fields that only have text datatypes
            
        Called by:
            handlerTableFunctionsShowValues
        
        Calls:
        
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerTableValuesTextOnly')
            
# check if connected to a MySQL server
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return 
        
# set last button pressed
        self.lastButtonPressed(
            BUTTONLABEL_SHOWTEXTFIELDS
            )

# search thru all column headers for fields that have a text datatype
        temp_dictColumnHeaders = {}
        temp_tableStructure = []
        temp_tableValues = []
        
        if DEBUG_SHOWTEXTFIELDSONLY:
            print('\nself.dictColumnHeaders:')
            print(self.dictColumnHeaders)
            print('\nself.tableValues:')
            print(self.tableValues)
            print('\nself.tableStructure:')
            icount=1
            for row in self.tableStructure:
                print '  %s. %s' % (icount,row)
                icount+=1
            
# save checked field names before re-defining self.dictColumnHeadersOriginal
        self.saveCheckedFieldNames()
            
        countHeader = 0
#        for key in self.dictColumnHeaders.keys():
#            value = self.dictColumnHeaders.get(key)
        for num in range(len(self.dictColumnHeaders)):
            value=num+1
# find key for this value
            for key,valueColumnHeader in self.dictColumnHeaders.iteritems():
                if valueColumnHeader == value:
                    for struct in self.tableStructure:
                        if struct[0] == key:
                            varDatatype = struct[1]
                            varfirst2 = varDatatype[0:2]
                            fieldIsText = self.checkIsFieldText(varfirst2)
                            if fieldIsText:
                                countHeader+=1
                                temp_dictColumnHeaders[key] = countHeader
                                temp_tableStructure.append(struct)
                                break
                    break
                    
# check for empty dict; if so, no text fields found, so do not change table display
        if temp_dictColumnHeaders == {}:
            print '\nNo text fields have been found.'
            self.MySQL_Output(
                0,
                '  No text fields have been found.'
                )
            showerror(
                'Error: no text fields found',
                '\nNo text fields have been found in the' + '\n' +
                'CURRENTLY DISPLAYED table fields.' + '\n\n' + 
                'HINT: To search all fields, click either' + '\n' +
                '  "Peek" or "Load All" button first, then click' + '\n' +
                '  "Show Text Fields Only". ' + '\n\n'
                )
            return
            
# determine index values of tableValues for retrieving info
        indexColumnHeaders = []
        for key1 in temp_dictColumnHeaders.keys():
            for key2 in self.dictColumnHeaders.keys():
                if key1 == key2:
                    indexColumnHeaders.append(self.dictColumnHeaders.get(key2))
                    break
# sort                    
        indexColumnHeaders.sort()
                    
        if DEBUG_SHOWTEXTFIELDSONLY:
            print('\nindexColumnHeaders for text fields only:')
            print(indexColumnHeaders)
        
# reform self.tableValues
        for row in self.tableValues:
            temp_list=[]
            for index in indexColumnHeaders:
                temp_list.append(row[index-1])
            temp_tableValues.append(temp_list)

        if DEBUG_SHOWTEXTFIELDSONLY:
# print new tables
            print('\n\nNEW VALUES for text fields only:')
            print('\n  temp_dictColumnHeaders:')
            print(temp_dictColumnHeaders)
            print('\n  temp_tableValues:')
            print(temp_tableValues)
            print('\n  temp_tableStructure:')
            for (num, row) in enumerate(temp_tableStructure):
                print('  %s. %s' % (num+1, row))
            
# reassign back to proper names        
        self.tableValues = ()
        self.tableStructure = ()
        self.dictColumnHeaders = {}
        self.tableValues = tuple(temp_tableValues)
        self.tableStructure = tuple(temp_tableStructure)
        self.dictColumnHeaders = temp_dictColumnHeaders
        
# display results
#        self.valuesDisplayRowDecimate(self.tableStructure,self.tableValues)
        self.handlerTableFunctionsShowValues(0,'all')
        
# update status line
        maxLinesDisplay = int(self.comboboxMaxLinesToDisplay.get())
        if maxLinesDisplay == 0 or maxLinesDisplay > len(self.tableValues):
            maxLinesDisplay = len(self.tableValues)

        self.handlerStatusLineRefresh(maxLinesDisplay)
 
# re-set indices for self.varXSelect and self.varYSelect
        self.resetVarXYSelect()
        
# restore checked fields
        self.restoreCheckedFieldNames()  
        
        return
        
        
    def checkIsFieldNumerical(self,varFirst2LettersOfDatatype):
        '''
        Purpose:
            check if selected field has datatype structure of
            numerical
            
        Called by:
            handlerTableValuesNumericalOnly
        
        Calls:
            None
        
        Input variables:
            varDatatype[0:2]    first two letters of the field's datatype
            
        Output variables:
            1       field is numerical
            0       field is text
           -1       field datatype has not been found in the list of 
                        valid types; this results in a recoverable error           
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'checkIsFieldNumericalOrText')
            
# set to 1 to print
        DEBUG_FIELDISNUMERICAL = 0
            
        vf2 = varFirst2LettersOfDatatype
        if (vf2 == 'de' or vf2 == 'do' or
            vf2 == 'fl' or vf2 == 'in' or
            vf2 == 'sm'):
# field is numerical
            if DEBUG_FIELDISNUMERICAL:
                print 'field is numerical: vf2 = "%s"\n' % (vf2)
            return 1           
        elif (vf2 == 'ch' or vf2 == 'da' or
              vf2 == 'lo' or vf2 == 'me' or
              vf2 == 'te' or vf2 == 'ti' or
              vf2 == 'va' or vf2 == 'ti' or
              vf2 == 'bl' or vf2 == 'en' or
              vf2 == 'et'):
            if DEBUG_FIELDISNUMERICAL:
                print 'field is NOT numerical: vf2 = "%s"\n' % (vf2)
# field is text
            return 0
        else:
# field is undefined
            print 'Error: field is undefined! vf2 = "%s"' % (vf2)
            print '  This should not happen. Check code logic.'
            return -1
            
        return
            
        
    def checkIsFieldText(self,varFirst2LettersOfDatatype):
        '''
        Purpose:
            check if selected field has datatype structure of
            text
            
        Called by:
            handlerTableValuesTextOnly
        
        Calls:
            None
        
        Input variables:
            varDatatype[0:2]    first two letters of the field's datatype
            
        Output variables:
            1       field is text
            0       field is numerical
           -1       field datatype has not been found in the list of 
                        valid types; this results in a recoverable error
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'checkIsFieldText')
            
# set to 1 to print
        DEBUG_FIELDISTEXTORNUMERICAL = 0
            
        vf2 = varFirst2LettersOfDatatype
        if (vf2 == 'ch' or vf2 == 'da' or
              vf2 == 'lo' or vf2 == 'me' or
              vf2 == 'te' or vf2 == 'ti' or
              vf2 == 'va' or vf2 == 'ti' or
              vf2 == 'bl' or vf2 == 'en' or
              vf2 == 'et'):
# field is text
            if DEBUG_FIELDISTEXTORNUMERICAL:
                print 'field is text: vf2 = "%s"\n' % (vf2)
            return 1           
        elif (vf2 == 'de' or vf2 == 'do' or
              vf2 == 'fl' or vf2 == 'in' or
              vf2 == 'sm'):
# field is numerical
            if DEBUG_FIELDISTEXTORNUMERICAL:
                print 'field is numerical: vf2 = "%s"\n' % (vf2)
            return 0
        else:
# field is undefined
            print 'Error: field is undefined! vf2 = "%s"' % (vf2)
            print '  This should not happen. Check code logic.'
            return -1
            
        return
            
        
    def handlerSelectYNumericalOrAll(self):
        '''
        Purpose:
            selects all Y-Select values (for writing out to a file, for example), 
            or just the numerical Y values (for plots)
            
        Called by:
            handlerTableFunctionsShowValues
        
        Calls:
        
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerSelectYNumericalOrAll')
            
# check if a table has even been read in 
        emptyTableCheck = self.checkIfEmptyTable()
        if emptyTableCheck:
            return
        
# clear all Y-Select boxes in Table Values window
        self.handlerClearAllY()
        
# clear all Y-Select boxes in Quik Select window
        try:
            [self.varCheckbuttonsQuikSelectY[i].set(0) for i in range(len(self.tableStructure))]
        except:
            pass
            
# select just numerical fields only
        if self.varSelectYNumericalOrAll.get():     # possible values are 0 (up) or 1 (down)
# check all Y-Select boxes, except the one below which X-Select is possibly picked
            varDatatype = ''
            for key,value in self.dictColumnHeaders.iteritems():
# check if field is numerical or text; if text, ignore
                for struct in self.tableStructure:
                    if struct[0] == key:
                        varDatatype = struct[1]
                        break
                if varDatatype == '':
                    print '\nError: varDatatype not found in search thru self.tableStructure'
                    self.MySQL_Output(
                        1,
                        'Error: varDatatype not found in search thru self.tableStructure'
                        )
                    showerror(
                        'Error: varDatatype not found',
                        '\nvarDatatype not found in search thru self.tableStructure.' + '\n' +
                        '  This should not have happened, so cause is unknown.' + '\n\n' + 
                        '  Look in ' + MODULE + '/' + 'handerlSelectAllNumericalY\n' +
                        '  for cause.'
                        )
                    return
             
# set Y-Select only if it is numerical and not equal to x-select if x-select has been selected;
#  also, field must not be the auto_increment field
                varfirst2 = varDatatype[0:2]
                fieldIsNumerical = self.checkIsFieldNumerical(varfirst2)
                if fieldIsNumerical:
                    headerCount=0
                    for header in self.varYSelect:
                        headerCount += 1
                        if value == headerCount and \
                        self.varXSelect.get() <> headerCount and \
                        struct[5] <> 'auto_increment':
                            header.set(1)


# set button text in Table Values window
            self.varstringSelectYNumericalOrAll.set(self.buttontextYAll)
            
# set button text in Quik Select window if mapped
            try:
                mapped = self.toplevelQuikSelectXY.winfo_exists()
            except:
                mapped = False
                
            if mapped:
# set button text in Quik Select window
                self.varstringQuikSelectYNumericalOrAll.set(self.buttontextQuikSelectYAll)
# select Quik Select button
                self.checkbuttonQuikSelectYNumericalOrAll.select()
                           
        else:
        
# select all y values, including x if selected and auto-increment
            [self.varYSelect[i].set(1) for i in range(len(self.varYSelect))]
            
# set button text in Table Values window
            self.varstringSelectYNumericalOrAll.set(self.buttontextYNumerical)
            
# set button text in Quik Select window if mapped
            try:
                mapped = self.toplevelQuikSelectXY.winfo_exists()
            except:
                mapped = False
                
            if mapped:
# set button text in Quik Select window
                self.varstringQuikSelectYNumericalOrAll.set(self.buttontextQuikSelectYNumerical)            
# de-select Quik Select button
                self.checkbuttonQuikSelectYNumericalOrAll.deselect()

# ------------
                
# set number of y selections in Table Values window; includes Quik Select window
        self.handlerDisplayNumberOfYValuesSelected()
        
        return


    def handlerClearAllY(self):
        '''
        Purpose:
            Clears all Y-Select values
            
        Called by:
            handlerTableFunctionsShowValues
            
        Calls:
        
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerClearAllY')
            
# set last button pressed
        self.lastButtonPressed(
            BUTTONLABEL_DESELECTALLY
            )
            
# check if a table has even been read in 
        emptyTableCheck = self.checkIfEmptyTable()
        if emptyTableCheck:
            return

# set Y-Select           
        for key,value in self.dictColumnHeaders.iteritems():                   
            for i,header in enumerate(self.varYSelect):
                if value == i+1:
                    header.set(0)
                    break
                    
# set number of y selections in Table Values window
        self.handlerDisplayNumberOfYValuesSelected()
                    
        return
        
        
    def handlerDisplayedRowsDelete(self):
        '''
        Purpose:
            Delete displayed rows after being selected and
            displayed by user. This is the only method in MySQL
            to delete rows in a table.
            
        Called by:
            handlerOptionsTableManagement
        
        Calls:
            None
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerDisplayedRowsDelete')
            
        myTable = self.myTable
        myDatabase = self.myDatabase
        
# save checked field headers
        self.saveCheckedFieldNames()
        
# check if WHERE string exists; if not, do NOT continue, as DELETE command will 
#    affect whole table and this is NOT what is intended!!
        if not self.stringCommandWhere:
            stringNoWhereOperators = (
                'The DELETE command is attempting to be used without' + '\n' +
                '    WHERE operators being specified. This is NOT allowed since this' + '\n'
                '    will result in the entire table being deleted.' + '\n\n' +
                'Table deletion can only be executed from the' + '\n'
                '    main window of PylotDB, not here.' + '\n\n' +
                'Select WHERE operators and try again.' + '\n'
                )
            print (
                '\n' + stringNoWhereOperators
                )
            self.MySQL_Output(
                1,
                stringNoWhereOperators
                )
            showerror(
                'Error: no WHERE operators',
                '\n' + stringNoWhereOperators + '\n\n'
                )
# destroy "Table Management Options" window
            self.toplevelOptionsTableManagement.destroy()
            return
            
# check if number of lines to be deleted equal the tables original number of lines.
#    If so, the whole table will be deleted and this is NOT what is intended.
        rowsDisplayed = len(self.tableValues)
        rowsOriginal = len(self.tableValuesOriginal)
        print '\nrowsDisplayed = %s, rowsOriginal = %s' % (rowsDisplayed,rowsOriginal)
        
# put together the DELETE-FROM-WHERE command
        stringCommand = 'DELETE '
        
# add FROM 
        stringCommand += 'FROM '

# specify the database and table
        stringCommand += myDatabase + '.' + myTable + ' '
        
# take 'WHERE' string from method "handlerDisplayOrderedFields"
        stringCommand += self.stringCommandWhere
        
# print entire string
        stringPrintCommand = (
            'self.cursorHandleMySQL.execute("' + stringCommand + '")'
            )
        print('\n' + stringPrintCommand) 
        self.MySQL_Commands(
            1,
            stringPrintCommand
            )
            

        if rowsDisplayed == rowsOriginal:
# allows deleting entire table but keeps table structure; in other words,
#   all entries are deleted and an empty table remains
            stringRowsOriginal = (
                'WARNING:\n' +
                '  The DELETE command as used will delete ALL entries in\n\n' +
                '    database: %s\n' +
                '    table: %s\n\n' +
                '  An empty table will remain.\n\n' +
                '  Are you sure you want to empty all table entries?'
                ) % (
                myDatabase,
                myTable
                )
            print (
                '\n' + stringRowsOriginal
                )
            self.MySQL_Output(
                1,
                stringRowsOriginal
                )
            ans = askokcancel(
                'Delete all entries ...',
                stringRowsOriginal
                )
            if not ans:
                return  
                
        else:
            stringCancel = (
                'You are about to delete %s of %s total rows from\n\n' +
                '  database: %s\n' +
                '  table: %s\n\n' + 
                'Do you wish to continue?'
                ) % (
                rowsDisplayed,
                rowsOriginal,
                myDatabase,
                myTable
                )
            
            ans = askokcancel(
                'Delete rows',
                stringCancel
                )
            if not ans:
                return

# execute command
        try:
            self.cursorHandleMySQL.execute(stringCommand)
            self.toplevelOptionsTableManagement.destroy()
        except:
            print(
                '\nError in MySQL command string.\n' +
                ' Examine following command string for errors and try again.\n' +
                ' Command string:\n' +
                '   ' + stringCommand
                )
            showerror(
                'Error: bad MySQL command string',
                '\nExamine following command string for errors and try again.\n\n' +
                'Command string:\n\n' +
                stringCommand
                )
            self.toplevelOptionsTableManagement.destroy()
            return
            
# re-order the auto_index field
        if(
        self.varCheckbuttonResequenceAutoIndex.get()
        and
        (rowsDisplayed <> rowsOriginal)
        ):
            self.resequenceAutoIncrementPrimaryKeyField(
                self.toplevelSelectDisplayOrderedFields
                )
                
# look for auto_index field
        flagAutoIndex = False
        for eachItem in self.tableStructureOriginal:
            if 'auto_index' in eachItem:
                flagAutoIndex = True
                break
 
# get all values from database table      
        if flagAutoIndex:
            stringGetAllFields = (
                'SELECT * FROM ' + self.myDatabase + '.' + self.myTable
                + ' order by auto_index'
                )
        else:
            stringGetAllFields = (
                'SELECT * FROM ' + self.myDatabase + '.' + self.myTable
                )
                
        self.cursorHandleMySQL.execute(stringGetAllFields)
        self.tableValues = self.cursorHandleMySQL.fetchall()
        self.tableValuesOriginal = self.tableValues
        
# no need to do anything with self.tableStructure since this attribute was not changed
#        print '\n Sorted Table Values:'
#        print self.tableValues

# display (refresh database table)
        self.valuesDisplayRowDecimate(self.tableStructure,self.tableValues)
        
        '''
        try:
            mapped = self.toplevelTableValues.winfo_exists()
        except:
            mapped = False
        
# recheck all fields that were originally checked
        if mapped:  
            self.restoreCheckedFieldNames()
#            showinfo(
#                'restore',
#                'checkmarks have been restored - 3'
#                )
        '''
        
# update status line
        maxLinesDisplay = int(self.comboboxMaxLinesToDisplay.get())
        if maxLinesDisplay == 0 or maxLinesDisplay > len(self.tableValues):
            maxLinesDisplay = len(self.tableValues)
        self.handlerStatusLineRefresh(maxLinesDisplay)
        
# reset indices for checked field headers
        self.resetVarXYSelect()
        
# restore checked field headers
        self.restoreCheckedFieldNames()
        
        return
        
        
    def handlerDisplayedRowsUpdate(self):
        '''
        Purpose:
            Update displayed rows after being selected and 
            displayed by user.
            
        Called by:
            handlerOptionsTableManagement
            
        Calls:
            None:
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerDisplayedRowsUpdate')
            
        self.notYetImplemented()
        
        return
            
            
    def handlerAllRowsClearOrSelect(self):
        '''
        Purpose:
            select or de-select all selected rows in 
            currently displayed table
            
        Called by:
            handlerTableFunctionsShowValues
        
        Calls:
        
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerAllRowsClearOrSelect')
            
# set last button pressed
        self.lastButtonPressed(
            BUTTONLABEL_CLEARSELECTALL
            )
            
# check if a table has even been read in 
        emptyTableCheck = self.checkIfEmptyTable()
        if emptyTableCheck:
            return
            
        if DEBUG_CLEARSELECTALL:
            print('\n=====\nself.varAllRowsClearOrSelect.get().strip() = %s' 
                % self.varAllRowsClearOrSelect.get()
                )
        
        if self.varAllRowsClearOrSelect.get():
# loop for selecting all rows
            try:
                for var in self.varSelectAnyRow:
                    var.set(1)
            except:
                pass
        else:
# loop for de-selecting all rows
            try:
                for var in self.varSelectAnyRow:
                    var.set(0)
            except:
                pass
                
# display count
        self.displayNumberOfRowsSelected_Table('')
                
        return
        
        
    def displayNumberOfRowsSelected_Table(self,event):
        '''
        Purpose:
            count number of rows checked in table, then display in widget
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'displayNumberOfRowsSelected')

        if DEBUG_ROWSELECT_TABLE:
            print('\nCALLED: NUMBER OF TABLE ROWS SELECTED')
            for number,var in enumerate(self.varSelectAnyRow):
                print('#%s. %s' % (number+1, var.get()))
            print('')     
        
# calculate number of rows checked
        iCount = 0
        for var in self.varSelectAnyRow:
            if var.get():
                iCount += 1
                
        self.varEntryNumberOfRowsSelected.set(iCount)
        
        return
        
        
    def displayNumberOfRowsSelected_Buffer(self,event):
        '''
        Purpose:
            count number of rows checked in buffer, then display in widget
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'displayNumberOfRowsSelected_buffer')

        if DEBUG_ROWSELECT_BUFFER:
            print('\nCALLED: NUMBER OF BUFFER ROWS SELECTED')
            for number,var in enumerate(self.varSelectAnyRow_Buffer):
                print('#%s. %s' % (number+1, var.get()))
            print('')     
        
# calculate number of rows checked
        iCount = 0
        for var in self.varSelectAnyRow_Buffer:
            if var.get():
                iCount += 1
                
        self.varEntryNumberOfRowsSelected_Buffer.set(iCount)
        
        return
      
      
    def handlerTableValuesSelectedRows(self):
        '''
        Purpose:
            display table fields that have been row-selected
            
        Called by:
            handlerTableFunctionsShowValues
        
        Calls:
        
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerTableValuesSelectedRows')
            
# set last button pressed
        self.lastButtonPressed(
            BUTTONLABEL_SHOWSELECTEDROWS
            )
            
# check if connected to a MySQL server
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return 
        
# check if a table has even been read in 
        emptyTableCheck = self.checkIfEmptyTable()
        if emptyTableCheck:
            return
            
# save checked fields
        self.saveCheckedFieldNames()  

# zero-out temp list
        temp_tableValues = []

# re-form self.tableValues
        rowCount = 0
        flag_VarGet = 0
        print('\n\nlen(self.tableValues), len(self.varSelectAnyRow) = %s, %s\n\n' % (
            len(self.tableValues), len(self.varSelectAnyRow)
            )
             )
        if len(self.varSelectAnyRow) > 0:
            for var in self.varSelectAnyRow:
                if var.get():
                    flag_VarGet = 1
                    temp_tableValues.append(self.tableValues[rowCount])
                rowCount+=1
            
# check if any rows found
        if not flag_VarGet:
            stringVarGet = (
                'No rows have been selected.' + '\n\n' +
                '  To use this option, select rows' + '\n' +
                '  and try again.' + '\n'
                )
            print(
                stringVarGet + '\n'
                )
            self.MySQL_Output(
                1,
                stringVarGet + '\n'
                )
            showinfo(
                'Warning: no rows selected',
                '\n' + stringVarGet + '\n'
                )
            return
                
# reassign back to proper names        
        self.tableValues = ()
        self.tableValues = tuple(temp_tableValues)
        
# save checked field names before re-defining self.dictColumnHeadersOriginal
        self.saveCheckedFieldNames()
        
# display results
#        self.valuesDisplayRowDecimate(self.tableStructure,self.tableValues)
        self.handlerTableFunctionsShowValues(0,'all')
        
# update status line
        maxLinesDisplay = int(self.comboboxMaxLinesToDisplay.get())
        if maxLinesDisplay == 0 or maxLinesDisplay > len(self.tableValues):
            maxLinesDisplay = len(self.tableValues)
        '''
        try:
            maxLinesDisplay = int(self.comboboxMaxLinesToDisplay.get())
            if maxLinesDisplay > len(self.tableValues):
                maxLinesDisplay = len(self.tableValues)
        except:
            maxLinesDisplay = len(self.tableValues)
        '''
            
        self.handlerStatusLineRefresh(maxLinesDisplay)
        
# restore checked fields
        self.restoreCheckedFieldNames()  
        
        return
        
        
    def handlerStatusLineRefresh(self,numRows):
        '''
        Purpose:
            refresh the status line variables
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerStatusLineRefresh')
            
# check if connected to a MySQL server
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return 
        
# check if a table has even been read in
        if len(self.tableValuesOriginal) == 0:
            return

# calculate status line variables to display
#        statusLine_linesTotal = len(self.tableValuesOriginal)
        statusLine_linesTotal = self.totalRowsInTable()
        statusLine_rowsDisplayed = numRows
        if len(self.tableValuesOriginal) > 0:
            statusLine_columnsTotal = len(self.tableValuesOriginal[0])
        else:
            statusLine_columnsTotal = 0
        if len(self.tableValues) > 0:
            statusLine_columnsDisplayed = len(self.tableValues[0])
        else:
            statusLine_columnsDisplayed = 0
# refresh variables
# ... total lines
#        self.entryTotalLines.configure(state='normal')
        self.varEntryTotalLines.set(statusLine_linesTotal)
#        self.entryTotalLines.configure(state='disabled')
# ... loaded rows
        self.varEntryLoadedRows.set(len(self.tableValues))
# ... current rows
#        self.entryDisplayedRows.configure(state='normal')
        self.varEntryDisplayedRows.set(statusLine_rowsDisplayed)
        
#        self.entryDisplayedRows.configure(state='disabled')
# ... total columns
#        self.entryTotalCols.configure(state='normal')
        self.varEntryTotalCols.set(statusLine_columnsTotal)
#        self.entryTotalCols.configure(state='disabled')
# ... current columns
#        self.entryDisplayedColumns.configure(state='normal')
        self.varEntryDisplayedColumns.set(statusLine_columnsDisplayed)
#        self.entryDisplayedColumns.configure(state='disabled')

        return
        
        
    def handlerDeselectX(self):
        '''
        Purpose: 
            deselects any X-Select radiobutton
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerDeselectX')
            
# set last button pressed
        self.lastButtonPressed(
            BUTTONLABEL_DESELECTX
            )
            
# check if a table has even been read in 
        emptyTableCheck = self.checkIfEmptyTable()
        if emptyTableCheck:
            return
            
        '''         
# if Plotting Specs window open, give user chance to cancel
        try:
            mapped = self.toplevelXYPlotPreprocess.winfo_exists()
        except:
            mapped = 0
            
        if mapped:
            stringMapped = (
                'De-selecting X value can cause problems with plotting.' + '\n\n' +
                'Hence, pressing OK will cause the "Plotting Specs"' + '\n' + 
                'window to be closed.' + '\n\n' +
                'Do you wish to continue?' + '\n\n'
                )
            okay = askokcancel(
                'Warning: plot window',
                stringMapped
                )
            if okay:
                self.plottingspecs_xWindowLocation_XY= self.toplevelXYPlotPreprocess.winfo_rootx()
                self.plottingspecs_yWindowLocation_XY= self.toplevelXYPlotPreprocess.winfo_rooty()
                self.toplevelXYPlotPreprocess.destroy()
            else:
                return  
            '''

# blank the display in Table Values window
        self.varEntryXValueSelected.set('')
# clear X radiobutton in Table Values window            
        self.varXSelect.set(0)

# set field to empty in Quik Select window if mapped
        try: 
            mapped = self.toplevelQuikSelectXY.winfo_exists()
        except:
            mapped = False
            
        if mapped:
# set field to blank
            self.varEntryQuikSelectXValueSelected.set('')
# clear radiobutton selection
            self.varRadiobuttonsQuikSelectX.set(0)
        
        return
        
                        
    def handlerSelectSingleOrMultiCurvePlots(self):
        '''
        Purpose:
            to select Single or Multi-Curves Per Plot 
                plotting specs using radio- and check-buttons
            
        Called by:
            handlerXYPlotPreprocess
        
        Calls:
        
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerSelectSingleOrMultiCurvePlots')
            
        plotSelection = self.varCurvesSelection.get()
        
        if plotSelection == 'single':
# SINGLE CURVE PER PLOT variables
# enable main title
            self.checkbuttonShowMainTitle_SingleCurvePerPlot.configure(state='normal')
            if self.varShowMainTitle_SingleCurvePerPlot.get():
                self.entryMainTitle_SingleCurvePerPlot.configure(state='normal')
                self.handlerRefreshMainTitleSize_SingleCurvePerPlot(1)
            else:
                self.entryMainTitle_SingleCurvePerPlot.configure(state='disabled')
                self.handlerRefreshMainTitleSize_SingleCurvePerPlot(0)
                
# enable title for single curve
            self.checkbuttonShowTitles_SingleCurvePerPlot.configure(state='normal')
            if self.varShowTitles_SingleCurvePerPlot.get():
#                self.comboboxFontTitle_SingleCurvePerPlot._entryWidget['state']=NORMAL
                self.handlerRefreshYLabelSize_SingleCurvePerPlot(1)
            else:
#                self.comboboxFontTitle_SingleCurvePerPlot._entryWidget['state']=DISABLED
                self.handlerRefreshYLabelSize_SingleCurvePerPlot(0)
                
# enable show grid for single curve
            self.checkbuttonShowGrid_SingleCurvePerPlot.configure(state='normal')
            
# ... single - show grids
            self.checkbuttonShowGrid_SingleCurvePerPlot.configure(state='normal')
            
            '''
# ... single - xy-labels font and color
            self.comboboxFontLabels_SingleCurvePerPlot._entryWidget['state']=NORMAL
            self.comboboxColorLabels_SingleCurvePerPlot._entryWidget['state']=NORMAL
# ... single - x-ticks font and color
            self.comboboxFontXTicks_SingleCurvePerPlot._entryWidget['state']=NORMAL
            self.comboboxColorXTicks_SingleCurvePerPlot._entryWidget['state']=NORMAL
# ... single - y-ticks font and color
            self.comboboxFontYTicks_SingleCurvePerPlot._entryWidget['state']=NORMAL
            self.comboboxColorYTicks_SingleCurvePerPlot._entryWidget['state']=NORMAL
# ... single - background
            self.comboboxColorBackground_SingleCurvePerPlot._entryWidget['state']=NORMAL
            '''
# ... single - xy-labels, x-ticks, y-ticks fonts and colors; background color
            self.handlerRefreshColors_SingleCurvePerPlot(1)

# MULTICURVE PER PLOT variables
# de-select the All Curves On One Plot radiobutton
#            self.radiobuttonAllCurvesOnePlot.deselect()
# disable checkbuttons
            self.checkbuttonShowTitle_AllCurvesOnePlot.configure(state='disabled')
            self.checkbuttonShowLabelY_AllCurvesOnePlot.configure(state='disabled')
            self.checkbuttonShowLabelX_AllCurvesOnePlot.configure(state='disabled')
            self.checkbuttonShowLegend_AllCurvesOnePlot.configure(state='disabled')
            self.checkbuttonShowGrid_AllCurvesOnePlot.configure(state='disabled')
            self.checkbuttonShowReferenceCurve_AllCurvesOnePlot.configure(state='disabled')
# disable title, y label, and x label
            self.entryShowTitle_AllCurvesOnePlot.configure(state='disabled')
            self.entryShowLabelY_AllCurvesOnePlot.configure(state='disabled')
#            self.entryShowLabelX_AllCurvesOnePlot.configure(state='disabled')
            self.comboboxShowLabelX_AllCurvesOnePlot._entryWidget['state']=DISABLED
# disable comboboxes for reference curve
            self.comboboxShowReferenceCurveMultiplier_AllCurvesOnePlot._entryWidget['state']=DISABLED
            self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot._entryWidget['state']=DISABLED

# disable comboboxes for sloped straight-line reference curve
# ... sloped straight-line reference curve
            self.checkbuttonShowSlopedStraightReferenceCurve_AllCurvesOnePlot.configure(state='disabled')
            self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xinitial.configure(entry_state='disabled')
            self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xfinal.configure(entry_state='disabled')
            self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yinitial.configure(entry_state='disabled')
            self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yfinal.configure(entry_state='disabled')
            self.checkbuttonLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot.configure(state='disabled')
            self.entryfieldLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot.configure(entry_state='disabled')
            self.checkbuttonLabelSlopeDegreesSlopedStraightReferenceCurve_AllCurvesOnePlot.configure(state='disabled')
            
# disable comboboxes for horizontal straight-line reference curve
# ... horizontal straight-line reference curve
            self.checkbuttonShowHorizontalStraightReferenceCurve_AllCurvesOnePlot.configure(state='disabled')
            self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xinitial.configure(entry_state='disabled')
            self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xfinal.configure(entry_state='disabled')
            self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Y.configure(entry_state='disabled')
            self.checkbuttonLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot.configure(state='disabled')
            self.entryfieldLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot.configure(entry_state='disabled')
            self.checkbuttonLabelYMaxHorizontalStraightReferenceCurve_AllCurvesOnePlot.configure(state='disabled')

# disable comboboxes for vertical straight-line reference curve
# ... vertical straight-line reference curve
            self.checkbuttonShowVerticalStraightReferenceCurve_AllCurvesOnePlot.configure(state='disabled')
            self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yinitial.configure(entry_state='disabled')
            self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yfinal.configure(entry_state='disabled')
            self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_X.configure(entry_state='disabled')
            self.checkbuttonLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot.configure(state='disabled')
            self.entryfieldLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot.configure(entry_state='disabled')
            self.checkbuttonLabelXMaxVerticalStraightLineReferenceCurve_AllCurvesOnePlot.configure(state='disabled')

# disable plot x-y from CSV file
            self.checkbuttonPlotCsvFileData_AllCurvesOnePlot.configure(state='disabled')
            self.entryPlotCsvFileData_AllCurvesOnePlot.configure(state='disabled')
            self.comboboxPlotCsvFileData_X_Column_AllCurvesOnePlot._entryWidget['state'] = DISABLED
            self.comboboxPlotCsvFileData_Y_Column_AllCurvesOnePlot._entryWidget['state'] = DISABLED
# disable show legend
            self.checkbuttonShowLegend_AllCurvesOnePlot.configure(state='disabled')
            self.comboboxShowLegendLocation_AllCurvesOnePlot._entryWidget['state'] = DISABLED
            self.comboboxFontLegend_AllCurvesOnePlot._entryWidget['state'] = DISABLED
# disable font sizes
            self.comboboxFontTitle_AllCurvesOnePlot._entryWidget['state'] = DISABLED
            self.comboboxFontXYLabels_AllCurvesOnePlot._entryWidget['state'] = DISABLED
            self.comboboxFontLegend_AllCurvesOnePlot._entryWidget['state']=DISABLED
            self.comboboxFontXTicks_AllCurvesOnePlot._entryWidget['state'] = DISABLED
            self.comboboxFontYTicks_AllCurvesOnePlot._entryWidget['state'] = DISABLED
# disable color
            '''
            self.comboboxColorXYLabels_AllCurvesOnePlot._entryWidget['state'] = DISABLED
            self.comboboxColorXTicks_AllCurvesOnePlot._entryWidget['state'] = DISABLED
            self.comboboxColorYTicks_AllCurvesOnePlot._entryWidget['state'] = DISABLED
            self.comboboxColorBackground_AllCurvesOnePlot._entryWidget['state'] = DISABLED
            '''
            self.handlerRefreshXYLabelsColor_AllCurvesOnOnePlot(0)
            self.handlerRefreshColors_AllCurvesOnOnePlot(0)
            self.comboboxColorTitle_AllCurvesOnePlot._entryWidget['state'] = DISABLED
# show appropriate labels window
            '''
# ... kill label window            
            try:
                self.toplevelLabelsSinglePlotPerCurve.destroy()
            except:
                pass
# ... kill legend window            
            try:
                self.toplevelLegendLabelsAllCurvesOnePlot.destroy()
            except:
                pass
            '''
            
            
# trying to keep windows from being presented multiple times, but keep the data
 
# display label window
            try:
                existsLabelsSingle = self.toplevelLabelsSinglePlotPerCurve.winfo_exists()
            except:
                existsLabelsSingle = 0
            
            if not existsLabelsSingle:
                self.labels_SingleCurvePerPlot(
                    self.labels_xWindowLocationSingle,
                    self.labels_yWindowLocationSingle
                    )
            else:
                try:
                    self.toplevelLabelsSinglePlotPerCurve.deiconify()
                except:
                    pass
#                self.toplevelLabelsSinglePlotPerCurve.lift(self.toplevelLegendLabelsAllCurvesOnePlot)
#                self.toplevelLabelsSinglePlotPerCurve.lift(self.toplevelXYPlotPreprocess)
                self.toplevelLabelsSinglePlotPerCurve.lift()
# iconify Legend Labels window
            try:
                existsLabelsAll = self.toplevelLegendLabelsAllCurvesOnePlot.winfo_exists()
            except:
                existsLabelsAll = False
                
            if existsLabelsAll:
                try:
#                    self.toplevelLegendLabelsAllCurvesOnePlot.iconify()
                    self.toplevelLegendLabelsAllCurvesOnePlot.withdraw()
                except:
                    pass

                
# can also use...
#                self.toplevelLegendLabelsAllCurvesOnePlot.withdraw()
    
        elif plotSelection == 'all':
            
#        self.radiobuttonAllCurvesOnePlot.select()
#        self.radiobuttonSingleCurvePerPlot.deselect()
        
# SINGLE CURVE PER PLOT variables
# ... main title
            self.checkbuttonShowMainTitle_SingleCurvePerPlot.configure(state='disabled')
            self.entryMainTitle_SingleCurvePerPlot.configure(state='disabled')
            self.handlerRefreshMainTitleSize_SingleCurvePerPlot(0)
            
# ... individual plot titles
            self.checkbuttonShowTitles_SingleCurvePerPlot.configure(state='disabled')
#            self.comboboxFontTitle_SingleCurvePerPlot._entryWidget['state']=DISABLED
            self.handlerRefreshYLabelSize_SingleCurvePerPlot(0)
            
# ... grid
            self.checkbuttonShowGrid_SingleCurvePerPlot.configure(state='disabled')
            '''
# ...       labels font and color - disable
            self.comboboxFontLabels_SingleCurvePerPlot._entryWidget['state']=DISABLED
            self.comboboxColorLabels_SingleCurvePerPlot._entryWidget['state']=DISABLED
# ...       x-ticks size and color - disable
            self.comboboxFontXTicks_SingleCurvePerPlot._entryWidget['state']=DISABLED
            self.comboboxColorXTicks_SingleCurvePerPlot._entryWidget['state']=DISABLED
# ...       y-ticks size and color - disable
            self.comboboxFontYTicks_SingleCurvePerPlot._entryWidget['state']=DISABLED
            self.comboboxColorYTicks_SingleCurvePerPlot._entryWidget['state']=DISABLED
# ...       background color
            self.comboboxColorBackground_SingleCurvePerPlot._entryWidget['state'] = DISABLED
            '''
            
# ... single - xy-labels, x-ticks, y-ticks fonts and colors; background color
            self.handlerRefreshColors_SingleCurvePerPlot(0)
     
# MULTICURVE PER PLOT variables
# enable checkbuttons
# ... title and title font
            self.checkbuttonShowTitle_AllCurvesOnePlot.configure(state='normal')
            if self.varCheckbuttonShowTitle_AllCurvesOnePlot.get():
                self.entryShowTitle_AllCurvesOnePlot.configure(state='normal')
                self.comboboxFontTitle_AllCurvesOnePlot._entryWidget['state'] = NORMAL
                self.comboboxColorTitle_AllCurvesOnePlot._entryWidget['state'] = NORMAL
            else:
                self.entryShowTitle_AllCurvesOnePlot.configure(state='disabled')
                self.comboboxFontTitle_AllCurvesOnePlot._entryWidget['state'] = DISABLED
                self.comboboxColorTitle_AllCurvesOnePlot._entryWidget['state'] = DISABLED
# ... label y
            self.checkbuttonShowLabelY_AllCurvesOnePlot.configure(state='normal')
            if self.varCheckbuttonShowLabelY_AllCurvesOnePlot.get():
                self.entryShowLabelY_AllCurvesOnePlot.configure(state='normal')
            else:
                self.entryShowLabelY_AllCurvesOnePlot.configure(state='disabled')
# ... label x
            self.checkbuttonShowLabelX_AllCurvesOnePlot.configure(state='normal')
            if self.varCheckbuttonShowLabelX_AllCurvesOnePlot.get():
#                self.entryShowLabelX_AllCurvesOnePlot.configure(state='normal')
                self.comboboxShowLabelX_AllCurvesOnePlot._entryWidget['state'] = NORMAL
            else:
#                self.entryShowLabelX_AllCurvesOnePlot.configure(state='disabled')
                self.comboboxShowLabelX_AllCurvesOnePlot._entryWidget['state'] = DISABLED
# ... label x-y font
            if (
              self.varCheckbuttonShowLabelY_AllCurvesOnePlot.get() 
              or
              self.varCheckbuttonShowLabelX_AllCurvesOnePlot.get()
              ):
                self.comboboxFontXYLabels_AllCurvesOnePlot._entryWidget['state']=NORMAL
                '''
                self.comboboxColorXYLabels_AllCurvesOnePlot._entryWidget['state']=NORMAL
                '''
                self.handlerRefreshXYLabelsColor_AllCurvesOnOnePlot(1)
# show appropriate labels window
            else:
                self.comboboxFontXYLabels_AllCurvesOnePlot._entryWidget['state']=DISABLED
#                self.comboboxColorXYLabels_AllCurvesOnePlot._entryWidget['state']=DISABLED
                self.handlerRefreshXYLabelsColor_AllCurvesOnOnePlot(0)
# show appropriate labels window
# ... legend
            self.checkbuttonShowLegend_AllCurvesOnePlot.configure(state='normal')
            if self.varCheckbuttonShowLegend_AllCurvesOnePlot.get():
                self.comboboxShowLegendLocation_AllCurvesOnePlot._entryWidget['state']=NORMAL
                self.comboboxFontLegend_AllCurvesOnePlot._entryWidget['state']=NORMAL
            else:
                self.comboboxShowLegendLocation_AllCurvesOnePlot._entryWidget['state']=DISABLED
                self.comboboxFontLegend_AllCurvesOnePlot._entryWidget['state']=DISABLED
# ... grid
            self.checkbuttonShowGrid_AllCurvesOnePlot.configure(state='normal')
# ... reference curve
            self.checkbuttonShowReferenceCurve_AllCurvesOnePlot.configure(state='normal')                  
# ...       enable/disable comboboxes for reference curve, depending on if 'All Curves' radiobutton and 'Show reference curve' checkbuttons are checked
            if self.varCheckbuttonShowReferenceCurve_AllCurvesOnePlot.get():
                self.comboboxShowReferenceCurveMultiplier_AllCurvesOnePlot._entryWidget['state']=NORMAL
                self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot._entryWidget['state']=NORMAL
            else:
                self.comboboxShowReferenceCurveMultiplier_AllCurvesOnePlot._entryWidget['state']=DISABLED
                self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot._entryWidget['state']=DISABLED

# ... sloped straight-line reference curve
            self.checkbuttonShowSlopedStraightReferenceCurve_AllCurvesOnePlot.configure(state='normal')
            if self.varCheckbuttonShowSlopedStraightReferenceCurve_AllCurvesOnePlot.get():
                self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xinitial.configure(entry_state='normal')
                self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xfinal.configure(entry_state='normal')
                self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yinitial.configure(entry_state='normal')
                self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yfinal.configure(entry_state='normal')
                self.checkbuttonLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot.configure(state='normal')
                self.entryfieldLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot.configure(entry_state='normal')
                self.checkbuttonLabelSlopeDegreesSlopedStraightReferenceCurve_AllCurvesOnePlot.configure(state='normal')
            else:
                self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xinitial.configure(entry_state='disabled')
                self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xfinal.configure(entry_state='disabled')
                self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yinitial.configure(entry_state='disabled')
                self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yfinal.configure(entry_state='disabled')
                self.checkbuttonLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot.configure(state='disabled')
                self.entryfieldLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot.configure(entry_state='disabled')
                self.checkbuttonLabelSlopeDegreesSlopedStraightReferenceCurve_AllCurvesOnePlot.configure(state='disabled')
                
# ... horizontal straight-line reference curve
            self.checkbuttonShowHorizontalStraightReferenceCurve_AllCurvesOnePlot.configure(state='normal')
            if self.varCheckbuttonShowHorizontalStraightReferenceCurve_AllCurvesOnePlot.get():
                self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xinitial.configure(entry_state='normal')
                self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xfinal.configure(entry_state='normal')
                self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Y.configure(entry_state='normal')
                self.checkbuttonLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot.configure(state='normal')
                self.entryfieldLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot.configure(entry_state='normal')
                self.checkbuttonLabelYMaxHorizontalStraightReferenceCurve_AllCurvesOnePlot.configure(state='normal')
            else:
                self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xinitial.configure(entry_state='disabled')
                self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xfinal.configure(entry_state='disabled')
                self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Y.configure(entry_state='disabled')
                self.checkbuttonLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot.configure(state='disabled')
                self.entryfieldLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot.configure(entry_state='disabled')
                self.checkbuttonLabelYMaxHorizontalStraightReferenceCurve_AllCurvesOnePlot.configure(state='disabled')
                
# ... vertical straight-line reference curve
            self.checkbuttonShowVerticalStraightReferenceCurve_AllCurvesOnePlot.configure(state='normal')
            if self.varCheckbuttonShowVerticalStraightReferenceCurve_AllCurvesOnePlot.get():
                self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yinitial.configure(entry_state='normal')
                self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yfinal.configure(entry_state='normal')
                self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_X.configure(entry_state='normal')
                self.checkbuttonLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot.configure(state='normal')
                self.entryfieldLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot.configure(entry_state='normal')
                self.checkbuttonLabelXMaxVerticalStraightLineReferenceCurve_AllCurvesOnePlot.configure(state='normal')
            else:
                self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yinitial.configure(entry_state='disabled')
                self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yfinal.configure(entry_state='disabled')
                self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_X.configure(entry_state='disabled')
                self.checkbuttonLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot.configure(state='disabled')
                self.entryfieldLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot.configure(entry_state='disabled')
                self.checkbuttonLabelXMaxVerticalStraightLineReferenceCurve_AllCurvesOnePlot.configure(state='disabled')
                
# ... plot x-y data from CSV file
            self.checkbuttonPlotCsvFileData_AllCurvesOnePlot.configure(state='normal')
            if self.varCheckbuttonPlotCsvFileData_AllCurvesOnePlot.get():
                self.entryPlotCsvFileData_AllCurvesOnePlot.configure(state='normal')
                self.comboboxPlotCsvFileData_X_Column_AllCurvesOnePlot._entryWidget['state']=NORMAL
                self.comboboxPlotCsvFileData_Y_Column_AllCurvesOnePlot._entryWidget['state']=NORMAL
            else:
                self.entryPlotCsvFileData_AllCurvesOnePlot.configure(state='disabled')
                self.comboboxPlotCsvFileData_X_Column_AllCurvesOnePlot._entryWidget['state']=DISABLED
                self.comboboxPlotCsvFileData_Y_Column_AllCurvesOnePlot._entryWidget['state']=DISABLED
# ... x-ticks size and color
            self.comboboxFontXTicks_AllCurvesOnePlot._entryWidget['state'] = NORMAL
#            self.comboboxColorXTicks_AllCurvesOnePlot._entryWidget['state'] = NORMAL
# ... y-ticks size and color
            self.comboboxFontYTicks_AllCurvesOnePlot._entryWidget['state'] = NORMAL
#            self.comboboxColorYTicks_AllCurvesOnePlot._entryWidget['state'] = NORMAL  
# ... background color
#            self.comboboxColorBackground_AllCurvesOnePlot._entryWidget['state'] = DISABLED
# ... x-ticks color, y-ticks color, and background color
            self.handlerRefreshColors_AllCurvesOnOnePlot(1)
# show appropriate labels window
             
# show appropriate labels window

# display label window                
            try:
                existsLabelsAll = self.toplevelLegendLabelsAllCurvesOnePlot.winfo_exists()
            except:
                existsLabelsAll = 0
                
            print '\n*** existsLabelsAll =',existsLabelsAll
            
            if not existsLabelsAll:
                print '    calling self.labels_AllCurvesOnePlot'
                self.labels_AllCurvesOnePlot(
                    self.labels_xWindowLocationAll,
                    self.labels_yWindowLocationAll
                    )
            else:
                print '    lift All above Single window'
                try:
                    self.toplevelLegendLabelsAllCurvesOnePlot.deiconify()
                except:
                    pass
#                self.toplevelLegendLabelsAllCurvesOnePlot.lift(self.toplevelLabelsSinglePlotPerCurve)
#                self.toplevelLegendLabelsAllCurvesOnePlot.lift(self.toplevelXYPlotPreprocess)
                self.toplevelLegendLabelsAllCurvesOnePlot.lift()
# iconify Plot Labels window
            try:
                existsLabelsSingle = self.toplevelLabelsSinglePlotPerCurve.winfo_exists()
            except:
                existsLabelsSingle = False

            if existsLabelsSingle:
                try:
#                    self.toplevelLabelsSinglePlotPerCurve.iconify()
                    self.toplevelLabelsSinglePlotPerCurve.withdraw()
                except:
                    pass
                
            '''
# hide legend window                
            try:
                mappedLabelsSingle = self.toplevelLabelsSinglePlotPerCurve.winfo_exists()
            except:
                mappedLabelsSingle = 0
            if mappedLabelsSingle: 
                self.toplevelLabelsSinglePlotPerCurve.iconify()
            '''
# can also use...
#                self.toplevelLabelsSinglePlotPerCurve.withdraw()
             
        else:
# wrong value associated with self.varCurvesSelection.get()
            stringError = ('Error: wrong value associated with\n' + 
                'variable: self.varCurvesSelection.get().strip() = ' +
                self.varCurvesSelection.get().strip() + '\n' +
                'module: handlerSelectSingleOrMultiCurvePlots\n\n' +
                'Value should be "single" or "all".\n\n'
                'Process canceled.\n'
                )
            print stringError
            self.MySQL_Output(
                1,
                stringError
                )
            showerror(
                'Error: invalid value',
                '\n' + stringError
                )
            return
            
        return
        
            
    def handlerShowReferenceCurve_AllCurvesOnePlot(self):
        '''
        Purpose:
            enable or disable reference curve multiplier and label for X-Y Plot
            
        Called by:
        
        Calls
        
        
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerShowReferenceCurve_AllCurvesOnePlot')
            
# enable/disable comboboxes for reference curve, depending on if 'All Curves' radiobutton 
#  and 'Show reference curve' checkbuttons are checked
        if self.varCurvesSelection.get().strip() == 'all':
# ... legend
            if self.varCheckbuttonShowLegend_AllCurvesOnePlot.get():
                self.comboboxShowLegendLocation_AllCurvesOnePlot._entryWidget['state']=NORMAL
                self.comboboxFontLegend_AllCurvesOnePlot._entryWidget['state']=NORMAL
            else:
                self.comboboxShowLegendLocation_AllCurvesOnePlot._entryWidget['state']=DISABLED
                self.comboboxFontLegend_AllCurvesOnePlot._entryWidget['state']=DISABLED
# ... reference curve                
            if self.varCheckbuttonShowReferenceCurve_AllCurvesOnePlot.get():
                self.comboboxShowReferenceCurveMultiplier_AllCurvesOnePlot._entryWidget['state']=NORMAL
                self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot._entryWidget['state']=NORMAL
            else:
                self.comboboxShowReferenceCurveMultiplier_AllCurvesOnePlot._entryWidget['state']=DISABLED
                self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot._entryWidget['state']=DISABLED   
            
        return
        
        
    def handlerShowPolynomialCurveFit_AllCurvesOnePlot_Scatter(self):
        '''
        Purpose:
            enable or disable curve fit widgets  for Scatter Plot
            
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerShowPolynomialCurveFit_AllCurvesOnePlot_Scatter')
            
# enable/disable comboboxes for curve fit, depending on if 'Show curve fit' checkbutton 
#  is checked
        if self.varCheckbuttonShowPolynomialCurveFit_AllCurvesOnePlot_Scatter.get():
# ... normal
# ...   checkbutton
            self.checkbuttonShowPolynomialCurveFit_AllCurvesOnePlot_Scatter.select()
# ...   degree of polynomial
            self.comboboxPolynomialDegree_AllCurvesOnePlot_Scatter._entryWidget['disabledbackground'] = 'white'
            self.comboboxPolynomialDegree_AllCurvesOnePlot_Scatter._entryWidget['disabledforeground'] = 'black'
# ...   number of points
            self.comboboxPolynomialNumberOfPoints_AllCurvesOnePlot_Scatter._entryWidget['disabledbackground'] = 'white'
            self.comboboxPolynomialNumberOfPoints_AllCurvesOnePlot_Scatter._entryWidget['disabledforeground'] = 'black'
# ...   coefficient decimal places
            self.comboboxPolynomialCoefficientDecimalPlaces_AllCurvesOnePlot_Scatter._entryWidget['disabledbackground'] = 'white'
            self.comboboxPolynomialCoefficientDecimalPlaces_AllCurvesOnePlot_Scatter._entryWidget['disabledforeground'] = 'black'
# ...   coefficient output format
            self.comboboxPolynomialCoefficientOutputFormat_AllCurvesOnePlot_Scatter._entryWidget['disabledbackground'] = 'white'
            self.comboboxPolynomialCoefficientOutputFormat_AllCurvesOnePlot_Scatter._entryWidget['disabledforeground'] = 'black'
# ...   checkbutton for plotting all lesser degree polynomials
            self.checkbuttonPlotAllLesserDegreePolynomials_AllCurvesOnePlot_Scatter.configure(state='normal')
# ...   button for storing last-displayed curve fits
            self.buttonStoreCurveFits_Buffer_Scatter.configure(state='normal')
# ...   show legend
            if not self.varCheckbuttonShowLegend_AllCurvesOnePlot_Scatter.get():
                self.varCheckbuttonShowLegend_AllCurvesOnePlot_Scatter.set(1)
                self.handlerShowLegend_AllCurvesOnePlot_Scatter()
            
        else:
# ... disabled
# ...   checkbutton
            self.checkbuttonShowPolynomialCurveFit_AllCurvesOnePlot_Scatter.deselect()
# ...   degree of polynomial
            self.comboboxPolynomialDegree_AllCurvesOnePlot_Scatter._entryWidget['disabledbackground'] = 'lightgray'             
            self.comboboxPolynomialDegree_AllCurvesOnePlot_Scatter._entryWidget['disabledforeground'] = '#777777'             
# ...   number of points
            self.comboboxPolynomialNumberOfPoints_AllCurvesOnePlot_Scatter._entryWidget['disabledbackground'] = 'lightgray'
            self.comboboxPolynomialNumberOfPoints_AllCurvesOnePlot_Scatter._entryWidget['disabledforeground'] = '#777777'
# ...   coefficient decimal places
            self.comboboxPolynomialCoefficientDecimalPlaces_AllCurvesOnePlot_Scatter._entryWidget['disabledbackground'] = 'lightgray'
            self.comboboxPolynomialCoefficientDecimalPlaces_AllCurvesOnePlot_Scatter._entryWidget['disabledforeground'] = '#777777'
# ...   coefficient output format
            self.comboboxPolynomialCoefficientOutputFormat_AllCurvesOnePlot_Scatter._entryWidget['disabledbackground'] = 'lightgray'
            self.comboboxPolynomialCoefficientOutputFormat_AllCurvesOnePlot_Scatter._entryWidget['disabledforeground'] = '#777777'
# ...   checkbutton for plotting all lesser degree polynomials
            self.checkbuttonPlotAllLesserDegreePolynomials_AllCurvesOnePlot_Scatter.configure(state='disabled')
# ...   button for storing last-displayed curve fits
            self.buttonStoreCurveFits_Buffer_Scatter.configure(state='disabled')


        return


    def handlerShowReferenceCurve_AllCurvesOnePlot_Scatter(self):
        '''
        Purpose:
            enable or disable reference curve multiplier and label for Scatter Plot
            
        Called by:
        
        Calls
        
        
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerShowReferenceCurve_AllCurvesOnePlot_Scatter')
            
# enable/disable comboboxes for reference curve, depending on if 'Show reference curve' checkbutton 
#  is checked; if checked, show legend
            
# ... reference curve                
        if self.varCheckbuttonShowReferenceCurve_AllCurvesOnePlot_Scatter.get():
            self.comboboxShowReferenceCurveMultiplier_AllCurvesOnePlot_Scatter._entryWidget['state'] = NORMAL
            self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot_Scatter._entryWidget['state'] = NORMAL
# ... show legend
            if not self.varCheckbuttonShowLegend_AllCurvesOnePlot_Scatter.get():
                self.varCheckbuttonShowLegend_AllCurvesOnePlot_Scatter.set(1)
                self.handlerShowLegend_AllCurvesOnePlot_Scatter()
        else:
            self.comboboxShowReferenceCurveMultiplier_AllCurvesOnePlot_Scatter._entryWidget['state'] = DISABLED
            self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot_Scatter._entryWidget['state'] = DISABLED   
            
        return
        
        
    def handlerShowSlopedStraightReferenceCurve_AllCurvesOnePlot(self):
        '''
        Purpose:
            enable or disable sloped straight reference curve values for X-Y Plots
            
        Called by:
        
        Calls
        
        
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerShowSlopedStraightReferenceCurve_AllCurvesOnePlot')
            
# enable/disable comboboxes for reference curve, depending on if 'All Curves' radiobutton and 'Show reference curve' checkbuttons are checked
        if self.varCurvesSelection.get().strip() == 'all':
# ... legend
            if self.varCheckbuttonShowLegend_AllCurvesOnePlot.get():
                self.comboboxShowLegendLocation_AllCurvesOnePlot._entryWidget['state']=NORMAL
                self.comboboxFontLegend_AllCurvesOnePlot._entryWidget['state']=NORMAL
            else:
                self.comboboxShowLegendLocation_AllCurvesOnePlot._entryWidget['state']=DISABLED
                self.comboboxFontLegend_AllCurvesOnePlot._entryWidget['state']=DISABLED
# ... sloped straight reference curve 
#            self.checkbuttonShowReferenceCurve_AllCurvesOnePlot.configure(state='normal')
            if self.varCheckbuttonShowSlopedStraightReferenceCurve_AllCurvesOnePlot.get():
                self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xinitial.configure(entry_state='normal')
                self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xfinal.configure(entry_state='normal')
                self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yinitial.configure(entry_state='normal')
                self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yfinal.configure(entry_state='normal')
                self.checkbuttonLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot.configure(state='normal')
                self.entryfieldLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot.configure(entry_state='normal')
                self.checkbuttonLabelSlopeDegreesSlopedStraightReferenceCurve_AllCurvesOnePlot.configure(state='normal')
            else:
                self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xinitial.configure(entry_state='disabled')
                self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xfinal.configure(entry_state='disabled')
                self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yinitial.configure(entry_state='disabled')
                self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yfinal.configure(entry_state='disabled')
                self.checkbuttonLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot.configure(state='disabled')
                self.entryfieldLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot.configure(entry_state='disabled')
                self.checkbuttonLabelSlopeDegreesSlopedStraightReferenceCurve_AllCurvesOnePlot.configure(state='disabled')
            
        return
        
        
    def handlerShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter(self):
        '''
        Purpose:
            enable or disable sloped straight reference curve values for Scatter Plots
            
        Called by:
        
        Calls
        
        
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter')
            
# enable/disable comboboxes for reference curve, depending on if 'Show reference curve' checkbutton is checked
# ... legend
        if self.varCheckbuttonShowLegend_AllCurvesOnePlot_Scatter.get():
            self.comboboxShowLegendLocation_AllCurvesOnePlot_Scatter._entryWidget['state'] = NORMAL
            self.comboboxFontLegend_AllCurvesOnePlot_Scatter._entryWidget['state'] = NORMAL
            self.checkbuttonShowLegendShadow_AllCurvesOnePlot_Scatter.configure(state='normal')
        else:
            self.comboboxShowLegendLocation_AllCurvesOnePlot_Scatter._entryWidget['state']=DISABLED
            self.comboboxFontLegend_AllCurvesOnePlot_Scatter._entryWidget['state']=DISABLED
            self.checkbuttonShowLegendShadow_AllCurvesOnePlot_Scatter.configure(state='disabled')
# ... sloped straight reference curve 
#            self.checkbuttonShowReferenceCurve_AllCurvesOnePlot.configure(state='normal')
        if self.varCheckbuttonShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter.get():
            self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xinitial_Scatter.configure(entry_state='normal')
            self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xfinal_Scatter.configure(entry_state='normal')
            self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yinitial_Scatter.configure(entry_state='normal')
            self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yfinal_Scatter.configure(entry_state='normal')
            self.checkbuttonLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter.configure(state='normal')
            self.entryfieldLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter.configure(entry_state='normal')
            self.checkbuttonLabelSlopeDegreesSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter.configure(state='normal')
        else:
            self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xinitial_Scatter.configure(entry_state='disabled')
            self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Xfinal_Scatter.configure(entry_state='disabled')
            self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yinitial_Scatter.configure(entry_state='disabled')
            self.entryfieldShowSlopedStraightReferenceCurve_AllCurvesOnePlot_Yfinal_Scatter.configure(entry_state='disabled')
            self.checkbuttonLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter.configure(state='disabled')
            self.entryfieldLabelUserSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter.configure(entry_state='disabled')
            self.checkbuttonLabelSlopeDegreesSlopedStraightReferenceCurve_AllCurvesOnePlot_Scatter.configure(state='disabled')
            
        return
        
        
    def handlerShowHorizontalStraightReferenceCurve_AllCurvesOnePlot(self):
        '''
        Purpose:
            enable or disable horizontal straight reference curve values for X-Y Plot window
            
        Called by:
        
        Calls
        
        
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerShowHorizontalStraightReferenceCurve_AllCurvesOnePlot')
            
# enable/disable comboboxes for reference curve, depending on if 'All Curves' radiobutton and 'Show reference curve' checkbuttons are checked
        if self.varCurvesSelection.get().strip() == 'all':
# ... legend
            if self.varCheckbuttonShowLegend_AllCurvesOnePlot.get():
                self.comboboxShowLegendLocation_AllCurvesOnePlot._entryWidget['state']=NORMAL
                self.comboboxFontLegend_AllCurvesOnePlot._entryWidget['state']=NORMAL
            else:
                self.comboboxShowLegendLocation_AllCurvesOnePlot._entryWidget['state']=DISABLED
                self.comboboxFontLegend_AllCurvesOnePlot._entryWidget['state']=DISABLED
# ... horizontal straight reference curve 
#            self.checkbuttonShowReferenceCurve_AllCurvesOnePlot.configure(state='normal')
            if self.varCheckbuttonShowHorizontalStraightReferenceCurve_AllCurvesOnePlot.get():
                self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xinitial.configure(entry_state='normal')
                self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xfinal.configure(entry_state='normal')
                self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Y.configure(entry_state='normal')
                self.checkbuttonLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot.configure(state='normal')
                self.entryfieldLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot.configure(entry_state='normal')
                self.checkbuttonLabelYMaxHorizontalStraightReferenceCurve_AllCurvesOnePlot.configure(state='normal')
            else:
                self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xinitial.configure(entry_state='disabled')
                self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xfinal.configure(entry_state='disabled')
                self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Y.configure(entry_state='disabled')
                self.checkbuttonLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot.configure(state='disabled')
                self.entryfieldLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot.configure(entry_state='disabled')
                self.checkbuttonLabelYMaxHorizontalStraightReferenceCurve_AllCurvesOnePlot.configure(state='disabled')
            
        return
        
        
    def handlerShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter(self):
        '''
        Purpose:
            enable or disable horizontal straight reference curve values for Scatter Plot window
            
        Called by:
        
        Calls
        
        
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter')
            
# enable/disable comboboxes for reference curve, depending on if 'Show reference curve' checkbutton is checked
# ... legend
        if self.varCheckbuttonShowLegend_AllCurvesOnePlot_Scatter.get():
            self.comboboxShowLegendLocation_AllCurvesOnePlot_Scatter._entryWidget['state'] = NORMAL
            self.comboboxFontLegend_AllCurvesOnePlot_Scatter._entryWidget['state'] = NORMAL
            self.checkbuttonShowLegendShadow_AllCurvesOnePlot_Scatter.configure(state='normal')
        else:
            self.comboboxShowLegendLocation_AllCurvesOnePlot_Scatter._entryWidget['state'] = DISABLED
            self.comboboxFontLegend_AllCurvesOnePlot_Scatter._entryWidget['state'] = DISABLED
            self.checkbuttonShowLegendShadow_AllCurvesOnePlot_Scatter.configure(state='disabled')
                
# ... horizontal straight reference curve 
#            self.checkbuttonShowReferenceCurve_AllCurvesOnePlot.configure(state='normal')

#        print('\n\n>> self.varCheckbuttonShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter.get() = %s' %
#            self.varCheckbuttonShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter.get()
#            )

        if self.varCheckbuttonShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter.get():
            self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xinitial_Scatter.configure(entry_state='normal')
            self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xfinal_Scatter.configure(entry_state='normal')
            self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Y_Scatter.configure(entry_state='normal')
            self.checkbuttonLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter.configure(state='normal')
            self.entryfieldLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter.configure(entry_state='normal')
            self.checkbuttonLabelYMaxHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter.configure(state='normal')
        else:
            self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xinitial_Scatter.configure(entry_state='disabled')
            self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Xfinal_Scatter.configure(entry_state='disabled')
            self.entryfieldShowHorizontalStraightReferenceCurve_AllCurvesOnePlot_Y_Scatter.configure(entry_state='disabled')
            self.checkbuttonLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter.configure(state='disabled')
            self.entryfieldLabelUserHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter.configure(entry_state='disabled')
            self.checkbuttonLabelYMaxHorizontalStraightReferenceCurve_AllCurvesOnePlot_Scatter.configure(state='disabled')
            
        return
        
        
    def handlerShowVerticalStraightReferenceCurve_AllCurvesOnePlot(self):
        '''
        Purpose:
            enable or disable vertical straight reference curve values for x-y plots
            
        Called by:
        
        Calls
        
        
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerShowVerticalStraightReferenceCurve_AllCurvesOnePlot')
            
# enable/disable comboboxes for reference curve, depending on if 'All Curves' radiobutton and 'Show reference curve' checkbuttons are checked
        if self.varCurvesSelection.get().strip() == 'all':
# ... legend
            if self.varCheckbuttonShowLegend_AllCurvesOnePlot.get():
                self.comboboxShowLegendLocation_AllCurvesOnePlot._entryWidget['state']=NORMAL
                self.comboboxFontLegend_AllCurvesOnePlot._entryWidget['state']=NORMAL
            else:
                self.comboboxShowLegendLocation_AllCurvesOnePlot._entryWidget['state']=DISABLED
                self.comboboxFontLegend_AllCurvesOnePlot._entryWidget['state']=DISABLED
# ... vertical straight reference curve 
#            self.checkbuttonShowReferenceCurve_AllCurvesOnePlot.configure(state='normal')
            if self.varCheckbuttonShowVerticalStraightReferenceCurve_AllCurvesOnePlot.get():
                self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yinitial.configure(entry_state='normal')
                self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yfinal.configure(entry_state='normal')
                self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_X.configure(entry_state='normal')
                self.checkbuttonLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot.configure(state='normal')
                self.entryfieldLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot.configure(entry_state='normal')
                self.checkbuttonLabelXMaxVerticalStraightLineReferenceCurve_AllCurvesOnePlot.configure(state='normal')
            else:
                self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yinitial.configure(entry_state='disabled')
                self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yfinal.configure(entry_state='disabled')
                self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_X.configure(entry_state='disabled')
                self.checkbuttonLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot.configure(state='disabled')
                self.entryfieldLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot.configure(entry_state='disabled')
                self.checkbuttonLabelXMaxVerticalStraightLineReferenceCurve_AllCurvesOnePlot.configure(state='disabled')
            
        return
        
        
    def handlerShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Scatter(self):
        '''
        Purpose:
            enable or disable vertical straight reference curve values for scatter plots
            
        Called by:
        
        Calls
        
        
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Scatter')
            
# enable/disable comboboxes for reference curve, depending on if 'Show reference curve' checkbutton is checked
# ... legend
        if self.varCheckbuttonShowLegend_AllCurvesOnePlot_Scatter.get():
            self.comboboxShowLegendLocation_AllCurvesOnePlot_Scatter._entryWidget['state'] = NORMAL
            self.comboboxFontLegend_AllCurvesOnePlot_Scatter._entryWidget['state'] = NORMAL
            self.checkbuttonShowLegendShadow_AllCurvesOnePlot_Scatter.configure(state='normal')
        else:
            self.comboboxShowLegendLocation_AllCurvesOnePlot_Scatter._entryWidget['state']=DISABLED
            self.comboboxFontLegend_AllCurvesOnePlot_Scatter._entryWidget['state']=DISABLED
            self.checkbuttonShowLegendShadow_AllCurvesOnePlot_Scatter.configure(state='disabled')
# ... vertical straight reference curve 
#            self.checkbuttonShowReferenceCurve_AllCurvesOnePlot.configure(state='normal')
        if self.varCheckbuttonShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Scatter.get():
            self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yinitial_Scatter.configure(entry_state='normal')
            self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yfinal_Scatter.configure(entry_state='normal')
            self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_X_Scatter.configure(entry_state='normal')
            self.checkbuttonLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot_Scatter.configure(state='normal')
            self.entryfieldLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot_Scatter.configure(entry_state='normal')
            self.checkbuttonLabelXMaxVerticalStraightLineReferenceCurve_AllCurvesOnePlot_Scatter.configure(state='normal')
        else:
            self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yinitial_Scatter.configure(entry_state='disabled')
            self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_Yfinal_Scatter.configure(entry_state='disabled')
            self.entryfieldShowVerticalStraightReferenceCurve_AllCurvesOnePlot_X_Scatter.configure(entry_state='disabled')
            self.checkbuttonLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot_Scatter.configure(state='disabled')
            self.entryfieldLabelUserVerticalStraightLineReferenceCurve_AllCurvesOnePlot_Scatter.configure(entry_state='disabled')
            self.checkbuttonLabelXMaxVerticalStraightLineReferenceCurve_AllCurvesOnePlot_Scatter.configure(state='disabled')
            
        return
        
        
    def handlerShowMainTitle_SingleCurvePerPlot(self):
        '''
        Purpose:
            enable or disable main plot title for single curves
            
        Called by:
        
        Calls
           
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerShowMainTitle_SingleCurvePerPlot')
            
# available to modify only when 'single' is active
        if self.varShowMainTitle_SingleCurvePerPlot.get():
            self.entryMainTitle_SingleCurvePerPlot.configure(state='normal')
            self.handlerRefreshMainTitleSize_SingleCurvePerPlot(1)
        else:
            self.entryMainTitle_SingleCurvePerPlot.configure(state='disabled')
            self.handlerRefreshMainTitleSize_SingleCurvePerPlot(0)
            
        return

            
    def handlerShowTitles_SingleCurvePerPlot(self):
        '''
        Purpose:
            enable or disable individual plot titles for single curves
            
        Called by:
        
        Calls
           
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerShowTitles_SingleCurvePerPlot')
            
# enable/disable comboboxes for reference curve, depending on if 'All Curves' radiobutton and 'Show reference curve' checkbuttons are checked
#        if self.varCurvesSelection.get().strip() == 'all':
# available to modify only when 'single' is active
        if self.varShowTitles_SingleCurvePerPlot.get():
#            self.comboboxFontTitle_SingleCurvePerPlot._entryWidget['state']=NORMAL
            self.handlerRefreshYLabelSize_SingleCurvePerPlot(1)
        else:
#            self.comboboxFontTitle_SingleCurvePerPlot._entryWidget['state']=DISABLED
            self.handlerRefreshYLabelSize_SingleCurvePerPlot(0)
            
        return
            
            
    def handlerShowTitle_AllCurvesOnePlot(self):
        '''
        Purpose:
            enable or disable plot title for multi-curves in X-Y Plot
            
        Called by:
        
        Calls
           
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerShowTitle_AllCurvesOnePlot')
            
# enable/disable comboboxes for reference curve, depending on if 'All Curves' radiobutton and 'Show reference curve' checkbuttons are checked
#        if self.varCurvesSelection.get().strip() == 'all':
# available to modify only when 'all' is active
        if self.varCheckbuttonShowTitle_AllCurvesOnePlot.get():
            self.entryShowTitle_AllCurvesOnePlot.configure(state='normal')
            self.comboboxFontTitle_AllCurvesOnePlot._entryWidget['state'] = NORMAL
            self.comboboxColorTitle_AllCurvesOnePlot._entryWidget['state'] = NORMAL
        else:
            self.entryShowTitle_AllCurvesOnePlot.configure(state='disabled')
            self.comboboxFontTitle_AllCurvesOnePlot._entryWidget['state'] = DISABLED
            self.comboboxColorTitle_AllCurvesOnePlot._entryWidget['state'] = DISABLED
            
        return
        
        
    def handlerConnectSymbols_AllCurvesOnePlot_Scatter(self):
        '''
        Purpose:
            enable or disable plot title for multi-curves in Scatter Plot
            
        Called by:
        
        Calls
           
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerShowTitle_AllCurvesOnePlot_Scatter')
            
# enable/disable comboboxes for reference curve, depending on if 'All Curves' radiobutton and 'Show reference curve' checkbuttons are checked
#        if self.varCurvesSelection.get().strip() == 'all':
# available to modify only when 'all' is active
        if self.varCheckbuttonConnectDataMarkers_Scatter.get():
            self.comboboxLineWidthPlots_Scatter._entryWidget['disabledforeground'] = 'black'
            self.comboboxLineWidthPlots_Scatter._entryWidget['disabledbackground'] = 'white'
            self.comboboxMarkerSizePlots_Scatter._entryWidget['state'] = NORMAL
        else:
            self.comboboxLineWidthPlots_Scatter._entryWidget['disabledforeground'] = '#777777'
            self.comboboxLineWidthPlots_Scatter._entryWidget['disabledbackground'] = 'lightgray'
            self.comboboxMarkerSizePlots_Scatter._entryWidget['state'] = NORMAL
            
        return
        
        
    def handlerShowTitle_AllCurvesOnePlot_Scatter(self):
        '''
        Purpose:
            enable or disable plot title for multi-curves in Scatter Plot
            
        Called by:
        
        Calls
           
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerShowTitle_AllCurvesOnePlot_Scatter')
            
# enable/disable comboboxes for reference curve, depending on if 'All Curves' radiobutton and 'Show reference curve' checkbuttons are checked
#        if self.varCurvesSelection.get().strip() == 'all':
# available to modify only when 'all' is active
        if self.varCheckbuttonShowTitle_AllCurvesOnePlot_Scatter.get():
            self.entryShowTitle_AllCurvesOnePlot_Scatter.configure(state='normal')
            self.comboboxFontTitle_AllCurvesOnePlot_Scatter._entryWidget['state'] = NORMAL
            self.comboboxColorTitle_AllCurvesOnePlot_Scatter._entryWidget['state'] = NORMAL
        else:
            self.entryShowTitle_AllCurvesOnePlot_Scatter.configure(state='disabled')
            self.comboboxFontTitle_AllCurvesOnePlot_Scatter._entryWidget['state'] = DISABLED
            self.comboboxColorTitle_AllCurvesOnePlot_Scatter._entryWidget['state'] = DISABLED
            
        return
        
        
    def handlerShowLabelY_AllCurvesOnePlot(self):
        '''
        Purpose:
            enable or disable plot y-label in X-Y Plot
            
        Called by:
        
        Calls
           
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerShowLabelY_AllCurvesOnePlot')
            
# enable/disable comboboxes for reference curve, depending on if 'All Curves' radiobutton and 'Show reference curve' checkbuttons are checked
#        if self.varCurvesSelection.get().strip() == 'all':
# available to modify only when 'all' is active
        if self.varCheckbuttonShowLabelY_AllCurvesOnePlot.get():
            self.entryShowLabelY_AllCurvesOnePlot.configure(state='normal')            
        else:
            self.entryShowLabelY_AllCurvesOnePlot.configure(state='disabled')
                
        if (self.varCheckbuttonShowLabelY_AllCurvesOnePlot.get() or 
            self.varCheckbuttonShowLabelX_AllCurvesOnePlot.get() ):
            self.comboboxFontXYLabels_AllCurvesOnePlot._entryWidget['state']=NORMAL
            self.comboboxColorXYLabels_AllCurvesOnePlot._entryWidget['state']=NORMAL
        else:
            self.comboboxFontXYLabels_AllCurvesOnePlot._entryWidget['state']=DISABLED
            self.comboboxColorXYLabels_AllCurvesOnePlot._entryWidget['state']=DISABLED

        return
        
        
    def handlerShowLabelY_AllCurvesOnePlot_Scatter(self):
        '''
        Purpose:
            enable or disable plot y-label in Scatter Plot
            
        Called by:
        
        Calls
           
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerShowLabelY_AllCurvesOnePlot_Scatter')
            
# enable/disable comboboxes for reference curve, depending on if 'All Curves' radiobutton and 'Show reference curve' checkbuttons are checked
#        if self.varCurvesSelection.get().strip() == 'all':
# available to modify only when 'all' is active
        if self.varCheckbuttonShowLabelY_AllCurvesOnePlot_Scatter.get():
            self.entryShowLabelY_AllCurvesOnePlot_Scatter.configure(state='normal')            
        else:
            self.entryShowLabelY_AllCurvesOnePlot_Scatter.configure(state='disabled')
            
# check whether the font size and font color widgets need to be grayed out
        self.handlerRefreshXYLabelsColor_AllCurvesOnOnePlot_Scatter()
        
        '''
        if (self.varCheckbuttonShowLabelY_AllCurvesOnePlot_Scatter.get() 
            or 
            self.varCheckbuttonShowLabelX_AllCurvesOnePlot_Scatter.get() 
            ):
            self.comboboxFontXYLabels_AllCurvesOnePlot_Scatter._entryWidget['state']=NORMAL
#            self.comboboxColorXYLabels_AllCurvesOnePlot_Scatter._entryWidget['state']=NORMAL
        else:
            self.comboboxFontXYLabels_AllCurvesOnePlot_Scatter._entryWidget['state']=DISABLED
#            self.comboboxColorXYLabels_AllCurvesOnePlot_Scatter._entryWidget['state']=DISABLED
        '''

        return
        
    
    def handlerShowLabelX_AllCurvesOnePlot(self):
        '''
        Purpose:
            enable or disable plot x-label in X-Y Plots
            
        Called by:
        
        Calls
           
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerShowLabelX_AllCurvesOnePlot')
            
# enable/disable comboboxes for reference curve, depending on if 'All Curves' radiobutton and 'Show reference curve' checkbuttons are checked
#        if self.varCurvesSelection.get().strip() == 'all':
# available to modify only when 'all' is active
        if self.varCheckbuttonShowLabelX_AllCurvesOnePlot.get():
#            self.entryShowLabelX_AllCurvesOnePlot.configure(state='normal') 
            self.comboboxShowLabelX_AllCurvesOnePlot._entryWidget['state']=NORMAL            
        else:
#            self.entryShowLabelX_AllCurvesOnePlot.configure(state='disabled')
            self.comboboxShowLabelX_AllCurvesOnePlot._entryWidget['state']=DISABLED
                
        if (self.varCheckbuttonShowLabelX_AllCurvesOnePlot.get() or 
            self.varCheckbuttonShowLabelY_AllCurvesOnePlot.get() ):
            self.comboboxFontXYLabels_AllCurvesOnePlot._entryWidget['state']=NORMAL
            self.comboboxColorXYLabels_AllCurvesOnePlot._entryWidget['state']=NORMAL
        else:
            self.comboboxFontXYLabels_AllCurvesOnePlot._entryWidget['state']=DISABLED
            self.comboboxColorXYLabels_AllCurvesOnePlot._entryWidget['state']=DISABLED 

        return
        
        
    def handlerShowLabelX_AllCurvesOnePlot_Scatter(self):
        '''
        Purpose:
            enable or disable plot x-label in Scatter Plots
            
        Called by:
        
        Calls
           
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerShowLabelX_AllCurvesOnePlot_Scatter')
            
# enable/disable comboboxes for reference curve, depending on if 'All Curves' radiobutton and 'Show reference curve' checkbuttons are checked
#        if self.varCurvesSelection.get().strip() == 'all':
# available to modify only when 'all' is active
        if self.varCheckbuttonShowLabelX_AllCurvesOnePlot_Scatter.get():
#            self.entryShowLabelX_AllCurvesOnePlot.configure(state='normal') 
            self.comboboxShowLabelX_AllCurvesOnePlot_Scatter._entryWidget['state']=NORMAL            
        else:
#            self.entryShowLabelX_AllCurvesOnePlot.configure(state='disabled')
            self.comboboxShowLabelX_AllCurvesOnePlot_Scatter._entryWidget['state']=DISABLED

# check whether the font size and font color widgets need to be grayed out
        self.handlerRefreshXYLabelsColor_AllCurvesOnOnePlot_Scatter()           
        '''
        if (self.varCheckbuttonShowLabelX_AllCurvesOnePlot_Scatter.get() or 
            self.varCheckbuttonShowLabelY_AllCurvesOnePlot_Scatter.get() 
            ):
            self.comboboxFontXYLabels_AllCurvesOnePlot_Scatter._entryWidget['state']=NORMAL
#            self.comboboxColorXYLabels_AllCurvesOnePlot_Scatter._entryWidget['state']=NORMAL
        else:
            self.comboboxFontXYLabels_AllCurvesOnePlot_Scatter._entryWidget['state']=DISABLED
#            self.comboboxColorXYLabels_AllCurvesOnePlot_Scatter._entryWidget['state']=DISABLED 
        '''
        
        return
    
            
    def handlerShowLegend_AllCurvesOnePlot(self):
        '''
        Purpose:
            enable or disable plot legend in X-Y Plot
            
        Called by:
        
        Calls
           
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerShowLegend_AllCurvesOnePlot')
            
# enable/disable comboboxes for reference curve, depending on if 'All Curves' radiobutton and 'Show reference curve' checkbuttons are checked
        if self.varCurvesSelection.get().strip() == 'all':
            if self.varCheckbuttonShowLegend_AllCurvesOnePlot.get():
                self.comboboxShowLegendLocation_AllCurvesOnePlot._entryWidget['state']=NORMAL
                self.comboboxFontLegend_AllCurvesOnePlot._entryWidget['state']=NORMAL
            else:
                self.comboboxShowLegendLocation_AllCurvesOnePlot._entryWidget['state']=DISABLED
                self.comboboxFontLegend_AllCurvesOnePlot._entryWidget['state']=DISABLED
            
        return
        
        
    def handlerShowLegend_AllCurvesOnePlot_Scatter(self):
        '''
        Purpose:
            enable or disable plot legend in Scatter Plot
            
        Called by:
        
        Calls
           
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerShowLegend_AllCurvesOnePlot_Scatter')
            
# enable/disable comboboxes for reference curve, depending on if 'All Curves' radiobutton and 
#  'Show reference curve' checkbuttons are checked
        if self.varCheckbuttonShowLegend_AllCurvesOnePlot_Scatter.get():
# ...   checkbutton
            self.checkbuttonShowLegend_AllCurvesOnePlot_Scatter.select()
# ...   location            
            self.comboboxShowLegendLocation_AllCurvesOnePlot_Scatter._entryWidget['state'] = NORMAL
# ...   font
            self.comboboxFontLegend_AllCurvesOnePlot_Scatter._entryWidget['state'] = NORMAL
# ...   legend shadow
            self.checkbuttonShowLegendShadow_AllCurvesOnePlot_Scatter.configure(state='normal')
        else:
# ...   checkbutton
            self.checkbuttonShowLegend_AllCurvesOnePlot_Scatter.deselect()
# ...   location
            self.comboboxShowLegendLocation_AllCurvesOnePlot_Scatter._entryWidget['state'] = DISABLED
# ...   font
            self.comboboxFontLegend_AllCurvesOnePlot_Scatter._entryWidget['state'] = DISABLED
# ...   legend shadow
            self.checkbuttonShowLegendShadow_AllCurvesOnePlot_Scatter.configure(state='disabled')
            
        return
        
            
    def handlerInvokeButtonToRefreshPlotXYWindow(self):
        '''
        Purpose:
            Check if self.toplevelXYPlotPreprocess window is opened.
            If it is, then invoke the self.buttonTableValuesPlotFields
            (Plot X-Y-Select Fields button) to re-display the window
            with new parameters. If not, then do NOT display the window, 
            since we do NOT know if the user will plot selected headers 
            or do something else with them.
            
        Called by:
            def valuesDisplayRowDecimate_Range
            def valuesDisplayRowDecimate
        
        Calls:
        
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerInvokeButtonToRefreshPlotXYWindow') 
        
# kill 'Sorted summary and statistics' window if present; loses integrity if x-select changes
        try:
            mapped1 = self.toplevelSummarize.winfo_exists()
        except:
            mapped1 = False
        if mapped1:
            self.toplevelSummarize.destroy()
            
# refresh plotting specs window if present  
        try:
            mapped2 = self.toplevelXYPlotPreprocess.winfo_exists()
        except:
            mapped2 = False
        if mapped2:
#            self.buttonTableValuesPlotFields.invoke()
            self.handlerUpdateXYPlots_Table_Initialize()   # handler for updating XY plots
            
# refresh User-Defined Fields Window for Storage Buffer if present
        try:
            mapped3 = self.toplevelUserDefinedFields.winfo_exists()
        except:
            mapped3 = False
        if mapped3:
#            self.buttonStoreXYSelect.invoke()
            self.handlerStoreXYinStorageBuffer_Table() # handler for Store XY Select
                 
        return
         
         
    def handlerCloseAllXYPlots(self):
        '''
        Purpose:
            close all plots; valid for either single or
            multiple X-Y plots
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerCloseAllXYPlots')
            
#        import module_PylabPlotMySQL_All
# call close method
        self.adjustPlotPieChartParams = False
        self.adjustPlotBarChartParams = False
# close all plots
        pylab.close('all')
# ignore exitProgram here
#        exitProgram = module_PylabPlotMySQL_All.pylabCloseAll()
        
        
        return
        
        
    def handlerCloseAllScatterPlots(self):
        '''
        Purpose:
            close all plots; scatter plots
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerCloseAllScatterPlots')
            
#        import module_PylabPlotMySQL_ScatterPlot
# call close method
        self.adjustPlotPieChartParams = False
        self.adjustPlotBarChartParams = False
# close all plots
        pylab.close('all')
# ignore exitProgram here
#        exitProgram = module_PylabPlotMySQL_ScatterPlot.pylabCloseAll()
        
        return
        
        
    def handlerCloseBarAndPiePlots(self):
        '''
        Purpose:
            close bar chart and pie chart plot windows; 
            
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerCloseBarAndPiePlots')
            
#        import module_PylabPlotMySQL_BarChart
# call close method
        self.adjustPlotPieChartParams = False
        self.adjustPlotBarChartParams = False
        module_PylabPlotMySQL_BarChart.pylabCloseBarAndPieCharts()
# disable 'adjust' buttons
        self.buttonPieChartAdjust.configure(state=DISABLED)
        self.buttonBarChartAdjust.configure(state=DISABLED)
        
        return
        
        
    def getTableStructure(self):
        '''
        Purpose:
            call server to get table structure
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'getTableStructure')
            
        stringTableStructure = (
            'SHOW COLUMNS FROM ' + self.myDatabase + '.' + self.myTable
            )
        self.MySQL_Commands(
            1,
            'self.cursorHandleMySQL.execute("' + stringTableStructure + '")'
            )
        start=time.time()
        try:
            self.cursorHandleMySQL.execute(
                stringTableStructure
                )
        except:
# check if connected to a MySQL server
            self.checkMySQLConnection()
            if self.connectionFlag == 0: return
# if not a connection problem, the command has wrong syntax
            stringErrorShowColumns = (
                'Unable to show field structure for editing.\n\n' +
                'Reason for this is unknown, but may be due to:\n\n' +
                ' - the MySQL command has the wrong syntax\n\n' +
                'Please report this error.'
                )
            print(
               stringErrorShowColumns
               )
            self.MySQL_Output(
                0,
                stringErrorShowColumns
                )
            showerror(
                'Error: MySQL command/access problem',
                stringErrorShowColumns
                )
            return
        completeTableStructure = self.cursorHandleMySQL.fetchall()
        finish=time.time()
        delta_t = finish - start
        self.MySQL_Commands(
            0,
            '  (Time: %-7.4f secs)' % delta_t
            )
            
        return completeTableStructure
        
    def handlerSortedColumnValuesForSelectField1(self,keyfieldNameWithNumber):
        '''
        Purpose:
         Create a list of all unique values in a database column.
         This is then listed in the SELECT 'string' combobox when a particular header is 
         selected in the 'Fields' combobox.
         
         Called by:
          handlerSelectDisplayOrderedFields
         
         Calls:
              
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerSortedColumnValuesForSelectField1')
            
# check if connected to a MySQL server
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return
        
# remove number from keyfieldNameWithNumber     
        keyfieldName = keyfieldNameWithNumber.split('.')[1].strip()
        
        '''
# ... now find the value that goes with this key
        foundIt = 0
        for key in self.dictColumnHeaders.keys():
            if key == keyfieldName:
                foundIt = 1
                value = self.dictColumnHeaders.get(key)
#                value = self.dictColumnHeadersOriginal.get(key)
                break
        if not foundIt:
# if not found, just leave combobox and items list blank
#            self.myColumnDataField1 = []
            self.comboboxSelectValueField1.clear()
            return

# use value to access field values
        if DEBUG_SELECTFIELD:
            print 
            print 'value =',value
            
        column = value - 1
        '''
        
        listColumnValues = []
        listColumnValues_Tuples = ()
        
# this code finds values just in local table; probably NOT what we want
        '''
        for row in range(len(self.tableValues)):
#        for row in range(len(self.tableValuesOriginal)):
#            print 'self.tableValuesOriginal[row][value-1] =',self.tableValuesOriginal[row][column]
#            listColumnValues.append(self.tableValuesOriginal[row][column])
            valueFromTable = self.tableValues[row][column]
            if valueFromTable <> None and valueFromTable <> '':
                listColumnValues.append(valueFromTable)
        '''

# look for auto_index field
        flagAutoIndex = False
        for eachItem in self.tableStructureOriginal:
            if 'auto_index' in eachItem:
                flagAutoIndex = True
                break
                                
# this code finds values from the entire table on the server
# extract information from table on server
        if flagAutoIndex:
            stringExtractFieldValue = (
                'SELECT ' + keyfieldName + ' FROM ' + self.myDatabase + '.' + self.myTable
                + ' order by auto_index'
                )
        else:
            stringExtractFieldValue = (
                'SELECT ' + keyfieldName + ' FROM ' + self.myDatabase + '.' + self.myTable
                )
                
        self.MySQL_Commands(
            1,
            stringExtractFieldValue
            )
            
        start = time.time()
        self.cursorHandleMySQL.execute(
            stringExtractFieldValue
            )
        listColumnValues_Tuples = list(self.cursorHandleMySQL.fetchall()) # output is type tuple, so change to list
        finish = time.time()
        delta_t = finish - start
        self.MySQL_Commands(
            0,
            '  (Time: %-7.4f secs)' % delta_t
            )
            
# move tuples to list
        for (index,element) in enumerate(listColumnValues_Tuples):
            listColumnValues.append(element[0])
            
# remove blank values
        try:
            listColumnValues.remove('')
        except:
            pass
        try:
            listColumnValues.remove('None')
        except:
            pass
            
        if DEBUG_SELECTFIELD:
            print('\nlistColumnValues = ')
            print(listColumnValues)
                
# error check
# ... if listColumnValues == 0, there are no values in any of the fields to search,
#       so print error and do not allow search on this field
        if len(listColumnValues) == 0:
            stringNoValuesToSearch = (
                'The field you have selected,\n\n' +
                '%s\n\n' +
                'has no values to search on, so this field\n\n' +
                'is not allowed in the SELECT statement.\n\n' +
                'Select another field and try again.'
                ) % keyfieldNameWithNumber
            print(stringNoValuesToSearch)
            self.MySQL_Output(
                0,
                stringNoValuesToSearch
                )
            showerror(
                'Error: field is empty',
                stringNoValuesToSearch
                )
            self.comboboxSelectField1.setentry('')
            self.comboboxSelectValueField1.setentry('')
            return
# ----- end of error check

# get table structure of entire table
        completeTableStructure = self.getTableStructure()

# determine datatype of the field value
        varDatatype = ''
        for struct in completeTableStructure:
#        for struct in self.tableStructureOriginal:
#            print('\nstruct[0] in for loop: %s   varField = %s' % (struct[0],keyfieldName))
            if struct[0] == keyfieldName:
                varDatatype = struct[1]
                varExtra = struct[5]    # see table structure; = auto_increment for auto_index
                break
        if varDatatype == '':
            print '\nError: varDatatype not found in search thru self.tableStructure'
            self.MySQL_Output(
                1,
                'Error: varDatatype not found in search thru self.tableStructure'
                )
            showerror(
                'Error: varDatatype not found',
                '\nvarDatatype not found in search thru self.tableStructure.' + '\n' +
                '  This should not have happened, so cause is unknown.' + '\n\n' + 
                '  Look in ' + MODULE + ' for cause.' + '\n\n'
                )
            return
            
        if DEBUG_SELECTFIELD:
            print('varDatatype (same as struct[1]): %s' % varDatatype)
               
# check if field is numerical; if so, handle differently than if text
        varfirst2 = varDatatype[0:2]
        fieldIsNumerical = self.checkIsFieldNumerical(varfirst2)
        listSummaryField = []
        
        if fieldIsNumerical:
            if DEBUG_SELECTFIELD:
                print '\nField is numerical.\n'
            dictTemp = {}
            for value in listColumnValues:
                dictTemp[value] = None
            listSummaryField = list(dictTemp)
            listSummaryField.sort()        
# another way: get min & max, then 10 intervals in-between; did not like this method, since
#   if you have only two numbers from the table, the dropdown menu would spit out eleven values
#   from which to choose -- not good
            '''
            if varfirst2 == 'in': # if integer, get all field values (e.g., auto_index)
                listSummaryField = listColumnValues
# min-max values
            elif len(listColumnValues) <> 0:
                columnData_max = max(listColumnValues)
                columnData_min = min(listColumnValues)
                print 'min, max = ',columnData_min,columnData_max
# generate 10 numbers inbetween for values from which to choose
                divisions = 10
                diff=(columnData_max - columnData_min)/divisions
                for i in range(divisions+1):
                    listSummaryField.append(columnData_min + i * diff)
            '''
            
        else:
            if DEBUG_SELECTFIELD:
                print '\nField is text.\n'
# sort field values using list from dictionary; much faster than using 'set', for example, since dicts use hash tables   
# ... dictionaries never repeat keys              
            dictTemp = {}
            for value in listColumnValues:
                dictTemp[value] = None
            listSummaryField = list(dictTemp) # or = dictTemp.keys()
            listSummaryField.sort()

# remove invalid values            
        try:
            listSummaryField.remove(None)
        except:
            pass
        try:
            listSummaryField.remove('')
        except:
            pass
            
        if DEBUG_SELECTFIELD:
            print('\nlistSummaryField (sorted) =')
            print(listSummaryField)
           
# regraph combobox with new list; can't just re-define list
        self.comboboxSelectValueField1 = Pmw.ComboBox(
            self.frame_10_03,
            scrolledlist_items=listSummaryField,
            listheight=120,
            entry_width=self.widthSelectValueField,
#            entry_justify=LEFT,
            scrolledlist_hull_width=500,
            )
        self.comboboxSelectValueField1.grid(
            row=2,
            column=4,
            padx=0,
            pady=0,
            ) 
            
        if DEBUG_SELECTFIELD:
            print('\nlistSummaryField = \n%s' % listSummaryField)
            
# place a value in widget, if available     
        if len(listSummaryField) <> 0:
            self.comboboxSelectValueField1.setentry(listSummaryField[0])  
        else:
            self.comboboxSelectValueField1.setentry('')
            
# if operator field is empty, place default value in field
        if self.comboboxSelectOperatorField1.get() == '':
            self.comboboxSelectOperatorField1.setentry(self.fieldSort[0])
               
        return
        
        
    def handlerSortedColumnValuesForSelectField2(self,keyfieldNameWithNumber):
        '''
        Purpose:
         Create a list of all unique values in a database column.
         This is then listed in the SELECT 'string' combobox when a particular header is 
         selected in the 'Fields' combobox.
         
         Called by:
          handlerSelectDisplayOrderedFields
         
         Calls:
              
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerSortedColumnValuesForSelectField2')
            
# check if connected to a MySQL server
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return
        
# remove number from keyfieldNameWithNumber
        keyfieldName = keyfieldNameWithNumber.split('.')[1].strip()
         
        '''
# ... now find the value that goes with this key
        foundIt = 0
        for key in self.dictColumnHeaders.keys():
            if key == keyfieldName:
                foundIt = 1
                value = self.dictColumnHeaders.get(key)
                break
        if not foundIt:
# if not found, just leave combobox and items list blank
#            self.myColumnDataField1 = []
            self.comboboxSelectValueField2.clear()
            return

# use value to access field values
        if DEBUG_SELECTFIELD:
            print 
            print 'value =',value
        column = value - 1
        '''
        
        listColumnValues = []
        listColumnValues_Tuples = ()
        
# this code finds values just in local table; probably NOT what we want
        '''
        for row in range(len(self.tableValues)):
#            print 'self.tableValues[row][value-1] =',self.tableValues[row][column]
#            listColumnValues.append(self.tableValues[row][column])
            valueFromTable = self.tableValues[row][column]
            if valueFromTable <> None and valueFromTable <> '':
                listColumnValues.append(valueFromTable)
        '''
        
# look for auto_index field
        flagAutoIndex = False
        for eachItem in self.tableStructureOriginal:
            if 'auto_index' in eachItem:
                flagAutoIndex = True
                break
        
# this code finds values from the entire table on the server
# extract information from table on server
        if flagAutoIndex:
            stringExtractFieldValue = (
                'SELECT ' + keyfieldName + ' FROM ' + self.myDatabase + '.' + self.myTable
                + ' order by auto_index'
                )
        else:
            stringExtractFieldValue = (
                'SELECT ' + keyfieldName + ' FROM ' + self.myDatabase + '.' + self.myTable
                )
                
        self.MySQL_Commands(
            1,
            stringExtractFieldValue
            )
        start = time.time()
        self.cursorHandleMySQL.execute(
            stringExtractFieldValue
            )
        listColumnValues_Tuples = list(self.cursorHandleMySQL.fetchall()) # output is type tuple, so change to list
        finish = time.time()
        delta_t = finish - start
        self.MySQL_Commands(
            0,
            '  (Time: %-7.4f secs)' % delta_t
            )
            
# move tuples to list
        for (index,element) in enumerate(listColumnValues_Tuples):
            listColumnValues.append(element[0])
            
# remove blank values
        try:
            listColumnValues.remove('')
        except:
            pass
        try:
            listColumnValues.remove('None')
        except:
            pass
            
        if DEBUG_SELECTFIELD:
            print('\nlistColumnValues = ')
            print(listColumnValues)

                
# error check
# ... if listColumnValues == 0, there are no values in any of the fields to search,
#       so print error and do not allow search on this field
        if len(listColumnValues) == 0:
            stringNoValuesToSearch = (
                'The field you have selected,\n\n' +
                '%s\n\n' +
                'has no values to search on, so this field\n\n' +
                'is not allowed in the SELECT statement.\n\n' +
                'Select another field and try again.'
                ) % keyfieldNameWithNumber
            print(stringNoValuesToSearch)
            self.MySQL_Output(
                0,
                stringNoValuesToSearch
                )
            showerror(
                'Error: field is empty',
                stringNoValuesToSearch
                )
            self.comboboxSelectField2.setentry('')
            self.comboboxSelectValueField2.setentry('')
            return
# ----- end of error check

# get table structure of entire table
        completeTableStructure = self.getTableStructure()

# determine datatype of the field value
        varDatatype = ''
        for struct in completeTableStructure:
#            print('\nstruct[0] in for loop: %s   varField = %s' % (struct[0],keyfieldName))
            if struct[0] == keyfieldName:
                varDatatype = struct[1]
                varExtra = struct[5] # see table structure; = auto_increment for auto_index
                break
        if varDatatype == '':
            print '\nError: varDatatype not found in search thru self.tableStructure'
            self.MySQL_Output(
                1,
                'Error: varDatatype not found in search thru self.tableStructure'
                )
            showerror(
                'Error: varDatatype not found',
                '\nvarDatatype not found in search thru self.tableStructure.' + '\n' +
                '  This should not have happened, so cause is unknown.' + '\n\n' + 
                '  Look in ' + MODULE + ' for cause.' + '\n\n'
                )
            return
            
        if DEBUG_SELECTFIELD:
            print('varDatatype (same as struct[1]): %s' % varDatatype)
               
# check if field is numerical; if so, handle differently than if text
        varfirst2 = varDatatype[0:2]
        fieldIsNumerical = self.checkIsFieldNumerical(varfirst2)
        listSummaryField = []
        if fieldIsNumerical:
            if DEBUG_SELECTFIELD:
                print '\nField is numerical.\n'
            dictTemp = {}
            for value in listColumnValues:
                dictTemp[value] = None
            listSummaryField = list(dictTemp)
            listSummaryField.sort() 
# another way: get min & max, then 10 intervals in-between; did not like this method, since
#   if you have only two numbers from the table, the dropdown menu would spit out eleven values
#   from which to choose -- not good
            '''
            if varfirst2 == 'IN': # if integer, get all (e.g., auto_index)
                listSummaryField = listColumnValues
# min-max values
            elif len(listColumnValues) <> 0:
                columnData_max = max(listColumnValues)
                columnData_min = min(listColumnValues)
#                print 'min, max = ',columnData_min,columnData_max
# generate 10 numbers inbetween for values from which to choose
                divisions = 10.
                diff=(columnData_max - columnData_min)/divisions
                for i in range(divisions+1):
                    listSummaryField.append(columnData_min + i * diff)
            '''
            
        else:
            if DEBUG_SELECTFIELD:
                print '\nField is text.\n'
# sort field values using list from dictionary; much faster than using 'set', for example, since dicts use hash tables   
# ... dictionaries never repeat keys              
            dictTemp = {}
            for value in listColumnValues:
                dictTemp[value] = None
            listSummaryField = list(dictTemp)
            listSummaryField.sort()   
       
# remove invalid values       
        try:
            listSummaryField.remove(None)
        except:
            pass
        try:
            listSummaryField.remove('')
        except:
            pass
            
        if DEBUG_SELECTFIELD:
            print('\nlistSummaryField (sorted) =')
            print(listSummaryField)
        
# regraph combobox with new list; can't just re-define list
        self.comboboxSelectValueField2 = Pmw.ComboBox(
            self.frame_10_03,
#            scrolledlist_items=self.myColumnDataField1,
            scrolledlist_items=listSummaryField,
            listheight=120,
            entry_width=self.widthSelectValueField,
#            entry_justify=CENTER,
            scrolledlist_hull_width=500,
            )
        self.comboboxSelectValueField2.grid(
            row=4,
            column=4,
            padx=0,
            pady=0,
            )   
               
# place a value in widget, if available
        if DEBUG_SELECTFIELD:
            print('\nlistSummaryField = \n%s' % listSummaryField)
            
# place a value in widget, if available
        if len(listSummaryField) <> 0:
            self.comboboxSelectValueField2.setentry(listSummaryField[0])  
        else:
            self.comboboxSelectValueField2.setentry('')
            
# if operator field is empty, place default value in field
        if self.comboboxSelectOperatorField2.get() == '':
            self.comboboxSelectOperatorField2.setentry(self.fieldSort[0])
               
        return
        
        
    def handlerSortedColumnValuesForSelectField3(self,keyfieldNameWithNumber):
        '''
        Purpose:
         Create a list of all unique values in a database column.
         This is then listed in the SELECT 'string' combobox when a particular header is 
         selected in the 'Fields' combobox.
         
         Called by:
          handlerSelectDisplayOrderedFields
         
         Calls:
              
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerSortedColumnValuesForSelectField3')
            
# check if connected to a MySQL server
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return
        
# remove number from keyfieldNameWithNumber
        keyfieldName = keyfieldNameWithNumber.split('.')[1].strip()
        
        '''
# ... now find the value that goes with this key
        foundIt = 0
        for key in self.dictColumnHeaders.keys():
            if key == keyfieldName:
                foundIt = 1
                value = self.dictColumnHeaders.get(key)
                break
        if not foundIt:
# if not found, just leave combobox and items list blank
#            self.myColumnDataField1 = []
            self.comboboxSelectValueField3.clear()
            return

# use value to access field values
        if DEBUG_SELECTFIELD:
            print 
            print 'value =',value
        column = value - 1
        '''
        
        listColumnValues = []
        listColumnValues_Tuples = ()

# this code finds values just in local table; probably NOT what we want
        '''
        for row in range(len(self.tableValues)):
#            print 'self.tableValues[row][value-1] =',self.tableValues[row][column]
            valueFromTable = self.tableValues[row][column]
            if valueFromTable <> None and valueFromTable <> '':
                listColumnValues.append(valueFromTable)
        '''
        
# look for auto_index field
        flagAutoIndex = False
        for eachItem in self.tableStructureOriginal:
            if 'auto_index' in eachItem:
                flagAutoIndex = True
                break
        
# this code finds values from the entire table on the server
# extract information from table on server
        if flagAutoIndex:
            stringExtractFieldValue = (
                'SELECT ' + keyfieldName + ' FROM ' + self.myDatabase + '.' + self.myTable
                + ' order by auto_index'
                )
        else:
            stringExtractFieldValue = (
                'SELECT ' + keyfieldName + ' FROM ' + self.myDatabase + '.' + self.myTable
                )
                
        self.MySQL_Commands(
            1,
            stringExtractFieldValue
            )
            
        start = time.time()
        self.cursorHandleMySQL.execute(
            stringExtractFieldValue
            )
        listColumnValues_Tuples = list(self.cursorHandleMySQL.fetchall()) # output is type tuple, so change to list
        finish = time.time()
        delta_t = finish - start
        self.MySQL_Commands(
            0,
            '  (Time: %-7.4f secs)' % delta_t
            )
            
# move tuples to list
        for (index,element) in enumerate(listColumnValues_Tuples):
            listColumnValues.append(element[0])
            
# remove blank values
        try:
            listColumnValues.remove('')
        except:
            pass
        try:
            listColumnValues.remove('None')
        except:
            pass
            
        if DEBUG_SELECTFIELD:
            print('\nlistColumnValues = ')
            print(listColumnValues)
                
# error check
# ... if listColumnValues == 0, there are no values in any of the fields to search,
#       so print error and do not allow search on this field
        if len(listColumnValues) == 0:
            stringNoValuesToSearch = (
                'The field you have selected,\n\n' +
                '%s\n\n' +
                'has no values to search on, so this field\n\n' +
                'is not allowed in the SELECT statement.\n\n' +
                'Select another field and try again.'
                ) % keyfieldNameWithNumber
            print(stringNoValuesToSearch)
            self.MySQL_Output(
                0,
                stringNoValuesToSearch
                )
            showerror(
                'Error: field is empty',
                stringNoValuesToSearch
                )
            self.comboboxSelectField3.setentry('')
            self.comboboxSelectValueField3.setentry('')
            return
# ----- end of error check

# get table structure of entire table
        completeTableStructure = self.getTableStructure()
        
# determine datatype of the field value
        varDatatype = ''
        for struct in completeTableStructure:
            print('\nstruct[0] in for loop: %s   varField = %s' % (struct[0],keyfieldName))
            if struct[0] == keyfieldName:
                varDatatype = struct[1]
                varExtra = struct[5]    # see table structure; = auto_increment for auto_index
                break
        if varDatatype == '':
            print '\nError: varDatatype not found in search thru self.tableStructure'
            self.MySQL_Output(
                1,
                'Error: varDatatype not found in search thru self.tableStructure'
                )
            showerror(
                'Error: varDatatype not found',
                '\nvarDatatype not found in search thru self.tableStructure.' + '\n' +
                '  This should not have happened, so cause is unknown.' + '\n\n' + 
                '  Look in ' + MODULE + ' for cause.' + '\n\n'
                )
            return
            
        if DEBUG_SELECTFIELD:
            print('varDatatype (same as struct[1]): %s' % varDatatype)
               
# check if field is numerical; if so, handle differently than if text
        varfirst2 = varDatatype[0:2]
        fieldIsNumerical = self.checkIsFieldNumerical(varfirst2)
        listSummaryField = []
        if fieldIsNumerical:
            if DEBUG_SELECTFIELD:
                print '\nField is numerical.\n'
            dictTemp = {}
            for value in listColumnValues:
                dictTemp[value] = None
            listSummaryField = list(dictTemp)
            listSummaryField.sort()
# another way: get min & max, then 10 intervals in-between; did not like this method, since
#   if you have only two numbers from the table, the dropdown menu would spit out eleven values
#   from which to choose -- not good
            '''
            if varfirst2 == 'IN': # if integer, get all (e.g., auto_index)
                listSummaryField = listColumnValues
# min-max values
            elif len(listColumnValues) <> 0:
                columnData_max = max(listColumnValues)
                columnData_min = min(listColumnValues)
                print('\nlistColumnValues = \n%s' % listColumnValues)
                print 'min, max = ',columnData_min,columnData_max
# generate 10 numbers inbetween for values from which to choose
                divisions = 10.
                diff=(columnData_max - columnData_min)/divisions
                for i in range(divisions+1):
                    listSummaryField.append(columnData_min + i * diff)
            '''
            
        else:
            if DEBUG_SELECTFIELD:
                print '\nField is text.\n'
# sort field values using list from dictionary; much faster than using 'set', for example, since dicts use hash tables   
# ... dictionaries never repeat keys              
            dictTemp = {}
            for value in listColumnValues:
                dictTemp[value] = None
            listSummaryField = list(dictTemp)
            listSummaryField.sort()   
            
# remove invalid values            
        try:
            listSummaryField.remove(None)
        except:
            pass
        try:
            listSummaryField.remove('')
        except:
            pass
            
        if DEBUG_SELECTFIELD:
            print('\nlistSummaryField (sorted) =')
            print(listSummaryField)
        
# regraph combobox with new list; can't just re-define list
        self.comboboxSelectValueField3 = Pmw.ComboBox(
            self.frame_10_03,
#            scrolledlist_items=self.myColumnDataField1,
            scrolledlist_items=listSummaryField,
            listheight=120,
            entry_width=self.widthSelectValueField,
#            entry_justify=CENTER,
            scrolledlist_hull_width=500,
            )
        self.comboboxSelectValueField3.grid(
            row=6,
            column=4,
            padx=0,
            pady=0,
            ) 
         
        if DEBUG_SELECTFIELD:
            print('\nlistSummaryField = \n%s' % listSummaryField)
            
# place a value in widget, if available
        if len(listSummaryField) <> 0:
            self.comboboxSelectValueField3.setentry(listSummaryField[0])  
        else:
            self.comboboxSelectValueField3.setentry('')       

# if operator field is empty, place default value in field
        if self.comboboxSelectOperatorField3.get() == '':
            self.comboboxSelectOperatorField3.setentry(self.fieldSort[0])            
               
        return
        

    def handlerResetFieldSizeDefaults(self):
        '''
        Purpose:
            reset 'Field width', 'Field height', and 'Field font' values
            
        Called by:
            handlerTableFunctionsShowValues
            
        Calls:
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerResetFieldSizeDefaults')
            
# set last button pressed
        self.lastButtonPressed(
            BUTTONLABEL_RESET
            )

# check if connected to a MySQL server
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return

# reset default values
        self.comboboxWidthField.selectitem(self.mytableFieldWidths[2])
        self.comboboxHeightField.selectitem(self.mytableFieldHeights[0])
        self.comboboxFontField.selectitem(self.mytableFieldFonts[1])
# refresh table view
        self.handlerRefreshTableView(0)
# update status line
        maxLinesDisplay = int(self.comboboxMaxLinesToDisplay.get())
        if maxLinesDisplay == 0 or maxLinesDisplay > len(self.tableValues):
            maxLinesDisplay = len(self.tableValues)

        self.handlerStatusLineRefresh(maxLinesDisplay)
        
        return
        
        
    def handlerBaseForLogPlots_XY(self):
        '''
        Purpose:
            enables or disables 'Base for log plots' combobox, depending on whether
            'cartesian' is selected
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerBaseForLogPlots')
            
        if self.var_radiobuttonPlotStyle.get().strip() == 'cartesian':
            self.comboboxBaseForLogPlotsX._entryWidget['state']=DISABLED
            self.comboboxBaseForLogPlotsY._entryWidget['state']=DISABLED
        elif self.var_radiobuttonPlotStyle.get().strip() == 'semilogx':
            self.comboboxBaseForLogPlotsX._entryWidget['state']=NORMAL
            self.comboboxBaseForLogPlotsY._entryWidget['state']=DISABLED
        elif self.var_radiobuttonPlotStyle.get().strip() == 'semilogy':
            self.comboboxBaseForLogPlotsX._entryWidget['state']=DISABLED
            self.comboboxBaseForLogPlotsY._entryWidget['state']=NORMAL
        else:
            self.comboboxBaseForLogPlotsX._entryWidget['state']=NORMAL
            self.comboboxBaseForLogPlotsY._entryWidget['state']=NORMAL
        
        return
        
        
    def handlerBaseForLogPlots_Scatter(self):
        '''
        Purpose:
            enables or disables 'Base for log plots' combobox, depending on whether
            'cartesian' is selected
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerBaseForLogPlots_Scatter')
            
        if self.var_radiobuttonPlotStyle_Scatter.get().strip() == 'cartesian':
            self.comboboxBaseForLogPlotsX_Scatter._entryWidget['state']=DISABLED
            self.comboboxBaseForLogPlotsY_Scatter._entryWidget['state']=DISABLED
        elif self.var_radiobuttonPlotStyle_Scatter.get().strip() == 'semilogx':
            self.comboboxBaseForLogPlotsX_Scatter._entryWidget['state']=NORMAL
            self.comboboxBaseForLogPlotsY_Scatter._entryWidget['state']=DISABLED
        elif self.var_radiobuttonPlotStyle_Scatter.get().strip() == 'semilogy':
            self.comboboxBaseForLogPlotsX_Scatter._entryWidget['state']=DISABLED
            self.comboboxBaseForLogPlotsY_Scatter._entryWidget['state']=NORMAL
        else:
            self.comboboxBaseForLogPlotsX_Scatter._entryWidget['state']=NORMAL
            self.comboboxBaseForLogPlotsY_Scatter._entryWidget['state']=NORMAL
        
        return
        
        
    def handlerCheckbuttonPlotCsvFileData_AllCurvesOnePlot(self):
        '''
        Purpose:
            enables or disables entry, x, and y fields in 'Plotting Specs' window
            depending on whether checkbutton is set
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerCheckbuttonPlotCsvFileData_AllCurvesOnePlot')
            
        if self.varCheckbuttonPlotCsvFileData_AllCurvesOnePlot.get():
            self.entryPlotCsvFileData_AllCurvesOnePlot.configure(state='normal')
            self.comboboxPlotCsvFileData_X_Column_AllCurvesOnePlot._entryWidget['state']=NORMAL
            self.comboboxPlotCsvFileData_Y_Column_AllCurvesOnePlot._entryWidget['state']=NORMAL
        else:
            self.entryPlotCsvFileData_AllCurvesOnePlot.configure(state='disabled')
            self.comboboxPlotCsvFileData_X_Column_AllCurvesOnePlot._entryWidget['state']=DISABLED
            self.comboboxPlotCsvFileData_Y_Column_AllCurvesOnePlot._entryWidget['state']=DISABLED

            
        return
        
        
    def handlerCheckbuttonPlotCsvFileData_AllCurvesOnePlot_Scatter(self):
        '''
        Purpose:
            enables or disables entry, x, and y fields in 'Plotting Specs' window
            depending on whether checkbutton is set
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerCheckbuttonPlotCsvFileData_AllCurvesOnePlot_Scatter')
            
        if self.varCheckbuttonPlotCsvFileData_AllCurvesOnePlot_Scatter.get():
            self.entryPlotCsvFileData_AllCurvesOnePlot_Scatter.configure(state='normal')
            self.comboboxPlotCsvFileData_X_Column_AllCurvesOnePlot_Scatter._entryWidget['state']=NORMAL
            self.comboboxPlotCsvFileData_Y_Column_AllCurvesOnePlot_Scatter._entryWidget['state']=NORMAL
        else:
            self.entryPlotCsvFileData_AllCurvesOnePlot_Scatter.configure(state='disabled')
            self.comboboxPlotCsvFileData_X_Column_AllCurvesOnePlot_Scatter._entryWidget['state']=DISABLED
            self.comboboxPlotCsvFileData_Y_Column_AllCurvesOnePlot_Scatter._entryWidget['state']=DISABLED

            
        return
        

    def handlerButtonBrowseForPlotCsvFileData_AllCurvesOnePlot(self):
        '''
        Purpose:
            browse for file from which to read x-y data to plot 
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerButtonBrowseForPlotCsvFileData_AllCurvesOnePlot')

# define dictionary of options for askopenfilename()
        options = {}
        options = {
            'defaultextension' : '.csv',
            'filetypes' : [('Comma-Separated Values','.csv'),('All files','*')],
            'initialdir' : '.',
            'initialfile' : '',
            'parent' : self.toplevelXYPlotPreprocess,
            'title' : 'Pick csv filename'
            }      
# get current filename in entry field
#        currentFileName = self.varEntryPlotFileData_AllCurvesOnePlot.get()
#        print '     Current filename:',currentFileName
        
# clear current selection
        self.entryPlotFileData_AllCurvesOnePlot.select_clear()
# get filename using askopenfilename
#        dirname, filename = os.path.split(tkFileDialog.askopenfilename(**options))
        self.fullpath_FileNameForPlotFileData_AllCurvesOnePlot = tkFileDialog.askopenfilename(**options)
        dirname, filename = os.path.split(self.fullpath_FileNameForPlotFileData_AllCurvesOnePlot)
#        dirname, filename = os.path.split(asksaveasfilename(**options))
# dwb - NOTE
#   os.path.split(askopenfilename()) gives forward slashes in the filename
#   os.getcwd() gives backward slashes in the filename
#       Hence, one cannot compare the results of these two methods to ensure the user stays in the same directory.
#       Too bad :(
#        if filename == '' and currentFileName == '':
        if filename == '':
            print '   No filename chosen!'
            showinfo(
                '\nNo filename chosen...',
                'You must enter a filename.\n\n'
                )
            return            
        else:
            print
            print ' dirname =',dirname
            print ' filename =',filename
            print ' full pathname = ',self.fullpath_FileNameForPlotFileData_AllCurvesOnePlot
            print
            self.varEntryPlotFileData_AllCurvesOnePlot.set(filename)

# get headers from this file and use as scrolledlist_items in x-col and y-col comboboxes
            
        return
        
        
    def handlerButtonBrowseForPlotCsvFileData_AllCurvesOnePlot_Scatter(self):
        '''
        Purpose:
            browse for file from which to read x-y data to plot 
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerButtonBrowseForPlotCsvFileData_AllCurvesOnePlot_Scatter')

# define dictionary of options for askopenfilename()
        options = {}
        options = {
            'defaultextension' : '.csv',
            'filetypes' : [('Comma-Separated Values','.csv'),('All files','*')],
            'initialdir' : '.',
            'initialfile' : '',
            'parent' : self.toplevelScatterPlotPreprocess,
            'title' : 'Pick csv filename'
            }      
# get current filename in entry field
#        currentFileName = self.varEntryPlotFileData_AllCurvesOnePlot.get()
#        print '     Current filename:',currentFileName
        
# clear current selection
        self.entryPlotFileData_AllCurvesOnePlot_Scatter.select_clear()
# get filename using askopenfilename
#        dirname, filename = os.path.split(tkFileDialog.askopenfilename(**options))
        self.fullpath_FileNameForPlotFileData_AllCurvesOnePlot_Scatter = tkFileDialog.askopenfilename(**options)
        dirname, filename = os.path.split(self.fullpath_FileNameForPlotFileData_AllCurvesOnePlot_Scatter)
#        dirname, filename = os.path.split(asksaveasfilename(**options))
# dwb - NOTE
#   os.path.split(askopenfilename()) gives forward slashes in the filename
#   os.getcwd() gives backward slashes in the filename
#       Hence, one cannot compare the results of these two methods to ensure the user stays in the same directory.
#       Too bad :(
#        if filename == '' and currentFileName == '':
        if filename == '':
            print '   No filename chosen!'
            showinfo(
                '\nNo filename chosen...',
                'You must enter a filename.\n\n'
                )
            return            
        else:
            print
            print ' dirname =',dirname
            print ' filename =',filename
            print ' full pathname = ',self.fullpath_FileNameForPlotFileData_AllCurvesOnePlot_Scatter
            print
            self.varEntryPlotFileData_AllCurvesOnePlot_Scatter.set(filename)

# get headers from this file and use as scrolledlist_items in x-col and y-col comboboxes
            
        return
        
        
    def handlerUpdateFieldSelectValues(self):
        '''
        Purpose:
            Depending on whether the 'all' or 'y-select' button is checked
            in the Select & Display window, update the field values from
            which to choose.
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerUpdateFieldSelectValues')
            
# initialize variables
        valueForX = 0
            
# sort field headers as taken from server, not displayed table
#        itemList.sort()
        tempMyDatabaseFields = []
        for number,field in enumerate(self.myDatabaseFields): #[0:-1]):
            tempMyDatabaseFields.append(str(number + 1) + '. ' + field)
# define as scrolled list items for all 3 boxes in Select & Display window
# select-field 1
# ... save original entry and re-display, even though new list may not contain that item
        saveField1 = self.comboboxSelectField1.get()
        self.comboboxSelectField1 = Pmw.ComboBox(
            self.frame_10_03,
            scrolledlist_items = tempMyDatabaseFields,
            selectioncommand=self.handlerSortedColumnValuesForSelectField1,
            scrolledlist_hull_width=500,
            )
        self.comboboxSelectField1.grid(
            row=2,
            column=2,
            padx=5,
            pady=0,
            )
        self.comboboxSelectField1.setentry(saveField1)
#        self.comboboxSelectField1.component('label').configure(bg='tan')
# select-field 2
        saveField2 = self.comboboxSelectField2.get()
        self.comboboxSelectField2 = Pmw.ComboBox(
            self.frame_10_03,
            scrolledlist_items = tempMyDatabaseFields,
            selectioncommand=self.handlerSortedColumnValuesForSelectField2,
            scrolledlist_hull_width=500,
            )
        self.comboboxSelectField2.grid(
            row=4,
            column=2,
            padx=0,
            pady=0,
            )
        self.comboboxSelectField2.setentry(saveField2)
#        self.comboboxSelectField2.component('label').configure(bg='tan')
# select-field 3
        saveField3 = self.comboboxSelectField3.get()
        self.comboboxSelectField3 = Pmw.ComboBox(
            self.frame_10_03,
#            scrolledlist_items = self.myDatabaseFields,
            scrolledlist_items = tempMyDatabaseFields,
            selectioncommand=self.handlerSortedColumnValuesForSelectField3,
            scrolledlist_hull_width=500,
            )
        self.comboboxSelectField3.grid(
            row=6,
            column=2,
            padx=0,
            pady=0,
            )
        self.comboboxSelectField3.setentry(saveField3)
#        self.comboboxSelectField3.component('label').configure(bg='tan')
# leave 'Operator' and 'Value' fields as is for all fields
# now define scrolled list items for 'Sort Order' fields
# ... sort-order field 1
        saveOrderByField1 = self.comboboxOrderByField1.get()
        self.comboboxOrderByField1 = Pmw.ComboBox(
            self.frame_10_05,
#            scrolledlist_items = itemList,
            scrolledlist_items = tempMyDatabaseFields,
            label_text='1. ',
            labelpos='w',
            label_background='tan',
            listheight=150,
            scrolledlist_hull_width=500,
            )
        self.comboboxOrderByField1.grid(
            row=1,
            column=0,
            rowspan=2,
            padx=5,
            pady=5,
            )
        self.comboboxOrderByField1.setentry(saveOrderByField1)
#        self.comboboxOrderByField1.component('label').configure(bg='tan')
# ... sort-order field 2
        saveOrderByField2 = self.comboboxOrderByField2.get()
        self.comboboxOrderByField2 = Pmw.ComboBox(
            self.frame_10_05,
#            scrolledlist_items = itemList,
            scrolledlist_items = tempMyDatabaseFields,
            label_text='2. ',
            labelpos='w',
            label_background='tan',
            listheight=150,
            scrolledlist_hull_width=500,
            )
        self.comboboxOrderByField2.grid(
            row=4,
            column=0,
            rowspan=2,
            padx=5,
            pady=5,
            )
        self.comboboxOrderByField2.setentry(saveOrderByField2)
#        self.comboboxOrderByField2.component('label').configure(bg='tan')
# ... sort-order field 3
        saveOrderByField3 = self.comboboxOrderByField3.get()
        self.comboboxOrderByField3 = Pmw.ComboBox(
            self.frame_10_05,
#            scrolledlist_items = itemList,
            scrolledlist_items = tempMyDatabaseFields,
            label_text='1. ',
            labelpos='w',
            label_background='tan',
            listheight=150,
            scrolledlist_hull_width=500,
            )
        self.comboboxOrderByField3.grid(
            row=7,
            column=0,
            rowspan=2,
            padx=5,
            pady=5,
            )
        self.comboboxOrderByField3.setentry(saveOrderByField3)
#        self.comboboxOrderByField3.component('label').configure(bg='tan')

        return
        

    def handlerRefreshTableView(self,value):
        '''
        Purpose:
        refresh current table view with latest values for
        field width, field height, and field font
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerRefreshTableView')
            
# save checked field names before re-defining self.dictColumnHeadersOriginal
        self.saveCheckedFieldNames()
            
# display results
#        self.valuesDisplayRowDecimate(self.tableStructure,self.tableValues)
        self.handlerTableFunctionsShowValues(0,'all')
        
# restore checked field names
        self.restoreCheckedFieldNames()
        
# update status line
        '''
        maxLinesDisplay = int(self.comboboxMaxLinesToDisplay.get())
        if maxLinesDisplay == 0 or maxLinesDisplay > len(self.tableValues):
            maxLinesDisplay = len(self.tableValues)
            
        self.handlerStatusLineRefresh(maxLinesDisplay)
        '''
        
        return
        
        
    def handlerResetFieldSizeDefaultsBuffer(self):
        '''
        Purpose:
            reset Storage Buffer window to default values
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerResetFieldSizeDefaultsBuffer')
            
        self.comboboxWidthFieldBuffer.selectitem(self.mytableFieldWidths[2])
        self.comboboxHeightFieldBuffer.selectitem(self.mytableFieldHeights[0])
        self.comboboxFontFieldBuffer.selectitem(self.mytableFieldFonts[1])
# display with default values set
        self.handlerDisplayStorageBufferValues_Call()
        
        return
        
        
    def handlerRefreshBufferView(self):
        '''
        Purpose:
            refresh current buffer view with latest values for
        field width, field height, and field font
        '''
# clear parts of window that need to be refreshed
# clear the previous row numbers and database grid  
# ... checkbuttons with row number    
        '''
        self.clear_grid(self.frame_21_canvas_Buffer)
# ... fields
        self.clear_grid(self.frame_22_canvas_Buffer)
#  ... header frame
        self.clear_grid(self.frame_11_canvas_Buffer)
# ... scrollbars
        self.clear_grid(self.yScroll_frame_22_Buffer)
        self.clear_grid(self.xScroll_frame_22_Buffer)
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerRefreshBufferView')
        
#        self.handlerShowStorageBuffer()
# first, set Hide/Show User Fields button to Hide; display is refreshed for 2nd line
#        self.varHideShowSet.set(0)
        self.handlerHideShowUserFields_Buffer()
# refresh display (generates a pop-up asking to destroy or continue with X-Y Plot window)
#        self.handlerInvokeButtonToRefreshPlotXYWindow()
        
        return
        
        
    def handlerComboboxDisplayStorageBufferValues_Call(self,notUsed):
        '''
        Purpose:
            Call displayStorageBufferValues with appropriate
            value to refresh all, or all fields except User, fields
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerComboboxDisplayStorageBufferValues_Call')
        
        try:
            numRows = self.bufferRowStore_NumRows
        except:
            numRows = 0
        
        if numRows == 0:
            try:
                self.buffer_xWindowLocation = self.toplevelShowStorageBuffer.winfo_rootx() - self.offsetWindowX
                self.buffer_yWindowLocation = self.toplevelShowStorageBuffer.winfo_rooty() - self.offsetWindowY
                self.toplevelShowStorageBuffer.destroy()
            except:
                pass
# display new total in main table window
            self.countDisplayStorageBuffer.set(
                'BUFFER: Display (0 rows)'
                )
# set status line
            try:
                showinfo(
                    'Info: empty buffer',
                    'Storage buffer is empty',
                    parent=self.toplevelShowStorageBuffer
                    )
            except:
                showinfo(
                    'Info: empty buffer',
                    'Storage buffer is empty'
                    )
            return
            
        try:
            varHideShow = self.varHideShowSet.get()
        except:
            varHideShow = 0
        
        if varHideShow == 0:
# show all user fields
            self.displayStorageBufferValues(0)
        else:
# hide all user fields
            self.displayStorageBufferValues(5)
        
        return
        
        
    def handlerDisplayStorageBufferValues_Call(self):
        '''
        Purpose:
            Call displayStorageBufferValues with appropriate
            value to refresh all, or all fields except User, fields.
            Refresh Storage Buffer window.
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerDisplayStorageBufferValues_Call')

# set last button pressed
        self.lastButtonPressed(
            BUTTONLABEL_BUFFERDISPLAY
            )
            
# if buffer window exists, do nothing
        '''
        try:
            mapped = self.toplevelShowStorageBuffer.winfo_exists()
        except:
            mapped = False
  
        if mapped:
            stringStorageBufferIsMapped = (
                'Storage Buffer window is already open.'
                )
            showinfo(
                'Info: window is open',
                stringStorageBufferIsMapped
                )
            return
        '''
        try:
            numRows = self.bufferRowStore_NumRows
        except:
            numRows = self.bufferRowStore_NumRows = 0
        
        if numRows == 0:
            try:
                self.buffer_xWindowLocation = self.toplevelShowStorageBuffer.winfo_rootx() - self.offsetWindowX
                self.buffer_yWindowLocation = self.toplevelShowStorageBuffer.winfo_rooty() - self.offsetWindowY
# #                self.toplevelShowStorageBuffer.destroy()
            except:
                pass
# display new total in main table window
            self.countDisplayStorageBuffer.set(
                'BUFFER: Display (0 rows)'
                )
# #            showinfo(
# #                'Info: empty buffer',
# #                'Storage buffer is empty'
# #                parent=self.toplevelShowStorageBuffer
# #                )
# #            return
            
        try:
            varHideShow = self.varHideShowSet.get()
        except:
            varHideShow = 0
        
        if varHideShow == 0:
# show all user fields
            self.displayStorageBufferValues(0)
        else:
# hide all user fields
            self.displayStorageBufferValues(5)
# refresh Plotting Specs window if open
#        self.handlerInvokeButtonToRefreshPlotXYWindow()
# refresh  Storage Buffer window
#        self.buttonTableValuesShowAll_Buffer.invoke()
        self.handlerRefreshBufferView() # handler for Table Values Show All - Buffer
        
# if no rows, say so
        if numRows == 0:
            self.bufferRowStore_NumRows = 0
            try:
                showinfo(
                    'Info: empty buffer',
                    'Storage buffer is empty',
                    parent=self.toplevelShowStorageBuffer
                    )
            except:
                showinfo(
                    'Info: empty buffer',
                    'Storage buffer is empty'
                    )
        
        return
        
        
    def handlerReplotInCurrentWindow(self):
        '''
        Purpose:
        to disable/enable the checkbutton for
          'Erase previous plot' in X-Y Plot window
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerReplotInCurrentWindow')
            
        # ...       disable replot button if 'erase previous plot' button is not checked
        if self.varReplotInCurrentWindow.get():
            self.checkbuttonKeepPreviousPlotInCurrentWindow.configure(state='normal')
        else:
            self.checkbuttonKeepPreviousPlotInCurrentWindow.configure(state='disabled')
            
        return
        
        
    def handlerReplotInCurrentWindow_Scatter(self):
        '''
        Purpose:
        to disable/enable the checkbutton for
          'Erase previous plot' in Scatter Plot window
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerReplotInCurrentWindow_Scatter')
            
        # ...       disable replot button if 'erase previous plot' button is not checked
        if self.varReplotInCurrentWindow_Scatter.get():
            self.checkbuttonKeepPreviousPlotInCurrentWindow_Scatter.configure(state='normal')
        else:
            self.checkbuttonKeepPreviousPlotInCurrentWindow_Scatter.configure(state='disabled')
            
        return
        
        
    def handlerDestroyToplevelTableValues(self):
        '''
        Purpose:
            destroy toplevel TableValues window;
            also sets to zero the number of curves selected
            in the 'Plotting Specs' window if this window
            is currently displayed
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerDestroyToplevelTableValues')
                
# destroy "Table Filter" window if open, but ask first
# ... (let user close it if needed, so comment the following section)
        '''
        try:
            mappedFilter = self.toplevelSelectDisplayOrderedFields.winfo_exists()
        except:
            mappedFilter = False
            
        if mappedFilter:
            stringAskToCloseMappedFilter = (
                'The Filter window is open!\n\n' +
                'Close it?'
                )
            ans = askyesno(
                'Question: close filter window?',
                stringAskToCloseMappedFilter
                )
            if ans:
                try:
                    self.toplevelSelectDisplayOrderedFields.destroy()
                except:
                    pass
        '''
            
# kill the Quik-Select window if open
        self.handlerQuikSelectCancelWindow()   
            
# see what other windows are open and take appropriate action
# ... reset number of curves entry to zero if window is displayed  

# ... check XY Plot Specs window 
        try:
            mappedXYPlotSpecs = self.toplevelXYPlotPreprocess.winfo_exists()
        except:
            mappedXYPlotSpecs = False
            
# ... check Scatter Plot Specs window
        try:
            mappedScatterPlotSpecs = self.toplevelScatterPlotPreprocess.winfo_exists()
        except: 
            mappedScatterPlotSpecs = False
            
# ... check Kiviat Plot Specs window
        try:
            mappedKiviatPlotSpecs = self.toplevelKiviatPlotPreprecess.winfo_exists()
        except:
            mappedKiviatPlotSpecs = False
            
        if mappedXYPlotSpecs or mappedScatterPlotSpecs or mappedKiviatPlotSpecs:
            stringClosePlotWindows = (
                'The following plotting windows are open:\n\n' 
                )
            if mappedXYPlotSpecs:
                stringClosePlotWindows += (
                    '  - XY Plot Specs\n'
                    )
            if mappedKiviatPlotSpecs:
                stringClosePlotWindows += (
                    '  - Kiviat Plot Specs\n' 
                    )
            if mappedScatterPlotSpecs:
                stringClosePlotWindows += (
                    '  - Scatter Plot Specs\n'
                    )
            stringClosePlotWindows += (
                '\nClose these windows?'
                )
                
            ans = askyesno(
                'Question: close plot windows',
                stringClosePlotWindows
                )
                
            if ans:
                if mappedXYPlotSpecs:
                    self.toplevelXYPlotPreprocess.destroy()
                    
                if mappedKiviatPlotSpecs:
                    self.toplevelKiviatPlotPreprecess.destroy()
                    
                if mappedScatterPlotSpecs:
                    self.toplevelScatterPlotPreprocess.destroy()
                    
            else:
            
                if mappedXYPlotSpecs:
                    self.varNumberOfTableCurves.set(0)
                    self.varNumberOfStorageBufferCurves.set(0)
                    self.varNumberOfTotalCurves.set(0)
                    
                if mappedKiviatPlotSpecs:
                    self.varNumberOfTableGroups_Kiviat.set(0)
                    self.varNumberOfStorageBufferGroups_Kiviat.set(0)
                    
                if mappedScatterPlotSpecs:
                    self.varNumberOfTableCurves_Scatter.set(0)
                    self.varNumberOfStorageBufferCurves_Scatter.set(0)
                    self.varNumberOfTotalCurves_Scatter.set(0)
                    
# save checked field names before re-defining self.dictColumnHeadersOriginal;
# ... don't call if self.varYSelect <> self.dictColumnHeader, since then value
# ... for self.varYSelect does not reflect the values recently defined in 
# ... self.dictColumnHeader, which implies the table has yet to be updated
#        if len(self.varYSelect) == len(self.dictColumnHeader):
#            self.saveCheckedFieldNames() 
                    
# destroy toplevel, but mark location first; new window will open in same location
        self.tableValues_xWindowLocation = self.toplevelTableValues.winfo_rootx() - self.offsetWindowX
        self.tableValues_yWindowLocation = self.toplevelTableValues.winfo_rooty() - self.offsetWindowY
        self.toplevelTableValues.destroy()
                    
        return
        
        
    def handlerCheckbuttonBufferData(self):
        '''
        Purpose:
            if no data have been selected in storage buffer,
            then uncheck this box if checked by user, and give
            error msg
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerCheckbuttonBufferData')
            
        curvesSelectedFromTable = self.varNumberOfTableCurves.get()
        curvesToPlotBuffer = self.varNumberOfStorageBufferCurves.get()
        curvesSelectedFromBuffer = 0
        for var in self.varSelectAnyRow_Buffer:
            if var.get():
                curvesSelectedFromBuffer += 1
               
        if self.bufferRowStore_NumRows == 0:
# display new total in main table window
            self.countDisplayStorageBuffer.set(
                'BUFFER: Display (0 rows)'
                )
            try:
                showinfo(
                    'Info: empty buffer',
                    'Storage buffer is empty',
                    parent=self.toplevelXYPlotPreprocess,
                    )
            except:
                showinfo(
                    'Info: empty buffer',
                    'Storage buffer is empty'
                    )
            self.varCheckbuttonBufferData.set(0)
            return

# 'Plot curves from Storage Buffer'  is checked but there are no curves
        if curvesSelectedFromBuffer == 0:
            stringErrorNoBufferCurves = (
                'No data have been selected for plotting\n' +
                'from the storage buffer.\n\n' + 
                'Select desired buffer data before checking this box.'
                )
            print stringErrorNoBufferCurves
            self.MySQL_Output(
                0,
                stringErrorNoBufferCurves
                )
            showerror(
                'Error: no buffer data selected',
                stringErrorNoBufferCurves
                )
            self.varCheckbuttonBufferData.set(0)        
        elif self.varCheckbuttonBufferData.get():
# adjust plot window if it's open
            self.handlerInvokeButtonToRefreshPlotXYWindow()
# if 'include select curves' is checked add  'Number of curves' and 'from storage buffer'      
            '''
            plotsTotal = (
                self.varNumberOfTableCurves.get() + self.varNumberOfStorageBufferCurves.get()
                )
            self.varNumberOfTotalCurves.set(plotsTotal)
            '''
        else:  
# adjust plot window if it's open
            self.handlerInvokeButtonToRefreshPlotXYWindow()        
# if 'include select curves' is NOT checked, total curves is simply 'number of curves selected from table'
            '''
            self.varNumberOfTotalCurves.set(curvesTable)
            '''
        return
            
        
    def handlerDestroyToplevelShowStorageBuffer(self):
        '''
        Purpose:
            destroy toplevel TableValues window;
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerDestroyToplevelShowStorageBuffer')
            
# first, deselect all curves
        try:
            for var in self.varSelectAnyRow_Buffer:
                var.set(0)
        except:
            pass
# refresh Plotting Specs window if open (generates a pop-up asking to destroy or continue with X-Y Plot window)
#        self.handlerInvokeButtonToRefreshPlotXYWindow()
# destroy toplevel
        self.buffer_xWindowLocation = self.toplevelShowStorageBuffer.winfo_rootx() - self.offsetWindowX
        self.buffer_yWindowLocation = self.toplevelShowStorageBuffer.winfo_rooty() - self.offsetWindowY
        self.toplevelShowStorageBuffer.destroy()
            
        return
        
    
    def handlerStoreXYinStorageBuffer_Table(self):
        '''
        Purpose:
          Displays X-Y values from table in storage buffer.
          
          Structure of storage buffer:
          1. user_field_1
          2. user_field_2
          3. user_field_3
          4. user_field_4
          5. x header
          6. y header
          7. first (x,y) pair
          8. last (x,y) pair
          9. database name
          10. table name
          11. number of points stored
          12. timestamp
         Not shown but present:
          13. x values
          14. y values 
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerStoreXYinStorageBuffer_Table')
 
# set last button pressed
        self.lastButtonPressed(
            BUTTONLABEL_BUFFERSTORE
            )
 
# set to 1 to print
        DEBUG_STOREXYINSTORAGEBUFFER = 0
            
# check if connected to a MySQL server
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return  

# check if a table has even been read in 
        emptyTableCheck = self.checkIfEmptyTable()
        if emptyTableCheck:
            return        
            
# what is current buffer row?
        try:
            self.bufferRowStore_NumRows = len(self.bufferRowStore)
        except:
# initialize; bufferRowStore_NumRows needs to be defined as list of lists
            self.bufferRowStore = []
            self.bufferRowStore_NumRows = 0
            
# assume initially that all selected fields will be numerical
        flag_FieldXIsNotNumerical = 0
        flag_FieldYIsNotNumerical = 0
        stringIndexExists = ''
# make sure both x and y have been selected
        xIndexExists = self.varXSelect.get()
        yIndexExists = False
        for var in self.varYSelect:
            yIndexExists = var.get()
            if yIndexExists: break
        if (not xIndexExists) or (not yIndexExists):
            if not xIndexExists:
                stringIndexExists += 'No X value selected.\n\n'
            if not yIndexExists:
                stringIndexExists += 'No Y value(s) selected.\n\n'
            stringIndexExists += (
                'Please select both X and Y values and try again.\n'
                )
            print(stringIndexExists)
            showerror(
                'Error: values not selected',
                stringIndexExists
                )
            return
                       
# now make sure x and y are both numerical fields
# ... x index -- only one!
        xIndexError = True
        self.xHeader_Buffer = ''
        index = self.varXSelect.get()
        if index:
            xIndexError = False
            if DEBUG_STOREXYINSTORAGEBUFFER:
                print 'self.varXSelect index =\n',index
            for key,value in self.dictColumnHeaders.iteritems():
                if value == index:
                    if DEBUG_STOREXYINSTORAGEBUFFER:
                        print '    > x_header = ',key
                    self.xHeader_Buffer = key
                    xIndex = index - 1
                    break
# check if x-field is numerical
        xVarFirst2 = self.tableStructure[xIndex][1][0:2]
        print 'xVarFirst2 =',xVarFirst2
        fieldXIsNumerical = self.checkIsFieldNumerical(xVarFirst2)
        if not fieldXIsNumerical:
# x-select  field is NOT numerical
            flag_FieldXIsNotNumerical = 1
            print('\nError: X-Select field "%s" for plotting is not numerical' % key)
            self.MySQL_Output(
                1,
                'Error: X-Select field "%s" for plotting is not numerical' % (key)
                )
        else:
# x-select field is numerical, so OK
            if DEBUG_ISNUMERICALFIELD:
                print('\nX-Select field "%s" is a numerical field' % key)
                    
# ... y indices -- can be more than one
        self.yHeader_Buffer = []
        yIndex = []
        if DEBUG_STOREXYINSTORAGEBUFFER:
            print
            print 'self.varYSelect =\n'
        index = 0
        yIndexError = True     # if a value is found, this will be set to False
        for var in self.varYSelect:
            index += 1
            if DEBUG_STOREXYINSTORAGEBUFFER:
                print '  var =',var.get()
            if var.get():
                yIndexError = False
                for key,value in self.dictColumnHeaders.iteritems():
                    if value == index: 
                        if DEBUG_STOREXYINSTORAGEBUFFER:
                            print '    > y_header =',key
                        self.yHeader_Buffer.append(key)
                        yIndex.append(index-1)
#   check if field is numerical
                        yVarFirst2 = self.tableStructure[index-1][1][0:2]
#                        print ' self.tableStructureOriginal = ',self.tableStructureOriginal
                        fieldYIsNumerical = self.checkIsFieldNumerical(yVarFirst2)
                        if not fieldYIsNumerical:
# y-select field is NOT numerical
                            flag_FieldYIsNotNumerical = 1
                            print('\nError: Y-Select field "%s" for plotting is not numerical' % key)
                            self.MySQL_Output(
                                1,
                                'Error: Y-Select field "%s" for plotting is not numerical' % (key)
                                )
                        else:
# y-select field is numerical, so OK
                            if DEBUG_ISNUMERICALFIELD:
                                print('\nY-Select field "%s" is a numerical field' % key)
                        break
# check if x and y values are chosen                        
        if xIndexError or yIndexError:
            stringIndexError = ''
            if xIndexError:
                stringIndexError += 'No X-Select value chosen.\n\n'
            if yIndexError:
                stringIndexError += 'No Y-Select value(s) chosen.\n\n'
            stringIndexError += 'Please select X-Select AND Y-Select value(s) and try again.\n'
            showerror(
                'Error: no value(s) selected',
                stringIndexError
                )
            return 

# if any field is not numerical, tell user and return
# if X-Select or Y-Select is not numerical, return                            
        if flag_FieldXIsNotNumerical or flag_FieldYIsNotNumerical:
            stringFieldError = ''
            if flag_FieldXIsNotNumerical:
                stringFieldError+='X-Select field not numerical.' + '\n\n'         
            if flag_FieldYIsNotNumerical:
                stringFieldError+='Y-Select field(s) not numerical.' + '\n\n'
            stringFieldError+=(
                'Select numerical fields for both X and Y' + '\n' +
                '  and try again.'
                )
            showerror(
                'Error: field(s) not numerical',
                stringFieldError
                )
            return              
        
        if DEBUG_STOREXYINSTORAGEBUFFER:
            print
            print 'xIndex = ',xIndex
            print
            print 'yIndex = ',yIndex
            print
            print 'self.tableValues ='
            for i in range(len(self.tableValues)):
                print self.tableValues[i]
            print 
            print '+++++++++++++++++++++'
            print

# x values
        self.xValues = []
        column=xIndex
        for row in range(len(self.tableValues)):
            self.xValues.append(self.tableValues[row][column])
        if DEBUG_STOREXYINSTORAGEBUFFER:
            print('\nxValues = %s' % self.xValues)
            print('')
            
# y values        
        self.yValues = []
        yTemp = []
        for column in yIndex:
            for row in range(len(self.tableValues)):
                if DEBUG_STOREXYINSTORAGEBUFFER:
                    print('++ row, column = %s, %s' % (row,column))
                yTemp.append(self.tableValues[row][column])
            self.yValues.append(yTemp)
            yTemp = []
            if DEBUG_STOREXYINSTORAGEBUFFER:
                print('')
            
        if DEBUG_STOREXYINSTORAGEBUFFER:
            print 
            print 'yValues =\n',self.yValues
            print 'len(yValues) = %s ' % len(self.yValues)
            print 'len(xValues) = %s ' % len(self.xValues)
            for listNum in range(len(self.yValues)):
                print '\n=== column %s ===' % (listNum)
                for element in range(len(self.xValues)):
                    print ' listNum = %s, element=%s' % (listNum,element)
                    print '   x=%s, y=%s' % (self.xValues[element],self.yValues[listNum][element])
        
# all X and Y values have been captured and checked at this point
        
# DEFINE FIRST 4 FIELDS OF BUFFER
        self.defineBufferFields_Table()
        
        return
        
        
    def defineBufferFields_Table(self):
        '''
        Purpose:
            Allow user to define 4 fields and user comment.
            Fields are defined from Table at user discretion.
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'defineBufferFields_Table')
        
        # destroy any old toplevel frames
        try:
            self.toplevelUserDefinedFields.destroy()
            self.MySQL_Output(
                1,
                'Previous toplevel widget removed from screen.'
                )
        except: 
            self.MySQL_Output(
                1,
                'No previous toplevel widget to remove from screen.'
                )
            
# open Toplevel frame for entering database name
        self.toplevelUserDefinedFields = Toplevel(
#            self.frameParent,
            bg='lightgreen'
            )
        self.toplevelUserDefinedFields.title(
#            'Field functions'
            'Server: ' + self.comboServerMySQL.get() + '     ' +
            'Database: ' + self.comboboxDbSelect.get() + '     ' +
            'Table: ' + self.comboboxDbTableSelect.get().strip()
             )
        self.toplevelUserDefinedFields.transient(
            self.toplevelTableValues
            )
            
# place the top window
        x_Windows = self.userDefinedFields_xWindowLocation
        y_Windows = self.userDefinedFields_yWindowLocation
        self.toplevelUserDefinedFields.geometry(
            '+%d+%d' % (x_Windows, y_Windows)
            )
            
# FRAMES
        bgcolor = 'lightgreen'
# ... title
        frame_00_UserDefinedFields = Frame(
            self.toplevelUserDefinedFields,
            bg=bgcolor,
            )
        frame_00_UserDefinedFields.grid(
            row=0,
            column=0,
            padx=5,
            pady=5,
            )
# ... notes           
        frame_10_UserDefinedFields = Frame(
            self.toplevelUserDefinedFields,
            bg=bgcolor,
            )
        frame_10_UserDefinedFields.grid(
            row=1,
            column=0,
            padx=5,
            pady=5,
            )
# ... notes
        frame_20_UserDefinedFields = Frame(
            self.toplevelUserDefinedFields,
            bg=bgcolor,
            )
        frame_20_UserDefinedFields.grid(
            row=2,
            column=0,
            padx=5,
            pady=5,
            )
# ... user comment field
        self.frame_40_UserCommentField = Frame(
            self.toplevelUserDefinedFields,
            bg=bgcolor,
            )
        self.frame_40_UserCommentField.grid(
            row=3,
            column=0,
            padx=5,
            pady=5,
            )
# ... user fields
        self.frame_30_UserDefinedFields = Frame(
            self.toplevelUserDefinedFields,
            bg=bgcolor,
            )
        self.frame_30_UserDefinedFields.grid(
            row=4,
            column=0,
            padx=5,
            pady=5,
            )
# ... cancel button
        frame_99_UserDefinedFields = Frame(
            self.toplevelUserDefinedFields,
            bg=bgcolor,
            )
        frame_99_UserDefinedFields.grid(
            row=99,
            column=0,
            padx=5,
            pady=5,
            )   

# initialize lists
        self.listValuesDefinedField_1 = []
        self.listValuesDefinedField_2 = []
        self.listValuesDefinedField_3 = []
        self.listValuesDefinedField_4 = []

            
# WIDGETS    
# ... frame_00
        labelUserDefinedFields_Title = Label(
            frame_00_UserDefinedFields,
            text='SPECIFY USER-DEFINED FIELDS FROM TABLE\nFOR STORAGE BUFFER',
            bg=bgcolor,
            justify=CENTER,
#            font=self.labelFontMedium,
            font=self.titleFontBigBold,
            )
        labelUserDefinedFields_Title.grid(
            row=0,
            column=0,
            padx=5,
            pady=10,
            )
# ... frame_10
        stringText1 = (
            'Notes:\n' +
            '0. Four "user_fields" are used to help identify data in buffer for plotting.\n' +
            '1. Only text fields are user-selectable for any of these values.\n' +
            '2. OK to leave any field blank; field will show blank in storage buffer.\n' +
            '3. User_fields 1 & 2 must be selected such that each field has a unique value.\n' +
            '     An error will display if either field is multi-valued.\n' +
            '4. User_fields 3 & 4 can be multi-valued. User may select from drop-down menu\n' +
            '     which value to display.\n' +
            '5. Length of values is limited to 30 characters since some values may be\n' +
            '     used in plot legends.\n'
            '6. Try to be consistent across database tables by using same or similar names for\n' +
            '     same table fields where possible. Makes it much easier to identify buffer data.'
            )
        stringText2 = (
            'Notes:\n' +
            '0. "User_fields" are taken from the DISPLAYED table text fields, not the original table!\n' +
            '     It is best to display all fields when using the Storage Buffer so that "user_fields"\n' +
            '     can be selected appropriately. If only numerical fields are displayed, there will\n' +
            '     be no selections available for the "user_fields" below.\n' +
            '1. The four "user_fields" are used to help identify data in buffer for plotting.\n' +
            '2. Only text fields are user-selectable for any of these values.\n' +
#            '3. Length of values is automatically shortened to 20 characters since values may be used in\n' +
#            '     plot legends.\n' +
            '3. Any or all fields may be left blank, but choices for plotting legends will be affected.\n' +
            '4. Try to be consistent across database tables by using same or similar names for\n' +
            '     same table fields where possible. Makes it much easier to identify buffer data.\n' +
            '5. If data is to be plotted, at least one "user_field" should be single valued, and\n' +
            '     this field should be one of those used in the plot legends.\n' +
            '6. User comment may be left blank.'
            )
        labelUserDefinedFields_Notes1 = Label(
            frame_10_UserDefinedFields,
            text=stringText2,
            bg=bgcolor,
            justify=LEFT,
            font=self.labelFontMedium,
            )
        labelUserDefinedFields_Notes1.grid(
            row=0,
            column=0,
            padx=5,
            pady=0,
            )
# ... frame_20          
        label_UserDefinedFields_Choose = Label(
            frame_20_UserDefinedFields,
            text=(
                'ADD USER COMMENT FOR SELECTED DATA, THEN\n' +
                'CHOOSE WHICH TABLE FIELDS WILL OCCUPY FIRST 4 BUFFER FIELDS:\n' +
                '(all fields are optional, but entries help with plots)'
                ),
            bg=bgcolor,
            justify=CENTER,
            font=self.labelFontMedium,
            )
        label_UserDefinedFields_Choose.grid(
            row=0,
            column=0,
            columnspan=99,
            padx=5,
            pady=10,
            )
            
# determine list of text fields in current table
        listOfTextFields = []
        icount = 0
        for row in range(len(self.tableStructure)):
            icount += 1
            myField, myDatatype, myNull, myKey, myDefault, myExtra = \
                self.tableStructure[row]
            varfirst2 = myDatatype[0:2]
# check if text
            fieldNameIsText = self.checkIsFieldText(varfirst2)
            if fieldNameIsText:
                listOfTextFields.append(str(icount) + '. ' + myField) 
# sort
# (don't sort if numbering fields in order!
#        listOfTextFields.sort()

# determine list of all fields in current table
        listOfAllFields = []
        icount=0
        for row in range(len(self.tableStructure)):
            icount += 1
            myField, myDatatype, myNull, myKey, myDefault, myExtra = \
                self.tableStructure[row]
            listOfAllFields.append(str(icount) + '. ' + myField)

        Pady = 5
# ... first row, user defined fields
#... zeroth row
        Row=0
        label_04 = Label(
            self.frame_30_UserDefinedFields,
            text='Single\nvalued',
            bg=bgcolor,
            font=self.labelFontMedium,
            )
        label_04.grid(
            row=Row,
            column=4,
            padx=5,
            pady=Pady
            )
        label_05 = Label(
            self.frame_30_UserDefinedFields,
            text='Multi-\nvalued',
            bg=bgcolor,
            font=self.labelFontMedium,
            )
        label_05.grid(
            row=Row,
            column=5,
            padx=5,
            pady=Pady
            )
# ... First Row
        Row += 1
# ...       label (=user_field 1:)
        label_1 = Label(
            self.frame_30_UserDefinedFields,
            text='user_field 1: ',
            bg=bgcolor,
            justify=RIGHT,
            font=self.labelFontMedium,
            )
        label_1.grid(
            row=Row,
            column=0,
            padx=5,
            pady=Pady,
            )
# ...       user-specified table field (text fields only) 
        self.comboboxDefinedField_1 = Pmw.ComboBox(
            self.frame_30_UserDefinedFields,
#            scrolledlist_items=listOfTextFields,
            scrolledlist_items=listOfAllFields,
            listheight=125,
            entry_width=20,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            selectioncommand=self.handlerValueField_1,
            scrolledlist_hull_width=500,
            )
        self.comboboxDefinedField_1.grid(
            row=Row,
            column=1,
            padx=5,
            pady=Pady
            )
# ...       label (= value:)
        labelValue_1 = Label(
            self.frame_30_UserDefinedFields,
            text='value: ',
            bg=bgcolor,
            justify=RIGHT,
            font=self.labelFontMedium,
            )
        labelValue_1.grid(
            row=Row,
            column=2,
            padx=5,
            pady=Pady,
            )
# ...       value to store in buffer
        self.comboboxValueDefinedField_1 = Pmw.ComboBox(
            self.frame_30_UserDefinedFields,
            scrolledlist_items=self.listValuesDefinedField_1,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxValueDefinedField_1.grid(
            row=Row,
            column=3,
            padx=5,
            pady=Pady,
            sticky=W,
            )
        self.comboboxValueDefinedField_1.setentry('')
# ...       single-valued checkbox
        self.varSV_1 = IntVar()
        self.checkboxSV_1 = Checkbutton(
            self.frame_30_UserDefinedFields,
            variable=self.varSV_1,
            bg=bgcolor,
            disabledforeground='red',
            state=DISABLED,
            )
        self.checkboxSV_1.grid(
            row=Row,
            column=4,
            padx=5,
            pady=Pady,
            )
# ...       multi-valued checkbox
        self.varMV_1 = IntVar()
        self.checkboxMV_1 = Checkbutton(
            self.frame_30_UserDefinedFields,
            variable=self.varMV_1,
            bg=bgcolor,
            disabledforeground='red',
            state=DISABLED,
            )
        self.checkboxMV_1.grid(
            row=Row,
            column=5,
            padx=5,
            pady=Pady,
            )

#        self.valueDefinedField_1.configure(state='disabled')
            
# ... Second Row
        Row += 1
# ...       label (=user_field 2:)
        label_2 = Label(
            self.frame_30_UserDefinedFields,
            text='user_field 2: ',
            bg=bgcolor,
            justify=RIGHT,
            font=self.labelFontMedium,
            )
        label_2.grid(
            row=Row,
            column=0,
            padx=5,
            pady=Pady,
            )
# ...       user-specified table field (text fields only) 
        self.comboboxDefinedField_2 = Pmw.ComboBox(
            self.frame_30_UserDefinedFields,
#            scrolledlist_items=listOfTextFields,
            scrolledlist_items=listOfAllFields,
            listheight=125,
            entry_width=20,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            selectioncommand=self.handlerValueField_2,
            scrolledlist_hull_width=500,
            )
        self.comboboxDefinedField_2.grid(
            row=Row,
            column=1,
            padx=5,
            pady=Pady
            )
# ...       label (= value:)
        labelValue_2 = Label(
            self.frame_30_UserDefinedFields,
            text='value: ',
            bg=bgcolor,
            justify=RIGHT,
            font=self.labelFontMedium,
            )
        labelValue_2.grid(
            row=Row,
            column=2,
            padx=5,
            pady=Pady,
            )
# ...       value to store in buffer
        self.comboboxValueDefinedField_2 = Pmw.ComboBox(
            self.frame_30_UserDefinedFields,
            scrolledlist_items=self.listValuesDefinedField_2,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxValueDefinedField_2.grid(
            row=Row,
            column=3,
            padx=5,
            pady=Pady,
            sticky=W,
            )
        self.comboboxValueDefinedField_2.setentry('')
# ...       single-valued checkbox
        self.varSV_2 = IntVar()
        self.checkboxSV_2 = Checkbutton(
            self.frame_30_UserDefinedFields,
            variable=self.varSV_2,
            bg=bgcolor,
            disabledforeground='red',
            state=DISABLED,
            )
        self.checkboxSV_2.grid(
            row=Row,
            column=4,
            padx=5,
            pady=Pady,
            )
# ...       multi-valued checkbox
        self.varMV_2 = IntVar()
        self.checkboxMV_2 = Checkbutton(
            self.frame_30_UserDefinedFields,
            variable=self.varMV_2,
            bg=bgcolor,
            disabledforeground='red',
            state=DISABLED,
            )
        self.checkboxMV_2.grid(
            row=Row,
            column=5,
            padx=5,
            pady=Pady,
            )

# ... Third Row
        Row += 1
# ...       label (=user_field 3:)
        label_3 = Label(
            self.frame_30_UserDefinedFields,
            text='user_field 3: ',
            bg=bgcolor,
            justify=RIGHT,
            font=self.labelFontMedium,
            )
        label_3.grid(
            row=Row,
            column=0,
            padx=5,
            pady=Pady,
            )
# ...       user-specified table field (text fields only) 
        self.comboboxDefinedField_3 = Pmw.ComboBox(
            self.frame_30_UserDefinedFields,
#            scrolledlist_items=listOfTextFields,
            scrolledlist_items=listOfAllFields,
            listheight=125,
            entry_width=20,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            selectioncommand=self.handlerValueField_3,
            scrolledlist_hull_width=500,
            )
        self.comboboxDefinedField_3.grid(
            row=Row,
            column=1,
            padx=5,
            pady=Pady
            )
# ...       label (= value:)
        labelValue_3 = Label(
            self.frame_30_UserDefinedFields,
            text='value: ',
            bg=bgcolor,
            justify=RIGHT,
            font=self.labelFontMedium,
            )
        labelValue_3.grid(
            row=Row,
            column=2,
            padx=5,
            pady=Pady,
            )
# ...       value to store in buffer
        self.comboboxValueDefinedField_3 = Pmw.ComboBox(
            self.frame_30_UserDefinedFields,
            scrolledlist_items=self.listValuesDefinedField_3,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxValueDefinedField_3.grid(
            row=Row,
            column=3,
            padx=5,
            pady=Pady,
            sticky=W,
            )
        self.comboboxValueDefinedField_3.setentry('')
# ...       single-valued checkbox
        self.varSV_3 = IntVar()
        self.checkboxSV_3 = Checkbutton(
            self.frame_30_UserDefinedFields,
            variable=self.varSV_3,
            bg=bgcolor,
            disabledforeground='red',
            state=DISABLED,
            )
        self.checkboxSV_3.grid(
            row=Row,
            column=4,
            padx=5,
            pady=Pady,
            )
# ...       multi-valued checkbox
        self.varMV_3 = IntVar()
        self.checkboxMV_3 = Checkbutton(
            self.frame_30_UserDefinedFields,
            variable=self.varMV_3,
            bg=bgcolor,
            disabledforeground='red',
            state=DISABLED,
            )
        self.checkboxMV_3.grid(
            row=Row,
            column=5,
            padx=5,
            pady=Pady,
            )

# ... Fourth Row
        Row += 1
# ...       label (=user_field 4:)
        label_4 = Label(
            self.frame_30_UserDefinedFields,
            text='user_field 4: ',
            bg=bgcolor,
            justify=RIGHT,
            font=self.labelFontMedium,
            )
        label_4.grid(
            row=Row,
            column=0,
            padx=5,
            pady=Pady,
            )
# ...       user-specified table field (text fields only) 
        self.comboboxDefinedField_4 = Pmw.ComboBox(
            self.frame_30_UserDefinedFields,
#            scrolledlist_items=listOfTextFields,
            scrolledlist_items=listOfAllFields,
            listheight=125,
            entry_width=20,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            selectioncommand=self.handlerValueField_4,
            scrolledlist_hull_width=500,
            )
        self.comboboxDefinedField_4.grid(
            row=Row,
            column=1,
            padx=5,
            pady=Pady
            )
# ...       label (= value:)
        labelValue_4 = Label(
            self.frame_30_UserDefinedFields,
            text='value: ',
            bg=bgcolor,
            justify=RIGHT,
            font=self.labelFontMedium,
            )
        labelValue_4.grid(
            row=Row,
            column=2,
            padx=5,
            pady=Pady,
            )
# ...       value to store in buffer
        self.comboboxValueDefinedField_4 = Pmw.ComboBox(
            self.frame_30_UserDefinedFields,
            scrolledlist_items=self.listValuesDefinedField_3,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxValueDefinedField_4.grid(
            row=Row,
            column=3,
            padx=5,
            pady=Pady,
            sticky=W,
            )
        self.comboboxValueDefinedField_4.setentry('')
# ...       single-valued checkbox
        self.varSV_4 = IntVar()
        self.checkboxSV_4 = Checkbutton(
            self.frame_30_UserDefinedFields,
            variable=self.varSV_4,
            bg=bgcolor,
            disabledforeground='red',
            state=DISABLED,
            )
        self.checkboxSV_4.grid(
            row=Row,
            column=4,
            padx=5,
            pady=Pady,
            )
# ...       multi-valued checkbox
        self.varMV_4 = IntVar()
        self.checkboxMV_4 = Checkbutton(
            self.frame_30_UserDefinedFields,
            variable=self.varMV_4,
            bg=bgcolor,
            disabledforeground='red',
            state=DISABLED,
            )
        self.checkboxMV_4.grid(
            row=Row,
            column=5,
            padx=5,
            pady=Pady,
            )

# clear all
        Row += 1
        buttonClearDefinedFields = Button(
            self.frame_30_UserDefinedFields,
            text='Clear all user fields',
            width=20,
            background='white',
            foreground='blue',
            relief=RAISED,
            borderwidth=3,
            command=self.handlerClearBufferDefinedFields,
            font=self.labelFontMedium,
            )
        buttonClearDefinedFields.grid(
            row=Row,
            column=0,
            columnspan=99,
            padx=5,
            pady=Pady,
            )
            
# user comment field
        Row = 0
        labelUserComment = Label(
            self.frame_40_UserCommentField,
            text='Add user comment\n(limit to ~30 chars): ',
            bg=bgcolor,
            justify=RIGHT,
            font=self.labelFontMedium,
            )
        labelUserComment.grid(
            row=Row,
            column=0,
            padx=5,
            pady=Pady,
            )
        self.varUserComment_Buffer = StringVar()
        entryUserComment = Entry(
            self.frame_40_UserCommentField,
            width=40,
            textvariable=self.varUserComment_Buffer
            )
        entryUserComment.grid(
            row=Row,
            column=1,
            padx=0,
            pady=Pady,
            )
        '''
        entryUserComment.bind(
            "<KeyPress-Return>",
            self.handlerContinueForStorageBuffer,
            )
        '''
        Row += 1
        buttonClearUserComment_Buffer = Button(
            self.frame_40_UserCommentField,
            text='Clear comment',
            width=20,
            background='white',
            foreground='blue',
            relief=RAISED,
            borderwidth=3,
            command=self.handlerClearUserComment_UserDefinedFieldsForBuffer,
            font=self.labelFontMedium,
            )
        buttonClearUserComment_Buffer.grid(
            row=Row,
            column=0,
            columnspan=99,
            padx=5,
            pady=0,
            )
                      
# continue
        self.buttonContinueToStorageBuffer = Button(
            frame_99_UserDefinedFields,
            text='Continue',
            width=20,
            borderwidth=5,
            relief=RAISED,
            justify=CENTER,
            command=self.handlerStoreFieldsInBuffer,
            font=self.labelFontMedium,
            )
        self.buttonContinueToStorageBuffer.grid(
            row=0,
            column=0,
            padx=5,
            pady=10,
            )
            
# cancel
        buttonCancel = Button(
            frame_99_UserDefinedFields,
            text='Cancel',
            width=20,
            borderwidth=5,
            relief=RAISED,
            justify=CENTER,
            command=self.handlerToplevelUserDefinedFieldsDestroy,
            font=self.labelFontMedium,
            )
        buttonCancel.grid(
            row=0,
            column=1,
            padx=5,
            pady=10,
            )
            
# checks
# ... for empty text fields
          
        return
        
        
    def handlerStoreXYinStorageBuffer_Scatter(self):
        '''
        Purpose:
          Displays X-Y values from table in storage buffer.
          
          Structure of storage buffer:
          1. user_field_1
          2. user_field_2
          3. user_field_3
          4. user_field_4
          5. x header
          6. y header
          7. first (x,y) pair
          8. last (x,y) pair
          9. database name
          10. table name
          11. number of points stored
          12. timestamp
         Not shown but present:
          13. x values
          14. y values 
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerStoreXYinStorageBuffer_Scatter')
            
# set to 1 to print
        DEBUG_STOREXYINSTORAGEBUFFER = 0
            
# check if connected to a MySQL server
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return  

# check if a table has even been read in 
        emptyTableCheck = self.checkIfEmptyTable()
        if emptyTableCheck:
            return     

# check if data values have been defined
        if len(self.curvefit_BestX_Scatter) == 0:
            stringNoData = (
                'No data is available from curve fits for scatter plots.\n\n' +
                'Curve fits must be plotted before saving to the buffer.'
                )
            print('\n' + stringNoData)
            self.MySQL_Output(
                0,
                stringNoData
                )
            showerror(
                'Error: no data',
                stringNoData,
                parent=self.toplevelScatterPlotPreprocess
                )
            return
            
# what is current buffer row?
        try:
            self.bufferRowStore_NumRows_Scatter = len(self.bufferRowStore_Scatter)
        except:
# initialize; bufferRowStore_NumRows needs to be defined as list of lists
            self.bufferRowStore_Scatter = []
            self.bufferRowStore_NumRows_Scatter = 0

# x values: self.curvefit_BestX_Scatter, defined from scatter plot
        if DEBUG_STOREXYINSTORAGEBUFFER:
            print('\nX values =')
            print(self.curvefit_BestX_Scatter)       
# y values: self.curvefit_BestY_Scatter, defined from scatter plot
            print('\nY values = ')
            print(self.curvefit_BestY_Scatter)
            print('len(self.curvefit_BestY_Scatter) =')
            print(len(self.curvefit_BestY_Scatter))
            print('len(self.curvefit_BestX_Scatter) = ')
            print(len(self.curvefit_BestX_Scatter))
            for listNum in range(len(self.curvefit_BestY_Scatter)):
                print '\n=== column %s ===' % (listNum)
                for element in range(len(self.curvefit_BestX_Scatter)):
                    print(' listNum = %s, element=%s' % (listNum,element))
                    print('   x=%s, y=%s' % (
                        self.curvefit_BestX_Scatter[element],
                        self.curvefit_BestY_Scatter[listNum][element]
                        )
                        )
        
        
# DEFINE FIRST 4 FIELDS OF BUFFER
        self.defineBufferFields_Scatter()
        
        return
        
        
    def defineBufferFields_Scatter(self):
        '''
        Purpose:
            Allow user to define 4 fields and user comment.
            Fields are defined from Table at user discretion.
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'defineBufferFields_Scatter')
        
        # destroy any old toplevel frames
        try:
            self.toplevelUserDefinedFields_Scatter.destroy()
            self.MySQL_Output(
                1,
                'Previous toplevel widget removed from screen.'
                )
        except: 
            self.MySQL_Output(
                1,
                'No previous toplevel widget to remove from screen.'
                )
            
# open Toplevel frame for entering database name
        self.toplevelUserDefinedFields_Scatter = Toplevel(
            bg='lightgreen'
            )
        self.toplevelUserDefinedFields_Scatter.title(
#            'Field functions'
            'Server: ' + self.comboServerMySQL.get() + '     ' +
            'Database: ' + self.comboboxDbSelect.get().strip() + '     ' +
            'Table: ' + self.comboboxDbTableSelect.get().strip()
            )
             
# if plot specs window exists, use it for transient; 
#   otherwise, use main table window
        try:
            mappedScatterPlotPreprocess = self.toplevelScatterPlotPreprocess.winfo_exists()
        except:
            mappedScatterPlotPreprocess = False
            
        if mappedScatterPlotPreprocess:
            self.toplevelUserDefinedFields_Scatter.transient(
                self.toplevelScatterPlotPreprocess
                )
        else:
            self.toplevelUserDefinedFields_Scatter.transient(
                self.toplevelTableValues
                )
            
# place the top window
        x_Windows = self.userDefinedFields_Scatter_xWindowLocation
        y_Windows = self.userDefinedFields_Scatter_yWindowLocation
        self.toplevelUserDefinedFields_Scatter.geometry(
            '+%d+%d' % (x_Windows, y_Windows)
            )
# FRAMES
        bgcolor = 'lightgreen'
# ... title
        frame_00_UserDefinedFields = Frame(
            self.toplevelUserDefinedFields_Scatter,
            bg=bgcolor,
            )
        frame_00_UserDefinedFields.grid(
            row=0,
            column=0,
            padx=5,
            pady=5,
            )
# ... notes           
        frame_10_UserDefinedFields = Frame(
            self.toplevelUserDefinedFields_Scatter,
            bg=bgcolor,
            )
        frame_10_UserDefinedFields.grid(
            row=1,
            column=0,
            padx=5,
            pady=5,
            )
# ... notes
        frame_20_UserDefinedFields = Frame(
            self.toplevelUserDefinedFields_Scatter,
            bg=bgcolor,
            )
        frame_20_UserDefinedFields.grid(
            row=2,
            column=0,
            padx=5,
            pady=5,
            )
# ... user comment field
        self.frame_40_UserCommentField_Scatter = Frame(
            self.toplevelUserDefinedFields_Scatter,
            bg=bgcolor,
            )
        self.frame_40_UserCommentField_Scatter.grid(
            row=3,
            column=0,
            padx=5,
            pady=5,
            )
# ... user fields
        self.frame_30_UserDefinedFields_Scatter = Frame(
            self.toplevelUserDefinedFields_Scatter,
            bg=bgcolor,
            )
        self.frame_30_UserDefinedFields_Scatter.grid(
            row=4,
            column=0,
            padx=5,
            pady=5,
            )
# ... cancel button
        frame_99_UserDefinedFields = Frame(
            self.toplevelUserDefinedFields_Scatter,
            bg=bgcolor,
            )
        frame_99_UserDefinedFields.grid(
            row=99,
            column=0,
            padx=5,
            pady=5,
            )   

# initialize lists
        self.listValuesDefinedField_1_Scatter = []
        self.listValuesDefinedField_2_Scatter = []
        self.listValuesDefinedField_3_Scatter = []
        self.listValuesDefinedField_4_Scatter = []

            
# WIDGETS    
# ... frame_00
        labelUserDefinedFields_Title = Label(
            frame_00_UserDefinedFields,
            text=(
                'SPECIFY USER-DEFINED FIELDS FROM TABLE\nFOR STORAGE BUFFER\n' +
                '(used with curve fits from Scatter Plots)'
                ),
            bg=bgcolor,
            justify=CENTER,
#            font=self.labelFontMedium,
            font=self.titleFontBigBold
            )
        labelUserDefinedFields_Title.grid(
            row=0,
            column=0,
            padx=5,
            pady=5,
            )
        entryfieldNumberOfCurvesToBuffer = Pmw.EntryField(
            frame_00_UserDefinedFields,
            entry_width=5,
#            entry_borderwidth=0,
            entry_relief='flat',
            entry_font=self.labelFontMedium,
            label_font=self.labelFontMedium,
            label_bg=bgcolor,
            labelpos='w',
            label_text='Number of curves to buffer: ',
            entry_state='disabled',
#            entry_disabledbackground='white',
            entry_disabledbackground=bgcolor,
            entry_disabledforeground='black',
            )
        entryfieldNumberOfCurvesToBuffer.grid(
            row=1,
            column=0,
            padx=5,
            pady=0,
            )
        entryfieldNumberOfCurvesToBuffer.setentry(
            len(self.curvefit_BestY_Scatter)
            )
# ... frame_10
        stringText1 = (
            'Notes:\n' +
            '0. Four "user_fields" are used to help identify data in buffer for plotting.\n' +
            '1. Most if not all fields have been filled with recommended values. Change if needed.\n' +
            '2. OK to leave any field blank; field will show blank in storage buffer.\n' +
            '3. User_fields 3 & 4 can be multi-valued. User may select from drop-down menu\n' +
            '     which value to display.\n' +
#            '4. Length of values is limited to 20 characters since some values may be\n' +
#            '     used in plot legends.\n'
            '4. If changed, try to specify fields such that it is easiy to identify scatter plot data.'
            )
        stringText2 = (
            'Notes:\n' +
            '0. "User_fields" are taken from scatter plot data, which may or may not be from table data!\n' +
            '1. The four "user_fields" are used to help identify data in scatter plots for plotting.\n' +
#            '2. Length of values is automatically shortened to 20 characters since values may be used in\n' +
#            '     plot legends.\n' +
            '2. Any or all fields may be left blank, but choices for plotting legends will be affected.\n' +
            '3. Try to makes it easy to identify scatter plot data.\n' 
            )
        labelUserDefinedFields_Notes1 = Label(
            frame_10_UserDefinedFields,
            text=stringText2,
            bg=bgcolor,
            justify=LEFT,
            font=self.labelFontMedium,
            )
        labelUserDefinedFields_Notes1.grid(
            row=0,
            column=0,
            padx=5,
            pady=0,
            )
# ... frame_20          
        label_UserDefinedFields_Choose = Label(
            frame_20_UserDefinedFields,
            text=(
                'ADD USER COMMENT FOR SELECTED DATA, THEN\n' +
                'CHOOSE WHICH TABLE FIELDS WILL OCCUPY FIRST 4 BUFFER FIELDS:\n' +
                '(all fields are optional, but entries help with plots)\n\n' +
                'NOTE: the Y header value in the Storage Buffer will contain the curve fit equation.'
                ),
            bg=bgcolor,
            justify=CENTER,
            font=self.labelFontMedium,
            )
        label_UserDefinedFields_Choose.grid(
            row=0,
            column=0,
            columnspan=99,
            padx=5,
            pady=10,
            )
            
# determine list of text fields in current table
        listOfTextFields = []
        icount = 0
        for row in range(len(self.tableStructure)):
            icount += 1
#            fieldType = self.tableStructure[row][1]
            myField, myDatatype, myNull, myKey, myDefault, myExtra = \
                self.tableStructure[row]
            varfirst2 = myDatatype[0:2]
# check if text
            fieldNameIsText = self.checkIsFieldText(varfirst2)
            if fieldNameIsText:
                listOfTextFields.append(str(icount) + '. ' + myField) 
        
# sort
# (don't sort if numbering fields in order!
#        listOfTextFields.sort()

        listOfAllFields = []
        icount=0
        for row in range(len(self.tableStructure)):
            icount += 1
            myField, myDatatype, myNull, myKey, myDefault, myExtra = \
                self.tableStructure[row]
            listOfAllFields.append(str(icount) + '. ' + myField)
        
# add plot title to dictionary for column headers; do it with deepcopy to keep separate
        self.dictColumnHeaders_Scatter = copy.deepcopy(self.dictColumnHeaders)

        Pady = 5
# ... first row, user defined fields
#... zeroth row
        Row=0
        label_04 = Label(
            self.frame_30_UserDefinedFields_Scatter,
            text='Single\nvalued',
            bg=bgcolor,
            font=self.labelFontMedium,
            )
        label_04.grid(
            row=Row,
            column=4,
            padx=5,
            pady=Pady
            )
        label_05 = Label(
            self.frame_30_UserDefinedFields_Scatter,
            text='Multi-\nvalued',
            bg=bgcolor,
            font=self.labelFontMedium,
            )
        label_05.grid(
            row=Row,
            column=5,
            padx=5,
            pady=Pady
            )
            
# ... first row
        Row += 1
# ...       label (=user_field 1:)
        label_1 = Label(
            self.frame_30_UserDefinedFields_Scatter,
            text='user_field 1: ',
            bg=bgcolor,
            justify=RIGHT,
            font=self.labelFontMedium,
            )
        label_1.grid(
            row=Row,
            column=0,
            padx=5,
            pady=Pady,
            )

# ...       user-specified table field (text fields only) 
        self.comboboxDefinedField_1_Scatter = Pmw.ComboBox(
            self.frame_30_UserDefinedFields_Scatter,
#           scrolledlist_items=listOfTextFields,
            scrolledlist_items=listOfAllFields,
            listheight=125,
            entry_width=20,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            selectioncommand=self.handlerValueField_1_Scatter,
            scrolledlist_hull_width=500,
            )
        self.comboboxDefinedField_1_Scatter.grid(
            row=Row,
            column=1,
            padx=5,
            pady=Pady
            )
        self.comboboxDefinedField_1_Scatter.setentry('')
        
# ...       label (= value:)
        labelValue_1 = Label(
            self.frame_30_UserDefinedFields_Scatter,
            text='value: ',
            bg=bgcolor,
            justify=RIGHT,
            font=self.labelFontMedium,
            )
        labelValue_1.grid(
            row=Row,
            column=2,
            padx=5,
            pady=Pady,
            )
# ...       value to store in buffer
        self.comboboxValueDefinedField_1_Scatter = Pmw.ComboBox(
            self.frame_30_UserDefinedFields_Scatter,
            scrolledlist_items=self.listValuesDefinedField_1_Scatter,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxValueDefinedField_1_Scatter.grid(
            row=Row,
            column=3,
            padx=5,
            pady=Pady,
            sticky=W,
            )
        self.comboboxValueDefinedField_1_Scatter.setentry('')
            
# ...       single-valued checkbox
        self.varSV_1_Scatter = IntVar()
        self.checkboxSV_1_Scatter = Checkbutton(
            self.frame_30_UserDefinedFields_Scatter,
            variable=self.varSV_1_Scatter,
            bg=bgcolor,
            disabledforeground='red',
            state=DISABLED,
            )
        self.checkboxSV_1_Scatter.grid(
            row=Row,
            column=4,
            padx=5,
            pady=Pady,
            )
        
# ...       multi-valued checkbox
        self.varMV_1_Scatter = IntVar()
        self.checkboxMV_1_Scatter = Checkbutton(
            self.frame_30_UserDefinedFields_Scatter,
            variable=self.varMV_1_Scatter,
            bg=bgcolor,
            disabledforeground='red',
            state=DISABLED,
            )
        self.checkboxMV_1_Scatter.grid(
            row=Row,
            column=5,
            padx=5,
            pady=Pady,
            )

#        self.valueDefinedField_1.configure(state='disabled')
            
# ... Second Row
        Row += 1
# ...       label (=user_field 2:)
        label_2 = Label(
            self.frame_30_UserDefinedFields_Scatter,
            text='user_field 2: ',
            bg=bgcolor,
            justify=RIGHT,
            font=self.labelFontMedium,
            )
        label_2.grid(
            row=Row,
            column=0,
            padx=5,
            pady=Pady,
            )
# ...       user-specified table field (text fields only) 
        self.comboboxDefinedField_2_Scatter = Pmw.ComboBox(
            self.frame_30_UserDefinedFields_Scatter,
#           scrolledlist_items=listOfTextFields,
            scrolledlist_items=listOfAllFields,
            listheight=125,
            entry_width=20,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            selectioncommand=self.handlerValueField_2_Scatter,
            scrolledlist_hull_width=500,
            )
        self.comboboxDefinedField_2_Scatter.grid(
            row=Row,
            column=1,
            padx=5,
            pady=Pady
            )
# ...       label (= value:)
        labelValue_2 = Label(
            self.frame_30_UserDefinedFields_Scatter,
            text='value: ',
            bg=bgcolor,
            justify=RIGHT,
            font=self.labelFontMedium,
            )
        labelValue_2.grid(
            row=Row,
            column=2,
            padx=5,
            pady=Pady,
            )
# ...       value to store in buffer
        self.comboboxValueDefinedField_2_Scatter = Pmw.ComboBox(
            self.frame_30_UserDefinedFields_Scatter,
            scrolledlist_items=self.listValuesDefinedField_2_Scatter,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxValueDefinedField_2_Scatter.grid(
            row=Row,
            column=3,
            padx=5,
            pady=Pady,
            sticky=W,
            )
        self.comboboxValueDefinedField_2_Scatter.setentry('')
# ...       single-valued checkbox
        self.varSV_2_Scatter = IntVar()
        self.checkboxSV_2_Scatter = Checkbutton(
            self.frame_30_UserDefinedFields_Scatter,
            variable=self.varSV_2_Scatter,
            bg=bgcolor,
            disabledforeground='red',
            state=DISABLED,
            )
        self.checkboxSV_2_Scatter.grid(
            row=Row,
            column=4,
            padx=5,
            pady=Pady,
            )
# ...       multi-valued checkbox
        self.varMV_2_Scatter = IntVar()
        self.checkboxMV_2_Scatter = Checkbutton(
            self.frame_30_UserDefinedFields_Scatter,
            variable=self.varMV_2_Scatter,
            bg=bgcolor,
            disabledforeground='red',
            state=DISABLED,
            )
        self.checkboxMV_2_Scatter.grid(
            row=Row,
            column=5,
            padx=5,
            pady=Pady,
            )

# ... Third Row
        Row += 1
# ...       label (=user_field 3:)
        label_3 = Label(
            self.frame_30_UserDefinedFields_Scatter,
            text='user_field 3: ',
            bg=bgcolor,
            justify=RIGHT,
            font=self.labelFontMedium,
            )
        label_3.grid(
            row=Row,
            column=0,
            padx=5,
            pady=Pady,
            )
# ...       user-specified table field (text fields only) 
        self.comboboxDefinedField_3_Scatter = Pmw.ComboBox(
            self.frame_30_UserDefinedFields_Scatter,
#           scrolledlist_items=listOfTextFields,
            scrolledlist_items=listOfAllFields,
            listheight=125,
            entry_width=20,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            selectioncommand=self.handlerValueField_3_Scatter,
            scrolledlist_hull_width=500,
            )
        self.comboboxDefinedField_3_Scatter.grid(
            row=Row,
            column=1,
            padx=5,
            pady=Pady
            )
# ...       label (= value:)
        labelValue_3 = Label(
            self.frame_30_UserDefinedFields_Scatter,
            text='value: ',
            bg=bgcolor,
            justify=RIGHT,
            font=self.labelFontMedium,
            )
        labelValue_3.grid(
            row=Row,
            column=2,
            padx=5,
            pady=Pady,
            )
# ...       value to store in buffer
        self.comboboxValueDefinedField_3_Scatter = Pmw.ComboBox(
            self.frame_30_UserDefinedFields_Scatter,
            scrolledlist_items=self.listValuesDefinedField_3_Scatter,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxValueDefinedField_3_Scatter.grid(
            row=Row,
            column=3,
            padx=5,
            pady=Pady,
            sticky=W,
            )
        self.comboboxValueDefinedField_3_Scatter.setentry('')
# ...       single-valued checkbox
        self.varSV_3_Scatter = IntVar()
        self.checkboxSV_3_Scatter = Checkbutton(
            self.frame_30_UserDefinedFields_Scatter,
            variable=self.varSV_3_Scatter,
            bg=bgcolor,
            disabledforeground='red',
            state=DISABLED,
            )
        self.checkboxSV_3_Scatter.grid(
            row=Row,
            column=4,
            padx=5,
            pady=Pady,
            )
# ...       multi-valued checkbox
        self.varMV_3_Scatter = IntVar()
        self.checkboxMV_3_Scatter = Checkbutton(
            self.frame_30_UserDefinedFields_Scatter,
            variable=self.varMV_3_Scatter,
            bg=bgcolor,
            disabledforeground='red',
            state=DISABLED,
            )
        self.checkboxMV_3_Scatter.grid(
            row=Row,
            column=5,
            padx=5,
            pady=Pady,
            )

# ... Fourth Row
        Row += 1
# ...       label (=user_field 4:)
        label_4 = Label(
            self.frame_30_UserDefinedFields_Scatter,
            text='user_field 4: ',
            bg=bgcolor,
            justify=RIGHT,
            font=self.labelFontMedium,
            )
        label_4.grid(
            row=Row,
            column=0,
            padx=5,
            pady=Pady,
            )
# ...       user-specified table field (text fields only) 
        self.comboboxDefinedField_4_Scatter = Pmw.ComboBox(
            self.frame_30_UserDefinedFields_Scatter,
#           scrolledlist_items=listOfTextFields,
            scrolledlist_items=listOfAllFields,
            listheight=125,
            entry_width=20,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            selectioncommand=self.handlerValueField_4_Scatter,
            scrolledlist_hull_width=500,
            )
        self.comboboxDefinedField_4_Scatter.grid(
            row=Row,
            column=1,
            padx=5,
            pady=Pady
            )
# ...       label (= value:)
        labelValue_4 = Label(
            self.frame_30_UserDefinedFields_Scatter,
            text='value: ',
            bg=bgcolor,
            justify=RIGHT,
            font=self.labelFontMedium,
            )
        labelValue_4.grid(
            row=Row,
            column=2,
            padx=5,
            pady=Pady,
            )
# ...       value to store in buffer
        self.comboboxValueDefinedField_4_Scatter = Pmw.ComboBox(
            self.frame_30_UserDefinedFields_Scatter,
            scrolledlist_items=self.listValuesDefinedField_4_Scatter,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxValueDefinedField_4_Scatter.grid(
            row=Row,
            column=3,
            padx=5,
            pady=Pady,
            sticky=W,
            )
        self.comboboxValueDefinedField_4_Scatter.setentry('')
# ...       single-valued checkbox
        self.varSV_4_Scatter = IntVar()
        self.checkboxSV_4_Scatter = Checkbutton(
            self.frame_30_UserDefinedFields_Scatter,
            variable=self.varSV_4_Scatter,
            bg=bgcolor,
            disabledforeground='red',
            state=DISABLED,
            )
        self.checkboxSV_4_Scatter.grid(
            row=Row,
            column=4,
            padx=5,
            pady=Pady,
            )
# ...       multi-valued checkbox
        self.varMV_4_Scatter = IntVar()
        self.checkboxMV_4_Scatter = Checkbutton(
            self.frame_30_UserDefinedFields_Scatter,
            variable=self.varMV_4_Scatter,
            bg=bgcolor,
            disabledforeground='red',
            state=DISABLED,
            )
        self.checkboxMV_4_Scatter.grid(
            row=Row,
            column=5,
            padx=5,
            pady=Pady,
            )

# clear all
        Row += 1
        buttonClearDefinedFields = Button(
            self.frame_30_UserDefinedFields_Scatter,
            text='Clear all user fields',
            width=20,
            background='white',
            foreground='blue',
            relief=RAISED,
            borderwidth=3,
            command=self.handlerClearBufferDefinedFields_Scatter,
            font=self.labelFontMedium,
            )
        buttonClearDefinedFields.grid(
            row=Row,
            column=0,
            columnspan=99,
            padx=5,
            pady=Pady,
            )
            
# user comment field
        Row = 0
        labelUserComment = Label(
            self.frame_40_UserCommentField_Scatter,
            text='User comment\n(initializes with scatter plot title):',
            bg=bgcolor,
            justify=RIGHT,
            font=self.labelFontMedium,
            )
        labelUserComment.grid(
            row=Row,
            column=0,
            padx=5,
            pady=Pady,
            )
        self.varUserComment_Buffer_Scatter = StringVar()
        entryUserComment = Entry(
            self.frame_40_UserCommentField_Scatter,
            width=40,
            state='normal',
#            state='disabled',
#            disabledbackground='white',
#            disabledforeground='black',
            textvariable=self.varUserComment_Buffer_Scatter
            )
        entryUserComment.grid(
            row=Row,
            column=1,
            padx=0,
            pady=Pady,
            )
# set default value to scatter plot title
        self.varUserComment_Buffer_Scatter.set(
             self.curvefit_Title_Scatter
            )
        '''
        entryUserComment.bind(
            "<KeyPress-Return>",
            self.handlerContinueForStorageBuffer,
            )
        '''
        Row += 1
        buttonClearUserComment_Buffer = Button(
            self.frame_40_UserCommentField_Scatter,
            text='Clear comment',
            width=20,
            background='white',
            foreground='blue',
            relief=RAISED,
            borderwidth=3,
            command=self.handlerClearUserComment_UserDefinedFieldsForBuffer_Scatter,
            font=self.labelFontMedium,
            )
        ''' DO NOT DELETE - MAY USE LATER
        buttonClearUserComment_Buffer.grid(
            row=Row,
            column=0,
            columnspan=99,
            padx=5,
            pady=0,
            )
        '''
                      
# continue
        self.buttonContinueToStorageBuffer_Scatter = Button(
            frame_99_UserDefinedFields,
            text='Continue',
            width=20,
            borderwidth=5,
            relief=RAISED,
            justify=CENTER,
            command=self.handlerStoreFieldsInBuffer_Scatter,
            font=self.labelFontMedium,
            )
        self.buttonContinueToStorageBuffer_Scatter.grid(
            row=0,
            column=0,
            padx=5,
            pady=10,
            )
            
# cancel
        buttonCancel = Button(
            frame_99_UserDefinedFields,
            text='Cancel',
            width=20,
            borderwidth=5,
            relief=RAISED,
            justify=CENTER,
            command=self.handlerToplevelUserDefinedFieldsDestroy_Scatter,
            font=self.labelFontMedium,
            )
        buttonCancel.grid(
            row=0,
            column=1,
            padx=5,
            pady=10,
            )
            
# checks
# ... for empty text fields
          
        return

        
    def handlerStoreFieldsInBuffer_Scatter(self):
        '''
        Purpose: 
            store all fields in buffer for later use
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerStoreFieldsInBuffer_Scatter')
            
# set to 1 to print
        DEBUG_STOREFIELDSINBUFFER = 0
            
# user comment
        user_comment = self.varUserComment_Buffer_Scatter.get()
# user_field values
        user_field_1 = self.comboboxValueDefinedField_1_Scatter.get()
        user_field_2 = self.comboboxValueDefinedField_2_Scatter.get()
        user_field_3 = self.comboboxValueDefinedField_3_Scatter.get()
        user_field_4 = self.comboboxValueDefinedField_4_Scatter.get()
        
# timestamp
        timestamp_Buffer = time.ctime(time.time())[0:19]
        
# database and table
        myDatabase_Buffer = self.comboboxDbSelect.get().strip()
        myTable_Buffer = self.comboboxDbTableSelect.get().strip()
        
# number of points
        num_points_Buffer = len(self.curvefit_BestX_Scatter)
        
# first (x,y) points
        xFirst = self.curvefit_BestX_Scatter[0]
        pointsFirst_Buffer = []
        for row in range(len(self.curvefit_BestY_Scatter)):
            yFirst = self.curvefit_BestY_Scatter[row][0]
            pointsFirst_Buffer.append('(%s, %s)' % (xFirst, yFirst))
        
# last (x,y) points
        xLast = self.curvefit_BestX_Scatter[num_points_Buffer -1]
        pointsLast_Buffer = []
        for row in range(len(self.curvefit_BestY_Scatter)):
            yLast = self.curvefit_BestY_Scatter[row][len(self.curvefit_BestY_Scatter[row])-1]
            pointsLast_Buffer.append('(%s, %s)' % (xLast, yLast))
            
# let user define first 4 columns of buffer data.
#   Purpose: to uniquely define the buffer row so that row can be easily identified for plotting
#        self.defineUserFields_Buffer()
# check toplevel
        
# print all
        if DEBUG_STOREFIELDSINBUFFER :
            print
            print 'user comment =', user_comment
            print 'user_field_1 =', user_field_1
            print 'user_field_2 =', user_field_2
            print 'user_field_3 =', user_field_3
            print 'user_field_4 =', user_field_4
            print 'xHeader_Buffer =', self.curvefit_XHeader_Scatter
            print 'yHeader_Buffer =', self.curvefit_YHeader_Scatter
            print 'pointsFirst_Buffer =', pointsFirst_Buffer
            print 'pointsLast_Buffer =', pointsLast_Buffer
            print 'myDatabase_Buffer =', myDatabase_Buffer
            print 'myTable_Buffer =', myTable_Buffer
            print 'num_points_Buffer =', num_points_Buffer  
            print 'timestamp_Buffer =', timestamp_Buffer
            print '-----'
            print 'length of xValues =',len(self.curvefit_BestX_Scatter)
            print 'length of yValues list =',len(self.curvefit_BestY_Scatter)
        
        for rowAdd in range(len(self.curvefit_BestY_Scatter)):
            self.bufferRowStore.append([]) 
            yHeader = self.curvefit_YHeader_Scatter[rowAdd]
            
            self.bufferRowStore[self.bufferRowStore_NumRows + rowAdd].append(user_comment)                  # 0
            self.bufferRowStore[self.bufferRowStore_NumRows + rowAdd].append(user_field_1)                  # 1
            self.bufferRowStore[self.bufferRowStore_NumRows + rowAdd].append(user_field_2)                  # 2
            self.bufferRowStore[self.bufferRowStore_NumRows + rowAdd].append(user_field_3)                  # 3
            self.bufferRowStore[self.bufferRowStore_NumRows + rowAdd].append(user_field_4)                  # 4
            self.bufferRowStore[self.bufferRowStore_NumRows + rowAdd].append(self.curvefit_XHeader_Scatter)  # 5
            self.bufferRowStore[self.bufferRowStore_NumRows + rowAdd].append(yHeader)   # 6
            self.bufferRowStore[self.bufferRowStore_NumRows + rowAdd].append(pointsFirst_Buffer[rowAdd])    # 7
            self.bufferRowStore[self.bufferRowStore_NumRows + rowAdd].append(pointsLast_Buffer[rowAdd])     # 8
            self.bufferRowStore[self.bufferRowStore_NumRows + rowAdd].append(myDatabase_Buffer)             # 9
            self.bufferRowStore[self.bufferRowStore_NumRows + rowAdd].append(myTable_Buffer)                # 10
            self.bufferRowStore[self.bufferRowStore_NumRows + rowAdd].append(num_points_Buffer)             # 11
            self.bufferRowStore[self.bufferRowStore_NumRows + rowAdd].append(timestamp_Buffer)              # 12
            self.bufferRowStore[self.bufferRowStore_NumRows + rowAdd].append(self.curvefit_BestX_Scatter)                  # 13
            self.bufferRowStore[self.bufferRowStore_NumRows + rowAdd].append(self.curvefit_BestY_Scatter[rowAdd])          # 14
            
        self.bufferRowStore_NumRows += len(self.curvefit_BestY_Scatter)
       
        if DEBUG_STOREFIELDSINBUFFER :
            print('bufferRowStore_NumRows = %s' % self.bufferRowStore_NumRows_Scatter)
            print('bufferRowStore = %s' % self.bufferRowStore_Scatter)
            print('len(bufferRowStore) = %s' % len(self.bufferRowStore_Scatter))
            print('\n\n')
        
        '''
        showinfo(
            'Info: buffer store',
            ('Data from %s x-y pair stored in buffer.\n\n' +
            'Total rows in buffer: %s')
             % (len(self.curvefit_BestY_Scatter),self.bufferRowStore_NumRows)
            )
        self.toplevelUserDefinedFields_Scatter.destroy()
        self.countDisplayStorageBuffer.set(
            'BUFFER: Display (' +
            str(self.bufferRowStore_NumRows) + 
            ' rows)'
            )
        '''
            
# give user option to clear all x and y in main table window
        stringClearXY = (
            'Data from %s X-Y selections stored in buffer.\n\n' +
            'Total rows now in buffer: %s\n\n' +
            'Keep the X-Y selections checked in main table?'
            ) % (len(self.curvefit_BestY_Scatter),self.bufferRowStore_NumRows)
        ans = askyesno(
            'Keep X-Y selections checked?',
            stringClearXY,
            parent=self.toplevelUserDefinedFields_Scatter
            )
        if not ans:
            self.buttonYSelectClear.invoke()
            self.buttonDeselectX.invoke()
            
        self.toplevelUserDefinedFields_Scatter.destroy()
        self.countDisplayStorageBuffer.set(
            'BUFFER: Display (' +
            str(self.bufferRowStore_NumRows) + 
            ' rows)'
            )

# if storage buffer is displayed, refresh
        try:
            mapped = self.toplevelShowStorageBuffer.winfo_exists()
        except:
            mapped = False
            
        if mapped:
#            self.buttonTableValuesShowAll_Buffer.invoke()
            self.handlerRefreshBufferView()
            
        return
        
         
    def handlerValueField_1_Scatter(self,numbered_user_field_1):
        '''
        Purpose:
            create list of values using numbered_user_field_1;
            list single value in value field
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerValueField_1_Scatter')
            
# get rid of number in front of 'numbered_user_field_1'
        user_field_1 = numbered_user_field_1.split('.')[1].strip()
            
# de-select checkboxes
        self.varSV_1_Scatter.set(0)
        self.varMV_1_Scatter.set(0)
        
# get index number from self.dictColumnHeaders
        localDict = {}
        flagFindField = False
        for key,value in self.dictColumnHeaders_Scatter.iteritems():
            if key == user_field_1:
                flagFindField = True
                for row in range(len(self.tableValues)):
                    localDict[str(self.tableValues[row][value-1])]=None
                break

        if not flagFindField:
# no field found
            stringErrorFindField = (
                'user_field_1 = %s was not found in the table,\n' +
                '  probably indicating an improper selection.\n\n'
                ) % user_field_1
            print stringErrorFindField
            self.MySQL_Output(
                0,
                stringErrorFindField
                )
            showerror(
                'Error: no field found',
                stringErrorFindField
                )
        else:
            self.listValuesDefinedField_1_Scatter = list(localDict)
# if list is a list of numbers, change to numerical fields and then sort
            tempList = []
            try:
# ... change to numerical values if possible
                for index in range(len(self.listValuesDefinedField_1_Scatter)):
                    tempList.append(eval(self.listValuesDefinedField_1_Scatter[index]))
# ... sort as numbers; numbers as text (i.e., numbers in quotes) do not sort well
                tempList.sort()
                if DEBUG_USER_DEFINED_FIELDS_SCATTER:
                    print('\nSORTED as numerical values')
# ... change back to strings
                self.listValuesDefinedField_1_Scatter = []
                for index in range(len(tempList)):
                    self.listValuesDefinedField_1_Scatter.append(str(tempList[index]))
            except:
# sort text
                self.listValuesDefinedField_1_Scatter.sort()
                if DEBUG_USER_DEFINED_FIELDS_SCATTER:
                    print('\nSORTED as text values')
            
            if DEBUG_USER_DEFINED_FIELDS_SCATTER:
                print(
                    '\nself.listValuesDefinedField_1_Scatter = \n %s' %
                    self.listValuesDefinedField_1_Scatter
                    )
                print(
                    '\nself.listValuesDefinedField_1_Scatter[0] = %s' % 
                    self.listValuesDefinedField_1_Scatter[0]
                    )
                print(
                    '\ntype(self.listValuesDefinedField_1_Scatter[0]) = %s' %
                    type(self.listValuesDefinedField_1_Scatter[0]) 
                    )
                print(
                    '\nlen(self.listValuesDefinedField_1_Scatter) = %s' % 
                    len(self.listValuesDefinedField_1_Scatter)
                    )
                    
# re-plot combobox to update scrolledlist_items
            self.comboboxValueDefinedField_1_Scatter = Pmw.ComboBox(
                self.frame_30_UserDefinedFields_Scatter,
                scrolledlist_items=self.listValuesDefinedField_1_Scatter,
                dropdown=1,
                entry_state='disabled',
                entry_disabledbackground='white',
                entry_disabledforeground='black',
                scrolledlist_hull_width=500,
                )
            self.comboboxValueDefinedField_1_Scatter.grid(
                row=1,
                column=3,
                padx=5,
                pady=5,
                sticky=W,
                )
                
# set entry           
            if(
            len(self.listValuesDefinedField_1_Scatter) <> 0
            and
            self.listValuesDefinedField_1_Scatter[0] <> None
            ):
                try:
                    self.comboboxValueDefinedField_1_Scatter.selectitem(
                        self.listValuesDefinedField_1_Scatter[0]
                        )
                except:
                    self.comboboxValueDefinedField_1_Scatter.setvalue('')
#                entry=self.comboboxValueDefinedField_1_Scatter.get()[0:20]
                entry=self.comboboxValueDefinedField_1_Scatter.get()
                self.comboboxValueDefinedField_1_Scatter.setentry(entry)                
                if len(self.listValuesDefinedField_1_Scatter) == 1:
                    self.varSV_1_Scatter.set(1)
                else:
                    self.varMV_1_Scatter.set(1)
            else:
                stringNoValues = (
                    'There are no values associated with field\n' +
                    '  %s\n\n' +
                    'Choose another field.'
                    ) % (
                    self.comboboxDefinedField_1_Scatter.get()
                    )
                print(stringNoValues)
                self.MySQL_Output(
                    0,
                    stringNoValues
                    )
                showinfo(
                    'Info: no values',
                    stringNoValues
                    )
                self.comboboxDefinedField_1_Scatter.setentry('')
            
        return

        
    def handlerValueField_2_Scatter(self,numbered_user_field_2):
        '''
        Purpose:
            create list of values using numbered_user_field_2;
            list single value in value field
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerValueField_2_Scatter')
            
# get rid of number in front of 'numbered_user_field_1'
        user_field_2 = numbered_user_field_2.split('.')[1].strip()
            
# de-select checkboxes
        self.varSV_2_Scatter.set(0)
        self.varMV_2_Scatter.set(0)
        
# get index number from self.dictColumnHeaders
        localDict = {}
        flagFindField = False
        for key,value in self.dictColumnHeaders_Scatter.iteritems():
            if key == user_field_2:
                flagFindField = True
                for row in range(len(self.tableValues)):
                    localDict[str(self.tableValues[row][value-1])]=None
                break
                
        if not flagFindField:
# no field found
            stringErrorFindField = (
                'user_field_2 = %s was not found in the table,\n' +
                '  probably indicating an improper selection.\n\n'
                ) % user_field_2
            print stringErrorFindField
            self.MySQL_Output(
                0,
                stringErrorFindField
                )
            showerror(
                'Error: no field found',
                stringErrorFindField
                )
        else:
            self.listValuesDefinedField_2_Scatter = list(localDict)
# if list is a list of numbers, change to numerical fields and then sort
            tempList = []
            try:
# ... change to numerical values if possible
                for index in range(len(self.listValuesDefinedField_2_Scatter)):
                    tempList.append(eval(self.listValuesDefinedField_2_Scatter[index]))
# ... sort as numbers; numbers as text (i.e., numbers in quotes) do not sort well
                tempList.sort()
                if DEBUG_USER_DEFINED_FIELDS_SCATTER:
                    print('\nSORTED as numerical values')
# ... change back to strings
                self.listValuesDefinedField_2_Scatter = []
                for index in range(len(tempList)):
                    self.listValuesDefinedField_2_Scatter.append(str(tempList[index]))
            except:
# sort text   
                self.listValuesDefinedField_2_Scatter.sort()
                if DEBUG_USER_DEFINED_FIELDS_SCATTER:
                    print('\nSORTED as text values')
            
            if DEBUG_USER_DEFINED_FIELDS_SCATTER:
                print(
                    '\nself.listValuesDefinedField_2_Scatter = \n %s' %
                    self.listValuesDefinedField_2_Scatter
                    )
                print(
                    '\nself.listValuesDefinedField_2_Scatter[0] = %s' % 
                    self.listValuesDefinedField_2_Scatter[0]
                    )
                print(
                    '\ntype(self.listValuesDefinedField_2_Scatter[0]) = %s' %
                    type(self.listValuesDefinedField_2_Scatter[0]) 
                    )
                print(
                    '\nlen(self.listValuesDefinedField_2_Scatter) = %s' % 
                    len(self.listValuesDefinedField_2_Scatter)
                    )
                    
# re-plot combobox to update scrolledlist_items
            self.comboboxValueDefinedField_2_Scatter = Pmw.ComboBox(
                self.frame_30_UserDefinedFields_Scatter,
                scrolledlist_items=self.listValuesDefinedField_2_Scatter,
                dropdown=1,
                entry_state='disabled',
                entry_disabledbackground='white',
                entry_disabledforeground='black',
                scrolledlist_hull_width=500,
                )
            self.comboboxValueDefinedField_2_Scatter.grid(
                row=2,
                column=3,
                padx=5,
                pady=5,
                sticky=W,
                )
# set entry
            if(
            len(self.listValuesDefinedField_2_Scatter) <> 0
            and
            self.listValuesDefinedField_2_Scatter[0] <> None
            ):
                try:
                    self.comboboxValueDefinedField_2_Scatter.selectitem(
                        self.listValuesDefinedField_2_Scatter[0]
                        )
                except:
                    self.comboboxValueDefinedField_2_Scatter.setvalue('')
#                entry=self.comboboxValueDefinedField_2_Scatter.get()[0:20]
                entry=self.comboboxValueDefinedField_2_Scatter.get()
                self.comboboxValueDefinedField_2_Scatter.setentry(entry)                
                if len(self.listValuesDefinedField_2_Scatter) == 1:
                    self.varSV_2_Scatter.set(1)
                else:
                    self.varMV_2_Scatter.set(1)
            else:
                stringNoValues = (
                    'There are no values associated with field\n' +
                    '  %s\n\n' +
                    'Choose another field.'
                    ) % (
                    self.comboboxDefinedField_2_Scatter.get()
                    )
                print(stringNoValues)
                self.MySQL_Output(
                    0,
                    stringNoValues
                    )
                showinfo(
                    'Info: no values',
                    stringNoValues
                    )
                self.comboboxDefinedField_2_Scatter.setentry('')
            
        return
        
        
    def handlerValueField_3_Scatter(self,numbered_user_field_3):
        '''
        Purpose:
            create list of values using numbered_user_field_3;
            list single value in value field
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerValueField_3_Scatter')
            
# get rid of number in front of 'numbered_user_field_1'
        user_field_3 = numbered_user_field_3.split('.')[1].strip()
            
# de-select checkboxes
        self.varSV_3_Scatter.set(0)
        self.varMV_3_Scatter.set(0)
        
# get index number from self.dictColumnHeaders
        localDict = {}
        flagFindField = False
        for key,value in self.dictColumnHeaders_Scatter.iteritems():
            if key == user_field_3:
                flagFindField = True
                for row in range(len(self.tableValues)):
                    localDict[str(self.tableValues[row][value-1])]=None
                break
                
        if not flagFindField:
# no field found
            stringErrorFindField = (
                'user_field_3 = %s was not found in the table,\n' +
                '  probably indicating an improper selection.\n\n'
                ) % user_field_3
            print stringErrorFindField
            self.MySQL_Output(
                0,
                stringErrorFindField
                )
            showerror(
                'Error: no field found',
                stringErrorFindField
                )
        else:
            self.listValuesDefinedField_3_Scatter = list(localDict)
# if list is a list of numbers, change to numerical fields and then sort
            tempList = []
            try:
# ... change to numerical values if possible
                for index in range(len(self.listValuesDefinedField_3_Scatter)):
                    tempList.append(eval(self.listValuesDefinedField_3_Scatter[index]))
# ... sort as numbers; numbers as text (i.e., numbers in quotes) do not sort well
                tempList.sort()
                if DEBUG_USER_DEFINED_FIELDS_SCATTER:
                    print('\nSORTED as numerical values')
# ... change back to strings
                self.listValuesDefinedField_3_Scatter = []
                for index in range(len(tempList)):
                    self.listValuesDefinedField_3_Scatter.append(str(tempList[index]))
            except:
# sort text
                self.listValuesDefinedField_3_Scatter.sort()
                if DEBUG_USER_DEFINED_FIELDS_SCATTER:
                    print('\nSORTED as text values')
            
            if DEBUG_USER_DEFINED_FIELDS_SCATTER:
                print(
                    '\nself.listValuesDefinedField_3_Scatter = \n %s' %
                    self.listValuesDefinedField_3_Scatter
                    )
                print(
                    '\nself.listValuesDefinedField_3_Scatter[0] = %s' % 
                    self.listValuesDefinedField_3_Scatter[0]
                    )
                print(
                    '\ntype(self.listValuesDefinedField_3_Scatter[0]) = %s' %
                    type(self.listValuesDefinedField_3_Scatter[0]) 
                    )
                print(
                    '\nlen(self.listValuesDefinedField_3_Scatter) = %s' % 
                    len(self.listValuesDefinedField_3_Scatter)
                    )

# re-plot combobox to update scrolledlist_items
            self.comboboxValueDefinedField_3_Scatter = Pmw.ComboBox(
                self.frame_30_UserDefinedFields_Scatter,
                scrolledlist_items=self.listValuesDefinedField_3_Scatter,
                dropdown=1,
                entry_state='disabled',
                entry_disabledbackground='white',
                entry_disabledforeground='black',
                scrolledlist_hull_width=500,
                )
            self.comboboxValueDefinedField_3_Scatter.grid(
                row=3,
                column=3,
                padx=5,
                pady=5,
                sticky=W,
                )
# set entry
            if(
            len(self.listValuesDefinedField_3_Scatter) <> 0
            and
            self.listValuesDefinedField_3_Scatter[0] <> None
            ):
                try:
                    self.comboboxValueDefinedField_3_Scatter.selectitem(
                        self.listValuesDefinedField_3_Scatter[0]
                        )
                except:
                    self.comboboxValueDefinedField_3_Scatter.setvalue('')
#                entry=self.comboboxValueDefinedField_3_Scatter.get()[0:20]
                entry=self.comboboxValueDefinedField_3_Scatter.get()
                self.comboboxValueDefinedField_3_Scatter.setentry(entry)                
                if len(self.listValuesDefinedField_3_Scatter) == 1:
                    self.varSV_3_Scatter.set(1)
                else:
                    self.varMV_3_Scatter.set(1)
            else:
                stringNoValues = (
                    'There are no values associated with field\n' +
                    '  %s\n\n' +
                    'Choose another field.'
                    ) % (
                    self.comboboxDefinedField_3_Scatter.get()
                    )
                print(stringNoValues)
                self.MySQL_Output(
                    0,
                    stringNoValues
                    )
                showinfo(
                    'Info: no values',
                    stringNoValues
                    )
                self.comboboxDefinedField_3_Scatter.setentry('')
            
        return
        
        
    def handlerValueField_4_Scatter(self,numbered_user_field_4):
        '''
        Purpose:
            create list of values using numbered_user_field_4;
            list single value in value field
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerValueField_4_Scatter')
            
# get rid of number in front of 'numbered_user_field_1'
        user_field_4 = numbered_user_field_4.split('.')[1].strip()
            
# de-select checkboxes
        self.varSV_4_Scatter.set(0)
        self.varMV_4_Scatter.set(0)
        
# get index number from self.dictColumnHeaders
        localDict = {}
        flagFindField = False
        for key,value in self.dictColumnHeaders_Scatter.iteritems():
            if key == user_field_4:
                flagFindField = True
                for row in range(len(self.tableValues)):
                    localDict[str(self.tableValues[row][value-1])]=None
                break
        if not flagFindField:
# no field found
            stringErrorFindField = (
                'user_field_4 = %s was not found in the table,\n' +
                '  probably indicating an improper selection.\n\n'
                ) % user_field_4
            print stringErrorFindField
            self.MySQL_Output(
                0,
                stringErrorFindField
                )
            showerror(
                'Error: no field found',
                stringErrorFindField
                )
        else:
            self.listValuesDefinedField_4_Scatter = list(localDict)
# if list is a list of numbers, change to numerical fields and then sort
            tempList = []
            try:
# ... change to numerical values if possible
                for index in range(len(self.listValuesDefinedField_4_Scatter)):
                    tempList.append(eval(self.listValuesDefinedField_4_Scatter[index]))
# ... sort as numbers; numbers as text (i.e., numbers in quotes) do not sort well
                tempList.sort()
                if DEBUG_USER_DEFINED_FIELDS_SCATTER:
                    print('\nSORTED as numerical values')
# ... change back to strings
                self.listValuesDefinedField_4_Scatter = []
                for index in range(len(tempList)):
                    self.listValuesDefinedField_4_Scatter.append(str(tempList[index]))
            except:
# sort text   
                self.listValuesDefinedField_4_Scatter.sort()
                if DEBUG_USER_DEFINED_FIELDS_SCATTER:
                    print('\nSORTED as text values')
            
            if DEBUG_USER_DEFINED_FIELDS_SCATTER:
                print(
                    '\nself.listValuesDefinedField_4_Scatter = \n %s' %
                    self.listValuesDefinedField_4_Scatter
                    )
                print(
                    '\nself.listValuesDefinedField_4_Scatter[0] = %s' % 
                    self.listValuesDefinedField_4_Scatter[0]
                    )
                print(
                    '\ntype(self.listValuesDefinedField_4_Scatter[0]) = %s' %
                    type(self.listValuesDefinedField_4_Scatter[0]) 
                    )
                print(
                    '\nlen(self.listValuesDefinedField_4_Scatter) = %s' % 
                    len(self.listValuesDefinedField_4_Scatter)
                    )
                    
# re-plot combobox to update scrolledlist_items
            self.comboboxValueDefinedField_4_Scatter = Pmw.ComboBox(
                self.frame_30_UserDefinedFields,
                scrolledlist_items=self.listValuesDefinedField_4_Scatter,
                dropdown=1,
                entry_state='disabled',
                entry_disabledbackground='white',
                entry_disabledforeground='black',
                scrolledlist_hull_width=500,
                )
            self.comboboxValueDefinedField_4_Scatter.grid(
                row=4,
                column=3,
                padx=5,
                pady=5,
                sticky=W,
                )
# set entry
            if(
            len(self.listValuesDefinedField_4_Scatter) <> 0
            and
            self.listValuesDefinedField_4_Scatter[0] <> None
            ):
                try:
                    self.comboboxValueDefinedField_4_Scatter.selectitem(
                        self.listValuesDefinedField_4_Scatter[0]
                        )
                except:
                    self.comboboxValueDefinedField_4_Scatter.setvalue('')
#                entry=self.comboboxValueDefinedField_4_Scatter.get()[0:20]
                entry=self.comboboxValueDefinedField_4_Scatter.get()
                self.comboboxValueDefinedField_4_Scatter.setentry(entry)                
                if len(self.listValuesDefinedField_4_Scatter) == 1:
                    self.varSV_4_Scatter.set(1)
                else:
                    self.varMV_4_Scatter.set(1)
            else:
                stringNoValues = (
                    'There are no values associated with field\n' +
                    '  %s\n\n' +
                    'Choose another field.'
                    ) % (
                    self.comboboxDefinedField_4_Scatter.get()
                    )
                print(stringNoValues)
                self.MySQL_Output(
                    0,
                    stringNoValues
                    )
                showinfo(
                    'Info: no values',
                    stringNoValues
                    )
                self.comboboxDefinedField_4_Scatter.setentry('')
            
        return
            
        
      
    def handlerClearBufferDefinedFields_Scatter(self):
        '''
        Purpose:
            clear user-defined fields for storage buffer using scatter plots
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerClearBufferDefinedFields_Scatter')
            
# clear fields
        self.comboboxDefinedField_1_Scatter.setentry('')
        self.comboboxDefinedField_2_Scatter.setentry('')
        self.comboboxDefinedField_3_Scatter.setentry('')
        self.comboboxDefinedField_4_Scatter.setentry('')
# clear values
        self.comboboxValueDefinedField_1_Scatter.setentry('')
        self.comboboxValueDefinedField_2_Scatter.setentry('')
        self.comboboxValueDefinedField_3_Scatter.setentry('')
        self.comboboxValueDefinedField_4_Scatter.setentry('')
# clear checkboxes
        self.varSV_1_Scatter.set(0)
        self.varMV_1_Scatter.set(0)
        self.varSV_2_Scatter.set(0)
        self.varMV_2_Scatter.set(0)
        self.varSV_3_Scatter.set(0)
        self.varMV_3_Scatter.set(0)
        self.varSV_4_Scatter.set(0)
        self.varMV_4_Scatter.set(0)

        return  
        
        
        
    def handlerClearUserComment_UserDefinedFieldsForBuffer_Scatter(self):
        '''
        clear user comment entry
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerClearUserComment_UserDefinedFieldsForBuffer_Scatter')
            
        self.varUserComment_Buffer_Scatter.set('')
        
        return
        
        
    def handlerToplevelUserDefinedFieldsDestroy_Scatter(self):
        '''
        Purpose:
            destroy 'User Defined Fields' window for scatter plots
        '''
        if DEBUG_PRINT_METHOD:
            print(
                '\n** In ' + MODULE + '/' + 
                'handlerToplevelUserDefinedFieldsDestroy_Scatter'
                )

# save location for next time window is opened
        self.userDefinedFields_xWindowLocation_Scatter = \
            self.toplevelUserDefinedFields_Scatter.winfo_rootx() - self.offsetWindowX
        self.userDefinedFields_yWindowLocation_Scatter = \
            self.toplevelUserDefinedFields_Scatter.winfo_rooty() - self.offsetWindowY

# destroy current toplevel            
        self.toplevelUserDefinedFields_Scatter.destroy()
        
        return
        

    def handlerToplevelUserDefinedFieldsDestroy(self):
        '''
        Purpose:
            destroy 'User Defined Fields' window
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerToplevelUserDefinedFieldsDestroy')

# save location for next time window is opened
        self.userDefinedFields_xWindowLocation = \
            self.toplevelUserDefinedFields.winfo_rootx() - self.offsetWindowX
        self.userDefinedFields_yWindowLocation = \
            self.toplevelUserDefinedFields.winfo_rooty() - self.offsetWindowY

# destroy current toplevel            
        self.toplevelUserDefinedFields.destroy()
        
        return
        
        
    def handlerClearUserComment_UserDefinedFieldsForBuffer(self):
        '''
        clear user comment entry
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerClearUserComment_UserDefinedFieldsForBuffer')
            
        self.varUserComment_Buffer.set('')
        
        return
        
        
    def handlerStoreFieldsInBuffer(self):
        '''
        Purpose: 
            store all fields in buffer for later use
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerStoreFieldsInBuffer')
            
# set to 1 to print
        DEBUG_STOREFIELDSINBUFFER = 0
            
# user comment
        user_comment = self.varUserComment_Buffer.get()
# user_field values
        user_field_1 = self.comboboxValueDefinedField_1.get()
        user_field_2 = self.comboboxValueDefinedField_2.get()
        user_field_3 = self.comboboxValueDefinedField_3.get()
        user_field_4 = self.comboboxValueDefinedField_4.get().strip()  
        
# timestamp
        timestamp_Buffer = time.ctime(time.time())[0:19]
        
# database and table
        myDatabase_Buffer = self.comboboxDbSelect.get().strip()
        myTable_Buffer = self.comboboxDbTableSelect.get().strip()
        
# number of points
        num_points_Buffer = len(self.yValues[0])
        
# first (x,y) points
        xFirst = self.xValues[0]
        pointsFirst_Buffer = []
        for row in range(len(self.yValues)):
            yFirst = self.yValues[row][0]
            pointsFirst_Buffer.append('(%s, %s)' % (xFirst, yFirst))
        
# last (x,y) points
        xLast = self.xValues[len(self.xValues)-1]
        pointsLast_Buffer = []
        for row in range(len(self.yValues)):
            yLast = self.yValues[row][len(self.yValues[row])-1]
            pointsLast_Buffer.append('(%s, %s)' % (xLast, yLast))
            
# let user define first 4 columns of buffer data.
#   Purpose: to uniquely define the buffer row so that row can be easily identified for plotting
#        self.defineUserFields_Buffer()
# check toplevel
        
# print all
        if DEBUG_STOREFIELDSINBUFFER :
            print
            print 'user comment =', user_comment
            print 'user_field_1 =', user_field_1
            print 'user_field_2 =', user_field_2
            print 'user_field_3 =', user_field_3
            print 'user_field_4 =', user_field_4
            print 'xHeader_Buffer =', self.xHeader_Buffer
            print 'yHeader_Buffer =', self.yHeader_Buffer
            print 'pointsFirst_Buffer =', pointsFirst_Buffer
            print 'pointsLast_Buffer =', pointsLast_Buffer
            print 'myDatabase_Buffer =', myDatabase_Buffer
            print 'myTable_Buffer =', myTable_Buffer
            print 'num_points_Buffer =', num_points_Buffer  
            print 'timestamp_Buffer =', timestamp_Buffer
            print '-----'
            print 'length of xValues =',len(self.xValues)
            print 'length of yValues =',len(self.yValues)
        
        for rowAdd in range(len(self.yValues)):
            self.bufferRowStore.append([]) 
            self.bufferRowStore[self.bufferRowStore_NumRows + rowAdd].append(user_comment)                  # 0
            self.bufferRowStore[self.bufferRowStore_NumRows + rowAdd].append(user_field_1)                  # 1
            self.bufferRowStore[self.bufferRowStore_NumRows + rowAdd].append(user_field_2)                  # 2
            self.bufferRowStore[self.bufferRowStore_NumRows + rowAdd].append(user_field_3)                  # 3
            self.bufferRowStore[self.bufferRowStore_NumRows + rowAdd].append(user_field_4)                  # 4
            self.bufferRowStore[self.bufferRowStore_NumRows + rowAdd].append(self.xHeader_Buffer)           # 5
            self.bufferRowStore[self.bufferRowStore_NumRows + rowAdd].append(self.yHeader_Buffer[rowAdd])   # 6
            self.bufferRowStore[self.bufferRowStore_NumRows + rowAdd].append(pointsFirst_Buffer[rowAdd])    # 7
            self.bufferRowStore[self.bufferRowStore_NumRows + rowAdd].append(pointsLast_Buffer[rowAdd])     # 8
            self.bufferRowStore[self.bufferRowStore_NumRows + rowAdd].append(myDatabase_Buffer)             # 9
            self.bufferRowStore[self.bufferRowStore_NumRows + rowAdd].append(myTable_Buffer)                # 10
            self.bufferRowStore[self.bufferRowStore_NumRows + rowAdd].append(num_points_Buffer)             # 11
            self.bufferRowStore[self.bufferRowStore_NumRows + rowAdd].append(timestamp_Buffer)              # 12
            self.bufferRowStore[self.bufferRowStore_NumRows + rowAdd].append(self.xValues)                  # 13
            self.bufferRowStore[self.bufferRowStore_NumRows + rowAdd].append(self.yValues[rowAdd])          # 14
            
        self.bufferRowStore_NumRows += len(self.yValues)
       
        if DEBUG_STOREFIELDSINBUFFER :
            print 'bufferRowStore_NumRows =', self.bufferRowStore_NumRows
            print 'bufferRowStore =\n', self.bufferRowStore
            print 'len(bufferRowStore) =', len(self.bufferRowStore)
            print('\n\n')
        
        
# give user option to clear all x and y in main table window
        stringClearXY = (
            'Data from %s X-Y selections stored in buffer.\n\n' +
            'Total rows now in buffer: %s\n\n' +
            'Keep the X-Y selections checked in main table?'
            ) % (len(self.yValues),self.bufferRowStore_NumRows)
        ans = askyesno(
            'Keep X-Y selections checked?',
            stringClearXY,
            parent=self.toplevelUserDefinedFields
            )
        if not ans:
            self.buttonYSelectClear.invoke()
            self.buttonDeselectX.invoke()

        self.toplevelUserDefinedFields.destroy()
        self.countDisplayStorageBuffer.set(
            'BUFFER: Display (' +
            str(self.bufferRowStore_NumRows) + 
            ' rows)'
            )

# if storage buffer is displayed, refresh
        try:
            mapped = self.toplevelShowStorageBuffer.winfo_exists()
        except:
            mapped = False
            
        if mapped:
#            self.buttonTableValuesShowAll_Buffer.invoke()
            self.handlerRefreshBufferView()
            
        return
        
            
    def handlerClearBufferDefinedFields(self):
        '''
        Purpose:
            clear user-defined fields for storage buffer
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerClearBufferDefinedFields')
            
# clear fields
        self.comboboxDefinedField_1.setentry('')
        self.comboboxDefinedField_2.setentry('')
        self.comboboxDefinedField_3.setentry('')
        self.comboboxDefinedField_4.setentry('')
# clear values
        self.comboboxValueDefinedField_1.setentry('')
        self.comboboxValueDefinedField_2.setentry('')
        self.comboboxValueDefinedField_3.setentry('')
        self.comboboxValueDefinedField_4.setentry('')
# clear checkboxes
        self.varSV_1.set(0)
        self.varMV_1.set(0)
        self.varSV_2.set(0)
        self.varMV_2.set(0)
        self.varSV_3.set(0)
        self.varMV_3.set(0)
        self.varSV_4.set(0)
        self.varMV_4.set(0)

        return  
        

    def handlerValueField_1(self,numbered_user_field_1):
        '''
        Purpose:
            create list of values using user_field_1;
            list single value in value field
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerValueField_1')
            
# get rid of number in front of 'numbered_user_field_1'
        user_field_1 = numbered_user_field_1.split('.')[1].strip()
            
# de-select checkboxes
        self.varSV_1.set(0)
        self.varMV_1.set(0)
        
# get index number from self.dictColumnHeaders
        localDict = {}
        flagFindField = False
        for key,value in self.dictColumnHeaders.iteritems():
            if key == user_field_1:
                flagFindField = True
                for row in range(len(self.tableValues)):
                    localDict[str(self.tableValues[row][value-1])]=None
                break
                
        if not flagFindField:
# no field found
            stringErrorFindField = (
                'user_field_1 = %s was not found in the table,\n' +
                '  probably indicating an improper selection.\n\n'
                ) % user_field_1
            print stringErrorFindField
            self.MySQL_Output(
                0,
                stringErrorFindField
                )
            showerror(
                'Error: no field found',
                stringErrorFindField
                )
        else:
            self.listValuesDefinedField_1 = list(localDict)
# if list is a list of numbers, change to numerical fields and then sort
            tempList = []
            try:
# ... change to numerical values if possible
                for index in range(len(self.listValuesDefinedField_1)):
                    tempList.append(eval(self.listValuesDefinedField_1[index]))
# ... sort as numbers; numbers as text (i.e., numbers in quotes) do not sort well
                tempList.sort()
                if DEBUG_USER_DEFINED_FIELDS:
                    print('\nSORTED as numerical values')
# ... change back to strings
                self.listValuesDefinedField_1 = []
                for index in range(len(tempList)):
                    self.listValuesDefinedField_1.append(str(tempList[index]))
            except:
# sort text
                self.listValuesDefinedField_1.sort()
                if DEBUG_USER_DEFINED_FIELDS:
                    print('\nSORTED as text values')
            
            if DEBUG_USER_DEFINED_FIELDS:
                print(
                    '\nself.listValuesDefinedField_1 = \n %s' %
                    self.listValuesDefinedField_1
                    )
                print(
                    '\nself.listValuesDefinedField_1[0] = %s' % 
                    self.listValuesDefinedField_1[0]
                    )
                print(
                    '\ntype(self.listValuesDefinedField_1[0]) = %s' %
                    type(self.listValuesDefinedField_1[0]) 
                    )
                print(
                    '\nlen(self.listValuesDefinedField_1) = %s' % 
                    len(self.listValuesDefinedField_1)
                    )
                    
# re-plot combobox to update scrolledlist_items
            self.comboboxValueDefinedField_1 = Pmw.ComboBox(
                self.frame_30_UserDefinedFields,
                scrolledlist_items=self.listValuesDefinedField_1,
                dropdown=1,
                entry_state='disabled',
                entry_disabledbackground='white',
                entry_disabledforeground='black',
                scrolledlist_hull_width=500,
                )
            self.comboboxValueDefinedField_1.grid(
                row=1,
                column=3,
                padx=5,
                pady=5,
                sticky=W,
                )
                
# set entry   
            if(
            len(self.listValuesDefinedField_1) <> 0
            and
            self.listValuesDefinedField_1[0] <> None
            ):
                try:
                    self.comboboxValueDefinedField_1.selectitem(
                        self.listValuesDefinedField_1[0]
                        )
                except:
                    self.comboboxValueDefinedField_1.setvalue('')
#                entry=self.comboboxValueDefinedField_1.get()[0:20]
                entry=self.comboboxValueDefinedField_1.get()
                self.comboboxValueDefinedField_1.setentry(entry)                
                if len(self.listValuesDefinedField_1) == 1:
                    self.varSV_1.set(1)
                else:
                    self.varMV_1.set(1)
            else:
                stringNoValues = (
                    'There are no values associated with field\n' +
                    '  %s\n\n' +
                    'Choose another field.'
                    ) % (
                    self.comboboxDefinedField_1.get()
                    )
                print(stringNoValues)
                self.MySQL_Output(
                    0,
                    stringNoValues
                    )
                showinfo(
                    'Info: no values',
                    stringNoValues
                    )
                self.comboboxDefinedField_1.setentry('')
            
        return

        
    def handlerValueField_2(self,numbered_user_field_2):
        '''
        Purpose:
            create list of values using user_field_2;
            list single value in value field
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerValueField_2')
            
# get rid of number in front of 'numbered_user_field_2'
        user_field_2 = numbered_user_field_2.split('.')[1].strip()
            
# de-select checkboxes
        self.varSV_2.set(0)
        self.varMV_2.set(0)
        
# get index number from self.dictColumnHeaders
        localDict = {}
        flagFindField = False
        for key,value in self.dictColumnHeaders.iteritems():
            if key == user_field_2:
                flagFindField = True
                for row in range(len(self.tableValues)):
                    localDict[str(self.tableValues[row][value-1])]=None
                break
        if not flagFindField:
# no field found
            stringErrorFindField = (
                'user_field_2 = %s was not found in the table,\n' +
                '  probably indicating an improper selection.\n\n'
                ) % user_field_2
            print stringErrorFindField
            self.MySQL_Output(
                0,
                stringErrorFindField
                )
            showerror(
                'Error: no field found',
                stringErrorFindField
                )
        else:
            self.listValuesDefinedField_2 = list(localDict)
# if list is a list of numbers, change to numerical fields and then sort
            tempList = []
            try:
# ... change to numerical values if possible
                for index in range(len(self.listValuesDefinedField_2)):
                    tempList.append(eval(self.listValuesDefinedField_2[index]))
# ... sort as numbers; numbers as text (i.e., numbers in quotes) do not sort well
                tempList.sort()
                if DEBUG_USER_DEFINED_FIELDS:
                    print('\nSORTED as numerical values')
# ... change back to strings
                self.listValuesDefinedField_2 = []
                for index in range(len(tempList)):
                    self.listValuesDefinedField_2.append(str(tempList[index]))
            except:
# sort text
                self.listValuesDefinedField_2.sort()
                if DEBUG_USER_DEFINED_FIELDS:
                    print('\nSORTED as text values')
            
            if DEBUG_USER_DEFINED_FIELDS:
                print(
                    '\nself.listValuesDefinedField_2 = \n %s' %
                    self.listValuesDefinedField_2
                    )
                print(
                    '\nself.listValuesDefinedField_2[0] = %s' % 
                    self.listValuesDefinedField_2[0]
                    )
                print(
                    '\ntype(self.listValuesDefinedField_2[0]) = %s' %
                    type(self.listValuesDefinedField_2[0]) 
                    )
                print(
                    '\nlen(self.listValuesDefinedField_2) = %s' % 
                    len(self.listValuesDefinedField_2)
                    )
                    
# re-plot combobox to update scrolledlist_items
            self.comboboxValueDefinedField_2 = Pmw.ComboBox(
                self.frame_30_UserDefinedFields,
                scrolledlist_items=self.listValuesDefinedField_2,
                dropdown=1,
                entry_state='disabled',
                entry_disabledbackground='white',
                entry_disabledforeground='black',
                scrolledlist_hull_width=500,
                )
            self.comboboxValueDefinedField_2.grid(
                row=2,
                column=3,
                padx=5,
                pady=5,
                sticky=W,
                )
                
# set entry                
            if(
            len(self.listValuesDefinedField_2) <> 0
            and
            self.listValuesDefinedField_2[0] <> None
            ):
                try:
                    self.comboboxValueDefinedField_2.selectitem(
                        self.listValuesDefinedField_2[0]
                        )
                except:
                    self.comboboxValueDefinedField_2.setvalue('')
#                entry=self.comboboxValueDefinedField_2.get()[0:20]
                entry=self.comboboxValueDefinedField_2.get()
                self.comboboxValueDefinedField_2.setentry(entry)                
                if len(self.listValuesDefinedField_2) == 1:
                    self.varSV_2.set(1)
                else:
                    self.varMV_2.set(1)
            else:
                stringNoValues = (
                    'There are no values associated with field\n' +
                    '  %s\n\n' +
                    'Choose another field.'
                    ) % (
                    self.comboboxDefinedField_2.get()
                    )
                print(stringNoValues)
                self.MySQL_Output(
                    0,
                    stringNoValues
                    )
                showinfo(
                    'Info: no values',
                    stringNoValues
                    )
                self.comboboxDefinedField_2.setentry('')
            
        return
        
        
    def handlerValueField_3(self,numbered_user_field_3):
        '''
        Purpose:
            create list of values using user_field_3;
            list single value in value field
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerValueField_3')
            
# get rid of number in front of 'numbered_user_field_3'
        user_field_3 = numbered_user_field_3.split('.')[1].strip()
            
# de-select checkboxes
        self.varSV_3.set(0)
        self.varMV_3.set(0)
        
# get index number from self.dictColumnHeaders
        localDict = {}
        flagFindField = False
        for key,value in self.dictColumnHeaders.iteritems():
            if key == user_field_3:
                flagFindField = True
                for row in range(len(self.tableValues)):
                    localDict[str(self.tableValues[row][value-1])]=None
                break
        if not flagFindField:
# no field found
            stringErrorFindField = (
                'user_field_3 = %s was not found in the table,\n' +
                '  probably indicating an improper selection.\n\n'
                ) % user_field_3
            print stringErrorFindField
            self.MySQL_Output(
                0,
                stringErrorFindField
                )
            showerror(
                'Error: no field found',
                stringErrorFindField
                )
        else:
            self.listValuesDefinedField_3 = list(localDict)
# if list is a list of numbers, change to numerical fields and then sort
            tempList = []
            try:
# ... change to numerical values if possible
                for index in range(len(self.listValuesDefinedField_3)):
                    tempList.append(eval(self.listValuesDefinedField_3[index]))
# ... sort as numbers; numbers as text (i.e., numbers in quotes) do not sort well
                tempList.sort()
                if DEBUG_USER_DEFINED_FIELDS:
                    print('\nSORTED as numerical values')
# ... change back to strings
                self.listValuesDefinedField_3 = []
                for index in range(len(tempList)):
                    self.listValuesDefinedField_3.append(str(tempList[index]))
            except:
# sort text
                self.listValuesDefinedField_3.sort()
                if DEBUG_USER_DEFINED_FIELDS:
                    print('\nSORTED as text values')
                
            if DEBUG_USER_DEFINED_FIELDS:
                print(
                    '\nself.listValuesDefinedField_3 = \n %s' %
                    self.listValuesDefinedField_3
                    )
                print(
                    '\nself.listValuesDefinedField_3[0] = %s' % 
                    self.listValuesDefinedField_3[0]
                    )
                print(
                    '\ntype(self.listValuesDefinedField_4[0]) = %s' %
                    type(self.listValuesDefinedField_3[0]) 
                    )
                print(
                    '\nlen(self.listValuesDefinedField_3) = %s' % 
                    len(self.listValuesDefinedField_3)
                    )
                    
# re-plot combobox to update scrolledlist_items
            self.comboboxValueDefinedField_3 = Pmw.ComboBox(
                self.frame_30_UserDefinedFields,
                scrolledlist_items=self.listValuesDefinedField_3,
                dropdown=1,
                entry_state='disabled',
                entry_disabledbackground='white',
                entry_disabledforeground='black',
                scrolledlist_hull_width=500,
                )
            self.comboboxValueDefinedField_3.grid(
                row=3,
                column=3,
                padx=5,
                pady=5,
                sticky=W,
                )
                
# set entry
            if(
            len(self.listValuesDefinedField_3) <> 0
            and
            self.listValuesDefinedField_3[0] <> None
            ):
                try:
                    self.comboboxValueDefinedField_3.selectitem(
                        self.listValuesDefinedField_3[0]
                        )
                except:
                    self.comboboxValueDefinedField_3.setvalue('')
#                entry=self.comboboxValueDefinedField_3.get()[0:20]
                entry=self.comboboxValueDefinedField_3.get()
                self.comboboxValueDefinedField_3.setentry(entry)                
                if len(self.listValuesDefinedField_3) == 1:
                    self.varSV_3.set(1)
                else:
                    self.varMV_3.set(1)
            else:
                stringNoValues = (
                    'There are no values associated with field\n' +
                    '  %s\n\n' +
                    'Choose another field.'
                    ) % (
                    self.comboboxDefinedField_3.get()
                    )
                print(stringNoValues)
                self.MySQL_Output(
                    0,
                    stringNoValues
                    )
                showinfo(
                    'Info: no values',
                    stringNoValues
                    )
                self.comboboxDefinedField_3.setentry('')
            
        return
        
        
    def handlerValueField_4(self,numbered_user_field_4):
        '''
        Purpose:
            create list of values using user_field_4;
            list single value in value field
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerValueField_4')
            
# get rid of number in front of 'numbered_user_field_4'
        user_field_4 = numbered_user_field_4.split('.')[1].strip()
            
# de-select checkboxes
        self.varSV_4.set(0)
        self.varMV_4.set(0)
# get index number from self.dictColumnHeaders
        localDict = {}
        flagFindField = False
        for key,value in self.dictColumnHeaders.iteritems():
            if key == user_field_4:
                flagFindField = True
                for row in range(len(self.tableValues)):
                    localDict[str(self.tableValues[row][value-1])]=None
                break
        if not flagFindField:
# no field found
            stringErrorFindField = (
                'user_field_4 = %s was not found in the table,\n' +
                '  probably indicating an improper selection.\n\n'
                ) % user_field_4
            print stringErrorFindField
            self.MySQL_Output(
                0,
                stringErrorFindField
                )
            showerror(
                'Error: no field found',
                stringErrorFindField
                )
        else:
            self.listValuesDefinedField_4 = list(localDict)
# if list is a list of numbers, change to numerical fields and then sort
            tempList = []
            try:
# ... change to numerical values if possible
                for index in range(len(self.listValuesDefinedField_4)):
                    tempList.append(eval(self.listValuesDefinedField_4[index]))
# ... sort as numbers; numbers as text (i.e., numbers in quotes) do not sort well
                tempList.sort()
                if DEBUG_USER_DEFINED_FIELDS:
                    print('\nSORTED as numerical values')
# ... change back to strings
                self.listValuesDefinedField_4 = []
                for index in range(len(tempList)):
                    self.listValuesDefinedField_4.append(str(tempList[index]))
            except:
# sort text
                self.listValuesDefinedField_4.sort()
                if DEBUG_USER_DEFINED_FIELDS:
                    print('\nSORTED as text values')
            
            if DEBUG_USER_DEFINED_FIELDS:
                print(
                    '\nself.listValuesDefinedField_4 = \n %s' %
                    self.listValuesDefinedField_4
                    )
                print(
                    '\nself.listValuesDefinedField_4[0] = %s' % 
                    self.listValuesDefinedField_4[0]
                    )
                print(
                    '\ntype(self.listValuesDefinedField_4[0]) = %s' %
                    type(self.listValuesDefinedField_4[0]) 
                    )
                print(
                    '\nlen(self.listValuesDefinedField_4) = %s' % 
                    len(self.listValuesDefinedField_4)
                    )
                    
# re-plot combobox to update scrolledlist_items
            self.comboboxValueDefinedField_4 = Pmw.ComboBox(
                self.frame_30_UserDefinedFields,
                scrolledlist_items=self.listValuesDefinedField_4,
                dropdown=1,
                entry_state='disabled',
                entry_disabledbackground='white',
                entry_disabledforeground='black',
                scrolledlist_hull_width=500,
                )
            self.comboboxValueDefinedField_4.grid(
                row=4,
                column=3,
                padx=5,
                pady=5,
                sticky=W,
                )
                
# set entry
            if(
            len(self.listValuesDefinedField_4) <> 0
            and
            self.listValuesDefinedField_4[0] <> None
            ):
                try:
                    self.comboboxValueDefinedField_4.selectitem(
                        self.listValuesDefinedField_4[0]
                        )
                except:
                    self.comboboxValueDefinedField_4.setvalue('')
#                entry=self.comboboxValueDefinedField_4.get()[0:20]
                entry=self.comboboxValueDefinedField_4.get()
                self.comboboxValueDefinedField_4.setentry(entry)                
                if len(self.listValuesDefinedField_4) == 1:
                    self.varSV_4.set(1)
                else:
                    self.varMV_4.set(1)
            else:
                stringNoValues = (
                    'There are no values associated with field\n' +
                    '  %s\n\n' +
                    'Choose another field.'
                    ) % (
                    self.comboboxDefinedField_4.get()
                    )
                print(stringNoValues)
                self.MySQL_Output(
                    0,
                    stringNoValues
                    )
                showinfo(
                    'Info: no values',
                    stringNoValues
                    )
                self.comboboxDefinedField_4.setentry('')
            
        return
            
            
    def displayStorageBufferValues(self,minValue):
        '''
        Purpose:
          Displays values in storage buffer.
          
          Structure of table:
          1. user comment
          2. user_field_1
          3. user_field_2
          4. user_field_3
          5. user_field_4
          6. x_header
          7. y_header
          8. first(x,y) pair
          9. last (x,y) pair
          10. database
          11. table
          12. numpoints
          13. timestamp
          14. x values (not displayed)
          15. y values (not displayed)
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'displayStorageBufferValues')

# define background color
        colorbg = 'lightblue'
        
# display in a text box with scrollbars
# FRAMES 
        try:
            mapped = self.toplevelShowStorageBuffer.winfo_exists()
        except:
            mapped = False
            
# save values if mapped
        if mapped:
            try:
                saveFieldWidths = int(self.comboboxWidthFieldBuffer.get())
                saveFieldHeights = int(self.comboboxHeightFieldBuffer.get())
                saveFieldFonts = int(self.comboboxFontFieldBuffer.get())
            except:
                stringFieldValues = (
                    'Invalid values have been entered into one of\n' +
                    '  the width, height, or font fields.\n\n' +
                    'Please check values and try again.\n'
                    )
                self.MySQL_Output(
                    1,
                    stringFieldValues
                    )
                try:
                    showerror(
                        'Error: invalid value',
                        '\n' + stringFieldValues,
                        parent=self.toplevelShowStorageBuffer
                        )
                except:
                    showerror(
                        'Error: invalid value',
                        '\n' + stringFieldValues
                        )
                return            
            print((
                '\n *** toplevelShowStorageBuffer is open!!! ###\n' +
                '     saveFieldWidths = %s\n' + 
                '     saveFieldHeights = %s\n' +
                '     saveFieldFonts = %s\n'
                ) % (saveFieldWidths, saveFieldHeights, saveFieldFonts)
                )                    
        else:
            print(
                '\n *** toplevelShowStorageBuffer is NOT open!!!\n'
                )   
                
# destroy any old toplevel frames                      
        try:
            self.buffer_xWindowLocation = self.toplevelShowStorageBuffer.winfo_rootx() - self.offsetWindowX
            self.buffer_yWindowLocation = self.toplevelShowStorageBuffer.winfo_rooty() - self.offsetWindowY
            self.toplevelShowStorageBuffer.destroy()
            self.MySQL_Output(
                1,
                'Previous toplevel widget removed from screen.'
                )
        except:  
            self.MySQL_Output(
                1,
                'No previous toplevel widget to remove from screen.'
                )

# open Toplevel frame for showing buffer
        self.toplevelShowStorageBuffer = Toplevel(
            self.toplevelTableValues,
            bg=colorbg,
            )
        self.toplevelShowStorageBuffer.title(
            'STORAGE BUFFER'
            )
#        self.toplevelShowStorageBuffer.transient(self.frameParent)
        self.toplevelShowStorageBuffer.transient(self.toplevelTableValues)
# place the top window
        self.toplevelShowStorageBuffer.geometry(
            '+%d+%d' % (self.buffer_xWindowLocation,self.buffer_yWindowLocation)
            )
# Row 0
# ... frame for number of selected rows
        frame_000 = Frame(
            self.toplevelShowStorageBuffer,
            bg=colorbg,
#                            relief=RIDGE,
#                            borderwidth=2,
#                            width=600,
            )
        frame_000.grid(
            row=0,
            column=0,
            columnspan=2,
            padx=5,
            pady=2,
            )
        frame_000_00 = Frame(
            frame_000,
            bg=colorbg,
            )
        frame_000_00.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
        frame_000_01 = Frame(
            frame_000,
            bg=colorbg,
            )
        frame_000_01.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            )
            
# ... title frame
        frame_00 = Frame(
            self.toplevelShowStorageBuffer,
            bg=colorbg,
#                            relief=RIDGE,
#                            borderwidth=2,
#                            width=600,
            )
        frame_00.grid(
            row=0,
            column=2,
            padx=2,
            pady=2,
#            sticky=E+W,
            )
# ... title subframes
#       ... frame_00_00
        frame_00_00 = Frame(
            frame_00,
            bg=colorbg,
            )
        frame_00_00.grid(
            row=0,
            column=0,
            columnspan=99,
            padx=0,
            pady=0,
            sticky=E+W,
            )
#       ... frame_00_10
        frame_00_10 = Frame(
            frame_00,
            bg=colorbg,
#                            borderwidth=2,
#                            relief=RIDGE,
            )
        frame_00_10.grid(
            row=1,
            column=0,
            padx=0,
            pady=0,
            sticky=W,
            )
#       ... frame_00_11
        frame_00_11 = Frame(
            frame_00,
            bg=colorbg,
#                            borderwidth=2,
#                            relief=RIDGE,
#                            width=300
            )
        '''
        frame_00_11.grid(
            row=1,
            column=1,
            padx=15,
            pady=0,
            sticky=E+W,
            )
        '''
#       ... frame_00_12
        frame_00_12 = Frame(
            frame_00,
            bg=colorbg,
#                            borderwidth=2,
#                            relief=RIDGE,
            )
        '''
        frame_00_12.grid(
            row=1,
            column=2,
            padx=0,
            pady=0,
            sticky=E,
            )
        '''
            
# Row 1
# ... header frame for 'Select all' (not gridded)                           
        frame_10 = Frame(
            self.toplevelShowStorageBuffer,
            bg=colorbg,
            height=70,
            )
        frame_10.grid(
            row=1,
            column=1,
            padx=2,
            pady=2,
            )
# ... header frame for column headers                               
        self.frame_11_Buffer = Frame(
            self.toplevelShowStorageBuffer,
            bg=colorbg,
            borderwidth=2,
            relief=RIDGE,
            )
        self.frame_11_Buffer.grid(
            row=1,
            column=2,
            padx=2,
            pady=2,
            )

        self.canvas_11_Buffer = Canvas(
            self.frame_11_Buffer,
            bg=colorbg,
            highlightbackground=colorbg,
            confine=0,
            width=720,
            height=70,
            )
        self.canvas_11_Buffer.grid(
            row=1,
            column=1,
            padx=2,
            pady=2,
            sticky=N,
            )
        self.frame_11_canvas_Buffer = Frame(
            self.canvas_11_Buffer,
            bg=colorbg,
            padx=1,
            )

#                        frame_11.grid_propagate(0)

# Row 2
# ... frame for buttons to show, plot, import, export                     
        frame_20 = Frame(
            self.toplevelShowStorageBuffer,
            bg=colorbg,
            )
        frame_20.grid(
            row=1,
            column=0,
            rowspan=99,
            padx=1,
            pady=0,
            sticky=N,
            )  
# ...   refresh display
        frame_20_00 = Frame(
            frame_20,
            bg=colorbg,
            )
        frame_20_00.grid(
            row=0,
            column=0,
            padx=0,
            pady=2,
            )
# ...   hide user fields
        frame_20_10 = Frame(
            frame_20,
            bg=colorbg,
            )
        frame_20_10.grid(
            row=1,
            column=0,
            padx=0,
            pady=2,
            )
# ... pickle/unpickle buffer
        frame_20_20 = Frame(
            frame_20,
            bg=colorbg,
            )
        frame_20_20.grid(
            row=2,
            column=0,
            padx=0,
            pady=2,
            )
# ...   save/read cvs files
        frame_20_30 = Frame(
            frame_20,
            bg=colorbg,
            )
        frame_20_30.grid(
            row=3,
            column=0,
            padx=0,
            pady=2,
            )
# ...   purge and sort
        frame_20_40 = Frame(
            frame_20,
            bg=colorbg,
            )
        frame_20_40.grid(
            row=4,
            column=0,
            padx=0,
            pady=2,
            )
# ...   delete selected rows; clear buffer
        frame_20_50 = Frame(
            frame_20,
            bg=colorbg,
            )
        frame_20_50.grid(
            row=5,
            column=0,
            padx=0,
            pady=2,
            )
        '''
# ...   clear buffer
        frame_20_60 = Frame(
            frame_20,
            bg=colorbg,
            )
        frame_20_60.grid(
            row=6,
            column=0,
            padx=0,
            pady=2,
            )
        '''
            
# ... frame for check buttons to select table rows      
        self.frame_21_Buffer = Frame(
            self.toplevelShowStorageBuffer,
            bg=colorbg,
            borderwidth=2,
            relief=RIDGE,
            )
        self.frame_21_Buffer.grid(
            row=2,
            column=1,
            padx=2,
            pady=2  ,
            sticky=N,
            )
        self.canvas_21_Buffer = Canvas(
            self.frame_21_Buffer,
            bg=colorbg,
            highlightbackground=colorbg,
            width=60,
            height=300,
            )
        self.canvas_21_Buffer.grid(
            row=0,
            column=0,
            padx=2,
            pady=2,
            sticky=N,
            )                         
        self.frame_21_canvas_Buffer = Frame(
            self.canvas_21_Buffer,
            bg=colorbg,
            padx=5
            )                                  
# ... table values                            
        self.frame_22_Buffer = Frame(
            self.toplevelShowStorageBuffer,
            bg=colorbg,
            borderwidth=2,
            relief=RIDGE,
            )
        self.frame_22_Buffer.grid(
            row=2,
            column=2,
            padx=2,
            pady=2,
            sticky=N
            )                                  
        self.yScroll_frame_22_Buffer = Scrollbar(
            self.toplevelShowStorageBuffer,
            orient=VERTICAL,
            )
        self.yScroll_frame_22_Buffer.grid(
            row=2,
            column=3,
            padx=0,
            sticky=N+S+W,
            )
        self.xScroll_frame_22_Buffer = Scrollbar(
            self.toplevelShowStorageBuffer,
            orient=HORIZONTAL,
            )
        self.xScroll_frame_22_Buffer.grid(
            row=3,
            column=2,
            sticky=N+E+W,
            )
        self.canvas_22_Buffer = Canvas(
            self.frame_22_Buffer,
            bg=colorbg,
            confine=0,
            width=720,
            height=300,
            highlightbackground=colorbg,
            yscrollcommand=self.yScroll_frame_22_Buffer.set,
            xscrollcommand=self.xScroll_frame_22_Buffer.set
            )
        self.canvas_22_Buffer.grid(
            row=0,
            column=0,
            padx=2,
            pady=2,
            sticky=N,
            )
        self.frame_22_canvas_Buffer = Frame(
            self.canvas_22_Buffer,
            bg=colorbg,
            padx=1,
            )         
            
        self.yScroll_frame_22_Buffer.config(
#                            command=self.canvas_22.yview
            command=self.handlerYScrollTwoFramesBuffer
            )
        self.xScroll_frame_22_Buffer.config(
            command=self.handlerXScrollTwoFramesBuffer
            )    
# Row 3
# ... 'Clear' button                            
        frame_31 = Frame(
            self.toplevelShowStorageBuffer,
            bg=colorbg,
            )
        frame_31.grid(
            row=3,
            column=1,
            padx=1,
            pady=5,
            )
# for table lines, max lines, etc
        frame_32_statusLine = Frame(
            self.toplevelShowStorageBuffer,
            bg=colorbg,
#                            relief=RIDGE,
#                            borderwidth=2,
            )
        frame_32_statusLine.grid(
            row=3,
            column=2,
            padx=0,
            pady=15,
            sticky=S+E+W,
            )
# ... subframe 32_00                           
        frame_32_00_statusLine = Frame(
            frame_32_statusLine,
            bg=colorbg,
            )
        frame_32_00_statusLine.grid(
            row=0,
            column=0,
            padx=3,
            pady=0,
            sticky=S,
            )
# ... subframe 32_01
        frame_32_01_statusLine = Frame(
            frame_32_statusLine,
            bg=colorbg,
            )
        frame_32_01_statusLine.grid(
            row=0,
            column=1,
            padx=12,
            pady=0,
            sticky=S,
            )
# ... subframe 32_02
        frame_32_02_statusLine = Frame(
            frame_32_statusLine,
            bg=colorbg,
            )
        frame_32_02_statusLine.grid(
            row=0,
            column=2,
            padx=3,
            pady=0,
            sticky=S,
            ) 

# Row 4, Main
# ... main frame
        frame_40_Main = Frame(
            self.toplevelShowStorageBuffer,
            bg=colorbg,
            )
        frame_40_Main.grid(
            row=4,
            column=2,
            padx=0,
            pady=0,
            columnspan=1,
            )
# ROW 4, COLUMN 0
# ... Form a new row from selected rows
        frame_40_00 = Frame(
            frame_40_Main,
            bg=colorbg,
#            borderwidth=2,
#            relief=RIDGE,
            )
        frame_40_00.grid(
            row=0,
            column=0,
            padx=3,
            pady=0,
            sticky=N,
            )
# ... title
        frame_40_00_00 = Frame(
            frame_40_00,
            bg=colorbg,
            )
        frame_40_00_00.grid(
            row=0,
            column=0,
            padx=10,
            pady=0,
            )
# ... 'using selected rows'
        frame_40_00_10 = Frame(
            frame_40_00,
            bg=colorbg,
            )
        frame_40_00_10.grid(
            row=1,
            column=0,
            padx=10,
            pady=0,
            )
# ... form new row
        frame_40_00_20 = Frame(
            frame_40_00,
            bg=colorbg,
            )
        frame_40_00_20.grid(
            row=2,
            column=0,
            padx=10,
            pady=0,
            )

# ROW 4, COLUMN 1
# ... Main - Title, group selected rows and clear all groups
        frame_40_01 = Frame(
            frame_40_Main,
            bg=colorbg,
#            borderwidth=2,
#            relief=RIDGE,
            )
        frame_40_01.grid(
            row=0,
            column=1,
            padx=3,
            pady=0,
            sticky=N,
            )
# ... title
        frame_40_01_00 = Frame(
            frame_40_01,
            bg=colorbg,
            )
        frame_40_01_00.grid(
            row=0,
            column=0,
            padx=10,
            pady=0,
            )
# ... 'using selected rows'
        frame_40_01_10 = Frame(
            frame_40_01,
            bg=colorbg,
            )
        frame_40_01_10.grid(
            row=1,
            column=0,
            padx=10,
            pady=0,
            )
# ... update x-y plots
        frame_40_01_20 = Frame(
            frame_40_01,
            bg=colorbg,
            )
        frame_40_01_20.grid(
            row=2,
            column=0,
            padx=10,
            pady=0,
            )
            
# ROW 4, COLUMN 2
# ... Main - Title, group selected rows and clear all groups
        frame_40_02 = Frame(
            frame_40_Main,
            bg=colorbg,
#            borderwidth=2,
#            relief=RIDGE,
            )
        frame_40_02.grid(
            row=0,
            column=2,
            padx=3,
            pady=0,
            sticky=N,
            )
# ... title
        frame_40_02_00 = Frame(
            frame_40_02,
            bg=colorbg,
            )
        frame_40_02_00.grid(
            row=0,
            column=0,
            padx=10,
            pady=0,
            )
# ... group selected rows
        frame_40_02_10 = Frame(
            frame_40_02,
            bg=colorbg,
            )
        frame_40_02_10.grid(
            row=1,
            column=0,
            padx=10,
            pady=0,
            )
# ... labeled as
        frame_40_02_20 = Frame(
            frame_40_02,
            bg=colorbg,
            )
        frame_40_02_20.grid(
            row=2,
            column=0,
            padx=10,
            pady=0,
            )
# ... group rows
        frame_40_02_30 = Frame(
            frame_40_02,
            bg=colorbg,
            )
        frame_40_02_30.grid(
            row=3,
            column=0,
            )
# ... show all groups, clear all groups,
        frame_40_02_40 = Frame(
            frame_40_02,
            bg=colorbg,
            )
        frame_40_02_40.grid(
            row=4,
            column=0,
            )
            
# ROW 4, COLUMN 3
# ... Main - kiviat plots
        frame_40_03 = Frame(
            frame_40_Main,
            bg=colorbg,
#            borderwidth=2,
#            relief=RIDGE,
            )
        frame_40_03.grid(
            row=0,
            column=3,
            padx=3,
            pady=0,
            sticky=N,
            )
# ... title
        frame_40_03_00 = Frame(
            frame_40_03,
            bg=colorbg,
            )
        frame_40_03_00.grid(
            row=0,
            column=0,
            padx=10,
            pady=3,
            )
# ... 'using all groups'
        frame_40_03_10 = Frame(
            frame_40_03,
            bg=colorbg,
            )
        frame_40_03_10.grid(
            row=1,
            column=0,
            padx=10,
            pady=0,
            )
# ... update kiviat plots
        frame_40_03_20 = Frame(
            frame_40_03,
            bg=colorbg,
            )
        frame_40_03_20.grid(
            row=2,
            column=0,
            padx=10,
            pady=0,
            )

# ROW 5                          
# ... Cancel button      
        frame_40_10 = Frame(
            frame_40_Main,
            bg=colorbg,
            )                            
        frame_40_10.grid(
            row=1,
            column=0,
            columnspan=2,
            padx=0,
            pady=0,
            )
        '''
        frame_50 = Frame(
            self.toplevelShowStorageBuffer,
            bg=colorbg,
            )                            
        frame_50.grid(
            row=5,
            column=0,
            columnspan=99,
            padx=0,
            pady=0,
            )
        '''

# -------------------------------------------     
        '''
        try:
# clear previous row numbers       
            self.clear_grid(self.frame_21_canvas_Buffer)
        except:
            pass
            
        try:
# clear database grid
            self.clear_grid(self.frame_22_canvas_Buffer)
        except:
            pass
        '''
            
# WIDGETS     
# ... number of rows selected in buffer
        label = Label(
            frame_000_00,
            text='Number of selected rows: ',
            bg=colorbg,
            justify=RIGHT,
            font=self.buttonFontSmall,
            )
        label.grid(
            row=0,
            column=0,
            padx=5,
            pady=2,
            sticky=E,
            )

        self.varEntryNumberOfRowsSelected_Buffer = IntVar()
        entryNumberOfRowsSelected_Buffer = Entry(
            frame_000_01,
            width=5,
            disabledbackground='white',
            disabledforeground='black',
            font=self.buttonFontSmall,
            state='disabled',
            textvariable=self.varEntryNumberOfRowsSelected_Buffer,
            )
        entryNumberOfRowsSelected_Buffer.grid(
            row=0,
            column=1,
            padx=0,
            pady=2,
            sticky=W,
            )

# ... title      
        labelTableValuesMain = Label(
            frame_00_00,
            text='STORAGE BUFFER\n(stores select data for X-Y and Scatter plots)',
#                            font=self.tableFont,
            bg=colorbg,
            justify=CENTER,
            font=self.titleFont,
            )
        labelTableValuesMain.grid(
            row=0,
            column=0,
            padx=0,
            pady=2,
            )
# ... width of fields
        labelWidthField = Label(
            frame_00_10,
            text=('Field\nwidth:'),
            font=self.buttonFontSmallest,
            bg=colorbg,
            fg='black',
            )
        labelWidthField.grid(
            row=0,
            column=0,
            padx=2,
            pady=0,
            sticky=W,
            )           
        self.comboboxWidthFieldBuffer = Pmw.ComboBox(
            frame_00_10,
            scrolledlist_items=self.mytableFieldWidths,
            entry_font=self.buttonFontSmallest,
            listheight=130,
            entry_width=5,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            selectioncommand=self.handlerComboboxDisplayStorageBufferValues_Call,
            scrolledlist_hull_width=500,
            )
        self.comboboxWidthFieldBuffer.grid(
            row=0,
            column=1,
            sticky=W,
            padx=2,
            pady=0,
            )

# ... height of fields (lines)
        labelHeightField = Label(
            frame_00_10,
            text=('  Field\n  height:'),
            font=self.buttonFontSmallest,
            bg=colorbg,
            fg='black',
            )
        labelHeightField.grid(
            row=0,
            column=2,
            padx=2,
            pady=0,
            )       
        self.comboboxHeightFieldBuffer = Pmw.ComboBox(
            frame_00_10,
            scrolledlist_items=self.mytableFieldHeights,
            entry_font=self.buttonFontSmallest,
            listheight=170,
            entry_width=5,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            selectioncommand=self.handlerComboboxDisplayStorageBufferValues_Call,
            scrolledlist_hull_width=500,
            )
        self.comboboxHeightFieldBuffer.grid(
            row=0,
            column=3,
            sticky=W,
            padx=2,
            pady=0,
            )

# ... font of fields
        labelFontField = Label(
            frame_00_10,
            text=('  Field\n  font:'),
            font=self.buttonFontSmallest,
            bg=colorbg,
            fg='black',
            )
        labelFontField.grid(
            row=0,
            column=4,
            padx=2,
            pady=0,
            )       
        self.comboboxFontFieldBuffer = Pmw.ComboBox(
            frame_00_10,
            scrolledlist_items=self.mytableFieldFonts,
            entry_font=self.buttonFontSmallest,
            listheight=80,
            entry_width=5,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            selectioncommand=self.handlerComboboxDisplayStorageBufferValues_Call,
            scrolledlist_hull_width=500,
            )
        self.comboboxFontFieldBuffer.grid(
            row=0,
            column=5,
            sticky=W,
            padx=2,
            pady=0,
            )
            
# set comboboxes for field width, height, font
        if mapped:
            self.comboboxWidthFieldBuffer.setentry(saveFieldWidths)
            self.comboboxHeightFieldBuffer.setentry(saveFieldHeights)
            self.comboboxFontFieldBuffer.setentry(saveFieldFonts)
        else:
            self.comboboxWidthFieldBuffer.selectitem(self.mytableFieldWidths[2])
            self.comboboxHeightFieldBuffer.selectitem(self.mytableFieldHeights[0])
            self.comboboxFontFieldBuffer.selectitem(self.mytableFieldFonts[1])
        ''' 
        width_Field_Buffer = self.comboboxWidthFieldBuffer.get()
        height_Field_Buffer = self.comboboxHeightFieldBuffer.get()
        fontsize_Field_Buffer = tkFont.Font(
            family='Helvetica',
            size=self.comboboxFontFieldBuffer.get(),
#            weight='bold'
            )
        '''

# set defaults for field width and height
        buttonResetFieldSizeDefaultsBuffer = Button(
            frame_00_10,
            text=('Reset'),
            bg='white',
            fg='blue',
            borderwidth=3,
            relief=RAISED,
            font=self.buttonFontSmallest,
            command=self.handlerResetFieldSizeDefaultsBuffer,
            )
        buttonResetFieldSizeDefaultsBuffer.grid(
            row=0,
            column=6,
            sticky=W,
            padx=2,
            pady=0,
            )

# constants
        width_Field_Buffer = self.comboboxWidthFieldBuffer.get()
        height_Field_Buffer = self.comboboxHeightFieldBuffer.get()
        fontsize_Field_Buffer = tkFont.Font(
            family='Helvetica',
            size=self.comboboxFontFieldBuffer.get(),
#            weight='bold'
            )    

# display values in Storage Buffer 
#        self.displayStorageBufferValues(0)

# ... headers
        self.varFieldSelectBuffer = IntVar()
        for j in range(minValue,len(self.headerNamesBufferStorage)): 
# header labels        
            labelHeader_test = Label(
                self.frame_11_canvas_Buffer,
                text=self.headerNamesBufferStorage[j],
                bg='white',
                fg='black',
                width=width_Field_Buffer,
                font=fontsize_Field_Buffer,
                anchor=NW,
                )
            labelHeader_test.grid(
                row=0,
                column=j,
                padx=2,
                pady=1,
                )
# radiobuttons
            radiobuttonFieldSelectBuffer = Radiobutton(
                self.frame_11_canvas_Buffer,
                bg=colorbg,
                justify=CENTER,
                variable=self.varFieldSelectBuffer,
                value=str(j+1),
                command = self.handlerPrintVar,
                borderwidth=0,
                )
            radiobuttonFieldSelectBuffer.grid(
                row=1,
                column=j,
                padx=2,
                pady=0,
                )
# number header columns                
            labelColumn = Label(
                self.frame_11_canvas_Buffer,
                text=str(j+1),
                bg=colorbg,
                justify=CENTER,
                width=width_Field_Buffer,     
                )
            labelColumn.grid(
                row=2,
                column=j,
                padx=2,
                pady=0,
                ) 

# ... user comment
        
# ... test input for canvases 11 and 22
        try:
            numRows = self.bufferRowStore_NumRows
        except:
            numRows = 0
        if numRows:
#            print '>> self.bufferRowStore_NumRows =', self.bufferRowStore_NumRows
#            print '>> len(self.headerNamesBufferStorage) =', len(self.headerNamesBufferStorage)
#            print '>> self.bufferRowStore[0] =', self.bufferRowStore[0]
            for i in range(self.bufferRowStore_NumRows):
                for j in range(minValue,len(self.headerNamesBufferStorage)):
                    labelTest = Label(
                        self.frame_22_canvas_Buffer,
                        text=self.bufferRowStore[i][j],
                        width=width_Field_Buffer,
                        height=height_Field_Buffer,
                        font=fontsize_Field_Buffer,
                        background='white',
                        foreground='black',
                        justify=CENTER,
                        anchor=NW,
                        )
                    labelTest.grid(
                        row=i,
                        column=j,
                        padx=2,
                        pady=1,
                        ) 

# setup 'Select row' checkbuttons:
        if numRows:
            self.varSelectAnyRow_Buffer = []
            tableColumn=0
            for i in range(self.bufferRowStore_NumRows):
                tableRow=i
                var = IntVar()
# checkbuttons for delete row
                checkbuttonSelectAnyRow = Checkbutton(
                    self.frame_21_canvas_Buffer,
                    bg=colorbg,
                    justify=LEFT,
                    variable=var,
                    font=self.buttonFontSmallest,
                    borderwidth=0,
                    height=height_Field_Buffer,
                    )
                checkbuttonSelectAnyRow.grid(
                    row=tableRow,
                    column=tableColumn,
                    padx=0,
                    pady=1,
                    sticky=E,
                    )
# use bindtags to switch binding order so that checkbuttons will be checked,
#   before being examined to see how many rows are checked;
#   normally, the first two parameters are switched below for the default value
                checkbuttonSelectAnyRow.bindtags((
                    'Checkbutton',                          # class binding
                    (str(checkbuttonSelectAnyRow)), # instance binding
                    'self.frame_21_canvas_Buffer',
                    'all'
                    ))
                checkbuttonSelectAnyRow.bind(
                    "<ButtonRelease-1>",
                    self.displayNumberOfRowsSelected_Buffer
                    )
# variable to check for on-off states
#  to check value, use:
#   for var in self.varSelectAnyRow:
#       print var.get()  # will be either 1 or 0
                self.varSelectAnyRow_Buffer.append(var)
                
# line numbers
                labelSelectAnyRow = Label(
                    self.frame_21_canvas_Buffer,
                    text='%-4s' % (i+1),
                    bg=colorbg,
                    justify=RIGHT,
                    height=height_Field_Buffer,
                    font=fontsize_Field_Buffer,
                    )
                labelSelectAnyRow.grid(
                    row=tableRow,
                    column=tableColumn+1,
                    padx=0,
                    pady=1,
                    sticky=W,
                    )                
 

 
# ... clear all row checkbuttons
        self.varAllRowsClearOrSelect_Buffer = IntVar()
        buttonClearAllCheckedBufferRows = Checkbutton(
            frame_31,
            indicator=0,
            text='/\\\nClear/Select\ndisplayed rows',
            variable=self.varAllRowsClearOrSelect_Buffer,
            bg='white',
            fg='blue',
            borderwidth=5,
            relief=RAISED,
            font=self.buttonFontSmallest,
            command=self.handlerAllRowsClearOrSelect_Buffer,
            )
        buttonClearAllCheckedBufferRows.grid(
            row=0,
            column=0,
            padx=0,
            pady=1,
            sticky=N,
            )

# width of all of the following buttons in storage buffer
        widthTableValueButtons = 18

# ... refresh buffer
        self.buttonTableValuesShowAll_Buffer = Button(
            frame_20_00,
            text='Refresh\ndisplay',
            width=widthTableValueButtons,
            borderwidth=5,
            relief=RAISED,
            justify=CENTER,
            font=self.buttonFontSmall,
#            command=self.handlerTableValuesShowAll_Buffer,
            command=self.handlerRefreshBufferView,
            )
        self.buttonTableValuesShowAll_Buffer.grid(
            row=0,
            column=0,
            padx=2,
            pady=0,
            sticky=N,
            )
# ... hide user fields
        self.checkbuttonHideShowFields_Buffer = Checkbutton(
            frame_20_10,
            indicatoron=0,
            width=widthTableValueButtons,
            background='blue',
            foreground='white',
            selectcolor='blue',
            textvariable=self.varTextForHideShowFields_Buffer,
            variable=self.varHideShowSet,
            borderwidth=5,
            relief=RAISED,
            justify=CENTER,
            font=self.buttonFontSmall,
            command=self.handlerHideShowUserFields_Buffer
            )       
        self.checkbuttonHideShowFields_Buffer.grid(
            row=0,
            column=0,
            padx=2,
            pady=0,
            sticky=N,
            )
            
# ... pickle buffer to file
        buttonTableValuesSavePickle_Buffer = Button(
            frame_20_20,
            text='Pickle (save)\nselect rows to file',
            width=widthTableValueButtons,
            borderwidth=5,
            relief=RAISED,
            justify=CENTER,
            font=self.buttonFontSmall,
            fg='black',
            bg='lightyellow',
            command=self.handlerTableValuesSavePickle_Buffer,
            )
        buttonTableValuesSavePickle_Buffer.grid(
            row=0,
            column=0,
            padx=2,
            pady=0,
            sticky=N,
            )
# ... unpickle file to buffer
        buttonTableValuesReadPickle_Buffer = Button(
            frame_20_20,
            text='unPickle (restore)\nfile to buffer',
            width=widthTableValueButtons,
            borderwidth=5,
            relief=RAISED,
            justify=CENTER,
            font=self.buttonFontSmall,
            fg='black',
            bg='lightyellow',
            command=self.handlerTableValuesReadPickle_Buffer,
            )
        buttonTableValuesReadPickle_Buffer.grid(
            row=1,
            column=0,
            padx=2,
            pady=0,
            sticky=N,
            )
          
# ... save select rows from current table to file in CVS format                        
        buttonTableValuesSaveCVS_Buffer = Button(
            frame_20_30,
            text='Save\nselect rows to CSV file',
            width=widthTableValueButtons,
            borderwidth=5,
            relief=RAISED,
            justify=CENTER,
            font=self.buttonFontSmall,
            fg='black',
            bg='lightgreen',
            command=self.handlerTableValuesSaveCVS_Buffer,
            )
        buttonTableValuesSaveCVS_Buffer.grid(
            row=0,
            column=0,
            padx=2,
            pady=0,
            sticky=N,
            )
# ... read file in CVS format (saved earlier) and append to current buffer
        buttonTableValuesReadCVS_Buffer = Button(
            frame_20_30,
            text='Read/append\nCSV file to buffer',
            width=widthTableValueButtons,
            borderwidth=5,
            relief=RAISED,
            justify=CENTER,
            font=self.buttonFontSmall,
            fg='black',
            bg='lightgreen',
            command=self.handlerTableValuesReadCVS_Buffer,
            )
        buttonTableValuesReadCVS_Buffer.grid(
            row=1,
            column=0,
            padx=2,
            pady=0,
            sticky=N,
            )
            
# ... purge duplicates
        buttonTableValuesPurgeDuplicates_Buffer = Button(
            frame_20_40,
            text='Purge\nduplicates from buffer',
            width=widthTableValueButtons,
            borderwidth=5,
            relief=RAISED,
            justify=CENTER,
            font=self.buttonFontSmall,
            fg='black',
            bg='tan',
            command=self.handlerTableValuesPurge_Buffer,
            )
        buttonTableValuesPurgeDuplicates_Buffer.grid(
            row=0,
            column=0,
            padx=2,
            pady=0,
            sticky=N,
            )
# ... auto-sort buffer based on columns
        buttonTableValuesAutoSort_Buffer = Button(
            frame_20_40,
            text='Auto-Sort\non selected column',
            width=widthTableValueButtons,
            borderwidth=5,
            relief=RAISED,
            justify=CENTER,
            font=self.buttonFontSmall,
            fg='black',
            bg='tan',
            command=self.handlerTableValuesAutoSort_Buffer
            )
        buttonTableValuesAutoSort_Buffer.grid(
            row=1,
            column=0,
            padx=2,
            pady=0,
            sticky=N,
            )
# ... move row
        buttonTableValuesMoveRow_Buffer = Button(
            frame_20_40,
            text='Move\nselected row',
            width=widthTableValueButtons,
            borderwidth=5,
            relief=RAISED,
            justify=CENTER,
            font=self.buttonFontSmall,
            fg='black',
            bg='tan',
            command=self.handlerTableValuesMoveRow_Buffer
            )
        buttonTableValuesMoveRow_Buffer.grid(
            row=2,
            column=0,
            padx=2,
            pady=0,
            sticky=N,
            )        
            
# ... delete selected rows of buffer (select all to empty buffer)
        self.buttonTableValuesDelete_Buffer = Button(
            frame_20_50,
            text='Delete\nselect rows',
            width=widthTableValueButtons,
            background='red',
            foreground='black',
            borderwidth=5,
            relief=RAISED,
            justify=CENTER,
            font=self.buttonFontSmall,
            command=self.handlerTableValuesDelete_Buffer
            )
        self.buttonTableValuesDelete_Buffer.grid(
            row=0,
            column=0,
            padx=2,
            pady=0,
            sticky=N,
            )
# ... clear buffer
        buttonTableValuesClear_Buffer = Button(
            frame_20_50,
            text='Clear\nbuffer',
            width=widthTableValueButtons,
            borderwidth=5,
            relief=RAISED,
            justify=CENTER,
            font=self.buttonFontSmall,
            fg='black',
            bg='red',
            command=self.handlerTableValuesClear_Buffer
            )
        buttonTableValuesClear_Buffer.grid(
            row=1,
            column=0,
            padx=2,
            pady=0,
            sticky=N,
            )
# STATUS line
# ... total rows
        labelTotalLines = Label(
            frame_32_00_statusLine,
            text='Total\nrows:',
            font=self.buttonFontSmallest,
            bg=colorbg,
            fg='black',
            )
        labelTotalLines.grid(
            row=0,
            column=0,
            padx=2,
            pady=2,
            )
            
        try:
            statusLine_linesTotal = len(self.varSelectAnyRow_Buffer)
        except:
            statusLine_linesTotal = 0
            
        self.varEntryTotalLinesBuffer = IntVar()
        self.entryTotalLinesBuffer = Entry(
            frame_32_00_statusLine,
            width=6,
            font=self.buttonFontSmallest,
            textvariable=self.varEntryTotalLinesBuffer,
            disabledforeground='black',
            disabledbackground='white',
            )
        self.entryTotalLinesBuffer.grid(
            row=0,
            column=1,
            padx=0,
            pady=2,
            )
#                        self.entryTotalLinesBuffer.configure(state='normal')
        self.varEntryTotalLinesBuffer.set(statusLine_linesTotal)
        self.entryTotalLinesBuffer.configure(state='disabled')
# ... total columns
        labelTotalCols = Label(
            frame_32_01_statusLine,
            text='Total\ncols:',
            font=self.buttonFontSmallest,
            bg=colorbg,
            fg='black',
            )
        labelTotalCols.grid(
            row=0,
            column=0,
            padx=2,
            pady=2,
            )
# if table is empty, will raise an exception
        try:
            statusLine_colsTotal = len(self.headerNamesBufferStorage)
        except:
            statusLine_colsTotal = 0
# show column total as zero if no rows exist, even though header columns exist
        if statusLine_linesTotal == 0:
            statusLine_colsTotal = 0
            
        self.varEntryTotalColsBuffer = IntVar()
        self.entryTotalColsBuffer = Entry(
            frame_32_01_statusLine,
            width=6,
            font=self.buttonFontSmallest,
            textvariable=self.varEntryTotalColsBuffer,
            disabledforeground='black',
            disabledbackground='white',
            )
        self.entryTotalColsBuffer.grid(
            row=0,
            column=1,
            padx=0,
            pady=2,
            )
        self.varEntryTotalColsBuffer.set(statusLine_colsTotal)
        self.entryTotalColsBuffer.configure(state='disabled')
        
# UPDATE PLOT WINDOWS
# ... update plots
        self.buttonUpdatePlotWindow_Buffer = Button(
            frame_40_00_00,
            text='UPDATE PLOT WINDOW\nwith new buffer selections -->',
            font=self.buttonFontSmallest,
            height=2,
            borderwidth=5,
            background='lightgreen',
            foreground='black',
            command=self.handlerUpdatePlotWindow_Buffer,
            )
        self.buttonUpdatePlotWindow_Buffer.grid(
            row=0,
            column=0,
            padx=3,
            pady=0,
            )
                            
# current plot windows available:
# ... 'X-Y', 'Kiviat', 'Scatter', 'Bar'
        self.comboListOfPlotWindows_Buffer = Pmw.ComboBox(
            frame_40_00_00,
            scrolledlist_items=self.listOfPlotWindowsAvailable_Buffer,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            entry_font=self.buttonFont,
            listheight=90,
            entry_width=12,
            scrolledlist_hull_width=500,
#                            selectioncommand=None,
             )
        self.comboListOfPlotWindows_Buffer.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            )
        self.comboListOfPlotWindows_Buffer.setentry(
            self.listOfPlotWindowsAvailable_Buffer[0]
            )
          
        labelUpdate = Label(
            frame_40_00_10,
            text=(
                '--------------\n' +
                'Using selected rows, update\n' + 
                'number of buffer plots in\n' +
                'designated plot window.'
                ),
            bg=colorbg,
            fg='black',
            font=self.labelFontMedium,
            )
        labelUpdate.grid(
            row=1,
            column=0,
            padx=0,
            pady=0,
            sticky=E,
            )
        
        buttonNewRow = Button(
            frame_40_01_00,
            text='FORM new row',
            width=20,
            height=2,
            borderwidth=5,
            relief=RAISED,
            justify=CENTER,
            bg='white',
            fg='blue',
            font=self.buttonFontSmall,
            command=self.handlerFormNewRow_Buffer,
            )
        buttonNewRow.grid(
            row=0,
            column=0,
            padx=3,
            pady=0,
            sticky=W,
            )
        
        labelNewRow = Label(
            frame_40_01_10,
            text=(
                '--------------\n' +
                'Using 4 or less selected rows, \n' +
                'form a new buffer row by math\n' +
                'combinations of row elements.'
                ),
            bg=colorbg,
            fg='black',
            font=self.labelFontMedium,
            )
        labelNewRow.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
          
# CANCEL button                           
        buttonCancelShowStorageBuffer = Button(
#            frame_50,
            frame_40_10,
            text='Cancel',
            width=25,
            borderwidth=5,
            relief=RAISED,
            justify=CENTER,
            font=self.buttonFontSmall,
            command=self.handlerDestroyToplevelShowStorageBuffer,
            )
        buttonCancelShowStorageBuffer.grid(
            row=0,
            column=0,
            pady=5,
            )
 
# display values in storage buffer 
#        self.displayStorageBufferValues(0)
            
# reposition widgets to be gridded correctly at top of frame instead of defaulting to middle of frame
# ... frame_11
        
        self.frame_11_canvas_Buffer.grid_rowconfigure(1,weight=1)
        self.canvas_11_Buffer.create_window(
            0,
            0,
            anchor=NW,
            window=self.frame_11_canvas_Buffer
            )
        self.frame_11_canvas_Buffer.update_idletasks()
        self.canvas_11_Buffer.config(scrollregion=self.canvas_11_Buffer.bbox('all'))
# ... frame_21       

        self.frame_21_canvas_Buffer.grid_rowconfigure(1,weight=1)
        self.canvas_21_Buffer.create_window(
            0,
            0,
            anchor=NW,
            window=self.frame_21_canvas_Buffer
            )
        self.frame_21_canvas_Buffer.update_idletasks()
        self.canvas_21_Buffer.config(scrollregion=self.canvas_21_Buffer.bbox('all'))
# ... frame_22    
        if statusLine_linesTotal <> 0:                   
            self.frame_22_canvas_Buffer.grid_rowconfigure(1,weight=1)
            self.canvas_22_Buffer.create_window(
                0,
                0,
                anchor=NW, 
                window=self.frame_22_canvas_Buffer
                )
            self.frame_22_canvas_Buffer.update_idletasks()
            self.canvas_22_Buffer.config(scrollregion=self.canvas_22_Buffer.bbox('all'))

        return
        
        
    def handlerTableValuesMoveRow_Buffer(self):
        '''
        Purpose:
            move buffer row to another location in buffer.
            This is so kiviat plots can be displayed with spokes in proper order, to
            match kiviat plots from table values
            
        Variables:
            self.varSelectAnyRow_Buffer     contains instances of checkboxes for rows; 
                                            also number of rows in buffer
            rowsChecked                     which buffer rows are checked
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerTableValuesMoveRow_Buffer')
        
# checks
# ... make sure at least one row is checked
        print('\nlen(self.varSelectAnyRow_Buffer)) = %s' % len(self.varSelectAnyRow_Buffer))
        if len(self.varSelectAnyRow_Buffer) == 0:
            stringNoRowChecked = (
                'No row in storage buffer is checked.\n\n' +
                'One, and only one, row must be checked\n' +
                'for this function to work.'
                )
            self.MySQL_Output(
                0,
                stringNoRowChecked
                )
            try:
                showerror(
                    'Error: no row checked',
                    stringNoRowChecked,
                    parent=self.toplevelShowStorageBuffer
                    )
            except:
                showerror(
                    'Error: no row checked',
                    stringNoRowChecked
                    )
            return
# ... make sure that ONLY one row is checked
        rowsChecked = []
        rowCount = 1
        for var in self.varSelectAnyRow_Buffer:
            if var.get():
                rowsChecked.append(rowCount)
            rowCount += 1
            
        if len(rowsChecked) > 1:
            stringTooManyRowsChecked = (
                'More than one row in Storage Buffer is checked.\n\n' +
                'Only one row can be checked for this function\n' +
                'to work.'
                )
            self.MySQL_Output(
                0,
                stringTooManyRowsChecked
                )
            try:
                showerror(
                    'Error: too many rows checked',
                    stringTooManyRowsChecked,
                    parent=self.toplevelShowStorageBuffer
                    )
            except:
                showerror(
                    'Error: too many rows checked',
                    stringTooManyRowsChecked
                    )
            return
        
# end of checks

# define background color
        colorbg = 'tan'

# define Toplevel
# destroy any old toplevel frames                      
        try:
            self.bufferMoveRow_xWindowLocation = self.toplevelMoveRowBuffer.winfo_rootx() - self.offsetWindowX
            self.bufferMoveRow_yWindowLocation = self.toplevelMoveRowBuffer.winfo_rooty() - self.offsetWindowY
            self.toplevelMoveRowStorageBuffer.destroy()
            self.MySQL_Output(
                1,
                'Previous toplevel widget removed from screen.'
                )
        except:  
            self.MySQL_Output(
                1,
                'No previous toplevel widget to remove from screen.'
                )

# open Toplevel frame for showing buffer
        self.toplevelMoveRowStorageBuffer = Toplevel(
            self.toplevelShowStorageBuffer,
            bg=colorbg,
            )
        self.toplevelMoveRowStorageBuffer.title(
            'STORAGE BUFFER'
            )
#        self.toplevelShowStorageBuffer.transient(self.frameParent)
        self.toplevelMoveRowStorageBuffer.transient(self.toplevelShowStorageBuffer)
# place the top window
        self.toplevelMoveRowStorageBuffer.geometry(
            '+%d+%d' % (self.bufferMoveRow_xWindowLocation,self.bufferMoveRow_yWindowLocation)
            )
# FRAMES
# Row 0
# ... title frame
        frame_00 = Frame(
            self.toplevelMoveRowStorageBuffer,
            bg=colorbg,
            )
        frame_00.grid(
            row=0,
            column=0,
            padx=5,
            pady=5,
            )
            
# ... insert at
        frame_10 = Frame(
            self.toplevelMoveRowStorageBuffer,
            bg=colorbg,
            )
        frame_10.grid(  
            row=1,
            column=0,
            padx=5,
            pady=5,
            sticky=W,
            )
            
# ... options for inserting
        frame_20 = Frame(
            self.toplevelMoveRowStorageBuffer,
            bg=colorbg,
            )
        frame_20.grid(
            row=2,
            column=0,
            padx=15,
            pady=5,
            )
            
# ... move button
        frame_30 = Frame(
            self.toplevelMoveRowStorageBuffer,
            bg=colorbg,
            )
        frame_30.grid(
            row=3,
            column=0,
            padx=5,
            pady=5,
            )

# row 100            
# ... cancel
        frame_100 = Frame(
            self.toplevelMoveRowStorageBuffer,
            bg=colorbg,
            )
        frame_100.grid(
            row=100,
            column=0,
            padx=0,
            pady=5,
            )


# WIDGETS
# ... title
        labelTitle = Label(
            frame_00,
            text='MOVE SELECTED ROW',
            bg=colorbg,
            justify=CENTER,
            font=self.titleFont,
            )
        labelTitle.grid(
            row=0,
            column=0,
            padx=0,
            pady=2,
            )
            
# ... label - insert into storage buffer
        label = Label(
            frame_10,
            text='Insert selected row ...',
            bg=colorbg,
            font=self.labelFontMedium,
            anchor=W,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            sticky=E+W,
            )
            
# ... select insert location
        self.varMoveRowIntoStorageBuffer = StringVar()
# ... select default value
        self.varMoveRowIntoStorageBuffer.set('after_last_row')
        
# ...       before first row
        self.buttonMoveRow_BeforeFirstRow = Radiobutton(
            frame_20,
            bg=colorbg,
            variable=self.varMoveRowIntoStorageBuffer,
            text='Before first row',
            value='before_first_row',
            anchor=W,
            )
        self.buttonMoveRow_BeforeFirstRow.grid(
            row=0,
            column=0,
            columnspan=2,
            padx=0,
            pady=0,
            sticky=W,
            )            
# ...       after row n            
        self.buttonMoveRow_AfterRow = Radiobutton(
            frame_20,
            bg=colorbg,
            variable=self.varMoveRowIntoStorageBuffer,
            text='After row number ',
            value='after_row',
            anchor=W,
            )
        self.buttonMoveRow_AfterRow.grid(
            row=1,
            column=0,
            padx=0,
            pady=0,
            sticky=W,
            )
            
        currentBufferRows = []
        if len(self.bufferRowStore) <> 0:
            currentBufferRows = range(1, len(self.bufferRowStore)+1)
        self.comboboxMoveRow_AfterRow = Pmw.ComboBox(
            frame_20,
            scrolledlist_items=currentBufferRows,
            dropdown=1,
            entry_width=10,
            listheight=100,
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            entry_state='disabled',
            scrolledlist_hull_width=500,
            )
        self.comboboxMoveRow_AfterRow.grid(
            row=1,
            column=1,
            padx=0,
            pady=0,
            sticky=W,
            )
        self.comboboxMoveRow_AfterRow.setentry(
            currentBufferRows[0]
            )
        
# ...       after last row        
        self.buttonMoveRow_AfterLastRow = Radiobutton(
            frame_20,
            bg=colorbg,
            variable=self.varMoveRowIntoStorageBuffer,
            text='After last row',
            value='after_last_row',
            anchor=W,
            )
        self.buttonMoveRow_AfterLastRow.grid(
            row=2,
            column=0,
            columnspan=2,
            padx=0,
            pady=0,
            sticky=W,
            )
            
# ... move button
        self.buttonMoveRowStorageBuffer = Button(
            frame_30,
            width=20,
            text='Move',
            bg='white',
            fg='blue',
            command=self.handlerMoveRowStorageBuffer,
            )
        self.buttonMoveRowStorageBuffer.grid(
            row=0,
            column=0,
            padx=5,
            pady=6,
            )

# ... cancel button
# CANCEL button                           
        buttonCancelMoveRowStorageBuffer = Button(
            frame_100,
            text='Cancel',
            width=25,
            borderwidth=5,
            relief=RAISED,
            justify=CENTER,
            font=self.buttonFontSmall,
            command=self.handlerDestroyToplevelMoveRowStorageBuffer,
            )
        buttonCancelMoveRowStorageBuffer.grid(
            row=0,
            column=0,
            pady=5,
            )            
        
        return
        
        
    def handlerMoveRowStorageBuffer(self):
        '''
        Purpose:
            to move one row in storage buffer
            
        Variables:
            self.varMoveRowIntoStorageBuffer        selection variable which will be either
                                                        - 'before_first_row'
                                                        - 'after_row'
                                                        - 'after_last_row'
            self.comboboxMoveRow_AfterRow           combobox for 'After row number'
            self.bufferRowStore                     buffer storage data; 'list' format
            
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerMoveRowStorageBuffer')

# checks
# ... only one row checked?  
# get rows checked
        rowCheckedForMove = []
        icount = 0
        for var in self.varSelectAnyRow_Buffer:
            icount += 1
            if var.get() == 1:
                rowCheckedForMove.append(icount)
                
        print('\n  Rows checked: %s' % rowCheckedForMove)
        
        if len(rowCheckedForMove) == 0:
            stringNoRowChecked = (
                'No row has been checked in the storage buffer.\n\n' +
                'Select only one row to move and try again.'
                )
            print('\n' + stringNoRowChecked)
            self.MySQL_Output(
                0,
                stringNoRowChecked
                )
            try:
                showerror(
                    'Error: no row checked',
                    stringNoRowChecked,
                    parent=self.toplevelShowStorageBuffer
                    )
            except:
                showerror(
                    'Error: no row checked',
                    stringNoRowChecked
                    )
            return
        if len(rowCheckedForMove) > 1:
            stringMoreThanOneRowChecked = (
                'More than one row has been checked in the storage buffer.\n\n' +
                'Select only one row to move and try again.'
                )
            print stringMoreThanOneRowChecked
            self.MySQL_Output(
                0,
                stringMoreThanOneRowChecked
                )
            try:
                showerror(
                    'Error: too many rows checked',
                    stringMoreThanOneRowChecked,
                    parent=self.toplevelShowStorageBuffer
                    )
            except:
                showerror(
                    'Error: too many rows checked',
                    stringMoreThanOneRowChecked
                    )
            return

# ----- end of checks -----

# store selected row
        selectedRow = []
        selectedRow = self.bufferRowStore[rowCheckedForMove[0] - 1]
        indexDeleteLocation = rowCheckedForMove[0] - 1
        if DEBUG_BUFFER_MOVE:
            print
            print('\nBuffer Row Move:')
            print('\n  selectedRow = %s' % selectedRow)
            print('\n  indexDeleteLocation = %s' % indexDeleteLocation)

# --------------------------------------------
# before first row
        if self.varMoveRowIntoStorageBuffer.get().strip() == 'before_first_row':
# ... index of insertion
            indexInsertLocation = 0
            if DEBUG_BUFFER_MOVE:
                print('\n  before_first_row indexInsertLocation = %s' % indexInsertLocation)
# ... insert
            self.bufferRowStore.insert(0,selectedRow)
# increment delete index by 1
            indexDeleteLocation += 1
# if the delete location is the last location
            if indexDeleteLocation == len(self.bufferRowStore) - 1:  
# don't do anything yet; will remove last item in list below
                pass
# ... but if the delete location is elsewhere
            elif indexDeleteLocation > len(self.bufferRowStore) - 1:
                    stringIndexError = (
                        'An index is out of bounds:\n\n' +
                        '  indexDeleteLocation = %s\n\n' +
                        '  len(self.bufferRowStore) - 1 = %s\n\n' +
                        'The value for "indexDeleteLocation" must always\n' +
                        'be smaller than or equal to "len(self.bufferRowStore) - 1".\n\n' +
                        'Contact code administrator to correct this error.'
                        ) % (indexDeleteLocation, len(self.bufferRowStore) - 1)
                    print stringIndexError
                    self.MySQL_Output(
                        0,
                        stringIndexError
                        )
                    try:
                        showerror(
                            'Error: index out of bounds',
                            stringIndexError,
                            parent=self.toplevelShowStorageBuffer
                            )
                    except:
                        showerror(
                            'Error: index out of bounds',
                            stringIndexError
                            )
                    return
            elif indexDeleteLocation < len(self.bufferRowStore) - 1:
# print list before decrementing
                if DEBUG_BUFFER_MOVE:
                    print('\n\nBefore decrementing, list self.bufferRowStore =')
                    for i in range(len(self.bufferRowStore)):
                        print('\n%s. %s' % (i+1, self.bufferRowStore[i]))
                    print('\nlen(self.bufferRowStore) = %s' % len(self.bufferRowStore))
# move items in list down by one index
                for i in range(indexDeleteLocation + 1,len(self.bufferRowStore) ):
                    self.bufferRowStore[i-1] = self.bufferRowStore[i]
                        
# when everything fails:
            else:
                stringBooleanError = (
                    'Boolean operation for variables\n\n' +
                    '  indexDeleteLocations\n\n' +
                    'and\n\n' +
                    '  len(self.bufferRowStore) - 1\n\n' +
                    'failed. The reason is unknown.\n\n' +
                    'Contact code administrator to correct this error.'
                    )
                print(stringBooleanError)
                self.MySQL_Output(
                    0,
                    stringBooleanError)
                try:
                    showinfo(
                        'Error: boolean logic failure',
                        stringBooleanError,
                        parent=self.toplevelShowStorageBuffer
                        )
                except:
                    showinfo(
                        'Error: boolean logic failure',
                        stringBooleanError
                        )
                return
                
# print list after decrementing
            if DEBUG_BUFFER_MOVE:
                print('\n\nAfter decrementing, list self.bufferRowStore =')
                for i in range(len(self.bufferRowStore)):
                    print('\n%s. %s' % (i+1, self.bufferRowStore[i]))  
                print('\nlen(self.bufferRowStore) = %s' % len(self.bufferRowStore))
                
# remove the last item in the list,always, since the last item is duplication in the next to the last item
            self.bufferRowStore.pop()
                
# --------------------------------------------
# after row number
        elif self.varMoveRowIntoStorageBuffer.get().strip() == 'after_row':
# ... index of insertion
            indexInsertLocation = int(self.comboboxMoveRow_AfterRow.get())
            if DEBUG_BUFFER_MOVE:
                print('\n  after_row indexInsertLocation = %s' % indexInsertLocation)
# ... insert
            self.bufferRowStore.insert(int(indexInsertLocation), selectedRow)
                
            if indexInsertLocation <= indexDeleteLocation:
# increment delete index by 1
                indexDeleteLocation += 1
# print some details
                if DEBUG_BUFFER_MOVE:
                    print('\n   indexInsertLocation <= indexDeleteLocation')
                    print('\n   type(indexInsertLocation) = %s, type(indexDeleteLocation) = %s' %
                        (type(indexInsertLocation), type(indexDeleteLocation)))
                    print('\n indexInsertLocation = %s, indexDeleteLocation = %s' % (
                        indexInsertLocation, indexDeleteLocation))
                    print('\n len(self.bufferRowStore) - 1 = %s' % (len(self.bufferRowStore) - 1))
# if the delete location is the last location
                if indexDeleteLocation == len(self.bufferRowStore) - 1:  
# don't do anything yet; will remove last item in list below
# print list before decrementing
                    if DEBUG_BUFFER_MOVE:
                        print('\n\nBefore decrementing, list self.bufferRowStore =')
                        for i in range(len(self.bufferRowStore)):
                            print('\n%s. %s' % (i+1, self.bufferRowStore[i]))
                        print('\nlen(self.bufferRowStore) = %s' % len(self.bufferRowStore))
                        
# if delete location is greater than (len() - 1) of the list, an index error has occurred
                elif indexDeleteLocation > len(self.bufferRowStore) - 1:
                    stringIndexError = (
                        'An index is out of bounds:\n\n' +
                        '  indexDeleteLocation = %s\n\n' +
                        '  len(self.bufferRowStore) - 1 = %s\n\n' +
                        'The value for "indexDeleteLocation" must always\n' +
                        'be smaller than or equal to "len(self.bufferRowStore) - 1".\n\n' +
                        'Contact code administrator to correct this error.'
                        ) % (indexDeleteLocation, len(self.bufferRowStore) - 1)
                    print stringIndexError
                    self.MySQL_Output(
                        0,
                        stringIndexError
                        )
                    try:
                        showerror(
                            'Error: index out of bounds',
                            stringIndexError,
                            parent=self.toplevelShowStorageBuffer
                            )
                    except:
                        showerror(
                            'Error: index out of bounds',
                            stringIndexError
                            )
                    return
                elif indexDeleteLocation < len(self.bufferRowStore) - 1:
# print list before decrementing
                    if DEBUG_BUFFER_MOVE:
                        print('\n\nBefore decrementing, list self.bufferRowStore =')
                        for i in range(len(self.bufferRowStore)):
                            print('\n%s. %s' % (i+1, self.bufferRowStore[i]))
                        print('\nlen(self.bufferRowStore) = %s' % len(self.bufferRowStore))
# move items in list down by one index
                    for i in range(indexDeleteLocation + 1,len(self.bufferRowStore) ):
                        self.bufferRowStore[i-1] = self.bufferRowStore[i]
                        
# when everything fails:
                else:
                    stringBooleanError = (
                        'Boolean operation for variables\n\n' +
                        '  indexDeleteLocations\n\n' +
                        'and\n\n' +
                        '  len(self.bufferRowStore) - 1\n\n' +
                        'failed. The reason is unknown.\n\n' +
                        'Contact code administrator to correct this error.'
                        )
                    print(stringBooleanError)
                    self.MySQL_Output(
                        0,
                        stringBooleanError)
                    try:
                        showinfo(
                            'Error: boolean logic failure',
                            stringBooleanError,
                            parent=self.toplevelShowStorageBuffer
                            )
                    except:
                        showinfo(
                            'Error: boolean logic failure',
                            stringBooleanError
                            )
                    return
                
# print list after decrementing
                if DEBUG_BUFFER_MOVE:
                    print('\n\nAfter decrementing, list self.bufferRowStore =')
                    for i in range(len(self.bufferRowStore)):
                        print('\n%s. %s' % (i+1, self.bufferRowStore[i]))  
                    print('\nlen(self.bufferRowStore) = %s' % len(self.bufferRowStore))
                    
            elif indexInsertLocation > indexDeleteLocation:
            
                if DEBUG_BUFFER_MOVE:
                    print('\n   indexInsertLocation > indexDeleteLocation')
                    print('\n   type(indexInsertLocation) = %s, type(indexDeleteLocation) = %s' %
                        (type(indexInsertLocation), type(indexDeleteLocation)))
                    print('\n indexInsertLocation = %s, indexDeleteLocation = %s' % (
                        indexInsertLocation, indexDeleteLocation))
#                self.bufferRowStore.remove(self.bufferRowStore[indexDeleteLocation])
                for i in range(indexDeleteLocation + 1,len(self.bufferRowStore)):
                    self.bufferRowStore[i-1] = self.bufferRowStore[i]
                    
# remove the last item in the list,always, since the last item is duplication in the next to the last item
            self.bufferRowStore.pop()

# --------------------------------------------            
# after last row
        elif self.varMoveRowIntoStorageBuffer.get().strip() == 'after_last_row':
# ... index of insertion
            indexInsertLocation = len(self.bufferRowStore)
            if DEBUG_BUFFER_MOVE:
                print('\n  after_last_row indexInsertLocation = %s' % indexInsertLocation)
# ... insert
            self.bufferRowStore.insert(int(indexInsertLocation), selectedRow)
# ... delete
#            self.bufferRowStore.remove(self.bufferRowStore[indexDeleteLocation])
# delete the copied row and move all indices bigger than this down one notch
# ... delete
            for i in range(indexDeleteLocation + 1, len(self.bufferRowStore)):
                self.bufferRowStore[i-1] = self.bufferRowStore[i]
# remove the last item in the list,always, since the last item is duplication in the next to the last item
            self.bufferRowStore.pop()

# --------------------------------------------
# error
        else:
            stringBadVar = (
                'An error has occurred for variable\n\n' +
                '   self.varMoveRowIntoStorageBuffer\n\n' +
                'Value is\n\n' +
                '   %s\n\n' +
                'Allowable values are\n\n' +
                '   - before_first_row\n' +
                '   - after_row\n' +
                '   - after_last_row\n\n' +
                'Please report this error to code administrator.'
                ) % self.varMoveRowIntoStorageBuffer.get()
            print('\n' + stringBadVar)
            self.MySQL_Output(
                0,
                stringBadVar
                )
            try:
                showerror(
                    'Error: bad variable',
                    stringBadVar,
                    parent=self.toplevelShowStorageBuffer
                    )
            except:
                showerror(
                    'Error: bad variable',
                    stringBadVar
                    )
            return

            
# ... clear all checkboxes in buffer storage window
        for var in self.varSelectAnyRow_Buffer:
            var.set(0) 
 
# ... set new number of rows
        self.bufferRowStore_NumRows = len(self.bufferRowStore)
        if DEBUG_BUFFER_MOVE:
            print('\nself.bufferRowStore_NumRows = %s' % self.bufferRowStore_NumRows)
        
# refresh buffer display to show new rows
#        self.buttonTableValuesShowAll_Buffer.invoke()
        self.handlerRefreshBufferView()
        
# display new total in main table window
        self.countDisplayStorageBuffer.set(
            'BUFFER: Display (' + str(self.bufferRowStore_NumRows) + ' rows)'
            )

        return
        

    def handlerDestroyToplevelMoveRowStorageBuffer(self):
        '''
        Purpose:
            destroy the window self.toplevelMoveRowStorageBuffer
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerDestroyToplevelMoveRowStorageBuffer')
            
        self.toplevelMoveRowStorageBuffer.destroy()
        
        return
        
        
    def handlerTableValuesSavePickle_Buffer(self):
        '''
        Purpose:
            pickle select rows of buffer to file
            
        Variables:
            self.varSelectAnyRow_Buffer         # checked rows
            self.bufferRowStore                 # buffer data
            self.toplevelShowStorageBuffer      # parent frame
         
        Called by:
            def displayStorageBufferValues(self)
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerTableValuesSavePickle_Buffer')
            
# get rows checked
        self.rowsCheckedForPickling = []
        icount = 0
        for var in self.varSelectAnyRow_Buffer:
            icount += 1
            if var.get() == 1:
                self.rowsCheckedForPickling.append(icount)
                
        if DEBUG_FORMNEWROWS_BUFFER:
            print('\n  Rows checked:\n%s' % self.rowsCheckedForPickling)
                
            
# if no rows checked, say so and return            
        if len(self.rowsCheckedForPickling) == 0:
            if self.bufferRowStore_NumRows <>0:
                stringNoRowsChecked = (
                    'No rows have been selected in the buffer.\n\n' +
                    'Check desired rows to pickle and try again.'
                    )
                print(stringNoRowsChecked)
                self.MySQL_Output(
                    0,
                    stringNoRowsChecked
                    )
                try:
                    showerror(
                        'Error: no rows checked',
                        stringNoRowsChecked,
                        parent=self.toplevelShowStorageBuffer
                        )
                except:
                    showerror(
                        'Error: no rows checked',
                        stringNoRowsChecked
                        )
                return
            else:
                stringNoRowsAvailable = (
                    'Storage Buffer is empty.\n\n' +
                    'No rows are available to pickle.'
                    )
                print stringNoRowsAvailable
                self.MySQL_Output(
                    0,
                    stringNoRowsAvailable
                    )
                try:
                    showerror(
                        'Error: no rows available',
                        stringNoRowsAvailable,
                        parent=self.toplevelShowStorageBuffer
                        )
                except:
                    showerror(
                        'Error: no rows available',
                        stringNoRowsAvailable
                        )
                return
            
# define toplevel params
        bgToplevel = 'lightyellow'
        
# destroy any old toplevel frames
        try: 
            self.toplevelPickleBuffer.destroy()
            self.MySQL_Output(
                1,
                'Previous toplevel widget removed from screen.'
                )
        except: 
            self.MySQL_Output(
                1,
                'No previous toplevel widget to remove from screen.'
                )        
        
# open Toplevel frame for showing buffer
        self.toplevelPickleBuffer = Toplevel(
            self.toplevelShowStorageBuffer,
            bg=bgToplevel,
            )
        self.toplevelPickleBuffer.title(
            'PICKLE SELECT ROWS TO FILE'
            )

        self.toplevelPickleBuffer.transient(self.toplevelShowStorageBuffer)
# place the top window
        self.toplevelPickleBuffer.geometry(
#            '+%d+%d' % (self.pickleBuffer_xWindowLocation,self.pickleBuffer_yWindowLocation)
            '+%d+%d' % (
            self.toplevelShowStorageBuffer.winfo_rootx() + 100,
            self.toplevelShowStorageBuffer.winfo_rooty() + 40
            )
            )
            
# define widget frames
# ... title
        frame_00 = Frame(
            self.toplevelPickleBuffer,
            bg=bgToplevel,
            )
        frame_00.grid(
            row=0,
            column=0,
            padx=5,
            pady=2,
            )
# ... saving n rows
        frame_10 = Frame(
            self.toplevelPickleBuffer,
            bg=bgToplevel,
            )
        frame_10.grid(
            row=1,
            column=0,
            padx=5,
            pady=2,
            )
# ... enter filename, entry field, browse
        frame_20 = Frame(
            self.toplevelPickleBuffer,
            bg=bgToplevel,
            )
        frame_20.grid(
            row=2,
            column=0,
            padx=5,
            pady=2,
            )
# ... save to file, cancel
        frame_30 = Frame(
            self.toplevelPickleBuffer,
            bg=bgToplevel,
            )
        frame_30.grid(
            row=3,
            column=0,
            padx=5,
            pady=2,
            )
 
# define widgets
# ... title
        title = Label(
            frame_00,
            text='PICKLE SELECT ROWS TO FILE',
            font=self.titleFont,
            bg=bgToplevel,
            justify=CENTER,
            )
        title.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
# ... saving n rows
        label = Label(
            frame_10,
#            text=( 
#                'Saving ' + str(len(rowsCheckedForPickling)) + ' rows from Storage Buffer'
#                ),
            bg=bgToplevel,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            ) 
        if len(self.rowsCheckedForPickling) == 1:
            label.configure(text=(
                'Pickling ' + str(len(self.rowsCheckedForPickling)) + ' row from Storage Buffer'
                )
                )
        else:
            label.configure(text=(
                'Pickling ' + str(len(self.rowsCheckedForPickling)) + ' rows from Storage Buffer'
                ))

# ... save to file, cancel
        button_PickleSaveToFile = Button(
            frame_30,
            text='Pickle to file',
            width=20,
            borderwidth=5,
            relief=RAISED,
            font=self.buttonFont,
            bg='white',
            fg='blue',
            command=self.handlerPickleSaveToFile,
            )
        button_PickleSaveToFile.grid(
            row=0,
            column=0,
            padx=5,
            pady=5,
            )
        button_PickleCancel = Button(
            frame_30,
            text='Cancel',
            width=10,
            borderwidth=5,
            relief=RAISED,
            font=self.buttonFont,
            command=self.handlerPickleCancel,
            )
        button_PickleCancel.grid(
            row=1,
            column=0,
            padx=5,
            pady=10,
            )

        return
        
        
    def handlerPickleCancel(self):
        '''
        Purpose:
            cancel process of saving pickled storage buffer to file
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerPickleCancel')
            
        self.toplevelPickleBuffer.destroy()
        
        return
        

    def handlerPickleSaveToFile(self):
        '''
        Purpose:
            select filename and save pickled buffer data
            
        Variables:
            self.toplevelPickleBuffer       toplevel window; destroy if pickle is successful
        
        Called by:
            def handlerTableValuesSavePickle_Buffer(self)
            
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerPickleSaveToFile')
        
# check connection
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return

# define dictionary of options for askopenfilename()
        options = {}
        options = {
            'defaultextension' : '.pkl',
            'filetypes' : [('pickle','.pkl'),('All files','*')],
            'initialdir' : '.',
            'initialfile' : '',
            'parent' : self.toplevelPickleBuffer,
            'title' : 'Pickle filename'
            }      
# reset entry field
        '''
        self.varPickleFileName.set('')
        '''
        
# get directory and filename
        fullPathName = tkFileDialog.asksaveasfilename(**options)
        dirname, filename = os.path.split(fullPathName)

        if filename == '':
            print('   No filename chosen to pickle buffer!')
            try:
                showinfo(
                    '\nNo filename chosen to pickle buffer...',
                    'You must enter a filename to continue.\n\n',
                    parent=self.toplevelShowStorageBuffer
                    )
            except:
                showinfo(
                    '\nNo filename chosen to pickle buffer...',
                    'You must enter a filename to continue.\n\n'
                    )
            return            
        else:
            print('\n dirname = %s' % dirname)
            print(' filename = %s' % filename)
            print('    initial directory = %s\n' % options['initialdir'])
            
# set entry field
        '''
        self.varPickleFileName.set(
            filename
            )
        '''
# open file
        try:
            filePickle = open(fullPathName,'w')
        except:
            stringCannotOpenFile = (
                'Cannot open file %s.\n\n' +
                'Reason is unknown. Select another\n' +
                'filename and try again.'
                )
            print stringCannotOpenFile
            self.MySQL_Output(
                0,
                stringCannotOpenFile
                )
            try:
                showerror(
                    'Error: cannot open file',
                    stringCannotOpenFile,
                    parent=self.toplevelShowStorageBuffer
                    )
            except:
                showerror(
                    'Error: cannot open file',
                    stringCannotOpenFile
                    )
            return
        
# store user-selected Storage Buffer rows in temporary list for pickling
        tempBufferRowStore = []
        for row in self.rowsCheckedForPickling:
            tempBufferRowStore.append(self.bufferRowStore[row-1])
            
# instantiate pickler object
        p = pickle.Pickler(filePickle)
        
# dump tempBufferRowStore to pickler
        try:
            p.dump(tempBufferRowStore)
        except:
            stringNoPickleDump(
                'Could not pickle the Storage Buffer\n' +
                'rows to file %s.\n\n' +
                'Check directory/file permissions\n' +
                'and try again.'
                )
            print stringNoPickleDump
            self.MySQL_Output(
                0,
                stringNoPickleDump
                )
            try:
                showerror(
                    'Error: cannot pickle buffer',
                    stringNoPickleDump,
                    parent=self.toplevelShowStorageBuffer
                    )
            except:
                showerror(
                    'Error: cannot pickle buffer',
                    stringNoPickleDump
                    )
            return
        else:
            if len(self.rowsCheckedForPickling) == 1:
                stringPickleSuccess = (
                    '1 row successfully pickled'
                    )
            else:
                stringPickleSuccess = (
                '%s rows successfully pickled'
                ) % len(self.rowsCheckedForPickling)
            print stringPickleSuccess
            self.MySQL_Output(
                0,
                stringPickleSuccess
                )
            try:
                showinfo(
                    'Success',
                    stringPickleSuccess,
                    parent=self.toplevelShowStorageBuffer
                    )
            except:
                showinfo(
                    'Success',
                    stringPickleSuccess
                    )

# close file
        filePickle.close()
# destroy topLevel
        self.toplevelPickleBuffer.destroy()

        return
        
        
    def handlerTableValuesReadPickle_Buffer(self):
        '''
        Purpose:
            unpickle file of buffer rows to select placement in storage buffer
            
        Variables:
            self.bufferRowStore                 # buffer data
            self.toplevelShowStorageBuffer      # parent frame
         
        Called by:
            def displayStorageBufferValues(self)
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerTableValuesReadPickle_Buffer')                
            
# define toplevel params
        bgToplevel = 'lightyellow'
        
# destroy any old toplevel frames
        try: 
            self.toplevelUnPickleFile.destroy()
            self.MySQL_Output(
                1,
                'Previous toplevel widget removed from screen.'
                )
        except: 
            self.MySQL_Output(
                1,
                'No previous toplevel widget to remove from screen.'
                )        
        
# open Toplevel frame for showing buffer
        self.toplevelUnPickleFile = Toplevel(
            self.toplevelShowStorageBuffer,
            bg=bgToplevel,
            )
        self.toplevelUnPickleFile.title(
            'UNPICKLE FILE TO BUFFER'
            )

        self.toplevelUnPickleFile.transient(self.toplevelShowStorageBuffer)
# place the top window
        self.toplevelUnPickleFile.geometry(
#            '+%d+%d' % (self.unpickleFile_xWindowLocation,self.unpickleFile_yWindowLocation)
            '+%d+%d' % (
            self.toplevelShowStorageBuffer.winfo_rootx()  + 120,
            self.toplevelShowStorageBuffer.winfo_rooty()  + 60
            )
            )
            
# initialize
        self.fullPathName_UnPickle = ''
            
# define widget frames
# ... title
        frame_00 = Frame(
            self.toplevelUnPickleFile,
            bg=bgToplevel,
            )
        frame_00.grid(
            row=0,
            column=0,
            padx=5,
            pady=2,
            )
# ... browse for filename
        frame_10 = Frame(
            self.toplevelUnPickleFile,
            bg=bgToplevel,
            )
        frame_10.grid(
            row=1,
            column=0,
            padx=5,
            pady=2,
            )
        if self.bufferRowStore_NumRows > 0:
# ... label - insert into storage buffer
            frame_20 = Frame(
                self.toplevelUnPickleFile,
                bg=bgToplevel,
                )
            frame_20.grid(
                row=2,
                column=0,
                padx=5,
                pady=2,
                sticky=W
                )
# ... select insert location
            frame_30 = Frame(
                self.toplevelUnPickleFile,
                bg=bgToplevel,
                )
            frame_30.grid(
                row=3,
                column=0,
                padx=20,
                pady=2,
                )
# Unpickle to storage buffer, cancel
        frame_40 = Frame(
            self.toplevelUnPickleFile,
            bg=bgToplevel,
            )
        frame_40.grid(
            row=4,
            column=0,
            padx=5,
            pady=5,
            )
 
# define widgets
# ... title
        title = Label(
            frame_00,
            text='UNPICKLE FILE TO STORAGE BUFFER',
            font=self.titleFont,
            bg=bgToplevel,
            justify=CENTER,
            )
        title.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )

# ... browse for filename
        label = Label(
            frame_10,
            text='Select file to unpickle: ',
            bg=bgToplevel,
            font=self.labelFontMedium,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            sticky=E,
            )
        self.varUnPickleFileName = StringVar()
# ...   fullpath name: self.fullpathPickleFileName
        self.entryUnPickleFileName = Entry(
            frame_10,
            textvariable=self.varUnPickleFileName,
            background='white',
            foreground='black',
            width=30,
            font=self.labelFontMedium,
            disabledbackground='white',
            disabledforeground='black',
            state=DISABLED,
            )
        self.entryUnPickleFileName.grid(
            row=0,
            column=1,
            padx=0,
            pady=2,
            sticky=W,
            )
        self.buttonUnpickleFileNameBrowse = Button(
            frame_10,
            text='Browse',
            borderwidth=3,
            relief=RAISED,
            background='white',
            foreground='blue',
            font=self.labelFontMedium,
            width=10,
            command=self.handlerUnpickleBrowseForFile,
            )
        self.buttonUnpickleFileNameBrowse.grid(
            row=1,
            column=1,
            padx=0,
            pady=0,
            )
            
        if self.bufferRowStore_NumRows > 0:            
# ... label - insert into storage buffer
            label = Label(
                frame_20,
                text='Insert into Storage Buffer ...',
                bg=bgToplevel,
                font=self.labelFontMedium,
                anchor=W,
                )
            label.grid(
                row=0,
                column=0,
                padx=0,
                pady=0,
                )
            
# ... select insert location
            self.varInsertIntoStorageBuffer = StringVar()
# ... select default value
            self.varInsertIntoStorageBuffer.set('after_last_row')
        
# ...       before first row
            self.buttonUnpickle_BeforeFirstRow = Radiobutton(
                frame_30,
                bg=bgToplevel,
                variable=self.varInsertIntoStorageBuffer,
                text='Before first row',
                value='before_first_row',
                anchor=W,
                )
            self.buttonUnpickle_BeforeFirstRow.grid(
                row=0,
                column=0,
                columnspan=2,
                padx=0,
                pady=0,
                sticky=W,
                )            
# ...       after row n            
            self.buttonUnpickle_AfterRow = Radiobutton(
                frame_30,
                bg=bgToplevel,
                variable=self.varInsertIntoStorageBuffer,
                text='After row number ',
                value='after_row',
                anchor=W,
                )
            self.buttonUnpickle_AfterRow.grid(
                row=1,
                column=0,
                padx=0,
                pady=0,
                sticky=W,
                )
            currentBufferRows = []
            if len(self.bufferRowStore) <> 0:
                currentBufferRows = range(1, len(self.bufferRowStore)+1)
            self.comboboxUnpickle_AfterRow = Pmw.ComboBox(
                frame_30,
                scrolledlist_items=currentBufferRows,
                dropdown=1,
                entry_width=10,
                listheight=100,
                scrolledlist_hull_width=500,
                )
            self.comboboxUnpickle_AfterRow.grid(
                row=1,
                column=1,
                padx=0,
                pady=0,
                sticky=W,
                )
# ...       after last row        
            self.buttonUnpickle_AfterLastRow = Radiobutton(
                frame_30,
                bg=bgToplevel,
                variable=self.varInsertIntoStorageBuffer,
                text='After last row',
                value='after_last_row',
                anchor=W,
                )
            self.buttonUnpickle_AfterLastRow.grid(
                row=2,
                column=0,
                columnspan=2,
                padx=0,
                pady=0,
                sticky=W,
                )

# ... unpickle to storage buffer, cancel
        button_UnpickleToBuffer = Button(
            frame_40,
            text='Unpickle to Storage Buffer',
            width=25,
            borderwidth=5,
            relief=RAISED,
            font=self.buttonFont,
            bg='white',
            fg='blue',
            command=self.handlerUnpickleReadFromFile,
            )
        button_UnpickleToBuffer.grid(
            row=0,
            column=0,
            padx=5,
            pady=5,
            )
        button_UnpickleCancel = Button(
            frame_40,
            text='Cancel',
            width=15,
            borderwidth=5,
            relief=RAISED,
            font=self.buttonFont,
            command=self.handlerUnpickleCancel,
            )
        button_UnpickleCancel.grid(
            row=1,
            column=0,
            padx=5,
            pady=10,
            )

        return

            
    def handlerUnpickleCancel(self):
        '''
        Purpose: 
            destroy toplevel for unpickling a file to storage buffer
            
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerUnpickleCancel')

        self.toplevelUnPickleFile.destroy()
        
        return
        
    
    def handlerUnpickleBrowseForFile(self):
        '''
        Purpose:
            select filename and unpickle data into storage buffer
            
        Variables:
            self.toplevelPickleBuffer       toplevel window; destroy if pickle is successful
        
        Called by:
            def handlerTableValuesSavePickle_Buffer(self)
            
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerUnpickleBrowseForFile')
        
# check connection
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return

# define dictionary of options for askopenfilename()
        options = {}
        options = {
            'defaultextension' : '.pkl',
            'filetypes' : [('pickle','.pkl'),('All files','*')],
            'initialdir' : '.',
            'initialfile' : '',
            'parent' : self.toplevelUnPickleFile,
            'title' : 'Unpickle filename'
            }      

        self.varUnPickleFileName.set('')
        
# get directory and filename
        self.fullPathName_UnPickle = tkFileDialog.askopenfilename(**options)
        dirname, filename = os.path.split(self.fullPathName_UnPickle)
        print('\nself.fullPathName_UnPickle = %s' % self.fullPathName_UnPickle)

        if filename == '':
            print '   No filename chosen to unpickle!'
            showinfo(
                '\nNo filename chosen to unpickle.\n\n',
                'You must enter a filename to continue.'
                )
            return            
        else:
            print
            print ' dirname =',dirname
            print ' filename =',filename
            print '    initial directory =',options['initialdir']
            print
            
# set entry field
        self.varUnPickleFileName.set(
            filename
            )
            
        return
        
        
    def handlerUnpickleReadFromFile(self):
        '''
        Purpose:
            unpickle file and store contents in Storage Buffer
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerUnpickleReadFromFile')
        
# print full path name
        if DEBUG_BUFFER_PICKLE:
            print('\nself.fullPathName_UnPickle = %s' % self.fullPathName_UnPickle)
        
# checks
        if self.fullPathName_UnPickle == '':
            stringNoFile = (
                'No file has been selected to unpickle.\n\n' +
                'Select a file to unpickle and try again.'
                )
            print stringNoFile
            self.MySQL_Output(
                0,
                stringNoFile
                )
            try:
                showerror(
                    'Error: no file selected',
                    stringNoFile,
                    parent=self.toplevelShowStorageBuffer
                    )
            except:
                showerror(
                    'Error: no file selected',
                    stringNoFile
                )
            return
        
# open unpickle file
        try:
            fileUnPickle = open(self.fullPathName_UnPickle,'r')
        except:
            stringCannotOpenFile = (
                'Cannot open file %s.\n\n' +
                'Check file permissions, or select another\n' +
                'filename and try again.'
                ) % self.fullPathName_UnPickle
            print stringCannotOpenFile
            self.MySQL_Output(
                0,
                stringCannotOpenFile
                )
            try:
                showerror(
                    'Error: cannot open file',
                    stringCannotOpenFile,
                    parent=self.toplevelShowStorageBuffer
                    )
            except:
                showerror(
                    'Error: cannot open file',
                    stringCannotOpenFile
                    )
            return
        
# store user-selected Storage Buffer rows in temporary list for pickling
        tempBufferRowStore = []
            
# instantiate pickler object
        try:
            p = pickle.Unpickler(fileUnPickle)
        except:
            stringNoUnPickle = (
                'Cannot unpickle the file\n\n' +
                '%s\n\n' +
                'The file must not be a properly pickled file.\n\n' +
                'Select another file and try again.'
                ) % self.fullPathName_UnPickle
            print stringNoUnPickle
            self.MySQL_Output(
                0,
                stringNoUnPickle
                )
            try:
                showerror(
                    'Error: cannot unpickle file',
                    stringNoUnPickle,
                    parent=self.toplevelShowStorageBuffer
                    )
            except:
                showerror(
                    'Error: cannot unpickle file',
                    stringNoUnPickle
                    )
            return
        
# unpickle file and load to tempBufferRowStore
        try:
            tempBufferRowStore = p.load()
        except:
            stringNoPickleLoad = (
                'Could not load the unpickled file\n\n' +
                '%s\n\n' +
                'Pick another file and try again.'
                ) % self.fullPathName_UnPickle
            print stringNoPickleLoad
            self.MySQL_Output(
                0,
                stringNoPickleLoad
                )
            try:
                showerror(
                    'Error: cannot unpickle file',
                    stringNoPickleLoad,
                    parent=self.toplevelShowStorageBuffer
                    )
            except:
                showerror(
                    'Error: cannot unpickle file',
                    stringNoPickleLoad
                    )
            return
            
        if len(tempBufferRowStore) == 0:
            stringUnpickleEmpty = (
                'The contents of the unpickled file are empty.\n\n' +
                'The unpickling process cannot continue.'
                )
            print(stringUnpickleEmpty)
            self.MySQL_Output(
                0,
                stringUnpickleEmpty
                )
            try:
                showerror(
                    'Error: contents empty',
                    stringUnpickleEmtpty,
                    parent=self.toplevelShowStorageBuffer
                    )
            except:
                showerror(
                    'Error: contents empty',
                    stringUnpickleEmtpty
                    )
            sleep(10)
            showerror.destroy()
            return
            
# insert into storage buffer based on variable 
#       self.varInsertIntoStorageBuffer:
#               'before_first_row'
#               'after_row'
#               'after_last_row'
# current storage buffer contents:
#               self.bufferRowStore
# values to be inserted:
#               tempBufferRowStore
        if self.bufferRowStore_NumRows == 0:
            offset = 0
            
        elif self.varInsertIntoStorageBuffer.get().strip() == 'before_first_row':
            offset = 0
        
        elif self.varInsertIntoStorageBuffer.get().strip() == 'after_row':
# do some checks
# ... turn string value into integer with eval, if possible
            try:
                offset = eval(self.comboboxUnpickle_AfterRow.get())
# check if string of text was entered
            except NameError:
                stringNotDefined = (
                    'The row number must be an integer value.\n\n' +
                    'Enter an integer value and try again.'
                    )
                print stringNotDefined
                self.MySQL_Output(
                    0,
                    stringNotDefined
                    )
                try:
                    showerror(
                        'Error: bad row number',
                        stringNotDefined,
                        parent=self.toplevelShowStorageBuffer
                        )
                except:
                    showerror(
                        'Error: bad row number',
                        stringNotDefined
                        )
                return
# ... check if float was entered
            if type(offset) <> int or type(offset) <> long:
                stringRowValueWrongType = (
                    'Row value entered is not an integer value.\n\n' +
                    'Enter a valid integer value and try again.'
                    )
                print(stringRowValueWrongType)
                self.MySQL_Output(
                    0,
                    stringRowValueWrongType
                    )
                try:
                    showerror(
                        'Error: wrong datatype',
                        stringRowValueWrongType,
                        parent=self.toplevelShowStorageBuffer
                        )
                except:
                    showerror(
                        'Error: wrong datatype',
                        stringRowValueWrongType
                        )
                return
            
# ... check if value for row is in bounds for the current storage buffer            
            if offset > len(self.bufferRowStore):
                stringRowValueTooLarge = (
                    'Row value entered is larger than the number\n' +
                    'of rows in the Storage Buffer.\n\n' +
                    'Row value = %s\n\n' +
                    'Rows in storage buffer = %s\n\n' +
                    'Enter a valid row value and try again.'
                    ) % (offset, len(self.bufferRowStore))
                print(stringRowValueTooLarge)
                self.MySQL_Output(
                    0,
                    stringRowValueTooLarge
                    )
                try:
                    showerror(
                        'Error: row value too large',
                        stringRowValueTooLarge,
                        parent=self.toplevelShowStorageBuffer
                        )
                except:
                    showerror(
                        'Error: row value too large',
                        stringRowValueTooLarge
                        )
                return
            elif offset < 1:
                stringRowValueTooSmall = (
                    'Row value entered cannot be less than 1.\n\n' +
                    'Enter a valid row value and try again.'
                    )
                print(stringRowValueTooSmall)
                self.MySQL_Output(
                    0,
                    stringRowValueTooSmall
                    )
                try:
                    showerror(
                        'Error: row value < 1',
                        stringRowValueTooSmall,
                        parent=self.toplevelShowStorageBuffer
                        )
                except:
                    showerror(
                        'Error: row value < 1',
                        stringRowValueTooSmall
                        )
                return
# end of checks
#                self.bufferRowStore.insert(offset,tempBufferRowStore)
            
        elif self.varInsertIntoStorageBuffer.get().strip() == 'after_last_row':
            offset = len(self.bufferRowStore)
#            self.bufferRowStore.insert(len(self.bufferRowStore),tempBufferRowStore)
            
        else:
            stringBadUnpickleButtonVariable = (
                'Invalid button value for self.varInsertIntoStorageBuffer:\n\n' + 
                '%s\n\n' +
                'Storage Buffer data insertion cannot continue.\n\n' +
                'Please contact code administator.'
                ) % self.varInsertIntoStorageBuffer.get()
            print stringBadUnpickleButtonVariable
            self.MySQL_Output(
                0,
                stringBadUnpickleButtonVariable
                )
            try:
                showerror(
                    'Error: bad value',
                    stringBadUnpickleButtonVariable,
                    parent=self.toplevelShowStorageBuffer
                    )
            except:
                showerror(
                    'Error: bad value',
                    stringBadUnpickleButtonVariable
                    )
            return
            
# insert rows into buffer
        try:
            print('Inserting the following rows:')
            for i in range(len(tempBufferRowStore)):
                self.bufferRowStore.insert(offset,tempBufferRowStore[i])
                print('%s. %s\n' % (i, tempBufferRowStore[i]))
                offset += 1.
        except:
            stringNoInsert = (
                'Insertion of unpickled rows into storage buffer failed.\n\n'
                'Examine output for any irregularities in the unpickled\n' +
                'file content.'
                )
            print stringNoInsert
            self.MySQL_Output(
                0,
                stringNoInsert
                )
            try:
                showinfo(
                    'Error: insertion failed',
                    stringNoInsert,
                    parent=self.toplevelShowStorageBuffer
                    )
            except:
                showinfo(
                    'Error: insertion failed',
                    stringNoInsert
                    )
            return
            
# print success
            
        if len(tempBufferRowStore) == 1:
            stringUnpickleSuccess = (
           '1 row successfully unpickled to storage buffer'
                )
        else:
            stringUnpickleSuccess = (
            '%s rows successfully unpickled to storage buffer'
            ) % len(tempBufferRowStore)
            
        print stringUnpickleSuccess
        self.MySQL_Output(
            0,
            stringUnpickleSuccess
            )
        try:
            showinfo(
                'Success',
                stringUnpickleSuccess,
                parent=self.toplevelShowStorageBuffer
                )
        except:
            showinfo(
                'Success',
                stringUnpickleSuccess
                )

# close file
        fileUnPickle.close()
        
# for debugging
        if DEBUG_BUFFER_PICKLE:
            print('\nself.bufferRowStore_NumRows = %s' % self.bufferRowStore_NumRows)
# ... print new buffer storage list
            print('\nself.bufferRowStore =\n%s\n' % self.bufferRowStore)
            for i in range(len(self.bufferRowStore)):
                print('%s. %s' % (i,self.bufferRowStore[i]))
                print
            
# clear file entry to toplevel; do not destroy
        self.varUnPickleFileName.set('')      
        
# refresh storage buffer
# ... clear all checkboxes in buffer storage window;
# ... Note: there may be no rows if a file has just been unpickled
        try:
            for var in self.varSelectAnyRow_Buffer:
                var.set(0)
        except:
            pass
      
# ... set new number of rows
        self.bufferRowStore_NumRows = len(self.bufferRowStore)
        
# ... refresh buffer display to show new rows           
#        self.buttonTableValuesShowAll_Buffer.invoke()
        self.handlerRefreshBufferView()
        
#        self.buttonShowStorageBuffer.invoke()

# display new total in main table window
        self.countDisplayStorageBuffer.set(
            'BUFFER: Display (' + str(self.bufferRowStore_NumRows) + ' rows)'
            )
            
        return
        
        
    def handlerFormNewRow_Buffer(self):
        '''
        Purpose:
            form new row from selected buffer rows by using
            math combinations on selected row elements
            
        Parent window:
            self.toplevelShowStorageBuffer
            
        Misc notes:
            1. cancel the toplevel window if 'Buffer: store' button is selected
            2. make user comment of new line = math expression using y-headers(???)
            3. #, Row#, x-header, y-header, select, operators, keypad
            4. select user-fields from text fields in displayed table (only thing to do!)
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerFormNewRow_Buffer')
        
# print selected row numbers from buffer
        rowsChecked = []
        icount = 0
        for var in self.varSelectAnyRow_Buffer:
            icount += 1
            if DEBUG_FORMNEWROWS_BUFFER:
                print '%s. var.get() = %s' % (icount,var.get())
            if var.get() == 1:
                rowsChecked.append(icount)
                
        if DEBUG_FORMNEWROWS_BUFFER:
            print('\nrowsChecked = %s\n' % rowsChecked)
        
# CHECKS
        if len(rowsChecked) == 0:
            stringNoRowsChecked = (
                'No rows have been selected.\n\n' +
                'Select up to 4 rows max to\n' +
                'form a new row and try again.'
                )
            print stringNoRowsChecked
            try:
                showerror(
                    'Error: no rows',
                    stringNoRowsChecked,
                    parent=self.toplevelShowStorageBuffer
                    )
            except:
                showerror(
                    'Error: no rows',
                    stringNoRowsChecked
                    )
            return
        if len(rowsChecked) > 4:
            stringTooManyRowsChecked = (
                'Too many rows have been selected.\n\n' +
                'Select up to 4 rows max to\n' +
                'form a new row and try again.'
                )
            print stringTooManyRowsChecked
            try:
                showerror(
                    'Error: too many rows',
                    stringTooManyRowsChecked,
                    parent=self.toplevelShowStorageBuffer
                    )
            except:
                showerror(
                    'Error: too many rows',
                    stringTooManyRowsChecked
                    )
            return
        
#check for same number of values
        rowFirst = rowsChecked[0]
        numPointsFirst = self.bufferRowStore[rowFirst-1][11]
        if len(rowsChecked) >= 2:
            for rowNum in rowsChecked:
                numPoints = self.bufferRowStore[rowNum-1][11]
                print('numPoints in Row %s: %s' % (rowNum, numPoints))
                if numPoints <> numPointsFirst:
                    stringMismatchedPoints = (
                        'Number of data points for each selected row\n' +
                        'must match for this operation.\n\n' +
                        'At the very least, the following rows do not match:\n\n' +
                        'Row %s: %s points\n' +
                        'Row %s: %s points\n\n' +
                        'Select rows that have same number of points\n' +
                        'and try again.'
                        ) % (rowFirst, numPointsFirst, rowNum, numPoints)
                    print stringMismatchedPoints
                    try:
                        showerror(
                            'Error: mismatched points',
                            stringMismatchedPoints,
                            parent=self.toplevelShowStorageBuffer
                            )
                    except:
                        showerror(
                            'Error: mismatched points',
                            stringMismatchedPoints
                            )
                    return

#check for same x-header; if not same, just warn user and continue if user desires
        rowFirst = rowsChecked[0]
        xHeaderFirst = self.bufferRowStore[rowFirst-1][5]
        if len(rowsChecked) >= 2:
            for rowNum in rowsChecked:
                xHeader = self.bufferRowStore[rowNum-1][5]
                print('xHeader in Row %s: %s' % (rowNum, xHeader))
                if xHeader <> xHeaderFirst:
                    stringMismatchedXHeaders = (
                        'The x headers for all selected rows do not HAVE\n' +
                        'to match for this operation, but the user is\n' +
                        'warned when they do not in case a selection mistake\n' +
                        'has been made.\n\n' +
                        'At the very least, the following x headers do not match:\n\n' +
                        'Row %s: %s\n' +
                        'Row %s: %s\n\n' +
                        'Select OK to continue, Cancel to quit this operation.'
                        ) % (rowFirst, xHeaderFirst, rowNum, xHeader)
                    print stringMismatchedXHeaders
                    okay = askokcancel(
                        'Warning: different x headers',
                        stringMismatchedXHeaders
                        )
                    if not okay:
                        return
                    else:
                        break
# --- end of CHECKS ---

# generate lists needed for drop-down menus
        dict_userCommentNew = {}
        dict_headersXNew = {}
        dict_headersYNew = {}
        dict_databasesNew = {}
        dict_tablesNew = {}
        dict_userFieldNew_1 = {}
        dict_userFieldNew_2 = {}
        dict_userFieldNew_3 = {}
        dict_userFieldNew_4 = {}
        self.headersXNew = []
        self.headersYNew = []
        self.databasesNew = []
        self.tablesNew = []
        self.userFieldNew_1 = []
        self.userFieldNew_2 = []
        self.userFieldNew_3 = []
        self.userFieldNew_4 = []
# use dicts to get unique values
        for rowNum in rowsChecked:
            dict_userCommentNew[self.bufferRowStore[rowNum-1][0]] = None
            dict_headersXNew[self.bufferRowStore[rowNum-1][5]] = None
            dict_headersYNew[self.bufferRowStore[rowNum-1][6]] = None
            dict_databasesNew[self.bufferRowStore[rowNum-1][9]] = None
            dict_tablesNew[self.bufferRowStore[rowNum-1][10]] = None
            dict_userFieldNew_1[self.bufferRowStore[rowNum-1][1]] = None
            dict_userFieldNew_2[self.bufferRowStore[rowNum-1][2]] = None
            dict_userFieldNew_3[self.bufferRowStore[rowNum-1][3]] = None
            dict_userFieldNew_4[self.bufferRowStore[rowNum-1][4]] = None
# make list out of dict keys   
        self.userCommentNew = list(dict_userCommentNew)
        self.headersXNew = list(dict_headersXNew)
        self.headersYNew = list(dict_headersYNew)
        self.databasesNew = list(dict_databasesNew)
        self.tablesNew = list(dict_tablesNew)
        self.userFieldNew_1 = list(dict_userFieldNew_1)
        self.userFieldNew_2 = list(dict_userFieldNew_2)
        self.userFieldNew_3 = list(dict_userFieldNew_3)
        self.userFieldNew_4 = list(dict_userFieldNew_4)
# sort in place
        self.userCommentNew.sort()
        self.headersXNew.sort()
        self.headersYNew.sort()
        self.databasesNew.sort()
        self.tablesNew.sort()
        self.userFieldNew_1.sort()
        self.userFieldNew_2.sort()
        self.userFieldNew_3.sort()
        self.userFieldNew_4.sort()

# destroy any old toplevel frames                      
        try:
            self.formNewRow_xWindowLocation = self.toplevelFormNewRow.winfo_rootx() - self.offsetWindowX
            self.formNewRow_yWindowLocation = self.toplevelFormNewRow.winfo_rooty() - self.offsetWindowY
            self.toplevelFormNewRow.destroy()
            self.MySQL_Output(
                1,
                'Previous toplevel widget removed from screen.'
                )
        except: 
#            self.formNewRow_xWindowLocation = self.buffer_xWindowLocation + 100
#            self.formNewRow_yWindowLocation = self.buffer_yWindowLocation + 50
            self.formNewRow_xWindowLocation = self.toplevelShowStorageBuffer.winfo_rootx() + 50
            self.formNewRow_yWindowLocation = self.toplevelShowStorageBuffer.winfo_rooty() + 25
            self.MySQL_Output(
                1,
                'No previous toplevel widget to remove from screen.'
                )


# colors for background and foreground
        bgToplevel = 'lightgreen'
        bgFrame = 'lightgreen'
        fgFrame = 'black'
        bgButton = 'white'
        fgButton = 'blue'
        bgButton_Function = 'white'
        fgButton_Function = 'blue'

# open Toplevel frame for showing buffer
        self.toplevelFormNewRow = Toplevel(
            self.toplevelShowStorageBuffer,
            bg=bgToplevel,
            )
        self.toplevelFormNewRow.title(
            'FORM NEW ROW'
            )
#        self.toplevelShowStorageBuffer.transient(self.frameParent)
        self.toplevelFormNewRow.transient(self.toplevelShowStorageBuffer)
# place the top window
        self.toplevelFormNewRow.geometry(
            '+%d+%d' % (self.formNewRow_xWindowLocation,self.formNewRow_yWindowLocation)
            )

            
# FRAMES
# Row 0
# ... title frame
        frame_00 = Frame(
            self.toplevelFormNewRow,
            bg=bgFrame,
#                            relief=RIDGE,
#                            borderwidth=2,
#                            width=600,
            )
        frame_00.grid(
            row=0,
            column=0,
            columnspan=99,
            padx=3,
            pady=2,
  #          sticky=E+W,
            )
# ... row selection
        frame_10 = Frame(
            self.toplevelFormNewRow,
            bg=bgFrame,
            )
        frame_10.grid(
            row=1,
            column=0,
            padx=10,
            pady=2,
            )
# ... operators
        frame_11 = Frame(
            self.toplevelFormNewRow,
            bg=bgFrame,
            )
        frame_11.grid(
            row=1,
            column=1,
            padx=10,
            pady=2,
            )
# ... keypad
        frame_12 = Frame(
            self.toplevelFormNewRow,
            bg=bgFrame,
            )
        frame_12.grid(
            row=1,
            column=2,
            padx=10,
            pady=2,
            )
# ... command line
        frame_20 = Frame(
            self.toplevelFormNewRow,
            bg=bgFrame,
            )
        frame_20.grid(
            row=2,
            column=0,
            columnspan=99,
            padx=3,
            pady=5,
            )
# ... insert into user comment field
        frame_21 = Frame(
            self.toplevelFormNewRow,
            bg=bgFrame,
            )
        frame_21.grid(
            row=3,
            column=0,
            columnspan=99,
            padx=3,
            pady=0,
            )
# ... execute and clear 
        frame_30 = Frame(
            self.toplevelFormNewRow,
            bg=bgFrame,
            )
        frame_30.grid(
            row=4,
            column=0,
            columnspan=99,
            padx=3,
            pady=0,
            )
# ... user fields
        frame_35 = Frame(
            self.toplevelFormNewRow,
            bg=bgFrame,
            )
        frame_35.grid(
            row=5,
            column=0,
            columnspan=99,
            padx=3,
            pady=0,
            )
# ... confirmation
        frame_37 = Frame(
            self.toplevelFormNewRow,
            bg=bgFrame,
            )
        frame_37.grid(
            row=6,
            column=0,
            columnspan=99,
            padx=3,
            pady=0,
            )
# ... cancel
        frame_40 = Frame(
            self.toplevelFormNewRow,
            bg=bgFrame,
            )
        frame_40.grid(
            row=7,
            column=0,
            columnspan=99,
            padx=3,
            pady=10,
            )
            
# Sub-Frames
# ... row selection sub-frames
# ...   subtitle
        frame_10_00 = Frame(
            frame_10,
            bg=bgFrame,
            )
        frame_10_00.grid(
            row=0,
            column=0,
            padx=0,
            pady=2,
            )
# ...   row selection
        frame_10_10 = Frame(
            frame_10,
            bg=bgFrame,
            )
        frame_10_10.grid(
            row=1,
            column=0,
            padx=0,
            pady=2,
            )
# ... operator subframes
# ...   subtitle
        frame_11_00 = Frame(
            frame_11,
            bg=bgFrame,
            )
        frame_11_00.grid(
            row=0,
            column=0,
            padx=0,
            pady=2,
            )            
# ...   functions
        frame_11_10 = Frame(
            frame_11,
            bg=bgFrame,
            )
        frame_11_10.grid(
            row=1,
            column=0,
            padx=0,
            pady=2,
            )
# ... keypad subframes
# ...   subtitle
        frame_12_00 = Frame(
            frame_12,
            bg=bgFrame,
            )
        frame_12_00.grid(
            row=0,
            column=0,
            padx=0,
            pady=2,
            )
# ...   numbered keys
        frame_12_10 = Frame(
            frame_12,
            bg=bgFrame,
            )
        frame_12_10.grid(
            row=1,
            column=0,
            padx=0,
            pady=2,
            )
            
# subframes for user fields
# ...   sub-title
        frame_35_00 = Frame(
            frame_35,
            bg=bgFrame,
            )
        frame_35_00.grid(
            row=0,
            column=0,
            columnspan=99,
            padx=0,
            pady=2,
            )
# ...   x header, y header
        frame_35_10 = Frame(
            frame_35,
            bg=bgFrame,
            )
        frame_35_10.grid(
            row=1,
            column=0,
            padx=0,
            pady=2,
            )
# ...   database, table
        frame_35_20 = Frame(
            frame_35,
            bg=bgFrame,
            )
        frame_35_20.grid(
            row=2,
            column=0,
            padx=0,
            pady=2,
            )
# ...   user fields
        frame_35_30 = Frame(
            frame_35,
            bg=bgFrame,
            )
        frame_35_30.grid(
            row=3,
            column=0,
            padx=0,
            pady=2,
            )
            
            
# WIDGETS
        
# Title        
        labelTitle = Label(
            frame_00,
            text=(
                'STORAGE-BUFFER ROW GENERATOR'
                ),
            bg=bgFrame,
            font=self.labelFontMedium,
            justify=CENTER,
            )
        labelTitle.grid(
            row=0,
            column=0,
            padx=5,
            pady=5,
            )
            
# Subtitle - Row Selection
        labelRowSelection = Label(
            frame_10_00,
            text=(
                'Row Selection'
                ),
            bg=bgFrame,
            font=self.labelFontMedium,
            justify=CENTER,
            )
        labelRowSelection.grid(
            row=0,
            column=0,
            padx=0,
            pady=2,
            sticky=N,
            )
# ...   row number
        labelRowNumber = Label(
            frame_10_10,
            text=(
                'Row #\n(select)'
                ),
            bg=bgFrame,
            justify=CENTER,
            )
        labelRowNumber.grid(
            row=0,
            column=2,
            padx=5,
            pady=2,
            )
# ...   x header
        labelXHeader = Label(
            frame_10_10,
            text=(
                '\nX-Header'
                ),
            bg=bgFrame,
            justify=CENTER,
            )
        labelXHeader.grid(
            row=0,
            column=0,
            padx=5,
            pady=2,
            )
# ...   y header
        labelYHeader = Label(
            frame_10_10,
            text=(
                '\nY-Header'
                ),
            bg=bgFrame,
            justify=CENTER,
            )
        labelYHeader.grid(
            row=0,
            column=1,
            padx=5,
            pady=2,
            )
            
# ...   row select - first
        self.varButtonRowSelect_First = StringVar()
        buttonRowSelect_First = Button(
            frame_10_10,
            textvariable=self.varButtonRowSelect_First,
            width=5,
            justify=CENTER,
            font=self.tableFontLarge,
            bg=bgButton_Function,
            fg=fgButton_Function,
            command=self.handlerFunction_FirstRowSelect,
            )
        buttonRowSelect_First.grid(
            row=1,
            column=2,
            padx=5,
            pady=2,
            )
        self.varEntryRowSelect_First_XHeader = StringVar()
        self.varEntryRowSelect_First_XHeader.set('')
        self.entryRowSelect_First_XHeader = Entry(
            frame_10_10,
            textvariable=self.varEntryRowSelect_First_XHeader,
            width=20,
            bg='white',
            fg='black',
            disabledbackground='white',
            disabledforeground='black',
            state=DISABLED,
            )
        self.entryRowSelect_First_XHeader.grid(
            row=1,
            column=0,
            padx=5,
            pady=2,
            )
        self.varEntryRowSelect_First_YHeader = StringVar()
        self.varEntryRowSelect_First_YHeader.set('')
        self.entryRowSelect_First_YHeader = Entry(
            frame_10_10,
            textvariable=self.varEntryRowSelect_First_YHeader,
            width=20,
            bg='white',
            fg='black',
            disabledbackground='white',
            disabledforeground='black',
            state=DISABLED,
            )
        self.entryRowSelect_First_YHeader.grid(
            row=1,
            column=1,
            padx=5,
            pady=2,
            )
            
# ...   row select - second
        self.varButtonRowSelect_Second = StringVar()
        buttonRowSelect_Second = Button(
            frame_10_10,
            textvariable=self.varButtonRowSelect_Second,
            width=5,
            justify=CENTER,
            font=self.tableFontLarge,
            bg=bgButton_Function,
            fg=fgButton_Function,
            command=self.handlerFunction_SecondRowSelect,
            )
        buttonRowSelect_Second.grid(
            row=2,
            column=2,
            padx=5,
            pady=2,
            )
        self.varEntryRowSelect_Second_XHeader = StringVar()
        self.varEntryRowSelect_Second_XHeader.set('')
        self.entryRowSelect_Second_XHeader = Entry(
            frame_10_10,
            textvariable=self.varEntryRowSelect_Second_XHeader,
            width=20,
            bg='white',
            fg='black',
            disabledbackground='white',
            disabledforeground='black',
            state=DISABLED,
            )
        self.entryRowSelect_Second_XHeader.grid(
            row=2,
            column=0,
            padx=5,
            pady=2,
            )
        self.varEntryRowSelect_Second_YHeader = StringVar()
        self.varEntryRowSelect_Second_YHeader.set('')
        self.entryRowSelect_Second_YHeader = Entry(
            frame_10_10,
            textvariable=self.varEntryRowSelect_Second_YHeader,
            width=20,
            bg='white',
            fg='black',
            disabledbackground='white',
            disabledforeground='black',
            state=DISABLED,
            )
        self.entryRowSelect_Second_YHeader.grid(
            row=2,
            column=1,
            padx=5,
            pady=2,
            )

# ...   row select - third
        self.varButtonRowSelect_Third = StringVar()
        buttonRowSelect_Third = Button(
            frame_10_10,
            textvariable=self.varButtonRowSelect_Third,
            width=5,
            justify=CENTER,
            font=self.tableFontLarge,
            bg=bgButton_Function,
            fg=fgButton_Function,
            command=self.handlerFunction_ThirdRowSelect,
            )
        buttonRowSelect_Third.grid(
            row=3,
            column=2,
            padx=5,
            pady=2,
            )
        self.varEntryRowSelect_Third_XHeader = StringVar()
        self.varEntryRowSelect_Third_XHeader.set('')
        self.entryRowSelect_Third_XHeader = Entry(
            frame_10_10,
            textvariable=self.varEntryRowSelect_Third_XHeader,
            width=20,
            bg='white',
            fg='black',
            disabledbackground='white',
            disabledforeground='black',
            state=DISABLED,
            )
        self.entryRowSelect_Third_XHeader.grid(
            row=3,
            column=0,
            padx=5,
            pady=2,
            )
        self.varEntryRowSelect_Third_YHeader = StringVar()
        self.varEntryRowSelect_Third_YHeader.set('')
        self.entryRowSelect_Third_YHeader = Entry(
            frame_10_10,
            textvariable=self.varEntryRowSelect_Third_YHeader,
            width=20,
            bg='white',
            fg='black',
            disabledbackground='white',
            disabledforeground='black',
            state=DISABLED,
            )
        self.entryRowSelect_Third_YHeader.grid(
            row=3,
            column=1,
            padx=5,
            pady=2,
            )
            
# ...   row select - fourth
        self.varButtonRowSelect_Fourth = StringVar()
        buttonRowSelect_Fourth = Button(
            frame_10_10,
            textvariable=self.varButtonRowSelect_Fourth,
            width=5,
            justify=CENTER,
            font=self.tableFontLarge,
            bg=bgButton_Function,
            fg=fgButton_Function,
            command=self.handlerFunction_FourthRowSelect,
            )
        buttonRowSelect_Fourth.grid(
            row=4,
            column=2,
            padx=5,
            pady=2,
            )
        self.varEntryRowSelect_Fourth_XHeader = StringVar()
        self.varEntryRowSelect_Fourth_XHeader.set('')
        self.entryRowSelect_Fourth_XHeader = Entry(
            frame_10_10,
            textvariable=self.varEntryRowSelect_Fourth_XHeader,
            width=20,
            bg='white',
            fg='black',
            disabledbackground='white',
            disabledforeground='black',
            state=DISABLED,
            )
        self.entryRowSelect_Fourth_XHeader.grid(
            row=4,
            column=0,
            padx=5,
            pady=2,
            )
        self.varEntryRowSelect_Fourth_YHeader = StringVar()
        self.varEntryRowSelect_Fourth_YHeader.set('')
        self.entryRowSelect_Fourth_YHeader = Entry(
            frame_10_10,
            textvariable=self.varEntryRowSelect_Fourth_YHeader,
            width=20,
            bg='white',
            fg='black',
            disabledbackground='white',
            disabledforeground='black',
            state=DISABLED,
            )
        self.entryRowSelect_Fourth_YHeader.grid(
            row=4,
            column=1,
            padx=5,
            pady=2,
            )

# Subtitle - Functions
        labelFunctions = Label(
            frame_11_00,
            text=(
                '\nFunctions'
                ),
            bg=bgFrame,
            font=self.labelFontMedium,
            justify=CENTER,
            )
        labelFunctions.grid(
            row=0,
            column=0,
            padx=0,
            pady=2,
            )
            
        widthFunctionButton = 8
# ...   plus
        buttonPlus = Button(
            frame_11_10,
            text='+',
            width=widthFunctionButton,
            font=self.tableFontLarge,
            bg=bgButton_Function,
            fg=fgButton_Function,
            command=self.handlerFunction_Plus,
            )
        buttonPlus.grid(
            row=0,
            column=0,
            padx=2,
            pady=2,
            )
# ...   minus
        buttonMinus = Button(
            frame_11_10,
            text='-',
            width=widthFunctionButton,
            font=self.tableFontLarge,
            bg=bgButton_Function,
            fg=fgButton_Function,
            command=self.handlerFunction_Minus,
            )
        buttonMinus.grid(
            row=0,
            column=1,
            padx=2,
            pady=2,
            )
# ...   times
        buttonTimes = Button(
            frame_11_10,
            text='*',
            width=widthFunctionButton,
            font=self.tableFontLarge,
            bg=bgButton_Function,
            fg=fgButton_Function,
            command=self.handlerFunction_Multiplication,
            )
        buttonTimes.grid(
            row=1,
            column=0,
            padx=2,
            pady=2,
            )
# ...   divide
        buttonDivide = Button(
            frame_11_10,
            text='/',
            width=widthFunctionButton,
            font=self.tableFontLarge,
            bg=bgButton_Function,
            fg=fgButton_Function,
            command=self.handlerFunction_Division,
            )
        buttonDivide.grid(
            row=1,
            column=1,
            padx=2,
            pady=2,
            )
# ...   power
        buttonPower = Button(
            frame_11_10,
            text='**',
            width=widthFunctionButton,
            font=self.tableFontLarge,
            bg=bgButton_Function,
            fg=fgButton_Function,
            command=self.handlerFunction_Power,
            )
        buttonPower.grid(
            row=2,
            column=0,
            columnspan=2,
            padx=2,
            pady=2,
            )
# ...   left parenthesis
        buttonLeftParen = Button(
            frame_11_10,
            text='(',
            width=widthFunctionButton,
            font=self.tableFontLarge,
            bg=bgButton_Function,
            fg=fgButton_Function,
            command=self.handlerFunction_LeftParenthesis,
            )
        buttonLeftParen.grid(
            row=3,
            column=0,
            padx=2,
            pady=2,
            )
# ...   right parenthesis
        buttonRightParen = Button(
            frame_11_10,
            text=')',
            width=widthFunctionButton,
            font=self.tableFontLarge,
            bg=bgButton_Function,
            fg=fgButton_Function,
            command=self.handlerFunction_RightParenthesis,
            )
        buttonRightParen.grid(
            row=3,
            column=1,
            padx=2,
            pady=2,
            )            
            
        widthButtonKeypad = 6
# Subtitle - Keypad
        labelKeypad = Label(
            frame_12_00,
            text=(
                '\nKeypad'
                ),
            bg=bgFrame,
            font=self.labelFontMedium,
            justify=CENTER,
            )
        labelKeypad.grid(
            row=0,
            column=0,
            padx=0,
            pady=2,
            )
# ...   keys 7,8,9
        buttonKeypad_Seven = Button(
            frame_12_10,
            text='7',
            width=widthButtonKeypad,
            font=self.tableFontLarge,
            bg=bgButton_Function,
            fg=fgButton_Function,
            command=self.handlerFunction_Seven,
            )
        buttonKeypad_Seven.grid(
            row=0,
            column=0,
            padx=2,
            pady=2,
            )
        buttonKeypad_Eight = Button(
            frame_12_10,
            text='8',
            width=widthButtonKeypad,
            font=self.tableFontLarge,
            bg=bgButton_Function,
            fg=fgButton_Function,
            command=self.handlerFunction_Eight,
            )
        buttonKeypad_Eight.grid(
            row=0,
            column=1,
            padx=2,
            pady=2,
            )
        buttonKeypad_Nine = Button(
            frame_12_10,
            text='9',
            width=widthButtonKeypad,
            font=self.tableFontLarge,
            bg=bgButton_Function,
            fg=fgButton_Function,
            command=self.handlerFunction_Nine,
            )
        buttonKeypad_Nine.grid(
            row=0,
            column=2,
            padx=2,
            pady=2,
            )
# ...   keys 4,5,6
        buttonKeypad_Four = Button(
            frame_12_10,
            text='4',
            width=widthButtonKeypad,
            font=self.tableFontLarge,
            bg=bgButton_Function,
            fg=fgButton_Function,
            command=self.handlerFunction_Four,
            )
        buttonKeypad_Four.grid(
            row=1,
            column=0,
            padx=2,
            pady=2,
            )
        buttonKeypad_Five = Button(
            frame_12_10,
            text='5',
            width=widthButtonKeypad,
            font=self.tableFontLarge,
            bg=bgButton_Function,
            fg=fgButton_Function,
            command=self.handlerFunction_Five,
            )
        buttonKeypad_Five.grid(
            row=1,
            column=1,
            padx=2,
            pady=2,
            )
        buttonKeypad_Six = Button(
            frame_12_10,
            text='6',
            width=widthButtonKeypad,
            font=self.tableFontLarge,
            bg=bgButton_Function,
            fg=fgButton_Function,
            command=self.handlerFunction_Six,
            )
        buttonKeypad_Six.grid(
            row=1,
            column=2,
            padx=2,
            pady=2,
            )
# ...   keys 123
        buttonKeypad_One = Button(
            frame_12_10,
            text='1',
            width=widthButtonKeypad,
            font=self.tableFontLarge,
            bg=bgButton_Function,
            fg=fgButton_Function,
            command=self.handlerFunction_One,
            )
        buttonKeypad_One.grid(
            row=2,
            column=0,
            padx=2,
            pady=2,
            )
        buttonKeypad_Two = Button(
            frame_12_10,
            text='2',
            width=widthButtonKeypad,
            font=self.tableFontLarge,
            bg=bgButton_Function,
            fg=fgButton_Function,
            command=self.handlerFunction_Two,
            )
        buttonKeypad_Two.grid(
            row=2,
            column=1,
            padx=2,
            pady=2,
            )
        buttonKeypad_Three = Button(
            frame_12_10,
            text='3',
            width=widthButtonKeypad,
            font=self.tableFontLarge,
            bg=bgButton_Function,
            fg=fgButton_Function,
            command=self.handlerFunction_Three,
            )
        buttonKeypad_Three.grid(
            row=2,
            column=2,
            padx=2,
            pady=2,
            )
# ...   keys 0, decimal point
        buttonKeypad_Zero = Button(
            frame_12_10,
            text='0',
            width=((widthButtonKeypad * 2) + 1),
            font=self.tableFontLarge,
            bg=bgButton_Function,
            fg=fgButton_Function,
            command=self.handlerFunction_Zero,
            )
        buttonKeypad_Zero.grid(
            row=3,
            column=0,
            columnspan=2,
            padx=2,
            pady=2,
            )
        buttonKeypad_DecimalPoint = Button(
            frame_12_10,
            text='.',
            width=widthButtonKeypad,
            font=self.tableFontLarge,
            bg=bgButton_Function,
            fg=fgButton_Function,
            command=self.handlerFunction_Decimal,
            )
        buttonKeypad_DecimalPoint.grid(
            row=3,
            column=2,
            padx=2,
            pady=2,
            )
            
# define row selects
# first row
        try:
            if rowsChecked[0]:
                rowNum = rowsChecked[0]
                xHeader = self.bufferRowStore[rowNum-1][5]
                yHeader = self.bufferRowStore[rowNum-1][6]
                self.varButtonRowSelect_First.set(str(rowNum))
                self.varEntryRowSelect_First_XHeader.set(xHeader)
                self.varEntryRowSelect_First_YHeader.set(yHeader)
        except:
            stringFirstRow = (
                'For first row, cannot determine which\n' +
                'row is checked, the x header, and/or\n' +
                'the y header.\n\n' +
                'This is caused by an unknown error and must\n' +
                'be checked by the code administrator or author.\n\n' +
                'This process will be stopped and control returned\n' +
                'to the previous window.'
                )
            print stringFirstRow
            try:
                showerror(
                    'Error: unknown error',
                    stringFirstRow,
                    parent=self.toplevelShowStorageBuffer
                    )
            except:
                showerror(
                    'Error: unknown error',
                    stringFirstRow
                    )
            self.toplevelFormNewRow.destroy()
            return
# second row                
        try:
            if rowsChecked[1]:
                rowNum = rowsChecked[1]
                xHeader = self.bufferRowStore[rowNum-1][5]
                yHeader = self.bufferRowStore[rowNum-1][6]
                self.varButtonRowSelect_Second.set(str(rowNum))
                self.varEntryRowSelect_Second_XHeader.set(xHeader)
                self.varEntryRowSelect_Second_YHeader.set(yHeader)
        except IndexError:
            pass
        except:
            stringSecondRow = (
                'For second row, cannot determine which\n' +
                'row is checked, the x header, and/or\n' +
                'the y header.\n\n' +
                'This is caused by an unknown error and must\n' +
                'be checked by the code administrator or author.\n\n' +
                'This process will be stopped and control returned\n' +
                'to the previous window.'
                )
            print stringSecondRow
            try:
                showerror(
                    'Error: unknown error',
                    stringSecondRow,
                    parent=self.toplevelShowStorageBuffer
                    )
            except:
                showerror(
                    'Error: unknown error',
                    stringSecondRow
                    )
            self.toplevelFormNewRow.destroy()
            return
# third row
        try:
            if rowsChecked[2]:
                rowNum = rowsChecked[2]
                xHeader = self.bufferRowStore[rowNum-1][5]
                yHeader = self.bufferRowStore[rowNum-1][6]
                self.varButtonRowSelect_Third.set(str(rowNum))
                self.varEntryRowSelect_Third_XHeader.set(xHeader)
                self.varEntryRowSelect_Third_YHeader.set(yHeader)
        except IndexError:
            pass
        except:
            stringThirdRow = (
                'For third row, cannot determine which\n' +
                'row is checked, the x header, and/or\n' +
                'the y header.\n\n' +
                'This is caused by an unknown error and must\n' +
                'be checked by the code administrator or author.\n\n' +
                'This process will be stopped and control returned\n' +
                'to the previous window.'
                )
            print stringThirdRow
            try:
                showerror(
                    'Error: unknown error',
                    stringThirdRow,
                    parent=self.toplevelShowStorageBuffer
                    )
            except:
                showerror(
                    'Error: unknown error',
                    stringThirdRow
                    )
            self.toplevelFormNewRow.destroy()
            return
# fourth row            
        try:
            if rowsChecked[3]:
                rowNum = rowsChecked[3]
                xHeader = self.bufferRowStore[rowNum-1][5]
                yHeader = self.bufferRowStore[rowNum-1][6]
                self.varButtonRowSelect_Fourth.set(str(rowNum))
                self.varEntryRowSelect_Fourth_XHeader.set(xHeader)
                self.varEntryRowSelect_Fourth_YHeader.set(yHeader)
        except IndexError:
                pass
        except:
            stringFourthRow = (
                'For fourth row, cannot determine which\n' +
                'row is checked, the x header, and/or\n' +
                'the y header.\n\n' +
                'This is caused by an unknown error and must\n' +
                'be checked by the code administrator or author.\n\n' +
                'This process will be stopped and control returned\n' +
                'to the previous window.'
                )
            print stringFourthRow
            try:
                showerror(
                    'Error: unknown error',
                    stringFourthRow,
                    parent=self.toplevelShowStorageBuffer
                    )
            except:
                showerror(
                    'Error: unknown error',
                    stringFourthRow
                    )
            self.toplevelFormNewRow.destroy()
            return
                
# Command line
        labelCommandLine = Label(
            frame_20,
            text=(
#                'Command: '
                'New row = '
                ),
            font=self.labelFontMedium,
            bg=bgFrame,
            )
        labelCommandLine.grid(
            row=0,
            column=0,
            padx=0,
            pady=2,
            sticky=E,
            )
        self.varEntryCommandLine = StringVar()
        self.entryCommandLine = Entry(
            frame_20,
            textvariable=self.varEntryCommandLine,
            width=60,
            bg='white',
            fg='black',
            disabledbackground='white',
            disabledforeground='black',
            )
        self.entryCommandLine.grid(
            row=0,
            column=1,
            padx=0,
            pady=2,
            sticky=W,
            )
        self.entryCommandLine.configure(state='disable')
        buttonCommandLine_Backspace = Button(
            frame_20,
            text='<-',
            bg=bgButton,
            fg=fgButton,
            borderwidth=3,
            relief=RAISED,
            width=8,
            command=self.handlerCommandLine_Backspace,
            )
        buttonCommandLine_Backspace.grid(
            row=0,
            column=2,
            padx=3,
            pady=2,
            sticky=W,
            )
        labelInsertIntoUserComment = Label(
            frame_21,
            text=(
#                'Insert into "user comment" field, using y-header labels: '
                'Insert into "Y-Header" field below, using Y-Header labels above: '
                ),
            bg=bgFrame,
            )
        labelInsertIntoUserComment.grid(
            row=0,
            column=0,
            padx=3,
            pady=0,
            sticky=N,
            )
        buttonInsertIntoUserComment = Button(
            frame_21,
            text='Insert',
            width=10,
            justify=CENTER,
            bg=bgButton_Function,
            fg=fgButton_Function,
            command=self.handlerInsertIntoUserComment,
            )
        buttonInsertIntoUserComment.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            sticky=N,
            )       

# Clear
        buttonClearCommandLine = Button(
            frame_30,
            text='Clear',
            bg=bgButton,
            fg=fgButton,
            borderwidth=3,
            relief=RAISED,
            width=10,
            command=self.handlerFormNewRow_Clear,
            )
        buttonClearCommandLine.grid(
            row=0,
            column=0,
            padx=5,
            pady=2,
            ) 

# subtitle for new fields
        labelTitleNew = Label(
            frame_35_00,
            text=(
                '\n--------------------------------------------\n' +
                'FIELDS FOR NEW ROW\n(User changeable, except for Database and Table entries)'
                ),
            bg=bgFrame,
            justify=CENTER
            )
        labelTitleNew.grid(
            row=0,
            column=0,
            padx=0,
            pady=2,
            sticky=N,
            )
# x header
        labelXHeaderNew = Label(
            frame_35_10,
            text=(
                'X-Header: '
                ),
            font=self.labelFontMedium,
            bg=bgFrame,
            )
        labelXHeaderNew.grid(
            row=0,
            column=0,
            padx=0,
            pady=2,
            sticky=E,
            )

        self.comboboxXHeaderNew = Pmw.ComboBox(
            frame_35_10,
            scrolledlist_items=self.headersXNew,
            dropdown=1,
            listheight=100,
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
#            selectioncommand=self.handler_ComboDatabaseTables,
            scrolledlist_hscrollmode='static',
            scrolledlist_vscrollmode='static',
            scrolledlist_hull_width=500,
            )
        self.comboboxXHeaderNew.grid(
            row=0,
            column=1,
            padx=0,
            pady=2,
            sticky=W,
            )
# ... affix scrollbars
#        self.comboboxXHeaderNew.configure(scrolledlist_hscrollmode = 'static')
#        self.comboboxXHeaderNew.configure(scrolledlist_vscrollmode = 'static')
# ... set value
        self.comboboxXHeaderNew.setentry(self.headersXNew[0])

# y header
        labelYHeaderNew = Label(
            frame_35_10,
            text=(
                '     Y-Header: '
                ),
            bg=bgFrame,
            font=self.labelFontMedium,
            )
        labelYHeaderNew.grid(
            row=0,
            column=2,
            padx=0,
            pady=2,
            sticky=E,
            )

        self.comboboxYHeaderNew = Pmw.ComboBox(
            frame_35_10,
            scrolledlist_items=self.headersYNew,
            dropdown=1,
            listheight=100,
            entry_width=40,
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
#            selectioncommand=self.handler_ComboDatabaseTables,
            scrolledlist_hscrollmode='static',
            scrolledlist_vscrollmode='static',
            scrolledlist_hull_width=500,
            )
        self.comboboxYHeaderNew.grid(
            row=0,
            column=3,
            padx=0,
            pady=2,
            sticky=W,
            )
# ... affix scrollbars
#        self.comboboxYHeaderNew.configure(scrolledlist_hscrollmode = 'static')
#        self.comboboxYHeaderNew.configure(scrolledlist_vscrollmode = 'static')
# ... set value
        self.comboboxYHeaderNew.setentry(self.headersYNew[0])
        
# database and table
# ... database
        labelDatabaseNew = Label(
            frame_35_20,
            text=(
                'Database(s): '
                ),
            bg=bgFrame,
            font=self.labelFontMedium,
            )
        labelDatabaseNew.grid(
            row=0,
            column=0,
            padx=0,
            pady=2,
            sticky=E,
            )
        self.varEntryDatabaseNew = StringVar()
        self.entryDatabaseNew = Entry(
            frame_35_20,
            textvariable=self.varEntryDatabaseNew,
            width=40,
            bg='white',
            fg='black',
            disabledbackground='white',
            disabledforeground='black',
            state=DISABLED
            )
        self.entryDatabaseNew.grid(
            row=0,
            column=1,
            padx=0,
            pady=2,
            sticky=W,
            )
# list all databases
        stringDatabasesNew = ''
        icount = 1
        ilength = len(self.databasesNew)
        for database in self.databasesNew:
            if icount <> ilength:
                stringDatabasesNew += database + ', '
                icount += 1
            else:
                stringDatabasesNew += database
# set entry
        self.varEntryDatabaseNew.set(stringDatabasesNew)
            
            
# ... tables
        labelTableNew = Label(
            frame_35_20,
            text=(
                '     Table(s): '
                ),
            bg=bgFrame,
            font=self.labelFontMedium,
            )
        labelTableNew.grid(
            row=0,
            column=2,
            padx=0,
            pady=2,
            sticky=E,
            )
        self.varEntryTableNew = StringVar()
        self.entryTableNew = Entry(
            frame_35_20,
            textvariable=self.varEntryTableNew,
            width=40,
            bg='white',
            fg='black',
            disabledbackground='white',
            disabledforeground='black',
            state=DISABLED
            )
        self.entryTableNew.grid(
            row=0,
            column=3,
            padx=0,
            pady=2,
            sticky=W,
            )
# list all tables
        stringTablesNew = ''
        icount = 1
        ilength = len(self.tablesNew)
        for table in self.tablesNew:
            if icount <> ilength:
                stringTablesNew += table + ', '
                icount += 1
            else:
                stringTablesNew += table
# set entry
        self.varEntryTableNew.set(stringTablesNew)
            
# user comment
        labelUserComment_New = Label(
            frame_35_30,
            text=(
                'user comment: '
                ),
            bg=bgFrame,
            font=self.labelFontMedium,
            )
        labelUserComment_New.grid(
            row=0,
            column=0,
            padx=0,
            pady=2,
            )
            
        self.comboboxUserComment_New = Pmw.ComboBox(
            frame_35_30,
            scrolledlist_items=self.userCommentNew,
            dropdown=1,
            listheight=100,
            entry_width=60,
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
#            selectioncommand=self.handler_ComboDatabaseTables,
            scrolledlist_hscrollmode='static',
            scrolledlist_vscrollmode='static',
            scrolledlist_hull_width=500,
            )
        self.comboboxUserComment_New.grid(
            row=0,
            column=1,
            padx=0,
            pady=2,
            sticky=W,
            )
        if self.userCommentNew <> []:
            self.comboboxUserComment_New.setentry(self.userCommentNew[0])
            
        '''
# use entry field instead of combobox above
        self.varEntryUserCommentNew = StringVar()
        self.entryUserCommentNew = Entry(
            frame_35_30,
            textvariable=self.varEntryUserCommentNew,
            width=60,
            bg='white',
            fg='black',
            disabledbackground='white',
            disabledforeground='black',
 #           state=DISABLED
            )
        self.entryUserCommentNew.grid(
            row=0,
            column=1,
            padx=0,
            pady=2,
            sticky=W,
            )
        '''    
            
        '''
        self.varEntryUserCommentNew.set(
            self.varEntryCommandLine.get()
            )
        '''
        '''
        self.varEntryUserCommentNew.set(
            'Generated row'
            )
        '''
        
        if self.userCommentNew[0] <> '':
            self.comboboxUserComment_New.setvalue(
                self.userCommentNew[0]
                )
        else:
            self.comboboxUserComment_New.setvalue('')
            
# clear user comment line
        buttonClearUserComment_Buffer = Button(
            frame_35_30,
            text='Clear',
            bg='white',
            fg='blue',
            borderwidth=3,
            relief=RAISED,
            width=10,
            command=self.handlerClearUserComment_Buffer,
            )
        buttonClearUserComment_Buffer.grid(
            row=0,
            column=2,
            padx=3,
            pady=2,
            sticky=W,
            )

# user fields 1 thru 4
# ... user field 1
        labelUserField_1_New = Label(
            frame_35_30,
            text=(
                'user_field 1: '
                ),
            bg=bgFrame,
            font=self.labelFontMedium,
            )
        labelUserField_1_New.grid(
            row=1,
            column=0,
            padx=0,
            pady=2,
            sticky=E,
            )

        self.comboboxUserField_1_New = Pmw.ComboBox(
            frame_35_30,
            scrolledlist_items=self.userFieldNew_1,
            dropdown=1,
            listheight=100,
            entry_width=40,
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
#            selectioncommand=self.handler_ComboDatabaseTables,
            scrolledlist_hscrollmode='static',
            scrolledlist_vscrollmode='static',
            scrolledlist_hull_width=500,
            )
        self.comboboxUserField_1_New.grid(
            row=1,
            column=1,
            padx=0,
            pady=2,
            sticky=W,
            )
# ... affix scrollbars
#        self.comboboxUserField_1_New.configure(scrolledlist_hscrollmode = 'static')
#        self.comboboxUserField_1_New.configure(scrolledlist_vscrollmode = 'static')
# ... set value
        if self.userFieldNew_1 <> []:
            self.comboboxUserField_1_New.setentry(self.userFieldNew_1[0])
            
# ... user field 2
        labelUserField_2_New = Label(
            frame_35_30,
            text=(
                'user_field 2: '
                ),
            bg=bgFrame,
            font=self.labelFontMedium,
            )
        labelUserField_2_New.grid(
            row=2,
            column=0,
            padx=0,
            pady=2,
            sticky=E,
            )       
        self.comboboxUserField_2_New = Pmw.ComboBox(
            frame_35_30,
            scrolledlist_items=self.userFieldNew_2,
            dropdown=1,
            listheight=100,
            entry_width=40,
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
#            selectioncommand=self.handler_ComboDatabaseTables,
            scrolledlist_hscrollmode='static',
            scrolledlist_vscrollmode='static',
            scrolledlist_hull_width=500,
            )
        self.comboboxUserField_2_New.grid(
            row=2,
            column=1,
            padx=0,
            pady=2,
            sticky=W,
            )
# ... affix scrollbars
#        self.comboboxUserField_2_New.configure(scrolledlist_hscrollmode = 'static')
#        self.comboboxUserField_2_New.configure(scrolledlist_vscrollmode = 'static')
# ... set value
        if self.userFieldNew_2 <> []:
            self.comboboxUserField_2_New.setentry(self.userFieldNew_2[0])
            
# ... user field 3
        labelUserField_3_New = Label(
            frame_35_30,
            text=(
                'user_field 3: '
                ),
            bg=bgFrame,
            font=self.labelFontMedium,
            )
        labelUserField_3_New.grid(
            row=3,
            column=0,
            padx=0,
            pady=2,
            sticky=E,
            )
        self.comboboxUserField_3_New = Pmw.ComboBox(
            frame_35_30,
            scrolledlist_items=self.userFieldNew_3,
            dropdown=1,
            listheight=100,
            entry_width=40,
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
#            selectioncommand=self.handler_ComboDatabaseTables,
            scrolledlist_hscrollmode='static',
            scrolledlist_vscrollmode='static',
            scrolledlist_hull_width=500,
            )
        self.comboboxUserField_3_New.grid(
            row=3,
            column=1,
            padx=0,
            pady=2,
            sticky=W,
            )
# ... affix scrollbars
#        self.comboboxUserField_3_New.configure(scrolledlist_hscrollmode = 'static')
#        self.comboboxUserField_3_New.configure(scrolledlist_vscrollmode = 'static')
# ... set value
        if self.userFieldNew_3 <> []:
            self.comboboxUserField_3_New.setentry(self.userFieldNew_3[0])            
            
# ... user field 4
        labelUserField_4_New = Label(
            frame_35_30,
            text=(
                'user_field 4: '
                ),
            bg=bgFrame,
            font=self.labelFontMedium,
            )
        labelUserField_4_New.grid(
            row=4,
            column=0,
            padx=0,
            pady=2,
            sticky=E,
            )
        self.comboboxUserField_4_New = Pmw.ComboBox(
            frame_35_30,
            scrolledlist_items=self.userFieldNew_4,
            dropdown=1,
            listheight=100,
            entry_width=40,
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
#            selectioncommand=self.handler_ComboDatabaseTables,
            scrolledlist_hscrollmode='static',
            scrolledlist_vscrollmode='static',
            scrolledlist_hull_width=500,
            )
        self.comboboxUserField_4_New.grid(
            row=4,
            column=1,
            padx=0,
            pady=2,
            sticky=W,
            )
# ... affix scrollbars
#        self.comboboxUserField_4_New.configure(scrolledlist_hscrollmode = 'static')
#        self.comboboxUserField_4_New.configure(scrolledlist_vscrollmode = 'static')
# ... set value
        if self.userFieldNew_4 <> []:
            self.comboboxUserField_4_New.setentry(self.userFieldNew_4[0])   

# display confirmation of row added to buffer
        self.varConfirmRowAddedToBuffer = IntVar()
        self.varConfirmRowAddedToBuffer.set(1)
        self.checkbuttonConfirmRowAddedToBuffer = Checkbutton(
            frame_37,
            variable=self.varConfirmRowAddedToBuffer,
            background=bgFrame,
            )
        self.checkbuttonConfirmRowAddedToBuffer.grid(
            row=0,
            column=0,
            padx=0,
            pady=5,
            )
        labelConfirmRowAddedToBuffer = Label(
            frame_37,
            text=(
                'show pop-up window to confirm\nrow has been added to buffer'
                ),
                justify=LEFT,
                bg=bgFrame,
                font=self.labelFontMedium,
                )
        labelConfirmRowAddedToBuffer.grid(
                row=0,
                column=1,
                padx=0,
                pady=5,
                sticky=W,
                )

# Execute and Cancel
        buttonExecuteCommandLine = Button(
            frame_40,
            text='Execute',
            bg=bgButton,
            fg=fgButton,
            borderwidth=3,
            relief=RAISED,
            width=15,
            command=self.handlerFormNewRow_Execute,
            )
        buttonExecuteCommandLine.grid(
            row=0,
            column=0,
            padx=7,
            pady=2,
            sticky=E,
            )
        buttonCancelCommandLine = Button(
            frame_40,
            text='Cancel',
            borderwidth=3,
            relief=RAISED,
            width=15,
            command=self.handlerFormNewRow_Cancel
            )
        buttonCancelCommandLine.grid(
            row=0,
            column=1,
            padx=7,
            pady=2,
            )   
            
        return
        
        
    def handlerInsertIntoUserComment(self):
        '''
        Purpose:
            insert "New row" field entry into the
            "user comment" field, but substituting
            y-header fields for row number in entry
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerInsertIntoUserComment')
        
# get command line (string for new row)
        commandLine = self.varEntryCommandLine.get()
        commandLineNew = commandLine
# determine which rows are checked
        rowsChecked = []
        icount = 0
        for var in self.varSelectAnyRow_Buffer:
            icount += 1
#            print '%s. var.get() = %s' % (icount,var.get())
            if var.get() == 1:
                rowsChecked.append(icount)

# get y headers, 1 thru 4
        yHeaders = []
        y1 = self.varEntryRowSelect_First_YHeader.get().strip() 
        y2 = self.varEntryRowSelect_Second_YHeader.get()
        y3 = self.varEntryRowSelect_Third_YHeader.get()
        y4 = self.varEntryRowSelect_Fourth_YHeader.get()
        if y1 <> '':
            yHeaders.append(y1)
        if y2 <> '':
            yHeaders.append(y2)
        if y3 <> '':
            yHeaders.append(y3)
        if y4 <> '':
            yHeaders.append(y4)
               
        vars = []
        vars = re.findall(r'\bRow\d+',commandLine)
        if DEBUG_BUFFER_COMMAND_LINE:
            print('list of vars in commandLine = %s' % vars)
# list of row numbers extracted from above 'variables to be replaced'
        rows = []
        rows = re.findall(r'\bRow(\d+)',commandLine)
# replace command line variables with actual data variables
        for i in range(len(vars)):
#            row = str(eval(rows[i]) - 1)
            stringReplace = eval(
                r'self.bufferRowStore[' + str(eval(rows[i])-1) + r'][6]'
                )
            try:
                commandLineNew = re.sub(vars[i],stringReplace,commandLineNew)
            except:
                stringErrorCommand = (
                    'An error was encountered while forming\n' +
                    'the new command line for\n\n' +
                    'i: %s\n' +
                    'var: %s\n' +
                    'row: %s\n\n'
                    'Execution of this process will now stop and control\n' +
                    'returned to the previous window.'
                    ) % (i, vars[i], rows[i])
                print stringErrorCommand
                try:
                    showerror(
                        'Error: cannot form command line',
                        stringErrorCommand,
                        parent=self.toplevelShowStorageBuffer
                        )
                except:
                    showerror(
                        'Error: cannot form command line',
                        stringErrorCommand
                        )
                return
                
        if DEBUG_BUFFER_COMMAND_LINE:
            print('commandLineNew = %s' % commandLineNew) 
            
# insert into user comment field
        '''
        self.varEntryUserCommentNew.set(
            commandLineNew
            )
        '''
# insert into y-header field
        self.comboboxYHeaderNew.setentry(
            commandLineNew
            )
            
        return
        
        
    def handlerClearUserComment_Buffer(self):
        '''
        Purpose:
            clear the "user comment" line the the window
            "Storage_Buffer Row Generator"
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerClearUserComment_Buffer')

# use with entry field            
#        self.varEntryUserCommentNew.set('')
# use with combobox
        self.comboboxUserComment_New.setentry('')
        
        return
        
        
    def handlerFunction_FirstRowSelect(self):
        '''
        Purpose:
            insert first row select into command line
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerFunction_FirstRowSelect')
        
# get row number from 'Row Selection'
        string1 = self.varButtonRowSelect_First.get()
# return if empty string
        if string1 == '':
            return
# get current command-line string
        stringCommandLine = self.varEntryCommandLine.get()
# append row number to current string
        stringCommandLine += 'Row' + string1 + ' '
# place new string back into command line
        self.varEntryCommandLine.set(stringCommandLine)
        
        return
        
    def handlerFunction_SecondRowSelect(self):
        '''
        Purpose:
            insert second row select into command line
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerFunction_SecondRowSelect')
        
# get row number from 'Row Selection'
        string2 = self.varButtonRowSelect_Second.get()
# return if empty string
        if string2 == '':
            return
# get current command-line string
        stringCommandLine = self.varEntryCommandLine.get()
# append row number to current string
        stringCommandLine += 'Row' + string2 + ' '
# place new string back into command line
        self.varEntryCommandLine.set(stringCommandLine)
        
        return
        
        
    def handlerFunction_ThirdRowSelect(self):
        '''
        Purpose:
            insert third row select into command line
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerFunction_ThirdRowSelect')
        
# get row number from 'Row Selection'
        string3 = self.varButtonRowSelect_Third.get()
# return if empty string
        if string3 == '':
            return
# get current command-line string
        stringCommandLine = self.varEntryCommandLine.get()
# append row number to current string
        stringCommandLine += 'Row' + string3 + ' '
# place new string back into command line
        self.varEntryCommandLine.set(stringCommandLine)
        
        return
        
       
    def handlerFunction_FourthRowSelect(self):
        '''
        Purpose:
            insert fourth row select into command line
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerFunction_FourthRowSelect')
        
# get row number from 'Row Selection'
        string4 = self.varButtonRowSelect_Fourth.get()
# return if empty string
        if string4 == '':
            return
# get current command-line string
        stringCommandLine = self.varEntryCommandLine.get()
# append row number to current string
        stringCommandLine += 'Row' + string4 + ' '
# place new string back into command line
        self.varEntryCommandLine.set(stringCommandLine)
        
        return
        
            
    def handlerFunction_Zero(self):
        '''
        Purpose:
            add zero to string
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerFunction_Zero')
        
# get current string
        stringCommandLine = self.varEntryCommandLine.get()
# add plus sign
        stringCommandLine += '0'
# set string
        self.varEntryCommandLine.set(stringCommandLine) 
        
        return
        
          
    def handlerFunction_One(self):
        '''
        Purpose:
            add zero to string
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerFunction_One')
        
 # get current string
        stringCommandLine = self.varEntryCommandLine.get()
# add plus sign
        stringCommandLine += '1'
# set string
        self.varEntryCommandLine.set(stringCommandLine) 
        
        return
        
        
    def handlerFunction_Two(self):
        '''
        Purpose:
            add zero to string
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerFunction_Two')
        
# get current string
        stringCommandLine = self.varEntryCommandLine.get()
# add plus sign
        stringCommandLine += '2'
# set string
        self.varEntryCommandLine.set(stringCommandLine) 
         
        return
        
        
    def handlerFunction_Three(self):
        '''
        Purpose:
            add zero to string
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerFunction_Three')
            
# get current string
        stringCommandLine = self.varEntryCommandLine.get()
# add plus sign
        stringCommandLine += '3'
# set string
        self.varEntryCommandLine.set(stringCommandLine) 
         
        return
        
        
    def handlerFunction_Four(self):
        '''
        Purpose:
            add zero to string
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerFunction_Four')
        
# get current string
        stringCommandLine = self.varEntryCommandLine.get()
# add plus sign
        stringCommandLine += '4'
# set string
        self.varEntryCommandLine.set(stringCommandLine) 
         
        return
        
        
    def handlerFunction_Five(self):
        '''
        Purpose:
            add zero to string
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerFunction_Five')
        
# get current string
        stringCommandLine = self.varEntryCommandLine.get()
# add plus sign
        stringCommandLine += '5'
# set string
        self.varEntryCommandLine.set(stringCommandLine) 
         
        return
        
        
    def handlerFunction_Six(self):
        '''
        Purpose:
            add zero to string
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerFunction_Six')
        
# get current string
        stringCommandLine = self.varEntryCommandLine.get()
# add plus sign
        stringCommandLine += '6'
# set string
        self.varEntryCommandLine.set(stringCommandLine) 
         
        return
        
        
    def handlerFunction_Seven(self):
        '''
        Purpose:
            add zero to string
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerFunction_Seven')
        
# get current string
        stringCommandLine = self.varEntryCommandLine.get()
# add plus sign
        stringCommandLine += '7'
# set string
        self.varEntryCommandLine.set(stringCommandLine) 
         
        return
        
        
    def handlerFunction_Eight(self):
        '''
        Purpose:
            add zero to string
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerFunction_Eight')
        
# get current string
        stringCommandLine = self.varEntryCommandLine.get()
# add plus sign
        stringCommandLine += '8'
# set string
        self.varEntryCommandLine.set(stringCommandLine) 
         
        return
        
        
    def handlerFunction_Nine(self):
        '''
        Purpose:
            add zero to string
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerFunction_Nine')
        
# get current string
        stringCommandLine = self.varEntryCommandLine.get()
# add plus sign
        stringCommandLine += '9'
# set string
        self.varEntryCommandLine.set(stringCommandLine) 
         
        return 
        
                
    def handlerFunction_Decimal(self):
        '''
        Purpose:
            add zero to string
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerFunction_Decimal')
        
# get current string
        stringCommandLine = self.varEntryCommandLine.get()
# add plus sign
        stringCommandLine += '.'
# set string
        self.varEntryCommandLine.set(stringCommandLine) 
         
        return  
        
                
    def handlerFunction_Plus(self):
        '''
        Purpose:
            plus sign
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerFunction_Plus')
        
# get current string
        stringCommandLine = self.varEntryCommandLine.get()
# add plus sign
        stringCommandLine += ' + '
# set string
        self.varEntryCommandLine.set(stringCommandLine)
        
        return
        
        
    def handlerFunction_Minus(self):
        '''
        Purpose:
            minus sign
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerFunction_Minus')
        
# get current string
        stringCommandLine = self.varEntryCommandLine.get()
# add plus sign
        stringCommandLine += ' - '
# set string
        self.varEntryCommandLine.set(stringCommandLine)
        
        return
        
        
    def handlerFunction_Multiplication(self):
        '''
        Purpose:
            multiplication sign
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerFunction_Multiplication')
        
# get current string
        stringCommandLine = self.varEntryCommandLine.get()
# add plus sign
        stringCommandLine += ' * '
# set string
        self.varEntryCommandLine.set(stringCommandLine)
        
        return
        
        
    def handlerFunction_Division(self):
        '''
        Purpose:
            division sign
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerFunction_Division')
            
# get current string
        stringCommandLine = self.varEntryCommandLine.get()
# add plus sign
        stringCommandLine += ' / '
# set string
        self.varEntryCommandLine.set(stringCommandLine)
        
        return
        
        
    def handlerFunction_Power(self):
        '''
        Purpose:
            power sign
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerFunction_Power')
        
# get current string
        stringCommandLine = self.varEntryCommandLine.get()
# add plus sign
        stringCommandLine += ' ** '
# set string
        self.varEntryCommandLine.set(stringCommandLine)
        
        return
        
   
    def handlerFunction_LeftParenthesis(self):
        '''
        Purpose:
            left parenthesis
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerFunction_LeftParenthesis')
        
# get current string
        stringCommandLine = self.varEntryCommandLine.get()
# add plus sign
        stringCommandLine += ' ( '
# set string
        self.varEntryCommandLine.set(stringCommandLine)
        
        return
        
        
    def handlerFunction_RightParenthesis(self):
        '''
        Purpose:
            right parenthesis
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerFunction_RightParenthesis')
        
# get current string
        stringCommandLine = self.varEntryCommandLine.get()
# add plus sign
        stringCommandLine += ' ) '
# set string
        self.varEntryCommandLine.set(stringCommandLine) 
        
        return
       
        
    def handlerCommandLine_Backspace(self):
        '''
        Purpose:
            delete last character from command line
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerCommandLine_Backspace')
        
        stringCommandLine = self.varEntryCommandLine.get()
        if DEBUG_BUFFER_ROW_GENERATOR:
            print 'stringCommandLine = %s' % stringCommandLine
            print 'len() = %s' % len(stringCommandLine)
# if len is zero, do nothing
        if len(stringCommandLine) == 0:
            return
# cut off last character of string
        stringNew = stringCommandLine[0:len(stringCommandLine)-1]
        if DEBUG_BUFFER_ROW_GENERATOR:
            print ' new string = %s' % stringNew
# set entry field to new string
        self.varEntryCommandLine.set(stringNew)
        
        return
        
        
    def handlerFormNewRow_Execute(self):
        '''
        Purpose:
            execute the command line in Form New Row window
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handerlFormNewRow_Execute')
            
        colorbg = 'lightblue'
        
# NOTE: there is no check for making sure all x values are identical,
#       just a check elsewhere that there are the same NUMBER of x values

# get command line string; strip white space at ends, if any
        commandLine = self.varEntryCommandLine.get().strip()
        if commandLine == '':
            stringErrorNoCommandLine = (
                'No commands have been entered in the\n' +
                '"Command" field.\n\n' +
                'Enter commands and try again.'
                )
            print stringErrorNoCommandLine
            showerror(
                'Error: no commands',
                stringErrorNoCommandLine
                )
            return
# duplicate the command line so original is not corrupted
        commandLineNew = commandLine
        if DEBUG_BUFFER_COMMAND_LINE:
            print('commandLine string = %s' % commandLine)
# list of variables to be replaced
        vars = []
        vars = re.findall(r'\bRow\d+',commandLine)
        if DEBUG_BUFFER_COMMAND_LINE:
            print('list of vars in commandLine = %s' % vars)
# list of row numbers extracted from above 'variables to be replaced'
        rows = []
        rows = re.findall(r'\bRow(\d+)',commandLine)
        if DEBUG_BUFFER_COMMAND_LINE:
            print('list of rows in commandLine = %s' % rows)
# check that each variable has same number of y values
# ... this re-check is here since future changes to code may allow users
# ... to input other rows on command line that are not listed in the window
        '''
        rowFirst = rows[0]
        numPointsFirst = self.bufferRowStore[rowFirst-1][11]
        if len(rows) >= 2:
            for row in rows:
                numPoints = self.bufferRowStore[row-1][11]
                print('numPoints in Row %s: %s' % (row,numPoints)
                if numPoints <> numPointsFirst:
                    stringMismatchedPoints = (
                        'Number of data points for each selected row\n' +
                        'must match for this operation.\n\n' +
                        'At the very least, the following rows do not match:\n\n' +
                        'Row %s: %s points\n' +
                        'Row %s: %s points\n\n' +
                        'Select rows that have same number of points\n' +
                        'and try again.'
                        ) % (rowFirst, numPointsFirst, rowNum, numPoints)
                    print stringMismatchedPoints
                    showerror(
                        'Error: mismatched points',
                        stringMismatchedPoints
                        )
                    return
        '''

# replace command line variables with actual data variables
        for i in range(len(rows)):
            row = str(eval(rows[i]) - 1)
            stringReplace = (
                r'self.bufferRowStore[' + row + r'][14][j] '    # y variable
                )
            try:
                commandLineNew = re.sub(vars[i],stringReplace,commandLineNew)   # has 'j' index embedded
            except:
                stringErrorCommand = (
                    'An error was encountered while forming\n' +
                    'the new command line for\n\n' +
                    'row %s\n' +
                    'var %s\n\n' +
                    'Execution of this process will now stop and control\n' +
                    'returned to the previous window.'
                    ) % (row, vars[i])
                print stringErrorCommand
                showerror(
                    'Error: cannot form command line',
                    stringErrorCommand
                    )
                return
        if DEBUG_BUFFER_COMMAND_LINE:
            print('commandLineNew = %s' % commandLineNew)

            
# gather X values
        xValuesNew = []
        if DEBUG_BUFFER_COMMAND_LINE:
            print('\n> Gather X values\n')
#        for i in range(0,len(rows),1):          
# new x values taken from bufferRowStore
        rowForX = str(eval(rows[0]) - 1)
        if DEBUG_BUFFER_COMMAND_LINE:
            print('    i, rows[i], rowForX = %s, %s, %s' % (i,rows[i],rowForX))
# extract list from self.bufferRowStore, a list of lists
        xValuesNew = eval('self.bufferRowStore[' + rowForX + r'][13]')
        if DEBUG_BUFFER_COMMAND_LINE:
            print('      xValuesNew = %s' % xValuesNew)
            
# check for following, each of which must be true to use this function:
# ... 1. all selected rows have the same number of Y values
# ... 2. all X values from chosen rows must be equal
# ... otherwise, it is assumed all rows are compatible and can be 
# ...   mathematically manipulated to generate a new row 

# 1. all selected rows have the same number of X values
        iflag = 0
        if len(rows) > 1:
            lenInitialXValues = len(xValuesNew)
            stringNotSameNumberOfXValues = (
                'The following buffer rows, chosen to form a new row,\n' +
                'do not have the same number of X values as the initial row:\n\n' +
                '  Row %s: %s X values (initial row)\n'
                ) % (rows[0],lenInitialXValues)
            xValuesOtherRows = []
            for i in range(1,len(rows),1):  
                rowForX = str(eval(rows[i])-1)
                xValuesOtherRows.append(eval('self.bufferRowStore[' + rowForX + r'][13]'))
                if len(xValuesOtherRows[i-1]) <> lenInitialXValues:
                    iflag = 1
                    stringNotSameNumberOfXValues += (
                        '  - Row %s: %s X values\n' 
                        ) % (rows[i], len(xValuesOtherRows[i]))
                        
            if iflag == 1:
                stringNotSameNumberOfXValues += (
                    '\nA new buffer row can only be formed from (X,Y) pairs\n' +
                    'in chosen buffer rows that have the same number of points.\n\n' +
                    'Check original storage buffer rows chosen for forming\n' +
                    'a new row for same number of points.\n\n' +
                    'New row generation halted.'
                    )
                print('\n' + stringNotSameNumberOfXValues)
                self.MySQL_Output(
                    0,
                    stringNotSameNumberOfXValues
                    )
                showinfo(
                    'Info: X values not equal across rows',
                    stringNotSameNumberOfXValues +
                    '\n'
                    )
                    
                return

# 2. all X values from chosen rows must be equal 
        iflag = 0
        if len(rows) > 1:
            lenInitialXValues = len(xValuesNew)
            stringNotSameXValues = (
                'The following buffer rows, chosen to form a new row,\n' +
                'do not have X values identical to initial row:\n\n' +
                '  - Row %s (initial row)'
                ) % rows[0]
            for i in range(1,len(rows),1):          
# new x values taken from bufferRowStore
#                rowForX = str(eval(rows[i]) - 1)
# extract list from self.bufferRowStore, a list of lists
#                xValuesNew[i] = eval('self.bufferRowStore[' + rowForX + r'][13]')
                if xValuesOtherRows[i-1] <> xValuesNew:
                    iflag = 1
                    stringNotSameXValues += (
                        '  - Row %s\n' 
                        ) % (rows[i])
                    
            if iflag == 1:
                stringNotSameXValues += (
                    '\nA new buffer row can only be formed from (X,Y) pairs\n' +
                    'in chosen buffer rows that have identical X values.\n\n' +
                    'Check original storage buffer rows chosen for forming\n' +
                    'a new row for compatibility in X values.\n\n' +
                    'New row generation halted.'
                    )
                print('\n' + stringNotSameXValues)
                self.MySQL_Output(
                    0,
                    stringNotSameXValues
                    )
                showinfo(
                    'Info: X values not equal across rows',
                    stringNotSameXValues + 
                    '\n'
                    )
                return

                
        if DEBUG_BUFFER_COMMAND_LINE:
            print('\nrowForX = %s' % rowForX)
            print('\nlen(xValuesNew) for row %s) = %s' % (row,len(xValuesNew)) )
            print('\nxValuesNew =\n %s' % xValuesNew)
        
# use list comprehension to evaluate yValuesNew (but lose control over logic if a value is invalid)
        '''
        yValuesNew = []
        try:
            yValuesNew = [eval(commandLineNew) for j in range(len(xValuesNew))]
        except:
            stringErrorCommandLineNew = (
                'Not able to evaluate command line in Row Generator.\n\n' +
                'Check command line format and try again.'
                )
            print('\n' + stringErrorCommandLineNew)
            self.MySQL_Output(
                0,
                stringErrorCommandLineNew
                )
            showerror(
                'Error: bad format',
                stringErrorCommandLineNew
                )
            return
            '''

# calculate new yValues; if either xValueNew or any 'value' is None (meaning no data), 
# ... then yValuesNew value is None. Apparently, matplotlib does not plot values with None, it
# ... just skips over them. Nice!
        yValuesNew = []
        for j in range(len(xValuesNew)):
            if xValuesNew[j] == None:
                yValuesNew.append(None)
                continue
            try:
                value = (eval(commandLineNew))
            except:
                value = None
            yValuesNew.append(value)
            
        if DEBUG_BUFFER_COMMAND_LINE:
            print('\nlen(yValuesNew) = %s' % len(yValuesNew))
            print('\nyValuesNew =\n %s' % yValuesNew)

# get user comment and user fields data

# calculate other data going into new buffer row, such as
#    (x-y headers, pointsFirst, pointsLast, databases, tables, timestamps)
# x header
        xHeaderNew = self.comboboxXHeaderNew.get()
# y header
        yHeaderNew = self.comboboxYHeaderNew.get()
# database
        myDatabaseNew = self.varEntryDatabaseNew.get()
# table
        myTableNew = self.varEntryTableNew.get()
# num_points
        num_pointsNew = len(xValuesNew)
# first x-y pair
        first_xy_pair_New = ('(%s, %s)') % (xValuesNew[0],yValuesNew[0])
# last x-y pair
        last_index = len(xValuesNew) - 1
        last_xy_pair_New = ('(%s, %s)') % (xValuesNew[last_index],yValuesNew[last_index])
# user comment
#        user_comment_New = self.varEntryUserCommentNew.get()
        user_comment_New = self.comboboxUserComment_New.get()
# user_field 1
        user_field_1_New = self.comboboxUserField_1_New.get()
# user_field 2
        user_field_2_New = self.comboboxUserField_2_New.get()
# user_field 3
        user_field_3_New = self.comboboxUserField_3_New.get()
# user_field 4
        user_field_4_New = self.comboboxUserField_4_New.get()
# timestamp
        timestampNew = time.ctime(time.time())[0:19]

# add new row to buffer data
        self.bufferRowStore_NumRows = len(self.bufferRowStore)
        old_buffer_NumRows = self.bufferRowStore_NumRows
        rowAdd = 0
        self.bufferRowStore.append([]) 
        self.bufferRowStore[self.bufferRowStore_NumRows + rowAdd].append(user_comment_New)          # 0
        self.bufferRowStore[self.bufferRowStore_NumRows + rowAdd].append(user_field_1_New)          # 1
        self.bufferRowStore[self.bufferRowStore_NumRows + rowAdd].append(user_field_2_New)          # 2
        self.bufferRowStore[self.bufferRowStore_NumRows + rowAdd].append(user_field_3_New)          # 3
        self.bufferRowStore[self.bufferRowStore_NumRows + rowAdd].append(user_field_4_New)          # 4
        self.bufferRowStore[self.bufferRowStore_NumRows + rowAdd].append(xHeaderNew)                # 5
        self.bufferRowStore[self.bufferRowStore_NumRows + rowAdd].append(yHeaderNew)                # 6
        self.bufferRowStore[self.bufferRowStore_NumRows + rowAdd].append(first_xy_pair_New)         # 7
        self.bufferRowStore[self.bufferRowStore_NumRows + rowAdd].append(last_xy_pair_New)          # 8
        self.bufferRowStore[self.bufferRowStore_NumRows + rowAdd].append(myDatabaseNew)             # 9
        self.bufferRowStore[self.bufferRowStore_NumRows + rowAdd].append(myTableNew)                # 10
        self.bufferRowStore[self.bufferRowStore_NumRows + rowAdd].append(num_pointsNew)             # 11
        self.bufferRowStore[self.bufferRowStore_NumRows + rowAdd].append(timestampNew)              # 12
        self.bufferRowStore[self.bufferRowStore_NumRows + rowAdd].append(xValuesNew)                # 13
        self.bufferRowStore[self.bufferRowStore_NumRows + rowAdd].append(yValuesNew)           # 14

# update number of buffer rows
        numRows = self.bufferRowStore_NumRows = len(self.bufferRowStore)
        if DEBUG_BUFFER_COMMAND_LINE:
            print('\nNew row has been added to buffer:')
            print('     Number of old buffer rows: %s' % old_buffer_NumRows)
            print('     Number of new buffer rows: %s' % self.bufferRowStore_NumRows)
            print   
# refresh buffer window before leaving; do NOT kill 'generate row' window
# ... NOTE: this kills the 'storage-buffer row generator' window
#        self.buttonTableValuesShowAll_Buffer.invoke()
        try:
            varHideShow = self.varHideShowSet.get()
        except:
            varHideShow = 0
        
        if varHideShow == 0:
# show all user fields
            minValue = 0
        else:
# hide all user fields
            minValue = 5
# constants
        width_Field_Buffer = self.comboboxWidthFieldBuffer.get()
        height_Field_Buffer = self.comboboxHeightFieldBuffer.get()
        fontsize_Field_Buffer = tkFont.Font(
            family='Helvetica',
            size=self.comboboxFontFieldBuffer.get(),
#            weight='bold'
            )
# get the checked rows
        rowsChecked = []
        for var in self.varSelectAnyRow_Buffer:
            rowsChecked.append(var.get())
        if DEBUG_BUFFER_COMMAND_LINE:
            print
            print('rowsChecked = %s' % rowsChecked)
            
# clear row numbers in storage buffer
        self.clear_grid(self.frame_21_canvas_Buffer)
# clear table in storage buffer
        self.clear_grid(self.frame_22_canvas_Buffer)
        
# fill in table with previous rows and new row
        for i in range(numRows):
            for j in range(minValue,len(self.headerNamesBufferStorage)):
                labelTest = Label(
                    self.frame_22_canvas_Buffer,
                    text=self.bufferRowStore[i][j],
                    width=width_Field_Buffer,
                    height=height_Field_Buffer,
                    font=fontsize_Field_Buffer,
                    background='white',
                    foreground='black',
                    justify=CENTER,
                    anchor=NW,
                    )
                labelTest.grid(
                    row=i,
                    column=j,
                    padx=2,
                    pady=1,
                    )    

# setup 'Select row' checkbuttons for storage buffer:
        self.varSelectAnyRow_Buffer = []
        tableColumn=0
#            for i in range(self.bufferRowStore_NumRows):
        for i in range(numRows):
            tableRow=i
            var = IntVar()
# checkbuttons for delete row
            checkbuttonSelectAnyRow = Checkbutton(
                self.frame_21_canvas_Buffer,
                bg=colorbg,
                justify=LEFT,
                variable=var,
                font=self.buttonFontSmallest,
                borderwidth=0,
                height=height_Field_Buffer,
#                    command=self.handlerInvokeButtonToRefreshPlotXYWindow,
                )
            checkbuttonSelectAnyRow.grid(
                row=tableRow,
                column=tableColumn,
                padx=0,
                pady=1,
                sticky=E,
                )
# use bindtags to switch binding order so that checkbuttons will be checked,
#   before being examined to see how many rows are checked;
#   normally, the first two parameters are switched below for the default value
            checkbuttonSelectAnyRow.bindtags((
                'Checkbutton',                          # class binding
                (str(checkbuttonSelectAnyRow)), # instance binding
                'self.frame_21_canvas_Buffer',
                'all'
                ))
            checkbuttonSelectAnyRow.bind(
                "<ButtonRelease-1>",
                self.displayNumberOfRowsSelected_Buffer
                )               
# variable to check for on-off states
#  to check value, use:
#   for var in self.varSelectAnyRow:
#       print var.get()  # will be either 1 or 0
            self.varSelectAnyRow_Buffer.append(var)
            
# line numbers
            labelSelectAnyRow = Label(
                self.frame_21_canvas_Buffer,
                text='%-4s' % (i+1),
                bg=colorbg,
                justify=RIGHT,
                height=height_Field_Buffer,
                font=fontsize_Field_Buffer,
                )
            labelSelectAnyRow.grid(
                row=tableRow,
                column=tableColumn+1,
                padx=0,
                pady=1,
                sticky=W,
                )          
                    
# set the previously checked rows to checked again -- preserve the previous status
        lenAnyRow_Buffer = len(self.varSelectAnyRow_Buffer)
        icount = 0
        if DEBUG_BUFFER_COMMAND_LINE:
            print('lenAnyRow_Buffer = %s' % lenAnyRow_Buffer)
        for var in self.varSelectAnyRow_Buffer:
            if DEBUG_BUFFER_COMMAND_LINE:
                print('%s. var.get() = %s' % (icount+1,var.get()))
            if icount < (lenAnyRow_Buffer - 1):
                var.set(rowsChecked[icount])
            else:
                var.set(0)
            icount += 1
            
# confirmation window
        if self.varConfirmRowAddedToBuffer.get():
            stringConfirm = (
                'Success!\n\n' +
                'New row #%s added to Storage Buffer'
                ) % numRows
            showinfo(
                'Info: new row added',
                stringConfirm,
                parent=self.toplevelFormNewRow
                )

        return

        
    def handlerFormNewRow_Clear(self):
        '''
        Purpose:
            clear the command line in Form New Row window
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerFormNewRow_Clear')
        
        self.varEntryCommandLine.set('')
        
        return
        
        
    def handlerFormNewRow_Cancel(self):
        '''
        Purpose:
            close the toplevel window associated with Form New Row
            window
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerFormNewRow_Cancel')
        
        self.toplevelFormNewRow.destroy()
        
        return

        
    def handlerTableValuesDelete_Buffer(self):
        '''
        Purpose:
            delete select rows from buffer
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerTableValuesDelete_Buffer')
        
# Checks        
# ... if no rows available, say so and return
        if self.bufferRowStore_NumRows == 0:
            stringNoRowsAvailable = (
                'Storage Buffer is empty.\n\n' +
                'No rows are available to delete.'
                )
            print stringNoRowsAvailable
            self.MySQL_Output(
                0,
                stringNoRowsAvailable
                )
            try:
                showerror(
                    'Error: no rows available',
                    stringNoRowsAvailable,
                    parent=self.toplevelShowStorageBuffer
                    )
            except:
                showerror(
                    'Error: no rows available',
                    stringNoRowsAvailable
                    )
            return
# end of Checks
        
# check to see if any buttons are checked
        checkedRow = False
        
        if DEBUG_DELETEROWSFROMBUFFER:
            print '\n-----'
            print 'self.varSelectAnyRow_Buffer =\n',self.varSelectAnyRow_Buffer
            print '\n-----'
        
        for var in self.varSelectAnyRow_Buffer:
            if var.get():
                checkedRow = True
        
        if not checkedRow:
            stringNothingChecked = (
                'No row has been selected.\n\n' +
                'Please check the corresponding row(s) and try again.' 
                )
            print stringNothingChecked
            self.MySQL_Output(
                0,
                stringNothingChecked
                )
            showerror(
                'Error: no selection',
                stringNothingChecked
                )
            return

# determine indices of rows to delete            
        indicesDelete = []
        index = 0
        for var in self.varSelectAnyRow_Buffer:
            if var.get():
                indicesDelete.append(index)
                print 'var.get().strip() = %s, index = %s' % (
                    var.get(), index
                    )
            index += 1
# reverse indices; must start delete at bottom and work up
        indicesDelete.reverse()
# finally, check with user
        if len(indicesDelete) == 1:
            okay = askokcancel(
                'Warning: row deletion',
                'WARNING!\n\n' + 
                '1 row has been selected for deletion.\n\n' +
                'Click \'OK\' to delete',
                parent=self.toplevelShowStorageBuffer
                )       
        else:
            okay = askokcancel(
                'Warning: row deletion',
                ('WARNING!\n\n' + 
                '%s rows have been selected for deletion.\n\n' +
                'Click \'OK\' to delete') % len(indicesDelete),
                parent=self.toplevelShowStorageBuffer
                )
        if not okay:
            return
# delete the rows
        for index in indicesDelete:
            self.bufferRowStore.remove(
                self.bufferRowStore[index]
                )
            self.varSelectAnyRow_Buffer.remove(
                self.varSelectAnyRow_Buffer[index]
                )
# re-calculate the number of rows in Buffer
        self.bufferRowStore_NumRows -= len(indicesDelete)
# refresh buffer view
#        self.handlerDisplayStorageBufferValues_Call()
# but if there is no data to display, destroy window and show Info message
        if self.bufferRowStore_NumRows <= 0:
            self.buffer_xWindowLocation = self.toplevelShowStorageBuffer.winfo_rootx() - self.offsetWindowX
            self.buffer_yWindowLocation = self.toplevelShowStorageBuffer.winfo_rooty() - self.offsetWindowY
            self.toplevelShowStorageBuffer.destroy()
            # display new total in main table window
            self.countDisplayStorageBuffer.set(
                'BUFFER: Display (0 rows)'
                )
            stringBufferEmpty = (
                'Storage buffer is empty'
                )
            print stringBufferEmpty
            self.MySQL_Output(
                0,
                stringBufferEmpty
                )
            try:
                showinfo(
                    'Info: empty buffer',
                    stringBufferEmpty,
                    parent=self.toplevelShowStorageBuffer
                    )
            except:
                showinfo(
                    'Info: empty buffer',
                    stringBufferEmpty
                    )

            try:
                mapped0 = self.toplevelXYPlotPreprocess.winfo_exists()
            except:
                mapped0 = False
            if mapped0:
                self.handlerUpdateXYPlots_Table()

        else:
#            self.buttonTableValuesShowAll_Buffer.invoke()
            self.handlerRefreshBufferView()
# refresh plotting window if open
        self.handlerInvokeButtonToRefreshPlotXYWindow()
# display new total in main table window
        self.countDisplayStorageBuffer.set(
            'BUFFER: Display (' +
            str(self.bufferRowStore_NumRows) + 
            ' rows)'
            )
        
        return
        
        
    def handlerTableValuesSaveCVS_Buffer(self):
        '''
        Purpose:
            save select rows from buffer to CVS-formatted file
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerTableValuesSave_Buffer')
        
# if no rows available, say so and return
        if self.bufferRowStore_NumRows == 0:
            stringNoRowsAvailable = (
                'Storage Buffer is empty.\n\n' +
                'No rows are available to save.'
                )
            print stringNoRowsAvailable
            self.MySQL_Output(
                0,
                stringNoRowsAvailable
                )
            try:
                showerror(
                    'Error: no rows available',
                    stringNoRowsAvailable,
                    parent=self.toplevelShowStorageBuffer
                    )
            except:
                showerror(
                    'Error: no rows available',
                    stringNoRowsAvailable
                    )
            return
        
# define dictionary of options for askopenfilename()
# ... first way
#        options['key'] = 'value'

# ... second way
        options = {}
        options = {
            'defaultextension' : '.csv',
            'filetypes' : [('csv','.csv'),('All files','*')],
            'initialdir' : os.getcwd(),
            'initialfile' : '',
            'parent' : self.toplevelShowStorageBuffer,
            'title' : 'Save buffer'
            }
# ... print options
        print(
            '   \ninitialdir = %s' % options['initialdir']
            )
        
# get filename
        fullPathName = tkFileDialog.asksaveasfilename(**options)
        dirname, filename = os.path.split(fullPathName)
        
#        dirname, filename = os.path.split(asksaveasfilename(**options))
# dwb - NOTE
#   os.path.split(askopenfilename()) gives forward slashes in the filename
#   os.getcwd() gives backward slashes in the filename
#       Hence, one cannot compare the results of these two methods to ensure the user stays in the same directory.
#       Too bad :(
        if filename == '':
            print '   No buffer filename chosen!'
            showinfo(
                'No buffer filename chosen...',
                'You must enter a filename for the buffer to be saved'
                )
            return
        else:
            print '    dirname =',dirname
            print '    filename =',filename
            print '    initial directory =',options['intialdir']
            
# work in progress
        showinfo(
            'Warning: work in progress',
            'This option is not yet functional.'
            )
            
        return
        
        
    def handlerTableValuesReadCVS_Buffer(self):
        '''
        Purpose:
            read file in CVS format into buffer
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerTableValuesReadCVS_Buffer')
        
# define dictionary of options for askopenfilename()
# ... first way
#        options['key'] = 'value'

# ... second way
        options = {}
        options = {
            'defaultextension' : '.cvs',
            'filetypes' : [('cvs','.cvs'),('All files','*')],
            'initialdir' : os.getcwd(),
            'initialfile' : '',
            'parent' : self.toplevelShowStorageBuffer,
            'title' : 'Read/append buffer'
            }
        
        
# get filename
        dirname, filename = os.path.split(
            tkFileDialog.askopenfilename(**options)
            )
#        dirname, filename = os.path.split(asksaveasfilename(**options))
# dwb - NOTE
#   os.path.split(askopenfilename()) gives forward slashes in the filename
#   os.getcwd() gives backward slashes in the filename
#       Hence, one cannot compare the results of these two methods to ensure the user stays in the same directory.
#       Too bad :(
        if filename == '':
            print '   No buffer filename chosen!'
            showinfo(
                'No buffer filename chosen...',
                'You must enter a filename for the file to be read'
                )
            return
        else:
            print '    dirname =',dirname
            print '    filename =',filename
            
# work in progress
        showinfo(
            'Warning: work in progress',
            'This option is not yet functional.'
            )
        return
            
# append this data to buffer data

# refresh buffer window to show new data 

# refresh Plotting Specs window if open
        self.handlerInvokeButtonToRefreshPlotXYWindow()
            
        return
        
        
    def handlerTableValuesPurge_Buffer(self):
        '''
        Purpose:
            purge duplicate entries from storage buffer
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerTableValuesPurge_Buffer')
        
# Checks
# ... if no rows available, say so and return
        if self.bufferRowStore_NumRows == 0:
            stringNoRowsAvailable = (
                'Storage Buffer is empty.\n\n' +
                'No rows are available to purge.'
                )
            print stringNoRowsAvailable
            self.MySQL_Output(
                0,
                stringNoRowsAvailable
                )
            try:
                showerror(
                    'Error: no rows available',
                    stringNoRowsAvailable,
                    parent=self.toplevelShowStorageBuffer
                    )
            except:
                showerror(
                    'Error: no rows available',
                    stringNoRowsAvailable
                    )
            return
# end of Checks            
        
        stringPurgeMsg = (
            'PURGE ignores user comment (field 1), all user fields (fields 2-5),\n' +
            'and the timestamp field (field 13) when comparing rows to search for\n' +
            'duplicate entries.'
            )
        ok = askokcancel(
            'PURGE: warning',
            stringPurgeMsg
            )
            
        if not ok:
            return
        
# determine indices to purge    
# use a dictionary here to ensure unique index values are an end result
        indicesPurge_Dict = {}
# no need to include very last row for index1
        for index1 in range(len(self.bufferRowStore) - 1):
            list1 = self.bufferRowStore[index1]
            indexCurrent = index1 + 1
            for index2 in range(
                indexCurrent,
                len(self.bufferRowStore),
                1
                ):
                if (
                    list1[5] == self.bufferRowStore[index2][5] and
                    list1[6] == self.bufferRowStore[index2][6] and
                    list1[7] == self.bufferRowStore[index2][7] and
                    list1[8] == self.bufferRowStore[index2][8] and
                    list1[9] == self.bufferRowStore[index2][9] and
                    list1[10] == self.bufferRowStore[index2][10] and
                    list1[11] == self.bufferRowStore[index2][11]
                    ):
                    indicesPurge_Dict[index2] = None
# get the list of keys from the dictionary
        indicesPurge = list(indicesPurge_Dict)
# if no duplicates, print msg and return
        if len(indicesPurge) == 0:
            stringNothingToPurge = (
                'No duplicates have been found in the Storage Buffer.'
                )
            print stringNothingToPurge
            self.MySQL_Output(
                0,
                stringNothingToPurge
                )
            showinfo(
                'Info: no duplicates',
                stringNothingToPurge
                )
            return
        else:
# sort indices
            indicesPurge.sort()
# reverse indices; must start purge at bottom and work up
            indicesPurge.reverse()
            print '\nIn handlerTableValuesPurge_Buffer:'
            print '  indicesPurge = ',
            print indicesPurge
            print 

# finally, check with user
        if len(indicesPurge) == 1:
            okay = askokcancel(
                'Warning: purge duplicates',
                'WARNING!\n\n' + 
                '1 row has been selected for purging.\n\n' +
                'Click \'OK\' to purge'
                )       
        else:
            okay = askokcancel(
                'Warning: purge duplicates',
                ('WARNING!\n\n' + 
                '%s rows have been selected for purging.\n\n' +
                'Click \'OK\' to purge') % len(indicesPurge)
                )
        if not okay:
            return
# delete the rows
        for index in indicesPurge:
            self.bufferRowStore.remove(
                self.bufferRowStore[index]
                )
            self.varSelectAnyRow_Buffer.remove(
                self.varSelectAnyRow_Buffer[index]
                )
# re-calculate the number of rows in Buffer
        self.bufferRowStore_NumRows -= len(indicesPurge)
# display new total in main table window for Storage Buffer
        self.countDisplayStorageBuffer.set(
            'BUFFER: Display (' +
            str(self.bufferRowStore_NumRows) + 
            ' rows)'
            )
# refresh buffer view
        self.handlerDisplayStorageBufferValues_Call()
# refresh plotting window if open
        self.handlerInvokeButtonToRefreshPlotXYWindow()
        
        return
        

    def handlerAllRowsClearOrSelect_Buffer(self):
        '''
        Purpose:
            select or de-select all selected rows in buffer
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerAllRowsClearOrSelect_Buffer')
            
        if DEBUG_ALLROWSCLEARORSELECT_BUFFER:
            print('\n======== handlerAllRowsClearOrSelect_Buffer =====' + 
                '\nself.varAllRowsClearOrSelect_Buffer.get() = %s' 
                ) % self.varAllRowsClearOrSelect_Buffer.get()
            print('\nlen(self.varSelectAnyRow_Buffer) = %s' % len(self.varSelectAnyRow_Buffer))
            print('\nself.bufferRowStore_NumRows = %s' % self.bufferRowStore_NumRows)

# check if empty buffer
        if self.bufferRowStore_NumRows == 0:
            stringEmptyBuffer = (
                'Storage buffer is empty.'
                )
            try:
                showinfo(
                    'Info: empty storage buffer',
                    stringEmptyBuffer,
                    parent=self.toplevelShowStorageBuffer
                    )
            except:
                showinfo(
                    'Info: empty storage buffer',
                    stringEmptyBuffer
                    )
            return
        
# clear list of which buffer rows are checked
        self.listWhichBufferRowsAreChecked = []
        totalRowsChecked = 0
        
        if self.varAllRowsClearOrSelect_Buffer.get():
# loop for selecting all rows
            for (num,var) in enumerate(self.varSelectAnyRow_Buffer):
                var.set(1)
                self.listWhichBufferRowsAreChecked.append(num)
                totalRowsChecked += 1
        else:
# loop for de-selecting all rows
            for (num,var) in enumerate(self.varSelectAnyRow_Buffer):
                var.set(0)
                self.listWhichBufferRowsAreChecked.append(num)
                
# display count
        self.displayNumberOfRowsSelected_Buffer('')
        
        if DEBUG_ALLROWSCLEARORSELECT_BUFFER:
            print('\ntotal rows checked in buffer: %s' % totalRowsChecked)
                
        return
        
        
    def handlerRefreshXYPlottingSpecsWindow(self):
        '''
        Purpose:
            refresh plotting specs window if it is open; 
            sets number of plots in plotting specs window if opened
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerRefreshXYPlottingSpecsWindow')
        
# Error checking

# ... check whether X-Y Plot Specs window is opened
        try:
            mapped = self.toplevelXYPlotPreprocess.winfo_exists()
        except:
            mapped = False
            
# ... see if at least one row is checked in buffer
        linesChecked = False
        for var in self.varSelectAnyRow_Buffer:
            if var.get(): 
                linesChecked = True
# if any line is checked, break out
                break
                
# if no lines are checked, print error msg and bail
        if not linesChecked:
            stringNoRowSelect = (
                'No rows have been selected for plotting.\n\n' +
                'Select at least one row and try again.' 
                )
            print '\nError: ' + stringNoRowSelect
            self.MySQL_Output(
                1,
                'Error: ' + stringNoRowSelect
                )
            try:
                showerror(
                    'Error: no plot values',
                    stringNoRowSelect,
                    parent=self.toplevelShowStorageBuffer,
                    )
            except:
                showerror(
                    'Error: no plot values',
                    stringNoRowSelect
                    )
            return
                      
        if mapped:
            numBufferCurves = self.varNumberOfStorageBufferCurves.get()
            if numBufferCurves == 0 and not linesChecked:
# do NOT refresh
                stringNoRowsSelectedInBuffer = (
                    'No rows have been selected in buffer.\n\n' +
                    'Select at least one row and try again.'
                    )
                print stringNoRowsSelectedInBuffer
                self.MySQL_Output(
                    0,
                    stringNoRowsSelectedInBuffer
                    )
                try:
                    showinfo(
                        'No row(s) selected',
                        stringNoRowsSelectedInBuffer,
                        parent=self.toplevelShowStorageBuffer,
                        )
                except:
                    showinfo(
                        'No row(s) selected',
                        stringNoRowsSelectedInBuffer
                        )
                return
            else:
#                self.handlerInvokeButtonToRefreshPlotXYWindow()
                if mappedToplevelXYPlotPreprocess:
                    try:
                        mapped1 = self.toplevelSummarize.winfo_exists()
                    except:
                        mapped1 = False
                    if mapped1:
                        self.toplevelSummarize.destroy()
                
#            self.handlerXYPlotPreprocess()
                self.handlerUpdateXYPlots_Buffer()

        else:
            '''
            stringWindowNotOpen = (
                'The "X-Y Plot Specs" window is not currently open.\n\n' +
                'Plot updates are accepted only when this window is open.'
                )
            print stringWindowNotOpen
            self.MySQL_Output(
                0,
                stringWindowNotOpen
                )
            showinfo(
                'Window not open',
                stringWindowNotOpen
                )
            '''
#            self.handlerXYPlotPreprocess()
            self.handlerUpdateXYPlots_Buffer()
        
        return
        
        
    def handlerRefreshKiviatPlottingSpecsWindow(self):
        '''
        Purpose:
            refresh kiviat plotting specs window; 
            sets number of plots in plotting specs window if opened
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerRefreshKiviatPlottingSpecsWindow')
        
        showinfo(
            'handlerRefreshKiviatPlottingSpecsWindow',
            'This command not yet implemented.'
            )
            
        return
        
        
    def handlerGroupSelectedRowsInBuffer(self):
        '''
        Purpose:
            group all selected rows into designated group number
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerGroupSelectedRowsInBuffer')
        
# check if Group # has been designated
        if self.comboboxGroupNumber.get().strip() == '':
            stringNoGroupNumber = (
                'No Group # has been specified.\n\n' +
                'Please specify a Group # and try again.'
                )
            print stringNoGroupNumber
            self.MySQL_Output(
                0,
                stringNoGroupNumber
                )
            showinfo(
                'No group #',
                stringNoGroupNumber
                )
            return

# check if group has been labeled
        if self.entryGroupLabel.get().strip() == '':
            stringNoGroupLabel = (
                'No Group Label has been specified.\n\n' +
                'Please specify a Group Label and try again.'
                )
            print stringNoGroupLabel
            self.MySQL_Output(
                0,
                stringNoGroupLabel
                )
            showinfo(
                'No group #',
                stringNoGroupLabel
                )
            return 


# get list of checked rows in buffer for group
        listOfRowsCheckedInBuffer = self.whichRowsChecked()
        '''
        inumWhichBufferRowsAreChecked = 0
        listWhichBufferRowsAreChecked = []
        for row in self.varSelectAnyRow_Buffer:
            inumWhichBufferRowsAreChecked += 1
            if row.get():
                listWhichBufferRowsAreChecked.append(
                    inumWhichBufferRowsAreChecked
                    )
        '''
        
        print(
            'nBuffer rows checked:\n'
            )
        print listOfRowsCheckedInBuffer
        print(
            '\n'
            )

        
# ... if list of rows is empty, no group has been checked
        if len(listOfRowsCheckedInBuffer) == 0:
            stringNoRowsChecked = (
                'No buffer rows have been selected.\n' +
                'Select desired buffer rows and try again.'
                )
            print stringNoRowsChecked
            self.MySQL_Output(
                0,
                stringNoRowsChecked
                )
            showinfo(
                'No rows selected',
                stringNoRowsChecked
                )
            return
            
# check if 3 or more rows have been selected; Kiviat diagrams require 3 or more rows 
        if len(listOfRowsCheckedInBuffer) < 3:
            stringNotEnoughRows = (
                'Not enough rows have been selected for Kiviat diagrams.\n\n' +
                'Select at least 3 or more rows and try again.'
                )
            print stringNotEnoughRows
            self.MySQL_Output(
                0,
                stringNotEnoughRows
                )
            showinfo(
                'Not enough rows selected',
                stringNotEnoughRows
                )
            return
                      
# ... if list of rows is non-empty and 3 or more, collect rows into group


# clear 'Group #' and label entries
        self.comboboxGroupNumber.setentry('')
        self.varGroupLabelForBuffer.set('')

        return
        
        
    def whichRowsChecked(self):
        '''
        Purpose:
            determine which buffer rows are checked
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'whichRowsChecked')
        
        inumWhichBufferRowsAreChecked = 0
        listWhichBufferRowsAreChecked = []
        for row in self.varSelectAnyRow_Buffer:
            inumWhichBufferRowsAreChecked += 1
            if row.get():
                listWhichBufferRowsAreChecked.append(
                    inumWhichBufferRowsAreChecked
                    )
  
        return listWhichBufferRowsAreChecked
        
        
    def handlerGroupNumber(self,numGroup):
        '''
        Purpose:
            automatically specify label for group
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerGroupNumber')
        
        labelGroup = 'Group' + ' ' + numGroup
# calculate which rows are checked
        listOfRowsCheckedInBuffer = self.whichRowsChecked()
        
        # ... if list of rows is empty, no group has been checked
        if len(listOfRowsCheckedInBuffer) == 0:
            stringNoRowsChecked = (
                'No buffer rows have been selected.\n' +
                'Select desired buffer rows and try again.'
                )
            print stringNoRowsChecked
            self.MySQL_Output(
                0,
                stringNoRowsChecked
                )
            showinfo(
                'No rows selected',
                stringNoRowsChecked
                )
            return
        
        labelGroup += ', ' + str(len(listOfRowsCheckedInBuffer)) + ' rows: '
# get y headers for label
        
        for icount,row in enumerate(listOfRowsCheckedInBuffer):
            yHeader = self.bufferRowStore[row - 1][6]
            if icount == 0:
                labelGroup += yHeader
            else:
                labelGroup += ', ' + yHeader
            
# clear label text            
        self.varGroupLabelForBuffer.set('')
# set label field
        self.varGroupLabelForBuffer.set(labelGroup)
        
        return
        
        
    def handlerGroupsShowFromBuffer(self):
        '''
        Purpose:
            show all groups that have been selected from buffer
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerGroupsShowFromBuffer')
        
        showinfo(
            'handlerGroupsShowFromBuffer',
            'This command not yet implemented.'
            )
            
        return
        
        
    def handlerGroupsClearFromBuffer(self):
        '''
        Purpose:
            clear all groups that have been selected from buffer
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerGroupsClearFromBuffer')
        
        showinfo(
            'handlerGroupsClearFromBuffer',
            'This command not yet implemented.'
            )
            
        return
        
        
    def checkAutoIncrementPrimaryKeyField(self):
        '''
        Purpose:
            check current table for auto-incrementing Primary Key field;
            if none exists; create one and add to end of table.
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'checkAutoIncrementPrimaryKeyField')

# don't even try this if this is a system database!
        if self.myDatabase == 'mysql':
            return
            
# display structure for each field
        self.checkPrimaryKey = False
        for i in range(len(self.tableStructureOriginal)):
            myField, myDatatype, myNull, myKey, myDefault, myExtra = \
                self.tableStructureOriginal[i]
            if myExtra == 'auto_increment' and myKey == 'PRI': 
                self.checkPrimaryKey = True
                stringCheckPrimaryKey = (
                    'Field ' + myField + ', table column #' + str(i+1) + 
                    ' is the PRIMARY KEY for this table'
                    )
                '''
                print(
                    '\n' + stringCheckPrimaryKey
                    )
                '''
                self.MySQL_Output(
                    1,
                    stringCheckPrimaryKey
                    )
                return
                
        stringNoPrimaryField = (
            'There is no PRIMARY KEY field. An attempt will be made to add it.'
            )

# no primary key found
        '''
        okay = askokcancel(
            'Warning: no PRIMARY KEY field',
            'Table has no auto-incrementing PRIMARY FIELD key.\n' +
            'This field is needed to uniquely identify table rows.\n' +
            'Click \'OK\' to add this field to end of table.'
            )
        '''
#        if okay:
        myDatabase = self.myDatabase
        myTable = self.myTable
        
# attempt to add or resequence auto_index column
        
        stringCommand = (
            'ALTER TABLE ' + myDatabase + '.' + myTable + ' ' +
            'ADD (auto_index INT(12) NOT NULL PRIMARY KEY AUTO_INCREMENT)'
            )
# print to COMMAND window
        self.MySQL_Commands(
            1,
            'self.cursorHandleMySQL.execute("' + stringCommand + '")'
            )
        try:
            self.cursorHandleMySQL.execute(stringCommand)
        except:
            stringCommandError = (
#                'Error in executing the MySQL command string.\n\n' + 
                'INFO: This is probably a system-owned table.\n\n' +
                'You do not have permission to alter the table.\n\n'
                )

# set this true so this method won't be called again
            self.checkPrimaryKey = True            
            return
            
# command successful
        stringCommandSuccess = (
            'An auto-incrementing PRIMARY KEY field has been added to table.'
            )
        print '\n' + stringCommandSuccess
        self.MySQL_Commands(
            0,
            stringCommandSuccess
            ) 
        showinfo(
            'Info: PRIMARY KEY field added',
            'An auto-incrementing PRIMARY KEY field has been added to table.\n\n' +
            'This field is needed to uniquely identify table rows.\n\n' +
            'Table will refresh to show added field.\n'
            ) 
# refresh the Fields box
        self.refreshFields()
# regrid 'Add field...' box so the drop-down box for the field listing is updated
#        self.handlerDatabaseFieldsAdd()   
         
        return
        
        
    def resequenceAutoIncrementPrimaryKeyField(self, parentFrame):
        '''
        Purpose:
            check current table for auto-incrementing Primary Key field;
            If none exists, return. 
            If one exists, drop then re-create it, so that it will be sequenced correctly.
            
            This is needed when rows are deleted from the database. Auto_index is not
            re-ordered automatically
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'resequenceAutoIncrementPrimaryKeyField')

# don't even try this if this is a system database!
        if self.myDatabase == 'mysql':
            return
            
        toplevel = parentFrame

# get current database and table            
        myDatabase = self.myDatabase
        myTable = self.myTable
            
# display structure for each field
        self.checkPrimaryKey = False
        for i in range(len(self.tableStructureOriginal)):
            myField, myDatatype, myNull, myKey, myDefault, myExtra = \
                self.tableStructureOriginal[i]
            if myExtra == 'auto_increment' and myKey == 'PRI': 
                self.checkPrimaryKey = True
                stringCheckPrimaryKey = (
                    'Field ' + myField + ', table column #' + str(i+1) + 
                    ' is the PRIMARY KEY for this table'
                    )
#                if DEBUG_RESEQUENCE_AUTO_INDEX:
                print(
                    '\n' + stringCheckPrimaryKey
                    )
                self.MySQL_Output(
                    0,
                    '\n' + stringCheckPrimaryKey
                    )
# drop auto_index from table
                stringDropAutoIndex = (
                    'ALTER TABLE ' + myDatabase + '.' + myTable + ' ' +
                    'DROP auto_index'
                    )
# ... print command to COMMAND window
                self.MySQL_Commands(
                    1,
                    'self.cursorHandleMySQL.execute("' + stringDropAutoIndex + '")'
                    )
                try:
                    self.cursorHandleMySQL.execute(stringDropAutoIndex)
                except:
                    stringCommandError = (
                        'INFO: Unable to drop auto_index field from table.\n\n' +
                        'This may be due to your not having permission to alter the table.\n\n'
                        )
                    print('\n' + stringCommandError)
                    self.MySQL_Output(
                        0,
                        '\n' + stringCommandError
                        )
                    showerror(
                        'Error: cannot drop auto_index field',
                        stringCommandError,
                        parent=toplevel,
                        )
                    return 0
           
# add auto_index to table
                stringAddAutoIndex = (
                    'ALTER TABLE ' + myDatabase + '.' + myTable + ' ' +
                    'ADD (auto_index INT(12) NOT NULL PRIMARY KEY AUTO_INCREMENT)'
                    )
# ... print command to COMMAND window
                self.MySQL_Commands(
                    1,
                    'self.cursorHandleMySQL.execute("' + stringAddAutoIndex + '")'
                    )
                try:
                    self.cursorHandleMySQL.execute(stringAddAutoIndex)
                except:
                    stringCommandError = (
                        'INFO: Unable to add auto_index field to table.\n\n' +
                        'This may be due to your not having permission to alter the table.\n\n'
                        )
                    print('\n' + stringCommandError)
                    self.MySQL_Output(
                        0,
                        '\n' + stringCommandError
                        )
                    showerror(
                        'Error: cannot add auto_index field',
                        stringCommandError,
                        parent=toplevel,
                        )
                    return 0
                    
                stringSuccess = (
                    'Field auto_index has been re-ordered.\n\n' +
                    'Table will now be refreshed.'
                    )
                print('\n' + stringSuccess)
                self.MySQL_Output(
                    0,
                    stringSuccess
                    )
                showinfo(
                    'SUCCESS: auto_index re-ordered',
                    stringSuccess,
                    parent=toplevel,
                    )
                return 1
                
# FAIL                
# searched thru all fields, cannot find auto_index Primary Key field                
        stringNoPrimaryField = (
            'There is no auto_index PRIMARY KEY field in this table.'
            )
        print('\n' + stringNoPrimaryField)
        self.MySQL_Output(
            0,
            stringNoPrimaryField
            )
        showinfo(
            'INFO: no auto_index field in table',
            stringNoPrimaryField,
            parent=toplevel,
            )
        
        return 0
        
        
    def handlerUpdateXYPlots_Buffer(self):
        '''
        Purpose: 
            update X-Y Plot Specs window with buffer selection
            
        Called by:
            def handlerUpdatePlotWindow_Buffer(self)
        
        Calls
            self.handlerXYPlotPreprocess()
            
        '''            
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerUpdateXYPlots_Buffer')
            
# if X-Y Plot window exists, do not have to open window
# ... if it does NOT exist, open the X-Y Plot window
        try:
            mappedToplevelXYPlotPreprocess = self.toplevelXYPlotPreprocess.winfo_exists()
        except:
            mappedToplevelXYPlotPreprocess = False
            
        self.plot_X_Buffer = []
        self.plot_Y_Buffer = []
        
        jcountBuffer = 0
        self.jcountBuffer = 0
        self.listWhichBufferRowsAreChecked = []
        
# determine how many rows are checked and create a list of checked rows  
        if DEBUG_SCATTER:
            print('\n#   self.varSelectAnyRow_Buffer.get()')
        for (inum,var) in enumerate(self.varSelectAnyRow_Buffer):
            if DEBUG_SCATTER:
                print('%s. %s' % (inum + 1, self.varSelectAnyRow_Buffer))
            if var.get(): 
                jcountBuffer += 1
                self.listWhichBufferRowsAreChecked.append(
                    inum + 1
                        )
                        
        self.jcountBuffer = jcountBuffer
        
        if DEBUG_SCATTER:
            print('\nlen(self.varSelectAnyRow_Buffer) = %s' % len(self.varSelectAnyRow_Buffer))
            print('\nself.jcountBuffer = %s' % self.jcountBuffer)
        
# display number of rows selected
        self.varEntryNumberOfRowsSelected_Buffer.set(jcountBuffer)
        
# if self.jcountBuffer is zero, show msg and return
        if not self.jcountBuffer and not mappedToplevelXYPlotPreprocess:
            stringNoBufferData = (
                'No buffer data has been selected with which\n' +
                'to update X-Y plots.\n\n' +
                'Select rows from the buffer and try again.'
                )
            print('\n' + stringNoBufferData)
            self.MySQL_Output(
                0,
                stringNoBufferData
                )
            showerror(
                'Error: no update',
                stringNoBufferData,
                parent=self.toplevelShowStorageBuffer
                )
                
            return
        
#        self.varNumberOfStorageBufferCurves.set(self.jcountBuffer)

        if self.jcountBuffer == 0:
            self.plot_X_Buffer = []
            self.plot_Y_Buffer = []
            self.headerNames_Y_Buffer = []
            self.headerNames_X_Buffer = []
            
        else:
        
#        if self.varNumberOfStorageBufferCurves.get() <> 0:
            for indexBufferRow in self.listWhichBufferRowsAreChecked:
                    index=indexBufferRow - 1
                    self.plot_X_Buffer.append(self.bufferRowStore[index][13])
                    self.plot_Y_Buffer.append(self.bufferRowStore[index][14]) 

# define header names taken from buffer
            self.headerNames_Y_Buffer = []
            self.headerNames_X_Buffer = []
            try:
                numBufferCurves = self.varNumberOfStorageBufferCurves.get()
            except:
                numBufferCurves = 0
#        if self.varNumberOfStorageBufferCurves.get():
            if numBufferCurves:
                for indexBufferRow in self.listWhichBufferRowsAreChecked:
                    index=indexBufferRow - 1
                    self.headerNames_Y_Buffer.append(
                        self.bufferRowStore[index][6] + ' (bufr row ' + str(indexBufferRow) + ')'
                        )
                    self.headerNames_X_Buffer.append(
                        self.bufferRowStore[index][5]
                        )

# determine if either X-Y PLOT LABELS window is open
        try:
            if self.varCurvesSelection.get() == 'single':
                mappedSingleOrAllPlotLabels = 'single'
            else:
                mappedSingleOrAllPlotLabels = 'all'
        except:
            mappedSingleOrAllPlotLabels = ''
                        

        if not mappedToplevelXYPlotPreprocess:
# open X-Y Plot Specs window if it did not already exist by
# ... calling handerlPlotPreprocess
#            self.buttonTableValuesPlotFields.invoke()
            self.jcountTable = 0
            self.headerNames_Y_Table = []
            self.headerNames_X_Table = []
        else:
            try:
                mappedToplevelSummarize = self.toplevelSummarize.winfo_exists()
            except: 
                mappedToplevelSummarize = False
            if mappedToplevelSummarize:
                self.toplevelSummarize.destroy()

        self.handlerXYPlotPreprocess()
        
# now regraph the LABELS window if either was previously graphed, 
#   either for 'single' or 'all' plot selection; if not previously
#   graphed, just return
        if mappedSingleOrAllPlotLabels <> '':
            if mappedSingleOrAllPlotLabels == 'single':
                self.varCurvesSelection.set('single')
                self.handlerSelectSingleOrMultiCurvePlots()
            else:
                self.varCurvesSelection.set('all')
                self.handlerSelectSingleOrMultiCurvePlots()
 
        return
            
            
    def handlerUpdateXYPlots_Table_Initialize(self):
        '''
        Purpose:
            initialize the Plotting Specs window; implemented by pressing
            'Plot x-y-Select Fields' button on left side of table in Values for Table window
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerUpdateXYPlots_Table_Initialize')
        
# set last button pressed
        self.lastButtonPressed(
            BUTTONLABEL_XYPLOTS
            )        
        
# check if a table has even been read in 
        emptyTableCheck = self.checkIfEmptyTable()
        if emptyTableCheck:
            return
        
# check if previous window exists
        try:
            mapped = self.toplevelXYPlotPreprocess.winfo_exists()
        except:
            mapped = False

# if previous window exists, ask user if ok to close previous window and start another
        if mapped:
            ans = askokcancel(
                'Initialize plot window',
                'To start a new "X-Y Plot Specs" window, click on OK,\n\n' +
                'This will destroy the old window and initialize a new\n' +
                'window with no Table or Buffer curves specified.\n\n' +
                'Otherwise, click Cancel to continue with the "X-Y Plot\n' +
                'Specs" window as is.',
                parent=self.toplevelXYPlotPreprocess
                )
            if not ans:
                return
                
# if ok to start another, initialize curves and labels
        if mapped:
            self.toplevelXYPlotPreprocess.destroy()
           
# ... following values used in 'handlerXYPlotPreprocess' to set table and buffer curves to zero
        self.jcountTable = 0
        self.jcountBuffer = 0
        self.listWhichBufferRowsAreChecked = []
        
# ... header names
        self.headerNames_Y_Table = []
        self.headerNames_X_Table = []
        
        self.headerNames_Y_Buffer = []
        self.headerNames_X_Buffer = []
        
        self.headerNames_Y = []
        self.headerNames_X = ['']
            
# if any x or y values are checked, go thru 'handlerUpdateXYPlots_Table' instead of here
        count_X = 0
        count_Y = 0
        for var in self.varYSelect:
            if var.get():
                count_Y = 1
                break
        if self.varXSelect.get():
            count_X = 1           
        if (count_X or count_Y):
            self.handlerUpdateXYPlots_Table()
            return
        
# graph Plotting Specs window
        self.handlerXYPlotPreprocess()
        
        return
            
        
    def handlerUpdateXYPlots_Table(self):
        '''
        Purpose: 
            update X-Y Plot Specs window with table selection
            
        Calls:
        
        
        Called by:
            def handlerUpdateXYPlots_Table_Initialize(self)
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerUpdateXYPlots_Table')
            
# check if a table has even been read in 
        emptyTableCheck = self.checkIfEmptyTable()
        if emptyTableCheck:
            return

# if X-Y Plot window exists, do not have to open window
# ... if it does NOT exist, open the X-Y Plot window
        try:
            mappedToplevelXYPlotPreprocess = self.toplevelXYPlotPreprocess.winfo_exists()
        except:
            mappedToplevelXYPlotPreprocess = False
            
# determine which table columns are checked, both X and Y
# get Y headers
        self.jcountTable = 0
# ... determine how many y-values are checked; then, display; also get headers
# ...       note that self.headerNamesY_Table is used in AllCurvesOnOnePlot
        self.headerNames_X_Table = []
        self.headerNames_Y_Table = []
        jindex=1
        try:
            for var in self.varYSelect:
                if var.get():
                    for key,value in self.dictColumnHeaders.iteritems():
                        if value == jindex:
                            self.headerNames_Y_Table.append(key)
                    self.jcountTable += 1
                jindex += 1
        except:
            pass # self.varYSelect not yet defined
            
        if DEBUG_TABLE_VALUES:
            print
            print('-'*50 + '\n')
            print(' self.headerNames_Y_Table = \n')
            print(self.headerNames_Y_Table)
            print('')

        
# get X header
        try:
            index_X = self.varXSelect.get()
        except:
            index_X = None  # self.varXSelect not yet defined
        self.index_X = index_X
# ... now find the key that goes with this index value
        for key,value in self.dictColumnHeaders.iteritems():
            if value == index_X:
                self.headerNames_X_Table.append(key)
                break
                
        if DEBUG_TABLE_VALUES:
            print('')
            print('\n***** #1 handlerUpdateXYPlots_Table *****')
            print('self.headerNames_Y_Table:\n%s' % self.headerNames_Y_Table)
            print('\nself.jcountTable = %s' % self.jcountTable)
            print('\nindex_X = %s' % index_X)
            print('\nself.headerNames_X_Table = %s' % self.headerNames_X_Table)  
            print('self.jcountBuffer = %s' % self.jcountBuffer)
            print('index_X = %s' % index_X)
            print('len(self.tableStructure) = %s' % len(self.tableStructure))
            print('len(self.tableStructure[0]) = ')
            print(len(self.tableStructure[0]))
            print('')
                
        flag_NoYSelect = 0
        flag_NoXSelect = 0
        j=0 
        self.index_Y = []
        try:
            for var in self.varYSelect:
                if var.get():
                    self.index_Y.append(j)       
                j+=1
        except:
            pass    # self.varYSelect not yet defined

#        print '\nself.index_Y = ',self.index_Y
        self.MySQL_Output(
            1,
            ('self.index_Y for plotting:\n%s' % self.index_Y)
            )            
         
        
# ERROR CHECKING   

# check length of index_Y          
        try:
            if len(self.index_Y):
                lenIndex_Y = len(self.index_Y)
            else:  
                lenIndex_Y = 0
        except:
            lenIndex_Y = 0 

# check length of index_X
        try:
            if len(self.index_X):
                lenIndex_X = len(self.index_X)
            else:
                lenIndex_X = 0
        except:
            lenIndex_X = 0
            
        if (
         (not mappedToplevelXYPlotPreprocess)
          and
         lenIndex_Y == 0
          and
         lenIndex_X == 0
         ):
            errorCheck = False
        else:
            errorCheck = True
            
        if errorCheck:    
            if len(self.index_Y) == 0:
# ... no Y-Select values have been chosen; must have at least 1 plot to plot
                flag_NoYSelect=1
            elif len(self.index_Y) > len(self.varYSelect):
# jcount itself is out of bounds
                stringIndexYError = (
                    'len(self.index_Y) error.'
                    )
                print (
                    'Error: ' + stringIndexYError + '\n' + 
                    '   len(self.index_Y) = %s' % len(self.index_Y)
                    )
                self.MySQL_Output(
                    1,
                    'Error: ' + stringIndexYError + '\n\n' +
                    ' len(self.index_Y) = %s' % len(self.index_Y)
                    )
                try:
                    showerror(
                        'Error: IndexYError',
                        '\n' + stringIndexYError + '\n\n' +
                        ' jcount = %s' % jcount,
                        parent=self.toplevelTableValues,
                        )
                except:
                    showerror(
                        'Error: IndexYError',
                        '\n' + stringIndexYError + '\n\n' +
                        ' jcount = %s' % jcount
                        )
                return  

# check for index_X
            if not self.varXSelect.get():
                flag_NoXSelect = 1
            
# print error if both X-Select and Y-Select are blank (no table curves) AND buffer curves are to be plotted but no buffer storage curves are checked
            if (
              (flag_NoXSelect or flag_NoYSelect) 
               and 
              self.jcountBuffer == 0
              ):
                errorStringForXYPlots = 'Error: trying to update X-Y plots'
# ... no X or Y value selected
                if flag_NoXSelect and flag_NoYSelect:
                    stringNoXYSelect = (
                        'No X-Y values have been selected for plotting from\n' +
                        'either the table or the buffer.\n\n' +
                        'Select X-Y values from table or buffer and try again.' 
                        )
                    print '\nError: ' + stringNoXYSelect
                    self.MySQL_Output(
                        1,
                        errorStringForXYPlots + '\n\n' + stringNoXYSelect
                        )
                    try:
                        showerror(
                            errorStringForXYPlots,
                            stringNoXYSelect,
                            parent=self.toplevelShowStorageBuffer,
                            )
                        return
                    except:
                        try:
                            showerror(
                                errorStringForXYPlots,
                                stringNoXYSelect,
                                parent=self.toplevelTableValues,
                                )
                            return
                        except:
                            showerror(
                                errorStringForXYPlots,
                                stringNoXYSelect
                                )
                            return
                        
# ... no X value selected, but Y has been
                if flag_NoXSelect:
                    stringNoXSelect = (
                        'No X value has been selected for plotting for\n' +
                        'the selected Y value(s).\n\n' +
                        'Select an X value and try again.'
                        )
                    print 'Error: ' + stringNoXSelect
                    self.MySQL_Output(
                        1,
                        errorStringForXYPlots + '\n\n'  + stringNoXSelect
                        )
                    try:
                        showerror(
                            errorStringForXYPlots,
                            stringNoXSelect,
                            parent=self.toplevelShowStorageBuffer,
                            )
                        return
                    except:
                        try:
                            showerror(
                                errorStringForXYPlots,
                                stringNoXSelect,
                                parent=self.toplevelTableValues,
                                )
                            return
                        except:
                            showerror(
                                errorStringForXYPlots,
                                stringNoXSelect
                                )
                            return
                            
# ... no Y value selected, but X has been
                if flag_NoYSelect:
                    stringNoYSelect = (
                        'No Y value has been selected for plotting for\n' +
                        'the selected X value.\n\n' +
                        'Select a Y value and try again.' + '\n'
                        )
                    print 'Error: ' + stringNoYSelect
                    self.MySQL_Output(
                        1,
                        errorStringForXYPlots + '\n\n'  + stringNoYSelect
                        )
                    try:
                        showerror(
                            errorStringForXYPlots,
                            stringNoYSelect,
                            parent=self.toplevelShowStorageBuffer,
                            )
                        return
                    except:
                        try:
                            showerror(
                                errorStringForXYPlots,
                                stringNoYSelect,
                                parent=self.toplevelTableValues,
                                )
                            return
                        except:
                            showerror(
                                errorStringForXYPlots,
                                stringNoYSelect
                                )
                            return

# check that the Y-Select values are numerical fields; can't plot text!
            flag_FieldXIsNotNumerical = 0
            
# see which column checkboxes have been checked
            varX = self.varXSelect.get()
#            print ' varX = %s \n' % varX
            self.MySQL_Output(
            1,
            ('varX for plotting:\n%s' % varX)
            )     
            
# find corresponding column number and title            
            for key,columnNumber in self.dictColumnHeaders.iteritems():
                columnHeader = key
                if columnNumber == varX:
# ... get first two characters of column header and check if field is numerical
                    varfirst2 = self.tableStructure[columnNumber-1][1][0:2]
                    fieldXIsNumerical = self.checkIsFieldNumerical(varfirst2)
                    if not fieldXIsNumerical:
# x-select  field is NOT numerical
                        flag_FieldXIsNotNumerical = 1
                        print('\nError: X-Select field "%s" for plotting is not numerical' % key)
                        self.MySQL_Output(
                            1,
                            'Error: X-Select field "%s" for plotting is not numerical' % (key)
                            )
                    else:
# x-select field is numerical, so OK
                        if DEBUG_ISNUMERICALFIELD:
                            print('\nX-Select field "%s" is a numerical field' % key)
                        break

# check that the Y-Select values are numerical fields; can't plot text!
            jcount=0
            flag_FieldYIsNotNumerical = 0
# see which column checkboxes have been checked
            for varY in self.varYSelect:
                jcount+=1
                if varY.get():
# find corresponding column number and title            
                    for key,columnNumber in self.dictColumnHeaders.iteritems():
                        columnHeader = key
                        if columnNumber == jcount:
# when column header is matched with checkbox, get first two characters of datatype and 
#   check if field is numerical
                            varfirst2 = self.tableStructure[jcount-1][1][0:2]
#                        print ' self.tableStructureOriginal = ',self.tableStructureOriginal
                            fieldYIsNumerical = self.checkIsFieldNumerical(varfirst2)
                            if not fieldYIsNumerical:
# y-select field is NOT numerical
                                flag_FieldYIsNotNumerical = 1
                                print('\nError: Y-Select field "%s" for plotting is not numerical' % key)
                                self.MySQL_Output(
                                    1,
                                    'Error: Y-Select field "%s" for plotting is not numerical' % (key)
                                    )
                            else:
# y-select field is numerical, so OK
                                if DEBUG_ISNUMERICALFIELD:
                                    print('\nY-Select field "%s" is a numerical field' % key)

# if X-Select or Y-Select is not numerical, return                            
            if flag_FieldXIsNotNumerical or flag_FieldYIsNotNumerical:
                try:
                    mappedToplevelXYPlotPreprocess = self.toplevelXYPlotPreprocess.winfo_exists()
                except:
                    mappedToplevelXYPlotPreprocess = False
                    
                if mappedToplevelXYPlotPreprocess:
# gray out Plot button in Plotting Specs
                    self.buttonXYPlottingSpecsPlot.configure(state='disabled')
                    
                stringFieldError = ''
                if flag_FieldXIsNotNumerical:
                    stringFieldError+='X-Select field not numerical.' + '\n\n'         
                if flag_FieldYIsNotNumerical:
                    stringFieldError+='Y-Select field(s) not numerical.' + '\n\n'
                stringFieldError+=(
                    'Select numerical fields for both X and Y' + '\n' +
                    '  and try again.'
                    )
                try:
                    showerror(
                        'Error: field(s) not numerical',
                        stringFieldError,
                        parent=self.toplevelTableValues,
                        )
                except:
                    showerror(
                        'Error: field(s) not numerical',
                        stringFieldError
                        )
                return  

# END OF ERROR CHECKING
        

# Default label values if needed, for single curve per plot
  
# ... determine index_Y and label_Y  
        self.label_Y_Table_Default = []
        self.label_X_Table_Default = []
        for index in self.index_Y:
            self.label_Y_Table_Default.append(self.tableStructure[index][0])
# define label_X            
        self.label_X_Table_Default.append(self.tableStructure[index_X - 1][0])
        
        if DEBUG_KIVIAT_TABLE:
            print '\n\nself.label_Y_Table_Default =\n',self.label_Y_Table_Default
            print '\nself.label_X_Table_Default =\n',self.label_X_Table_Default
            print '\nself.index_Y =\n',self.index_Y

# define X and Y data lists
        self.plot_X_Table = []
        self.plot_Y_Table = []
        
# store each row of Y values in a list, and append to master list
# ... this means the first element of each Y list comprises the first curve, 2nd element the 2nd curve, and so on
#        if self.varNumberOfTableCurves.get() <> 0:
        if len(self.index_Y) <> 0:
# define all x values for current table selections
            tempX=[]
            for i in range(len(self.tableValues)):
                tempX.append(self.tableValues[i][index_X - 1])

# define all y values for current table selections
# define columns with j
            for j in range(len(self.index_Y)):
                tempY=[]
# define rows with i
                for i in range(len(self.tableValues)):
                    tempY.append(self.tableValues[i][self.index_Y[j]])
                self.plot_Y_Table.append(tempY) 
                self.plot_X_Table.append(tempX)
            
        if mappedToplevelXYPlotPreprocess:
            try:
                mappedToplevelSummarize = self.toplevelSummarize.winfo_exists()
            except:
                mappedToplevelSummarize = False
            if mappedToplevelSummarize:
                self.toplevelSummarize.destroy()                

# refresh X-Y Plot Specs window
        self.handlerXYPlotPreprocess()
        
        if clearSelectionsFromTable_XY:
# clear X and Y entries from table
            self.handlerClearAllY()
            self.handlerDeselectX()
            
# clear selected rows
#            for var in self.varSelectAnyRow:
#                var.set(0)
           
        return
        
        
    def handlerUpdateScatterPlots_Buffer(self):
        '''
        Purpose: 
            update Scatter Plot Specs window with buffer selection
            
        Called by:
            def handlerUpdatePlotWindow_Buffer(self)
            
        Calls:
            self.handlerScatterPlotPreprocess()
        
        '''            
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerUpdateScatterPlots_Buffer')
            
# if Scatter Plot window exists, do not have to open window
# ... if it does NOT exist, open the X-Y Plot window
        try:
            mappedToplevelScatterPlotPreprocess = self.toplevelScatterPlotPreprocess.winfo_exists()
        except:
            mappedToplevelScatterPlotPreprocess = False
            
        self.plot_X_Buffer_Scatter = []
        self.plot_Y_Buffer_Scatter = []
        
        jcountBuffer = 0
        self.jcountBuffer_Scatter = 0
        self.listWhichBufferRowsAreChecked_Scatter = []

# determine how many rows are checked and create a list of checked rows  
        if DEBUG_SCATTER:
            print('\n#   self.varSelectAnyRow_Buffer.get()')
        for (inum,var) in enumerate(self.varSelectAnyRow_Buffer):
            if DEBUG_SCATTER:
                print('%s. %s' % (inum + 1, self.varSelectAnyRow_Buffer))
            if var.get(): 
                jcountBuffer += 1
                self.listWhichBufferRowsAreChecked_Scatter.append(
                    inum + 1
                        )
                        
        self.jcountBuffer_Scatter = jcountBuffer
        
        if DEBUG_SCATTER:
            print('\nlen(self.varSelectAnyRow_Buffer) = %s' % len(self.varSelectAnyRow_Buffer))
            print('\nself.jcountBuffer_Scatter = %s' % self.jcountBuffer_Scatter)
        
# display number of rows selected
        self.varEntryNumberOfRowsSelected_Buffer.set(jcountBuffer)
        
# if self.jcountBuffer_Scatter is zero, show msg and return
        if not self.jcountBuffer_Scatter and not mappedToplevelScatterPlotPreprocess:
            stringNoBufferData = (
                'No buffer data has been selected with which\n' +
                'to update Scatter plots.\n\n' +
                'Select rows from the buffer and try again.'
                )
            print('\n' + stringNoBufferData)
            self.MySQL_Output(
                0,
                stringNoBufferData
                )
            showerror(
                'Error: no update',
                stringNoBufferData,
                parent=self.toplevelShowStorageBuffer
                )
                
            return
        
#        self.varNumberOfStorageBufferCurves.set(self.jcountBuffer)

        if self.jcountBuffer_Scatter == 0:
            self.plot_X_Buffer_Scatter = []
            self.plot_Y_Buffer_Scatter = []
            self.headerNames_Y_Buffer_Scatter = []
            self.headerNames_X_Buffer_Scatter = []
          
        else:
        
#        if self.varNumberOfStorageBufferCurves.get() <> 0:
            for indexBufferRow in self.listWhichBufferRowsAreChecked_Scatter:
                    index=indexBufferRow - 1
                    self.plot_X_Buffer_Scatter.append(self.bufferRowStore[index][13])
                    self.plot_Y_Buffer_Scatter.append(self.bufferRowStore[index][14]) 

# define header names taken from buffer
            self.headerNames_Y_Buffer_Scatter = []
            self.headerNames_X_Buffer_Scatter = []
            try:
                numBufferCurves = self.varNumberOfStorageBufferCurves.get()
            except:
                numBufferCurves = 0
#        if self.varNumberOfStorageBufferCurves.get():
            if numBufferCurves:
                for indexBufferRow in self.listWhichBufferRowsAreChecked_Scatter:
                    index=indexBufferRow - 1
                    self.headerNames_Y_Buffer_Scatter.append(
                        self.bufferRowStore[index][6] + ' (bufr row ' + str(indexBufferRow) + ')'
                        )
                    self.headerNames_X_Buffer_Scatter.append(
                        self.bufferRowStore[index][5]
                        )

# determine if either SCATTER PLOT or STATS window is open
        if not mappedToplevelScatterPlotPreprocess:
            self.jcountTable_Scatter = 0
            self.headerNames_Y_Table_Scatter = []
            self.headerNames_X_Table_Scatter = []
        else:
            try:
                mappedToplevelSummarize = self.toplevelSummarize.winfo_exists()
            except: 
                mappedToplevelSummarize = False
            if mappedToplevelSummarize:
                self.toplevelSummarize.destroy()
                
        self.handlerScatterPlotPreprocess()
 
        return
            
        
        
    def handlerUpdateScatterPlots_Table_Initialize(self):
        '''
        Purpose:
            initialize the Scatter Plot Specs window; implemented by pressing
            'Scatter Plots' button on left side of table in Values for Table window
            
        Called by:
            def displayMainButtonGroup(self, flag)
            
        Calls:
            def handlerUpdateScatterPlots_Table(self)
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerUpdateScatterPlots_Table_Initialize')
        
# check if a table has even been read in 
        emptyTableCheck = self.checkIfEmptyTable()
        if emptyTableCheck:
            return
        
# check if previous window exists
        try:
            mapped = self.toplevelScatterPlotPreprocess.winfo_exists()
        except:
            mapped = False

# if previous window exists, ask user if ok to close previous window and start another
        if mapped:
            ans = askokcancel(
                'Initialize plot window',
                'To start a new "Scatter Plot Plotting Specs" window, click on OK,\n\n' +
                'This will destroy the old window and initialize a new\n' +
                'window with no Table or Buffer curves specified.\n\n' +
                'Otherwise, click Cancel to continue with the "Scatter Plot Specs"\n' +
                'window as is.',
                parent=self.toplevelScatterPlotPreprocess
                )
            if not ans:
                return
                
# if ok to start another, initialize curves and labels
        if mapped:
            self.toplevelScatterPlotPreprocess.destroy()
           
# ... following values used in 'handlerScatterPlotPreprocess' to set table and buffer curves to zero
        self.jcountTable_Scatter = 0
        self.jcountBuffer_Scatter = 0
        self.listWhichBufferRowsAreChecked_Scatter = []
        
# ... header names
        self.headerNames_Y_Table_Scatter = []
        self.headerNames_X_Table_Scatter = []
        
        self.headerNames_Y_Buffer_Scatter = []
        self.headerNames_X_Buffer_Scatter = []
        
        self.headerNames_Y_Scatter = []
        self.headerNames_X_Scatter = ['']
            
# if any x or y values are checked, go thru 'handlerUpdateScatterPlots_Table' instead of here
        count_X = 0
        count_Y = 0
        for var in self.varYSelect:
            if var.get():
                count_Y = 1
                break
        if self.varXSelect.get():
            count_X = 1           
        if (count_X or count_Y):
            self.handlerUpdateScatterPlots_Table()
            return
        
# graph Plotting Specs window
        self.handlerScatterPlotPreprocess()
        
        return

            
    def handlerUpdateScatterPlots_Table(self):
        '''
        Purpose: 
            update Scatter Plot Specs window with table selection
            
        Calls:
        
        Called by:
            def handlerUpdateScatterPlots_Table_Initialize(self)
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerUpdateScatterPlots_Table')
            
# check if a table has even been read in 
        emptyTableCheck = self.checkIfEmptyTable()
        if emptyTableCheck:
            return

# if Scatter Plot window exists, do not have to open window
# ... if it does NOT exist, open the Scatter Plot window
        try:
            mappedToplevelScatterPlotPreprocess = self.toplevelScatterPlotPreprocess.winfo_exists()
        except:
            mappedToplevelScatterPlotPreprocess = False
            
# determine which table columns are checked, both X and Y
# get Y headers
        self.jcountTable_Scatter = 0
# ... determine how many y-values are checked; then, display; also get headers
# ...       note that self.headerNamesY_Table is used in AllCurvesOnOnePlot
        self.headerNames_X_Table_Scatter = []
        self.headerNames_Y_Table_Scatter = []
        jindex=1
        try:
            for var in self.varYSelect:
                if var.get():
                    for key,value in self.dictColumnHeaders.iteritems():
                        if value == jindex:
                            self.headerNames_Y_Table_Scatter.append(key)
                    self.jcountTable_Scatter += 1
                jindex += 1
        except:
            pass # self.varYSelect not yet defined
            
        if DEBUG_TABLE_VALUES:
            print
            print('-'*50 + '\n')
            print(' self.headerNames_Y_Table_Scatter = \n') 
            print(self.headerNames_Y_Table_Scatter)
            print('')

        
# get X header
        try:
            index_X = self.varXSelect.get()
        except:
            index_X = None  # self.varXSelect not yet defined
        self.index_X_Scatter = index_X
# ... now find the key that goes with this index value
        for key,value in self.dictColumnHeaders.iteritems():
            if value == index_X:
                self.headerNames_X_Table_Scatter.append(key)
                break
                
        if DEBUG_TABLE_VALUES:
            print('')
            print('\n***** #1 handlerUpdateScatterPlots_Table *****')
            print('self.headerNames_Y_Table_Scatter:\n%s' % self.headerNames_Y_Table_Scatter)
            print('\nself.jcountTable_Scatter = %s' % self.jcountTable_Scatter)
            print('\nindex_X = %s' % index_X)
            print('\nself.headerNames_X_Table = %s' % self.headerNames_X_Table_Scatter)  
            print('self.jcountBuffer_Scatter = %s' % self.jcountBuffer_Scatter)
            print('index_X = %s' % index_X)
            print('len(self.tableStructure) = %s' % len(self.tableStructure))
            print('len(self.tableStructure[0]) = ')
            print(len(self.tableStructure[0]))
            print('')
                
        flag_NoYSelect = 0
        flag_NoXSelect = 0
        j=0 
        self.index_Y_Scatter = []
        try:
            for var in self.varYSelect:
                if var.get():
                    self.index_Y_Scatter.append(j)       
                j+=1
        except:
            pass    # self.varYSelect not yet defined

        print '\nself.index_Y_Scatter = ',self.index_Y_Scatter
        self.MySQL_Output(
            1,
            ('self.index_Y_Scatter for plotting:\n%s' % self.index_Y_Scatter)
            )            
         
        
# ERROR CHECKING   
            
# check length of index_Y          
        try:
            if len(self.index_Y_Scatter):
                lenIndex_Y = len(self.index_Y_Scatter)
            else:  
                lenIndex_Y = 0
        except:
            lenIndex_Y = 0 
            
# check length of index_X
        try:
            if len(self.index_X_Scatter):
                lenIndex_X = len(self.index_X_Scatter)
            else:
                lenIndex_X = 0
        except:
            lenIndex_X = 0
            
        if (
         (not mappedToplevelScatterPlotPreprocess)
          and
         lenIndex_Y == 0
          and
         lenIndex_X == 0
         ):
            errorCheck = False
        else:
            errorCheck = True
            
        if errorCheck:    
            if len(self.index_Y_Scatter) == 0:
# ... no Y-Select values have been chosen; must have at least 1 plot to plot
                flag_NoYSelect=1
            elif len(self.index_Y_Scatter) > len(self.varYSelect):
# jcount itself is out of bounds
                stringIndexYError = (
                    'len(self.index_Y) error.'
                    )
                print (
                    'Error: ' + stringIndexYError + '\n' + 
                    '   len(self.index_Y) = %s' % len(self.index_Y)
                    )
                self.MySQL_Output(
                    1,
                    'Error: ' + stringIndexYError + '\n\n' +
                    ' len(self.index_Y) = %s' % len(self.index_Y)
                    )
                try:
                    showerror(
                        'Error: IndexYError',
                        '\n' + stringIndexYError + '\n\n' +
                        ' jcount = %s' % jcount,
                        parent=self.toplevelTableValues,
                        )
                except:
                    showerror(
                        'Error: IndexYError',
                        '\n' + stringIndexYError + '\n\n' +
                        ' jcount = %s' % jcount
                        )
                return  

# check for index_X
            if not self.varXSelect.get():
                flag_NoXSelect = 1
            
# print error if both X-Select and Y-Select are blank (no table curves) AND buffer curves are to be plotted but no buffer storage curves are checked
            if (
              (flag_NoXSelect or flag_NoYSelect) 
               and 
              self.jcountBuffer_Scatter == 0
              ):
                errorStringForScatterPlots = 'Error: trying to update Scatter plots'
# ... no X or Y value selected
                if flag_NoXSelect and flag_NoYSelect:
                    stringNoXYSelect = (
                        'No X-Y values have been selected for plotting from\n' +
                        'either the table or the buffer.\n\n' +
                        'Select X-Y values from table or buffer and try again.' 
                        )
                    print '\nError: ' + stringNoXYSelect
                    self.MySQL_Output(
                        1,
                        errorStringForScatterPlots + '\n\n' + stringNoXYSelect
                        )
                    try:
                        showerror(
                            errorStringForScatterPlots,
                            stringNoXYSelect,
                            parent=self.toplevelShowStorageBuffer,
                            )
                        return
                    except:
                        try:
                            showerror(
                                errorStringForScatterPlots,
                                stringNoXYSelect,
                                parent=self.toplevelTableValues,
                                )
                            return
                        except:
                            showerror(
                                errorStringForScatterPlots,
                                stringNoXYSelect
                                )
                            return
                        
# ... no X value selected, but Y has been
                if flag_NoXSelect:
                    stringNoXSelect = (
                        'No X value has been selected for plotting for\n' +
                        'the selected Y value(s).\n\n' +
                        'Select an X value and try again.'
                        )
                    print 'Error: ' + stringNoXSelect
                    self.MySQL_Output(
                        1,
                        errorStringForScatterPlots + '\n\n' + stringNoXSelect
                        )
                    try:
                        showerror(
                            errorStringForScatterPlots,
                            stringNoXSelect,
                            parent=self.toplevelShowStorageBuffer,
                            )
                        return
                    except:
                        try:
                            showerror(
                                errorStringForScatterPlots,
                                stringNoXSelect,
                                parent=self.toplevelTableValues,
                                )
                            return
                        except:
                            showerror(
                                errorStringForScatterPlots,
                                stringNoXSelect
                                )
                            return

# ... no Y value selected, but X has been
                if flag_NoYSelect:
                    stringNoYSelect = (
                        'No Y value has been selected for plotting for\n' +
                        'the selected X value.\n\n' +
                        'Select a Y value and try again.' + '\n'
                        )
                    print 'Error: ' + stringNoYSelect
                    self.MySQL_Output(
                        1,
                        errorStringForScatterPlots + '\n\n' + stringNoYSelect
                        )
                    try:
                        showerror(
                            errorStringForScatterPlots,
                            stringNoYSelect,
                            parent=self.toplevelShowStorageBuffer,
                            )
                        return
                    except:
                        try:
                            showerror(
                                errorStringForScatterPlots,
                                stringNoYSelect,
                                parent=self.toplevelTableValues,
                                )
                            return
                        except:
                            showerror(
                                errorStringForScatterPlots,
                                stringNoYSelect
                                )
                            return

# check that the Y-Select values are numerical fields; can't plot text!
            flag_FieldXIsNotNumerical = 0
            
# see which column checkboxes have been checked
            varX = self.varXSelect.get()
            print ' varX = %s \n' % varX
            
# find corresponding column number and title            
            for key,columnNumber in self.dictColumnHeaders.iteritems():
                columnHeader = key
                if columnNumber == varX:
# ... get first two characters of column header and check if field is numerical
                    varfirst2 = self.tableStructure[columnNumber-1][1][0:2]
                    fieldXIsNumerical = self.checkIsFieldNumerical(varfirst2)
                    if not fieldXIsNumerical:
# x-select  field is NOT numerical
                        flag_FieldXIsNotNumerical = 1
                        print('\nError: X-Select field "%s" for plotting is not numerical' % key)
                        self.MySQL_Output(
                            1,
                            'Error: X-Select field "%s" for plotting is not numerical' % (key)
                            )
                    else:
# x-select field is numerical, so OK
                        print('\nX-Select field "%s" is a numerical field' % key)
                        break

# check that the Y-Select values are numerical fields; can't plot text!
            jcount=0
            flag_FieldYIsNotNumerical = 0
# see which column checkboxes have been checked
            for varY in self.varYSelect:
                jcount+=1
                if varY.get():
# find corresponding column number and title            
                    for key,columnNumber in self.dictColumnHeaders.iteritems():
                        columnHeader = key
                        if columnNumber == jcount:
# when column header is matched with checkbox, get first two characters of datatype and 
#   check if field is numerical
                            varfirst2 = self.tableStructure[jcount-1][1][0:2]
#                        print ' self.tableStructureOriginal = ',self.tableStructureOriginal
                            fieldYIsNumerical = self.checkIsFieldNumerical(varfirst2)
                            if not fieldYIsNumerical:
# y-select field is NOT numerical
                                flag_FieldYIsNotNumerical = 1
                                print('\nError: Y-Select field "%s" for plotting is not numerical' % key)
                                self.MySQL_Output(
                                    1,
                                    'Error: Y-Select field "%s" for plotting is not numerical' % (key)
                                    )
                            else:
# y-select field is numerical, so OK
                                if DEBUG_ISNUMERICALFIELD:
                                    print('\nY-Select field "%s" is a numerical field' % key)

# if X-Select or Y-Select is not numerical, return                            
            if flag_FieldXIsNotNumerical or flag_FieldYIsNotNumerical:
                try:
                    mappedToplevelScatterPlotPreprocess = self.toplevelScatterPlotPreprocess.winfo_exists()  
                except:
                    mappedToplevelScatterPlotPreprocess = False
                
                if mappedToplevelScatterPlotPreprocess:
# gray out Plot button in Plotting Specs 
                    self.buttonScatterPlottingSpecsPlot.configure(state='disabled')
                    
                stringFieldError = ''
                if flag_FieldXIsNotNumerical:
                    stringFieldError+='X-Select field not numerical.' + '\n\n'         
                if flag_FieldYIsNotNumerical:
                    stringFieldError+='Y-Select field(s) not numerical.' + '\n\n'
                stringFieldError+=(
                    'Select numerical fields for both X and Y' + '\n' +
                    '  and try again.'
                    )
                try:
                    showerror(
                        'Error: field(s) not numerical',
                        stringFieldError,
                        parent=self.toplevelTableValues,
                        )
                except:
                    showerror(
                        'Error: field(s) not numerical',
                        stringFieldError
                        )
                return  

# END OF ERROR CHECKING
        

# Default label values if needed, for single curve per plot
  
# ... determine index_Y and label_Y  
        self.label_Y_Table_Default_Scatter = []
        self.label_X_Table_Default_Scatter = []
        for index in self.index_Y_Scatter:
            self.label_Y_Table_Default_Scatter.append(self.tableStructure[index][0])
# define label_X            
        self.label_X_Table_Default_Scatter.append(self.tableStructure[self.index_X_Scatter - 1][0])
        
        if DEBUG_KIVIAT_TABLE:
            print '\n\nself.label_Y_Table_Default_Scatter =\n',self.label_Y_Table_Default_Scatter
            print '\nself.label_X_Table_Default_Scatter =\n',self.label_X_Table_Default_Scatter
            print '\nself.index_Y =\n',self.index_Y_Scatter

# define X and Y data lists
        self.plot_X_Table_Scatter = []
        self.plot_Y_Table_Scatter = []
        
# store each row of Y values in a list, and append to master list
# ... this means the first element of each Y list comprises the first curve, 2nd element the 2nd curve, and so on
#        if self.varNumberOfTableCurves.get() <> 0:
        if len(self.index_Y_Scatter) <> 0:
# define all x values for current table selections
            tempX=[]
            for i in range(len(self.tableValues)):
                tempX.append(self.tableValues[i][self.index_X_Scatter - 1])

# define all y values for current table selections
# define columns with j
            for j in range(len(self.index_Y_Scatter)):
                tempY=[]
# define rows with i
                for i in range(len(self.tableValues)):
                    tempY.append(self.tableValues[i][self.index_Y_Scatter[j]])
                self.plot_Y_Table_Scatter.append(tempY) 
                self.plot_X_Table_Scatter.append(tempX)
            
        if mappedToplevelScatterPlotPreprocess:
            try:
                mappedToplevelSummarize = self.toplevelSummarize.winfo_exists()
            except:
                mappedToplevelSummarize = False
            if mappedToplevelSummarize:
                self.toplevelSummarize.destroy()                

# refresh Scatter Plot Specs window
        self.handlerScatterPlotPreprocess()
        
        if clearSelectionsFromTable_Scatter:
# clear X and Y entries from table
            self.handlerClearAllY()
            self.handlerDeselectX()   
            
# clear any selected rows in table
#            for var in self.varSelectAnyRow:
#                var.set(0)
           
        return
        
        
# BAR CHARTS

    def handlerUpdateBarCharts_Buffer(self):
        '''
        Purpose: 
            update the Bar Chart Plot Specs window from buffer
        '''   
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerUpdateBarCharts_Buffer')
            
# check if a table has even been read in 
        emptyTableCheck = self.checkIfEmptyTable()
        if emptyTableCheck:
            return
            
# not yet implemented
        self.notYetImplemented()
        
        return

    def handlerUpdateBarCharts_Table_Initialize(self):
        '''
        Purpose: 
            initialize the Bar Chart Plot Specs window; implemented by pressing
            'Bar Chart Plots' button on left side of table in Values for Table window
        '''   
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerUpdateBarCharts_Table_Initialize')
            
# check if a table has even been read in 
        emptyTableCheck = self.checkIfEmptyTable()
        if emptyTableCheck:
            return
            
# not yet implemented
        self.notYetImplemented()
        
        return
        

    def handlerUpdateBarCharts_Table(self):
        '''
        Purpose: 
            update Bar Chart Plot Specs window with table selection
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerUpdateBarCharts_Table')
            
# check if a table has even been read in 
        emptyTableCheck = self.checkIfEmptyTable()
        if emptyTableCheck:
            return
            
# not yet implemented
        self.notYetImplemented()
        
        return

 
        
    def handlerConnectAfterPassword(self, event):
        '''
        Purpose:
            Connect to MySQL server after entering password just by
        hitting Enter
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerConnectAfterPassword')
        
        self.buttonConnectToMySQL.invoke()
        
        return
        
        
    def handlerContinueForStorageBuffer(self, event):
        '''
        Purpose:
            Continue with entering values into storage buffer
            after hitting Enter
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerContinueForStorageBuffer')
        
        self.buttonContinueToStorageBuffer.invoke()
        
        return
        
    def handlerTableValuesAutoSort_Buffer(self):
        '''
        Purpose:
            sort buffer rows
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerTableValuesAutoSort_Buffer')

# Checks        
# ... if no rows available, say so and return
        if self.bufferRowStore_NumRows == 0:
            stringNoRowsAvailable = (
                'Storage Buffer is empty.\n\n' +
                'No rows are available to sort.'
                )
            print stringNoRowsAvailable
            self.MySQL_Output(
                0,
                stringNoRowsAvailable
                )
            try:
                showerror(
                    'Error: no rows available',
                    stringNoRowsAvailable,
                    parent=self.toplevelShowStorageBuffer
                    )
            except:
                showerror(
                    'Error: no rows available',
                    stringNoRowsAvailable
                    )
            return
# end of Checks
        
# if no index, print error msg and return
        if self.varFieldSelectBuffer.get() == 0:
            stringIndexError = (
                'No column index has been selected in the Storage Buffer window.\n\n' +
                'Select a column and try again.'
                )
            print stringIndexError
            self.MySQL_Output(
                0,
                stringIndexError
                )
            showerror(
                'Error: no index',
                stringIndexError
                )
            return
            
        try:
            index = self.varFieldSelectBuffer.get() - 1            
        except:
            stringIndexUndefined = (
                'Column index in Storage Buffer is undefined.'
                )
            print stringIndexUndefined
            self.MySQL_Output(
                0,
                stringIndexUndefined
                )
            showerror(
                'Error: column index undefined',
                stringIndexUndefined
                )
            return
# sort
        self.bufferRowStore = self.sortFieldsInBufferStorage(self.bufferRowStore,index)
        print
        print 'index =',index
        print 'New buffer:\n',self.bufferRowStore
        print
# refresh buffer view
        self.handlerDisplayStorageBufferValues_Call()
        
        return
        
        
    def handlerTableValuesClear_Buffer(self):
        '''
        Purpose:
            clear Storage Buffer
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerTableValuesClear_Buffer')
        
# Checks        
# ... if no rows available, say so and return
        if self.bufferRowStore_NumRows == 0:
            stringNoRowsAvailable = (
                'Storage Buffer is empty.\n\n' +
                'No rows are available to clear.'
                )
            print stringNoRowsAvailable
            self.MySQL_Output(
                0,
                stringNoRowsAvailable
                )
            try:
                showerror(
                    'Error: no rows available',
                    stringNoRowsAvailable,
                    parent=self.toplevelShowStorageBuffer
                    )
            except:
                showerror(
                    'Error: no rows available',
                    stringNoRowsAvailable
                    )
            return
# end of Checks
        
# finally, check with user
        okay = askokcancel(
            'Warning: buffer deletion',
            'WARNING!\n\n' + 
            'Entire buffer will be deleted.\n\n' +
            'Click \'ok\' to continue.'
            )
        if not okay:
            return
# set lists to empty
        self.bufferRowStore = []
        self.bufferRowStore_NumRows = 0
        self.varSelectAnyRow_Buffer = []
        self.buffer_xWindowLocation = self.toplevelShowStorageBuffer.winfo_rootx() - self.offsetWindowX
        self.buffer_yWindowLocation = self.toplevelShowStorageBuffer.winfo_rooty() - self.offsetWindowY
# destroy storage buffer window
#        self.toplevelShowStorageBuffer.destroy()
# refresh storage buffer display
#        self.buttonTableValuesShowAll_Buffer.invoke()
        self.handlerRefreshBufferView()

# refresh plot window if open            
        self.handlerInvokeButtonToRefreshPlotXYWindow()
# display new total in main table window
        self.countDisplayStorageBuffer.set(
            'BUFFER: Display (0 rows)'
            )
# show empty buffer msg     
        try:
            showinfo(
                'Info: empty buffer',
                'Storage buffer is empty',
                parent=self.toplevelShowStorageBuffer
                )
        except:
            showinfo(
                'Info: empty buffer',
                'Storage buffer is empty'
                )

        return
        
        
    def sortFieldsInBufferStorage(self, list, field):
        '''
        Purpose:
            sort rows in Storage Buffer by user-selected field
            
        Usage:
            new_table = sort(old_table, field)
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'sortFieldsInBufferStorage')
        
        res = []
        for x in list:
            i = 0
            for y in res:
#                if x[field] <= y[field]: break
                if x[field] < y[field]: break
                i += 1
            res[i:i] = [x]
        return res
        
        
    def handlerPrintVar(self):
        '''
        Purpose:
            print self.varFieldSelectBuffer
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerPrintVar')
        
        print(
            '\n self.varFieldSelectBuffer.get()= %s\n' % self.varFieldSelectBuffer.get()
            )
        
        return
        
        
    def handlerHideShowUserFields_Buffer(self):
        '''
        Purpose:
            Hide or show user fields in Storage Buffer.
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerHideShowUserFields_Buffer')
        
        print '====='
        print 'self.varHideShowSet.get() = %s' % self.varHideShowSet.get()
        print '====='
#  get which rows have been selected ; to be restored below after Storage Buffer is displayed again
        indexStore = []
        icount = 0
# ... Note: there may be no rows if a file has just been unpickled
        try:
            for var in self.varSelectAnyRow_Buffer:
                if var.get(): 
                    indexStore.append(icount)
                icount += 1
        except:
            pass

        if self.varHideShowSet.get() == 0:
            self.displayStorageBufferValues(0)
            self.varTextForHideShowFields_Buffer.set('Hide\nuser fields')
        elif self.varHideShowSet.get() == 1:
            self.displayStorageBufferValues(5)
            self.varTextForHideShowFields_Buffer.set('Show\nuser fields')
        else:
# value not valid for self.varCleareSet
            stringErrorVarHideShowSet = (
                'Invalid value for "self.varHideShowSet.get()".\n' +
                '  self.varHideShowSet.get() = %s\n' + 
                'Cause is unknown. Please report this to code administrator.'
                % self.varHideShowSet.get()
                )
            print stringErrorVarHideShowSet
            self.MySQL_Output(
                0,
                stringErrorVarHideShowSet.get()
                )
            showerror(
                'Error: invalid value',
                stringErrorVarHideShowSet.get()
                )
                
# restore which rows have been selected
        for index in indexStore:
            self.varSelectAnyRow_Buffer[index].set(1)     

# show value in "number of selected rows" counter
        self.varEntryNumberOfRowsSelected_Buffer.set(
            len(indexStore)
            )
               
#        print '++++++++++++++++++'
#        print 'self.varHideShowSet.get() = %s' % self.varHideShowSet.get()
#        print '++++++++++++++++++'
        
        return
        
        
    def handlerExtractAndFill(self):
        '''
        Purpose:
            to extract data from a field that contains a data file
            (probably in YAML format, but can be in other formats) and 
            fill in the database table with the data; fields that do not 
            exist are automatically created using a special form of the 
            MySQL INSERT statement
            
        variables:
            self.dictColumnHeaders              list of current column headings
            self.dictColumnHeadersOriginal      list of all column headings
        '''
# let user know where we are
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerExtractAndFill')
            
# set last button pressed
        self.lastButtonPressed(
            BUTTONLABEL_EXTRACTDATAANDFILLTABLE
            )
            
# check if a table has even been read in 
        emptyTableCheck = self.checkIfEmptyTable()
        if emptyTableCheck:
            return

# check if connected to a MySQL server; if not, say so and return
        self.checkMySQLConnection()
        if self.connectionFlag == 0: return
        
# set background color
        colorbg = 'lightblue'

# get list of keys for 'Select column to extract from' combobox; don't sort in place, 
#   so that list will correspond with table headers
        self.listEnumerateHeaders = []
        for iSequence in range(len(self.dictColumnHeaders)):
            for (k,v) in self.dictColumnHeaders.iteritems():
                if k <> 'auto_index' and v == (iSequence + 1):
                    self.listEnumerateHeaders.append(str(v) + '. ' + k)

        if DEBUG_EXTRACT_FILL_YAML:
            print('\n self.dictColumnHeaders: \n%s' % self.dictColumnHeaders)
            print('\n self.listEnumerateHeaders = \n%s' % (self.listEnumerateHeaders))

# toplevel
        frameParent = self.toplevelTableValues

# destroy any old toplevel frames
        try:
            self.toplevelExtractAndFill.destroy()
            self.MySQL_Output(
            1,
            'Previous toplevel widget removed from screen.'
            )
        except: 
            self.MySQL_Output(
            1,
            'No previous toplevel widget to remove from screen.'
            )
# open Toplevel frame for entering database name
        self.toplevelExtractAndFill = Toplevel(
            frameParent,
            bg=colorbg
            )
        self.toplevelExtractAndFill.title(
            'Server: ' + self.comboServerMySQL.get() + '     ' +
            'Database: ' + self.myDatabase + '     ' +
            'Table: ' + self.myTable
            )
            
        self.toplevelExtractAndFill.transient(frameParent)
# place the top window
# ... absolute location
        '''
        x_Windows=50
        y_Windows=50
        self.toplevelChartBarAdjust.geometry(
            '+%d+%d' % (x_Windows, y_Windows)
            )
        '''
# ... relative location, relative to parent frame
        offsetX = 100
        offsetY = 50
        locX = self.toplevelTableValues.winfo_rootx() + offsetX
        locY = self.toplevelTableValues.winfo_rooty() + offsetY
        self.toplevelExtractAndFill.geometry(
            '+%d+%d' % (locX, locY)
            )
            
# add frames to toplevel   
# ... frame_00: title    
        Row = 0
        frame_00 = Frame(
            self.toplevelExtractAndFill,
            bg=colorbg,
            )
        frame_00.grid(
            row=Row,
            column=0,
#            sticky=E+W,
            )
# frame for select table column to extract from
        Row += 1
        frame_01 = Frame(
            self.toplevelExtractAndFill,
            bg=colorbg,
            )
        frame_01.grid(
            row=Row,
            column=0,
            padx=5,
            pady=0,
            sticky=W,
            )
# ... title - select table
        frame_01_00 = Frame(
            frame_01,
            bg=colorbg,
            )
        frame_01_00.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            sticky=W,
            )
# ... column # / column header
        frame_01_10 = Frame(
            frame_01,
            bg=colorbg,
            )
        frame_01_10.grid(
            row=1,
            column=0,
            padx=10,
            pady=0,
            sticky=W,
            )
# frame for choosing which rows to select (all or some)
        Row += 1
        frame_02 = Frame(
            self.toplevelExtractAndFill,
            bg=colorbg,
            )
        frame_02.grid(
            row=Row,
            column=0,
            padx=5,
            pady=10,
            sticky=W,
            )
# ... label
        frame_02_00 = Frame(
            frame_02,
            bg=colorbg,
            )
        frame_02_00.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            sticky=W,
            )
# ... all rows or selected rows
        frame_02_10 = Frame(
            frame_02,
            bg=colorbg,
            )
        frame_02_10.grid(
            row=1,
            column=0,
            padx=10,
            pady=0,
            sticky=W,
            )

# ... frame_05:  label for 'Choose protocol...'
        Row += 1
        frame_05 = Frame(
            self.toplevelExtractAndFill,
            bg=colorbg,
            )
        frame_05.grid(
            row=Row,
            column=0,
            padx=5,
            pady=0,
            sticky=W,
            )
        Row += 1
# ... frame_10:  choose YAML file protocol
        frame_10 = Frame(
            self.toplevelExtractAndFill,
            bg=colorbg,
            )
        frame_10.grid(
            row=Row,
            column=0,
            padx=10,
            pady=0,
            sticky=W,
            )
# ... frame_12:  choose unPickle file protocol
        ''' to be implemented if needed
        frame_12 = Frame(
            self.toplevelExtractAndFill,
            bg=colorbg,
            )
        frame_12.grid(
            row=3,
            column=0,
            padx=5,
            pady=5,
            sticky=W,
            )
        '''
# ... frame_14:  choose TEXT file protocol - uses alphanumeric search
#                   or regular expressions to find and extract data
# ...   label
        Row += 1
        frame_14 = Frame(
            self.toplevelExtractAndFill,
            bg=colorbg,
            )
        frame_14.grid(
            row=Row,
            column=0,
            padx=10,
            pady=0,
            sticky=W,
            )
# ...   choose which protocol: text-based or using regular expressions
        Row += 1
        frame_16 = Frame(
            self.toplevelExtractAndFill,
            bg=colorbg,
            )
        frame_16.grid(
            row=Row,
            column=0,
            padx=10,
            pady=0,
            sticky=W,
            )
# ... search all lines or limited range
        frame_16_00 = Frame(
            frame_16,
            bg=colorbg,
            )
        frame_16_00.grid(
            row=0,
            column=0,
            padx=30,
            pady=0,
            sticky=W,
            )
# ...       subframe
        frame_16_00_10 = Frame(
            frame_16_00,
            bg=colorbg,
            )
        frame_16_00_10.grid(
            row=0,
            column=0,
            padx=30,
            pady=0,
            sticky=W,
            )
        self.frame_16_00_20 = Frame(
            frame_16_00,
            bg=colorbg,
            )
        self.frame_16_00_20.grid(
            row=1,
            column=0,
            padx=30,
            pady=0,
            sticky=W,
            )
        frame_16_00_30 = Frame(
            frame_16_00,
            bg=colorbg,
            )
        frame_16_00_30.grid(
            row=2,
            column=0,
            padx=30,
            pady=0,
            sticky=W,
            )
# ...   frame for alphanumeric search
        frame_16_10 = Frame(
            frame_16,
            bg=colorbg,
            )
        frame_16_10.grid(
            row=1,
            column=0,
            padx=30,
            pady=5,
            sticky=W,
            )
# ...       frame for "Extract alphanumeric data ..."
        frame_16_10_00 = Frame(
            frame_16_10,
            bg=colorbg,
            )
        frame_16_10_00.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            sticky=W,
            )
# ...       frame for immediately following, preceding, or equal to
        frame_16_10_10 = Frame(
            frame_16_10,
            bg=colorbg,
            )
        frame_16_10_10.grid(
            row=1,
            column=0,
            padx=30,
            pady=0,
            sticky=W,
            )
# ...       frame for "nth occurrence" and "stop extracting"
        frame_16_10_20 = Frame(
            frame_16_10,
            bg=colorbg,
            )
        frame_16_10_20.grid(
            row=2,
            column=0,
            padx=30,
            pady=0,
            sticky=W,
            )
            
# ...   frame for regular expression search
        frame_16_20 = Frame(
            frame_16,
            bg=colorbg,
            )
        frame_16_20.grid(
            row=2,
            column=0,
            padx=30,
            pady=5,
            sticky=W,
            )
# ...       frame for "Extract using Python's ..."
# ...       frame for text to show example
# ...       frame for regular expression entry
        frame_16_20_00 = Frame(
            frame_16_20,
            bg=colorbg,
#            relief=RIDGE,
#            borderwidth=3,
            )
        frame_16_20_00.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            sticky=W,
            )           
        frame_16_20_10 = Frame(
            frame_16_20,
            bg=colorbg,
#            relief=RIDGE,
#            borderwidth=3,
            )
        frame_16_20_10.grid(
            row=1,
            column=0,
            padx=30,
            pady=0,
            sticky=W,
            )          
        frame_16_20_20 = Frame(
            frame_16_20,
            bg=colorbg,
#            relief=RIDGE,
#            borderwidth=3,
            )
        frame_16_20_20.grid(
            row=2,
            column=0,
            padx=30,
            pady=0,
            sticky=W,
            ) 

        '''
# ...   entry widget for regular expression
# ... frame_20: select table column to extract from
# ...   label
        Row += 1
        frame_20 = Frame(
            self.toplevelExtractAndFill,
            bg=colorbg,
#            relief=RIDGE,
#            borderwidth=3,
            )
        frame_20.grid(
            row=Row,
            column=0,
            padx=5,
            pady=10,
            sticky=W,
            )  
# ...   label: select column ...
        frame_20_00 = Frame(
            frame_20,
            bg=colorbg,
#            relief=RIDGE,
#            borderwidth=3,
            )
        frame_20_00.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            sticky=W,
            )
# ...   combobox: column # / column header combobox
        frame_20_10 = Frame(
            frame_20,
            bg=colorbg,
#            relief=RIDGE,
#            borderwidth=3,
            )
        frame_20_10.grid(
            row=1,
            column=0,
            padx=5,
            pady=0,
            sticky=W,
            )  
        '''

# frame_30: Widgets for 'Extract & Fill' and 'Cancel' buttons
        Row += 1
        frame_30 = Frame(
            self.toplevelExtractAndFill,
            bg=colorbg,
            )
        frame_30.grid(
            row=99,
            column=0,
            padx=5,
            pady=10,
            )
            
# WIDGETS
        
# ... frame_00: title
        stringTitle = (
            'EXTRACT & FILL TABLE\n' +
            'using selected column from which to extract data'
            )
        labelExtractAndFillTitle = Label(
            frame_00,
            text=stringTitle,
            font=self.titleFont,
            bg=colorbg,
            justify=CENTER,
            )
        labelExtractAndFillTitle.grid(
            row=0,
            column=0,
            padx=5,
            pady=5,
            )
# ... frame 01: select table column to extract from
        stringTableParametersTitle = (
            '1. SELECT TABLE COLUMN TO EXTRACT FROM:'
            )
        labelTableParametersTitle = Label(
            frame_01_00,
            text=stringTableParametersTitle,
            bg=colorbg,
            justify=LEFT,
            )
        labelTableParametersTitle.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            sticky=W,
            )
        self.comboboxExtractAndFillTableColumn = Pmw.ComboBox(
            frame_01_10,
            scrolledlist_items=self.listEnumerateHeaders,
            selectioncommand = self.updateXSelectFromExtractAndFill,
            dropdown=1,
            label_text='Column # / Column Header:',
            labelpos='w',
            entry_state='disabled',
#            entry_state='normal',
            entry_width=30,
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            label_background=colorbg,
            scrolledlist_vscrollmode = 'static',
            scrolledlist_hull_width=500,
            )
        self.comboboxExtractAndFillTableColumn.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            sticky=W,
            )
# scrollbars
#        self.comboboxExtractAndFillTableColumn.component('scrolledlist').configure(
#            vscrollmode='static'
#            )

# ... frame 02: extract all or select rows
        stringExtractAllOrSelectRows = (
#            'Extract from selected column using:'
            '2. EXTRACT FROM SELECTED COLUMN USING:'
            )
        labelExtractAllOrSelectRows = Label(
            frame_02_00,
            text=stringExtractAllOrSelectRows,
            bg=colorbg,
            justify=LEFT,
            )
        labelExtractAllOrSelectRows.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            sticky=W,
            )
            
        self.varButtonExtractAllOrSelectRows = StringVar()
        self.varButtonExtractAllOrSelectRows.set(
            'all'
            )
            
        buttonExtractAll = Radiobutton(
            frame_02_10,
            text='All rows in table',
            bg=colorbg,
            variable=self.varButtonExtractAllOrSelectRows,
            value='all',
            )
        buttonExtractAll.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            sticky=W,
            )
            
        buttonExtractDisplayedRows = Radiobutton(
            frame_02_10,
            text='Displayed rows only',
            bg=colorbg,
            variable=self.varButtonExtractAllOrSelectRows,
            value='displayed',
            )
        buttonExtractDisplayedRows.grid(
            row=1,
            column=0,
            padx=0,
            pady=0,
            sticky=W,
            )
            
        buttonExtractSelectRows = Radiobutton(
            frame_02_10,
            text='Selected rows only',
            bg=colorbg,
            variable=self.varButtonExtractAllOrSelectRows,
            value='select',
            )
        buttonExtractSelectRows.grid(
            row=2,
            column=0,
            padx=0,
            pady=0,
            sticky=W,
            )
            
# ... frame_05: label for 'Choose protocol...'            
        stringProtocolTitle = (
#            'Choose protocol for extracting data from the table field:'
            '3. CHOOSE PROTOCOL FOR EXTRACTING DATA FROM THE TABLE FIELD:'
            )
        labelProtocolTitle = Label(
            frame_05,
            text=stringProtocolTitle,
            bg=colorbg,
            )
        labelProtocolTitle.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            sticky=W,
            )
            
# ... frame_10:  choose file protocol (YAML, other (used for future protocols))
        self.varRadiobuttonProtocol = StringVar()
        self.varRadiobuttonProtocol.set(
            'yaml'
            )
        self.radiobuttonProtocolYaml = Radiobutton(
            frame_10,
            text=(
                'YAML - created by yaml.dump(); extracts all data to table;\n' +
                '    auto-creates table fields using assignment names in data'
                ),
            bg=colorbg,
            variable=self.varRadiobuttonProtocol,
            command=self.handlerProtocolYaml,
            value='yaml',
            )
        self.radiobuttonProtocolYaml.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            sticky=W,
            )
        ''' to be implemented if needed
        self.radiobuttonProtocolUnPickle = Radiobutton(
            frame_12,
            text='unPickle (created by Python\'s "pickle")',
            bg=colorbg,
            variable=self.varRadiobuttonProtocol,
            value='unpickle',
            state=DISABLED,
            )
        self.radiobuttonProtocolUnPickle.grid(
            row=2,
            column=0,
            padx=20,
            pady=0,
            sticky=W,
            )
        '''
        self.radiobuttonProtocolTextLineByLine = Radiobutton(
            frame_14,
            text=(
                'TEXT - read each selected column\'s fields line-by-line;\n' +
                '       search for data to extract using following methods:'
                ),
            bg=colorbg,
            variable=self.varRadiobuttonProtocol,
            command=self.handlerPickPossibleColumnForTextFile,
            value='text',
            )
        self.radiobuttonProtocolTextLineByLine.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            sticky=W,
            )
            
            
# ...       search all lines or limited range

        label = Label(
            frame_16_00_10,
            text='Search:  ',
            bg=colorbg,
            )
        label.grid(
            row=0,
            column=0,
            rowspan=2,
            padx=0,
            pady=0,
            sticky=W,
            )

# ...       search all lines
        self.varSearchAllLinesOrLimitedRange = StringVar()
        self.varSearchAllLinesOrLimitedRange.set('all') # 'all' or 'limited'
        self.radiobuttonExtractAndFill_SearchAll = Radiobutton(
            frame_16_00_10,
            text='All lines of each field',
            bg=colorbg,
            variable=self.varSearchAllLinesOrLimitedRange,
            value='all',
            )
        self.radiobuttonExtractAndFill_SearchAll.grid(
            row=0,
            column=1,
            columnspan=99,
            padx=0,
            pady=0,
            sticky=W,
            )
#        self.radiobuttonExtractAndFill_SearchAll.configure(state=DISABLED)
        
# ...       search limited range
        self.radiobuttonExtractAndFill_SearchLimited = Radiobutton(
            frame_16_00_10,
            text='Lines',
            bg=colorbg,
            variable=self.varSearchAllLinesOrLimitedRange,
            value='limited',
            command=self.handlerExtractAndFill_SearchLimited
            )
        self.radiobuttonExtractAndFill_SearchLimited.grid(
            row=1,
            column=1,
            padx=0,
            pady=0,
            sticky=W,
            )
#        self.radiobuttonExtractAndFill_SearchLimited.configure(state=DISABLED)
        
        self.comboboxExtractAndFill_SearchLimited_Start = Pmw.ComboBox(
            frame_16_00_10,
            scrolledlist_items=self.scrolledlistExtractAndFill_SearchLimited_Start,
            listheight=150,
            label_text='(START) to line',
            labelpos='e',
            label_background=colorbg,
#            entry_state='disabled',
#            entry_disabledbackground='white',  # this is set elsewhere
            entry_disabledforeground='black',
            entry_width=5,
            scrolledlist_hull_width=500,
            )
        self.comboboxExtractAndFill_SearchLimited_Start.grid(
            row=1,
            column=2,
            padx=0,
            pady=0,
            )
#        self.comboboxExtractAndFill_SearchLimited_Start.configure(entry_state='disabled')   
            
        self.comboboxExtractAndFill_SearchLimited_End = Pmw.ComboBox(
            frame_16_00_10,
            scrolledlist_items=self.scrolledlistExtractAndFill_SearchLimited_End,
            listheight=150,
            label_text='(END) of each field',
            labelpos='e',
            label_background=colorbg,
#            entry_state='disabled',
#            entry_disabledbackground='white',  # this is set elsewhere
            entry_disabledforeground='black',
            entry_width=5,
            scrolledlist_hull_width=500,
            )
        self.comboboxExtractAndFill_SearchLimited_End.grid(
            row=1,
            column=3,
            padx=0,
            pady=0,
            )
#        self.comboboxExtractAndFill_SearchLimited_End.configure(entry_state='disabled')
        
# ...   insert extracted data into new or existing column
# ...       named
        label = Label(
            self.frame_16_00_20,
            text='Extract data to column:',
            bg=colorbg,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            sticky=E,
            )
            
        self.comboboxExtractAndFill_ColumnNameToExtractTo = Pmw.ComboBox(
            self.frame_16_00_20,
            scrolledlist_items=self.listEnumerateHeaders,
            selectioncommand = self.handlerExtractAndFill_ColumnNameToExtractTo,
            dropdown=1,
#            label_text='Extract data to column:',
#            labelpos='w',
#            entry_state='disabled',
#            entry_state='normal',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            entry_width=20,
#            label_background=colorbg,
            scrolledlist_hull_width=500,
            )
        self.comboboxExtractAndFill_ColumnNameToExtractTo.grid(
            row=0,
            column=1,
#            columnspan=1,
            padx=0,
            pady=0,
            sticky=W,
            )
#        self.comboboxExtractAndFill_ColumnNameToExtractTo.configure(
#            entry_state='disabled',
#            entry_disabledbackground=?,
#            entry_disabledforeground=?
#            )
            
# ...       create new field for extracted data
        self.buttonExtractAndFill_CreateNewField = Button(
            self.frame_16_00_20,
            text='Create new field',
            width=15,
            font=self.buttonFontSmall,
            borderwidth=3,
            relief=RAISED,
            background='white',
            foreground='blue',
            command=self.handlerButtonExtractAndFill_CreateNewField,
            )
        self.buttonExtractAndFill_CreateNewField.grid(
            row=0,
            column=2,
            columnspan=2,
            padx=10,
            pady=0,
            )
#        self.buttonExtractAndFill_CreateNewField.configure(state=DISABLED)
        
# ...       with datatype
        label = Label(
            self.frame_16_00_20,
            text='having datatype:',
            bg=colorbg,
            )
        label.grid(
            row=1,
            column=0,
            padx=0,
            pady=0,
            sticky=E,
            )
            
        self.varEntryExtractAndFill_ColumnNameToExtractTo_Datatype = StringVar()
        self.entryExtractAndFill_ColumnNameToExtractTo_Datatype = Entry(
            self.frame_16_00_20,
            width=20,
            textvariable=self.varEntryExtractAndFill_ColumnNameToExtractTo_Datatype,
#            disabledbackground='white',
#            disabledforeground='black',
#            state=DISABLED,
#            state=NORMAL,
            )
        self.entryExtractAndFill_ColumnNameToExtractTo_Datatype.grid(
            row=1,
            column=1,
            padx=0,
            pady=0,
            sticky=W,
            )
#        self.entryExtractAndFill_ColumnNameToExtractTo_Datatype.configure(state=DISABLED)
        
        '''
        self.comboboxExtractAndFill_ColumnNameToExtractTo_Datatype = Pmw.ComboBox(
            self.frame_16_00_20,
            scrolledlist_items=self.fieldDataTypes,
            listheight=150,
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            entry_width=20,
            selectioncommand=self.handlerExtractAndFill_ColumnNameToExtractTo_Datatype,
            scrolledlist_hull_width=500,
            )
        self.comboboxExtractAndFill_ColumnNameToExtractTo_Datatype.grid(
            row=1,
            column=1,
            padx=0,
            pady=0,
            sticky=W,
            )
        '''
        '''    
        label = Label(
            self.frame_16_00_20,
            text='of length:',
            bg=colorbg,
            )
        label.grid(
            row=1,
            column=2,
            padx=0,
            pady=0,
            sticky=E,
            )
            
        self.varEntryExtractAndFill_ColumnNameToExtractTo_Length = StringVar()
        self.entryExtractAndFill_ColumnNameToExtractTo_Length = Entry(
            self.frame_16_00_20,
            width=10,
            textvariable=self.varEntryExtractAndFill_ColumnNameToExtractTo_Length,
#            disabledbackground='white',
#            disabledforeground='black',
#            state=DISABLED,
#            state=NORMAL,
            )
        self.entryExtractAndFill_ColumnNameToExtractTo_Length.grid(
            row=1,
            column=3,
            padx=0,
            pady=0,
            sticky=W,
            )
#        self.entryExtractAndFill_ColumnNameToExtractTo_Length.configure(state=DISABLED)
        '''
        
# ...       label         
        labelColumnNameDanger = Label(
            self.frame_16_00_20,
            text=(
                'Can be new or existing column.\n' +
                'WARNING: data in existing column will be overwritten!!'
                ),
            bg=colorbg,
            justify=LEFT,
            )
        labelColumnNameDanger.grid(
            row=3,
            column=0,
            columnspan=99,
            padx=0,
            pady=0,
            sticky=W,
            )
            
            
# ...       nth occurrence of word
        labelThe = Label(
            frame_16_00_30,
            text='Use the',
            bg=colorbg,
            )
        labelThe.grid(
            row=0,
            column=0,
            padx=10,
            pady=0,
            sticky=E,
            )
            
        self.comboboxExtractAndFill_NthOccurrence = Pmw.ComboBox(
            frame_16_00_30,
            scrolledlist_items=self.scrolledlistExtractAndFill_NthOccurrences,
            listheight=150,
            label_text='-th occurrence of a matched expression',
            label_background=colorbg,
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            labelpos='e',
            entry_width=5,
            scrolledlist_hull_width=500,
            )
        self.comboboxExtractAndFill_NthOccurrence.grid(
            row=0,
            column=1,
            columnspan=99,
            padx=0,
            pady=0,
            sticky=W,
            )
        self.comboboxExtractAndFill_NthOccurrence.setentry(
            self.scrolledlistExtractAndFill_NthOccurrences[0]
            )
#        self.comboboxExtractAndFill_NthOccurrence.configure(
#            entry_state='disabled',
#            entry_disabledbackground='??',
#            entry_disabledforeground='??'
#            )
            
# ...       extract data by text search
        self.varChooseWhichTextProtocol = StringVar()
        self.varChooseWhichTextProtocol.set('extract_regex')
        self.radiobuttonProtocolAlphanumeric = Radiobutton(
            frame_16_10_00,
            text='Extract alphanumeric data ...',
            bg=colorbg,
            variable=self.varChooseWhichTextProtocol,
            value='extract_alphanumeric',
            command=self.notYetImplemented,
            )
        self.radiobuttonProtocolAlphanumeric.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            sticky=W,
            )
#        self.radiobuttonProtocolAlphanumeric.configure(state=DISABLED)
        
# ... immediately folloiwng, preceding, or equal to
        self.varLocationOfTextToExtract = StringVar()
        self.varLocationOfTextToExtract.set('following')
        self.radiobuttonLocation_Following = Radiobutton(
            frame_16_10_10,
            text='immediately following',
            bg=colorbg,
            variable=self.varLocationOfTextToExtract,
            value='following',
            )
        self.radiobuttonLocation_Following.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            sticky=W,
            )
#        self.radiobuttonLocation_Following.configure(state=DISABLED)
            
        self.radiobuttonLocation_Preceding = Radiobutton(
            frame_16_10_10,
            text='immediately preceding',
            bg=colorbg,
            variable=self.varLocationOfTextToExtract,
            value='preceding',
            )
        self.radiobuttonLocation_Preceding.grid(
            row=1,
            column=0,
            padx=0,
            pady=0,
            sticky=W,
            )
#        self.radiobuttonLocation_Preceding.configure(state=DISABLED)
            
        self.radiobuttonLocation_Equal = Radiobutton(
            frame_16_10_10,
            text='equal to',
            bg=colorbg,
            variable=self.varLocationOfTextToExtract,
            value='equal',
            )
        self.radiobuttonLocation_Equal.grid(
            row=2,
            column=0,
            padx=0,
            pady=0,
            sticky=W,
            )
#        self.radiobuttonLocation_Equal.configure(state=DISABLED)
        
        labelContinued = Label(
            frame_16_10_20,
            text='     a phrase containing the words',
            bg=colorbg,
            )
        labelContinued.grid(
            row=1,
            column=1,
            padx=0,
            pady=0,
            sticky=E,
            )
            
        self.varEntryExtractAndFill_NthOccurrence = StringVar()
        self.entryExtractAndFill_NthOccurrence = Entry(
            frame_16_10_20,
            width=30,
            textvariable=self.varEntryExtractAndFill_NthOccurrence,
            )
        self.entryExtractAndFill_NthOccurrence.grid(
            row=1,
            column=2,
            padx=0,
            pady=0,
            sticky=W,
            )
 #       self.entryExtractAndFill_NthOccurrence.configure(state=DISABLED)
        
        self.comboboxExtractAndFill_StopExtracting = Pmw.ComboBox(
            frame_16_10_20,
            scrolledlist_items=self.scrolledlistExtractAndFill_StopExtractingDelimiter,
            listheight=100,
            entry_width=20,
            label_text='     and stop extracting when following delimiter is found:',
            labelpos='w',
            label_background=colorbg,
            scrolledlist_hull_width=500,
            )
        self.comboboxExtractAndFill_StopExtracting.grid(
            row=2,
            column=0,
            columnspan=99,
            padx=0,
            pady=0,
            sticky=W,
            )
        self.comboboxExtractAndFill_StopExtracting.setentry(
            self.scrolledlistExtractAndFill_StopExtractingDelimiter[0]
            )
 #       self.comboboxExtractAndFill_StopExtracting.configure(
 #           entry_state='disabled'
 #           )
            
# ...       extract data using regular expressions
        self.radiobuttonProtocolRegex = Radiobutton(
            frame_16_20_00,
            text=(
                'Extract using Python\'s "Regular Expressions" module\n'
                ),
            bg=colorbg,
            variable=self.varChooseWhichTextProtocol,
            value='extract_regex',
            )
        self.radiobuttonProtocolRegex.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
#            sticky=W,
            )
 #       self.radiobuttonProtocolRegex.configure(state=DISABLED)
            
# ...           example using regular expression
        labelExample = Label(
            frame_16_20_10,
            text=(
                'Use 1 pair of parentheses to save desired pattern\n' +
                'for table insertion.\n' +
                '  Example 1: [a-zA-Z0-9]:\s+\d+.\d+[x|X](\d+.\d+)x\d+.\d+ \n' +
                '  Example 2: result:\s+\d+.\d+[x|X](\d+.\d+)x\d+.\d+ \n' +
                'Both extract the string "60.3" from a line containing \n' +
                'the following: "end result:   10.5x60.3x100.7"'
                ),
            bg=colorbg,
            justify=LEFT,
            )
        labelExample.grid(
            row=0,
            column=0,
            padx=5,
            pady=0,
            sticky=W,
            )
            
        labelEntry = Label(
            frame_16_20_20,
            text='Regular expression:',
            bg=colorbg,
            )
        labelEntry.grid(
            row=0,
            column=0,
            padx=5,
            pady=5,
            sticky=W,
            )  
            
        self.varEntryExtractAndFill_RegularExpression = StringVar()
        self.entryExtractAndFill_RegularExpression = Entry(
            frame_16_20_20,
            width=50,
            textvariable=self.varEntryExtractAndFill_RegularExpression,
#            disabledbackground='gray',
            )
        self.entryExtractAndFill_RegularExpression.grid(
            row=0,
            column=1,
            padx=0,
            pady=5,
            sticky=W,
            )
 #       self.entryExtractAndFill_RegularExpression.configure(state=DISABLED)
                   
# ... frame_30: Widgets for 'Extract & Fill' and 'Cancel'
        buttonExtractAndFill = Button(
            frame_30,
            text='Extract & Fill',
            bg='white',
            fg='blue',
            borderwidth=5,
            relief=RAISED,
            width=20,
            command=self.handlerExtractDataAndFillTable_OneFieldAtATime,
#            command=self.handlerExtractDataAndFillTable_AllFieldsAtOnce,
            )
        buttonExtractAndFill.grid(
            row=0,
            column=0,
            padx=5,
            pady=10,
            )
            
        buttonExtractAndFillCancel = Button(
            frame_30,
            text='Cancel',
            borderwidth=5,
            relief=RAISED,
            width=20,
            command=self.handlerExtractAndFillCancel,
            )
        buttonExtractAndFillCancel.grid(
            row=0,
            column=1,
            padx=5,
            pady=10,
            )
            
# set default values for window
        self.handlerProtocolYaml()
            
        return
        
        
    def handlerExtractAndFill_ColumnNameToExtractTo_Datatype(self,datatype):
        '''
        Purpose:
            fill in the datatype length entry
        
        Notes:
        
        # DATATYPES and their max lengths
        # 1     BIGINT            255     opt     integer number range: -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807
        # 2     CHAR              255     req'd   max: 255 characters
        # 3     DATE              b       b       input: YYYY-MM-DD; storage format: YYY-MM-DD
        # 4     DECIMAL           255     opt     stores fixed-point numbers
        # 5     DOUBLE            b       opt     stores floating point numbers
        # 6     FLOAT             b       opt     stores floating point numbers
        # 7     INTEGER           255     opt     range: -2,147,483,648 to 2,147,483,647
        # 8     INTEGER UNSIGNED  255     opt     range: 0 to 4,294,967,295
        # 9     LONGTEXT          b       b       upto 4GB
        # 10    MEDIUMTEXT        b       b       up to 16MB
        # 11    SMALLINT          255     opt     integer number range: -32,768 to 32,767
        # 12    SMALLINT_UNSIGNED 255     opt     integer number range: 0 to 65500
        # 13    TEXT              b       b       max: 65500 bytes
        # 14    TIME              b       b       input: DD HH:MM:SS; storage format: HHH:MM:SS 
        # 15    TIMESTAMP         b       b       input: YYYY-MM-DD HH:MM:SS; storage format: YYY-MM-DD HH:MM:SS; assign NULL to set current date and time
        # 16    TINYTEXT          b       b       max: 255 bytes
        # 17    VARCHAR           65500   req'd   max: 65500 characters   
        '''

        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerFieldName_Datatype')
            
# clear entry field
        self.varEntryExtractAndFill_ColumnNameToExtractTo_Length.set('')

# update idletasks or else fields won't be 'observably' blanked, since these tasks aren't
#   apparently updated until the 'return' statement is encountered         
        self.toplevelExtractAndFill.update_idletasks()
        
# set field to normal; in case of error finding a datatype, user can set length
        self.entryExtractAndFill_ColumnNameToExtractTo_Length.configure(state=NORMAL)
          
# set default values
# ... 0. bigint
        if datatype == 'BIGINT':
            self.varEntryExtractAndFill_ColumnNameToExtractTo_Length.set(
                self.dictFieldDataTypesLength['setvalue_BIGINT']
                )
            if  self.varRadiobuttonProtocol.get() == 'text':
                self.entryExtractAndFill_ColumnNameToExtractTo_Length.configure(state=NORMAL)
            else:
                self.entryExtractAndFill_ColumnNameToExtractTo_Length.configure(state=DISABLED)
# ... 1. char
        elif datatype == 'CHAR':
#            self.varFieldName_Length[numField].setvalue('Width: max 255 chars')
            self.varEntryExtractAndFill_ColumnNameToExtractTo_Length.set(
                self.dictFieldDataTypesLength['setvalue_CHAR']
                )
            if  self.varRadiobuttonProtocol.get() == 'text':
                self.entryExtractAndFill_ColumnNameToExtractTo_Length.configure(state=NORMAL)
            else:
                self.entryExtractAndFill_ColumnNameToExtractTo_Length.configure(state=DISABLED)    
# ... 2. date                
        elif datatype == 'DATE':
#            self.varFieldName_Length[numField].setvalue('<\'YYYY-MM-DD\'>')
            self.varEntryExtractAndFill_ColumnNameToExtractTo_Length.set(
                self.dictFieldDataTypesLength['setvalue_DATE']
                )
            self.entryExtractAndFill_ColumnNameToExtractTo_Length.configure(state=DISABLED)
# ... 3. decimal                
        elif datatype == 'DECIMAL':
#            self.varFieldName_Length[numField].setvalue('10,5')
            self.varEntryExtractAndFill_ColumnNameToExtractTo_Length.set(
                self.dictFieldDataTypesLength['setvalue_DECIMAL']
                )
            if  self.varRadiobuttonProtocol.get() == 'text':
                self.entryExtractAndFill_ColumnNameToExtractTo_Length.configure(state=NORMAL)
            else:
                self.entryExtractAndFill_ColumnNameToExtractTo_Length.configure(state=DISABLED)
# ... 4. double               
        elif datatype == 'DOUBLE':
#            self.varFieldName_Length[numField].setvalue('20,5')
            self.varEntryExtractAndFill_ColumnNameToExtractTo_Length.set(
                self.dictFieldDataTypesLength['setvalue_DOUBLE']
                )
            self.entryExtractAndFill_ColumnNameToExtractTo_Length.configure(state=DISABLED)
# ... 5. float                
        elif datatype == 'FLOAT':
#            self.varFieldName_Length[numField].setvalue('20,5')
            self.varEntryExtractAndFill_ColumnNameToExtractTo_Length.set(
                self.dictFieldDataTypesLength['setvalue_FLOAT']
                )
            self.entryExtractAndFill_ColumnNameToExtractTo_Length.configure(state=DISABLED)
# ... 6. integer                
        elif datatype == 'INTEGER':
#            self.varFieldName_Length[numField].setvalue('5')
            self.varEntryExtractAndFill_ColumnNameToExtractTo_Length.set(
                self.dictFieldDataTypesLength['setvalue_INTEGER']
                )
            if  self.varRadiobuttonProtocol.get() == 'text':
                self.entryExtractAndFill_ColumnNameToExtractTo_Length.configure(state=NORMAL)
            else:
                self.entryExtractAndFill_ColumnNameToExtractTo_Length.configure(state=DISABLED)
# ... 7. integer unsigned                
        elif datatype == 'INTEGER UNSIGNED':
#            self.varFieldName_Length[numField].setvalue('10')
            self.varEntryExtractAndFill_ColumnNameToExtractTo_Length.set(
                self.dictFieldDataTypesLength['setvalue_INTEGER_UNSIGNED']
                )
            if  self.varRadiobuttonProtocol.get() == 'text':
                self.entryExtractAndFill_ColumnNameToExtractTo_Length.configure(state=NORMAL)
            else:
                self.entryExtractAndFill_ColumnNameToExtractTo_Length.configure(state=DISABLED)
# ... 8. longtext                
        elif datatype == 'LONGTEXT':
            self.varEntryExtractAndFill_ColumnNameToExtractTo_Length.set(
                self.dictFieldDataTypesLength['setvalue_LONGTEXT']
                )
            self.entryExtractAndFill_ColumnNameToExtractTo_Length.configure(state=DISABLED)
# ... 9. mediumtext                
        elif datatype == 'MEDIUMTEXT':
            self.varEntryExtractAndFill_ColumnNameToExtractTo_Length.set(
                self.dictFieldDataTypesLength['setvalue_MEDIUMTEXT']
                )
            self.entryExtractAndFill_ColumnNameToExtractTo_Length.configure(state=DISABLED)
# ... 10. smallint               
        elif datatype == 'SMALLINT':
            self.varEntryExtractAndFill_ColumnNameToExtractTo_Length.set(
                self.dictFieldDataTypesLength['setvalue_SMALLINT']
                )
            if  self.varRadiobuttonProtocol.get() == 'text':
                self.entryExtractAndFill_ColumnNameToExtractTo_Length.configure(state=NORMAL)
            else:
                self.entryExtractAndFill_ColumnNameToExtractTo_Length.configure(state=DISABLED)
# ... 11. smallint unsigned                
        elif datatype == 'SMALLINT UNSIGNED':
            self.varEntryExtractAndFill_ColumnNameToExtractTo_Length.set(
                self.dictFieldDataTypesLength['setvalue_SMALLINT_UNSIGNED']
                )
            if  self.varRadiobuttonProtocol.get() == 'text':
                self.entryExtractAndFill_ColumnNameToExtractTo_Length.configure(state=NORMAL)
            else:
                self.entryExtractAndFill_ColumnNameToExtractTo_Length.configure(state=DISABLED)
# ... 12. text                
        elif datatype == 'TEXT':
            self.varEntryExtractAndFill_ColumnNameToExtractTo_Length.set(
                self.dictFieldDataTypesLength['setvalue_TEXT']
                )
            self.entryExtractAndFill_ColumnNameToExtractTo_Length.configure(state=DISABLED)
# ... 13. time                
        elif datatype == 'TIME':
            self.varEntryExtractAndFill_ColumnNameToExtractTo_Length.set(
                self.dictFieldDataTypesLength['setvalue_TIME']
                )
            self.entryExtractAndFill_ColumnNameToExtractTo_Length.configure(state=DISABLED)
# ... 14. timestamp                
        elif datatype == 'TIMESTAMP':
            self.varEntryExtractAndFill_ColumnNameToExtractTo_Length.set(
                self.dictFieldDataTypesLength['setvalue_TIMESTAMP']
                )
            self.entryExtractAndFill_ColumnNameToExtractTo_Length.configure(state=DISABLED)
# ... 15. tinytext               
        elif datatype == 'TINYTEXT':
            self.varEntryExtractAndFill_ColumnNameToExtractTo_Length.set(
                self.dictFieldDataTypesLength['setvalue_TINYTEXT']
                )
            self.entryExtractAndFill_ColumnNameToExtractTo_Length.configure(state=DISABLED)
# ... 16. varchar                
        elif datatype == 'VARCHAR':
            self.varEntryExtractAndFill_ColumnNameToExtractTo_Length.set(
                self.dictFieldDataTypesLength['setvalue_VARCHAR']
                )
            if  self.varRadiobuttonProtocol.get() == 'text':
                self.entryExtractAndFill_ColumnNameToExtractTo_Length.configure(state=NORMAL)
            else:
                self.entryExtractAndFill_ColumnNameToExtractTo_Length.configure(state=DISABLED)
# ... error if here
        else:
# datatype has not been specified; output error messages
            stringNoDatatype = (
                'The following datatype has no defined default length.\n\n' +
                '   datatype = %s\n\n' +
                'This is a coding error.\n\n' +
                'Please contact code administrator to correct this problem.'
                ) % datatype
            print(stringNoDatatype)
            self.MySQL_Output(
                0,
                '\n' + stringNoDatatype
                )   
            showerror(
                'Error: no datatype',
                stringNoDatatype
                )
                
        return
        
        
    def handlerButtonExtractAndFill_CreateNewField(self):
        '''
        Purpose:
            Add new field on the fly to the 'Extract & Fill Table'
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerButtonExtractAndFill_CreateNewField')
        
#        self.buttonDatabaseFieldsAdd.invoke()
        self.handlerDatabaseFieldsAdd()
        
# re-form self.listEnumerateHeaders
        self.listEnumerateHeaders = []
        for iSequence in range(len(self.dictColumnHeaders)):
            for (k,v) in self.dictColumnHeaders.iteritems():
                if k <> 'auto_index' and v == (iSequence + 1):
                    self.listEnumerateHeaders.append(str(v) + '. ' + k)
                    
# re-graph combobox for column (not needed for datatype)
# ... column
        self.comboboxExtractAndFill_ColumnNameToExtractTo = Pmw.ComboBox(
            self.frame_16_00_20,
            scrolledlist_items=self.listEnumerateHeaders,
            selectioncommand = self.handlerExtractAndFill_ColumnNameToExtractTo,
            dropdown=1,
#            label_text='Extract data to column:',
#            labelpos='w',
            entry_state='disabled',
#            entry_state='normal',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            entry_width=20,
#            label_background=colorbg,
            scrolledlist_hull_width=500,
            )
        self.comboboxExtractAndFill_ColumnNameToExtractTo.grid(
            row=0,
            column=1,
#            columnspan=1,
            padx=0,
            pady=0,
            sticky=W,
            )
        
# clear column and datatype fields
        self.comboboxExtractAndFill_ColumnNameToExtractTo.setentry('')
        self.varEntryExtractAndFill_ColumnNameToExtractTo_Datatype.set('')
        
        return
        
        
    def handlerExtractAndFill_ColumnNameToExtractTo(self,enumeratedHeader):
        '''
        Purpose:
            When column selected exists, fill in datatype and length
            from table structure data; gray out datatype and length
            
            If column selected does NOT exist, let datatype and length
            fields be white bg so user is led to select from drop-down menu
        '''
        
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerExtractAndFill_ColumnNameToExtractTo')
        
# search thru column headers
        '''
        headerColumn, headerElect = \
            self.comboboxExtractAndFill_ColumnNameToExtractTo.get().split('.')
        headerElect = headerElect.strip()
        '''
        
        headerColumn, headerElect = enumeratedHeader.split('.')
        
        header,datatype,d,d,d,d = self.tableStructure[eval(headerColumn) - 1]
        
        print('header, datatype = %s, %s' % (header, datatype))
        
# set datatype field to datatype of column
        self.varEntryExtractAndFill_ColumnNameToExtractTo_Datatype.set(
            datatype
            )
        
        return
        
        
    def handlerProtocolYaml(self):
        '''
        Purpose:
            Looks for field in table that has yaml-formatted data; calculates
            index for that field.
            Also, since yaml has been selected, this method disables all widgets
            associated with the option for searching for text fields.
        '''
        
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerProtocolYaml')
  
# check to see if an X-Select radiobutton has been selected; if not, try and let PylotDB choose;
#   if that doesn't work, keep it blank
        index_X = self.varXSelect.get()
        if index_X <> 0 and index_X <> '':
            if DEBUG_EXTRACT_FILL_YAML:
                print('\nManually selected: index_X = %s' % index_X)
        elif index_X == 0 or index_X == '':
# cycle thru upto first five rows (that's all!) of DISPLAYED (not ORIGINAL) table to see if 
#   any entries were written using yaml.dump() format; if we check just one row, it might happen
#   that the row has an empty yaml field, thus giving us a false reading that checking more than one row 
#   might correct
            numColumns = len(self.tableValues[0])
            if DEBUG_EXTRACT_FILL_YAML:
                print('\nnumColumns = %s' % numColumns)
                print('\nTYPES of the table contents after yaml.load():')
                
            for icol in range(numColumns):
                try:
                    yl=yaml.load(self.tableValues[0][icol])
                    if DEBUG_EXTRACT_FILL_YAML:
                        print
                        print '%s. yaml.load() = %s' % (icol + 1, yl)
                    typeYaml = type(yaml.load(self.tableValues[0][icol]))
                    if DEBUG_EXTRACT_FILL_YAML:
                        print('  type = %s' % (typeYaml))
                    if typeYaml == dict:
                        index_X = icol + 1
                        if DEBUG_EXTRACT_FILL_YAML:
                            print('\nPylotDB selected: index_X = %s' % index_X)
                        break
                except:
                    if DEBUG_EXTRACT_FILL_YAML:
                        print('%s. type = INDETERMINATE YAML TYPE' % (icol + 1))
                        
# set column # widget in 'Extract & Fill Table' window 
#        self.comboboxExtractAndFillTableColumn.selectitem(index_X - 1,1)  
        
        if index_X <> 0 and index_X <> '':
            self.comboboxExtractAndFillTableColumn.selectitem(
                self.listEnumerateHeaders[index_X - 1]
                )
            self.varXSelect.set(index_X)
        else:
            self.comboboxExtractAndFillTableColumn.setentry('')

# disable all widgets associated with text search
        self.radiobuttonExtractAndFill_SearchAll.configure(state=DISABLED)
        self.radiobuttonExtractAndFill_SearchLimited.configure(state=DISABLED)
        self.comboboxExtractAndFill_SearchLimited_Start.configure(entry_state='disabled')
        self.comboboxExtractAndFill_SearchLimited_End.configure(entry_state='disabled')

#        self.comboboxExtractAndFill_ColumnNameToExtractTo.configure(
#            entry_state='disabled',
#            entry_disabledbackground='gray',
#            entry_disabledforeground=?
#            )
        storeTemp = self.comboboxExtractAndFill_ColumnNameToExtractTo.get().strip()
        self.comboboxExtractAndFill_ColumnNameToExtractTo = Pmw.ComboBox(
            self.frame_16_00_20,
            scrolledlist_items=self.listEnumerateHeaders,
            selectioncommand = self.handlerExtractAndFill_ColumnNameToExtractTo,
            dropdown=1,
#            label_text='Extract data to column:',
#            labelpos='w',
            entry_state='disabled',
#            entry_state='normal',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            entry_width=20,
#            label_background=colorbg,
            scrolledlist_hull_width=500,
            )
        self.comboboxExtractAndFill_ColumnNameToExtractTo.grid(
            row=0,
            column=1,
#            columnspan=1,
            padx=0,
            pady=0,
            sticky=W,
            )
        self.comboboxExtractAndFill_ColumnNameToExtractTo.setentry(storeTemp)
        
        self.buttonExtractAndFill_CreateNewField.configure(state=DISABLED)
        
        storeTemp = self.varEntryExtractAndFill_ColumnNameToExtractTo_Datatype.get().strip()
        self.entryExtractAndFill_ColumnNameToExtractTo_Datatype = Entry(
            self.frame_16_00_20,
            width=20,
            textvariable=self.varEntryExtractAndFill_ColumnNameToExtractTo_Datatype,
#            disabledbackground='white',
#            disabledforeground='black',
            state=DISABLED,
#            state=NORMAL,
            )
        self.entryExtractAndFill_ColumnNameToExtractTo_Datatype.grid(
            row=1,
            column=1,
            padx=0,
            pady=0,
            sticky=W,
            )
        self.varEntryExtractAndFill_ColumnNameToExtractTo_Datatype.set(storeTemp)

#        self.comboboxExtractAndFill_ColumnNameToExtractTo_Datatype.configure(
#            entry_state='disabled',
#            entry_disabledbackground='gray',
#            )
        '''   
        storeTemp = self.comboboxExtractAndFill_ColumnNameToExtractTo_Datatype.get().strip()
        self.comboboxExtractAndFill_ColumnNameToExtractTo_Datatype = Pmw.ComboBox(
            self.frame_16_00_20,
            scrolledlist_items=self.fieldDataTypes,
            listheight=150,
            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            entry_width=20,
            selectioncommand=self.handlerExtractAndFill_ColumnNameToExtractTo_Datatype,
            scrolledlist_hull_width=500,
            )
        self.comboboxExtractAndFill_ColumnNameToExtractTo_Datatype.grid(
            row=1,
            column=1,
            padx=0,
            pady=0,
            sticky=W,
            )
        self.comboboxExtractAndFill_ColumnNameToExtractTo_Datatype.setentry(storeTemp)
        '''
        
#        self.entryExtractAndFill_ColumnNameToExtractTo_Length.configure(state=DISABLED)
        self.comboboxExtractAndFill_NthOccurrence.configure(
            entry_state='disabled',
            )
        self.radiobuttonProtocolAlphanumeric.configure(state=DISABLED)
        self.radiobuttonLocation_Following.configure(state=DISABLED)
        self.radiobuttonLocation_Preceding.configure(state=DISABLED)
        self.radiobuttonLocation_Equal.configure(state=DISABLED)
        self.entryExtractAndFill_NthOccurrence.configure(state=DISABLED)
        self.comboboxExtractAndFill_StopExtracting.configure(
            entry_state='disabled'
            )
        self.radiobuttonProtocolRegex.configure(state=DISABLED)
        self.entryExtractAndFill_RegularExpression.configure(state=DISABLED)
        
        
        return
        
        
    def handlerExtractAndFill_SearchLimited(self):
        '''
        Purpose:
            if START and END line fields are empty, put some
            default values into them; if START has value in it, do
            NOT put a default value in END 
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerExtractAndFill_SearchLimited')
        
        stringNotFunctional = (
            'The ability to search limited lines has not been implemented.\n'
            )
        print('\n' + stringNotFunctional)
        self.MySQL_Output(
            0,
            stringNotFunctional
            )
        showinfo(
            'Not functional',
            stringNotFunctional
            )
        self.varSearchAllLinesOrLimitedRange.set('all')
        return

# ==================        
        
        valueStart = self.comboboxExtractAndFill_SearchLimited_Start.get()
        valueEnd = self.comboboxExtractAndFill_SearchLimited_End.get()

# set default for START        
        if valueStart == '':
            self.comboboxExtractAndFill_SearchLimited_Start.setentry(
                self.scrolledlistExtractAndFill_SearchLimited_Start[0]
                )
                
# set default for END           
        if (
        valueStart == ''
        and
        valueEnd == ''
        ):
            self.comboboxExtractAndFill_SearchLimited_End.setentry(
                self.scrolledlistExtractAndFill_SearchLimited_End[6]
                )
        elif (
        valueEnd <> ''
        and
        valueStart == ''
        ):
            self.comboboxExtractAndFill_SearchLimited_End.setentry('')
        elif (
            valueEnd <> ''
            and
            valueStart <> ''
            and
            (valueStart > valueEnd)
            ):
                self.comboboxExtractAndFill_SearchLimited_Start.setentry('')
                self.comboboxExtractAndFill_SearchLimited_End.setentry('')
        else:
            pass
                
        return
        
            
    def handlerExtractDataAndFillTable_AllFieldsAtOnce(self):
        '''
        Purpose:
            Extract data from table and fill appropriate fields
            
        Notes:
            1. use named fields in MySQL command to make this work; if
            fields do not exist, automatically create them. 
            This will be the most general form since extraction will
            happen regardless of whether fields are renamed by the user.
            
            2. this method attempts to send all fields at once to the
            database. However, this command can only be 8000 bytes long or the
            command will throw the error
                1030, 'Got error 139 from storage engine'
            As a result, the other method 
                handlerExtractDataAndFillTable_OneFieldAtATime(self)
            to send one field at a time to the database, circumventing this problem.
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerExtractDataAndFillTable')

# get current table and database            
        self.myTable = self.comboboxDbTableSelect.get().strip()
        self.myDatabase = self.comboboxDbSelect.get().strip()
        
# get column 
        columnNumberPlusHeader = self.comboboxExtractAndFillTableColumn.get().strip()

# if 'Select column to extract from' is blank, show error and return
        if columnNumberPlusHeader == '':
            stringNoValue = (
                'Specify "Column # / Column Header" and try again.'
                )
            print stringNoValue
            showerror(
                'Error: no value specified',
                stringNoValue
                )
            return
            
# determine which rows are involved
        row_numbers_Affected = []
        
# ALL ROWS
        if self.varButtonExtractAllOrSelectRows.get().strip() == 'all':
# get values from database table
            totalRows = self.totalRowsInTable()
            row_numbers_Affected = range(totalRows)
            
# DISPLAYED ROWS ONLY         
        elif self.varButtonExtractAllOrSelectRows.get().strip() == 'displayed':
            row_numbers_Affected = range(len(self.tableValues))
            
# SELECTED ROWS ONLY     
        elif self.varButtonExtractAllOrSelectRows.get().strip() == 'select':
            rowcount = 0
# check if any rows are checked
            if len(self.varSelectAnyRow) == 0:
                stringNoRowsChecked = (
                    'You have specified to extract from select rows, but\n' +
                    'no rows in the table have been checked.\n\n' +
                    'Select the rows you wish to extract from and try again.'
                    )
                print stringNoRowsChecked
                self.MySQL_Output(
                    0,
                    stringNoRowsChecked
                    )
                try:
                    showerror(
                        'Error: no rows checked',
                        stringNoRowsChecked,
                        parent=self.toplevelExtractAndFill,
                        )
                except:
                    showerror(
                        'Error: no rows checked',
                        stringNoRowsChecked
                        )
                return
            for var in self.varSelectAnyRow:
                print var.get()
                if var.get():
                    row_numbers_Affected.append(rowcount)
                rowcount += 1
                
        if DEBUG_YAML or DEBUG_TEXT_REGEX:
            print('row_numbers_Affected for extraction and fill:\n%s' % row_numbers_Affected)
        
# get column data using column selected in 'Extract & Fill Table' window
        columnNumber = eval(columnNumberPlusHeader.split('.')[0]) - 1 
        
# get all auto_index values from table in database
        '''
        listAutoIndexValuesAffected = []
        tupleAllAutoIndexValues = ()
        stringAutoIndexValues = 'select auto_index from ' + self.myDatabase + '.' + self.myTable
        print '\nstringAutoIndexValues = ',stringAutoIndexValues
        self.cursorHandleMySQL.execute(stringAutoIndexValues)
        tupleAllAutoIndexValues = self.cursorHandleMySQL.fetchall()
        for value in tupleAllAutoIndexValues:
            listAutoIndexValuesAffected.append(int(value[0]))
        if DEBUG_YAML or DEBUG_TEXT_REGEX:
            print
            print('listAutoIndexValuesAffected:')
            print listAutoIndexValuesAffected
        '''
# get auto_index values from DISPLAYED table, not from table on database server
        listAutoIndexValuesAffected = []
        
        if (
        self.varButtonExtractAllOrSelectRows.get().strip() == 'displayed'
        or
        self.varButtonExtractAllOrSelectRows.get().strip() == 'selected'
        ):
            for (k,v) in self.dictColumnHeaders.iteritems():
                if k == 'auto_index':
                    if DEBUG_AUTOINDEX:
                        print('\n> Found: key = %s, column location = %s' % (k,v))
#                for row in range(len(self.tableValues)):
                    for row in row_numbers_Affected:
                        listAutoIndexValuesAffected.append(self.tableValues[row][int(v) - 1])
                    break
                    
            if k <> 'auto_index':
                stringNoAutoIndex = (
                    'No "auto_index" column could be found in the current table.\n\n' +
                    'Every table in PylotDB must have such a column.\n\n' +
                    'This is a coding error. Please contact code administrator.'
                    )
                print(stringNoAutoIndex)
                self.MySQL_Output(
                    0,
                    stringNoAutoIndex
                    )
                showerror(
                    'Error: no auto_index column',
                    stringNoAutoIndex
                    )
                return
                    
        elif self.varButtonExtractAllOrSelectRows.get().strip() == 'all':
            try:
                stringAutoIndexValues = 'select auto_index from ' + self.myDatabase + '.' + self.myTable
                self.cursorHandleMySQL.execute(stringAutoIndexValues)
                listAutoIndexValuesAffected = list(self.cursorHandleMySQL.fetchall())  #turn tuple into a list
            except:
                stringNoAutoIndexFoundOnServer = (
                    'There was a problem selecting the "auto_index" field from\n\n' +
                    '  DATABASE: %s\n' +
                    '  TABLE: %s\n\n' +
                    'during the Extract & Fill process.\n\n' +
                    'Exact reason is unknown, but possibly due to\n' +
                    ' - no "auto_index" field exists in table\n' +
                    ' - database server is down\n' +
                    ' - database and/or table no longer exists\n\n' +
                    'This process is halted -- returning to main program.'
                    )
                print('\n' + stringNoAutoIndexFoundOnServer)
                try:
                    showerror(
                        'Error: problem selecting "auto_index" field',
                        stringNoAutoIndexFoundOnServer,
                        parent=self.toplevelTableValues
                        )
                except:
                    showerror(
                        'Error: problem selecting "auto_index" field',
                        stringNoAutoIndexFoundOnServer
                        )
                return
            
        if DEBUG_TEXT_REGEX:
            print('\nlistAutoIndexValuesAffected in current table:\n%s' % listAutoIndexValuesAffected)

# get list of column headers from "self.dictColumnHeadersOriginal" which
#   are ALL the column headers in the database table, not just the displayed table
        listColumnHeaders_Original = []
        listColumnHeaders_Original = copy.deepcopy(self.dictColumnHeadersOriginal.keys())
        listColumnHeaders_Original.sort()
        if DEBUG_YAML or DEBUG_TEXT_REGEX:
            print
            print '\nlistColumnHeaders_Original:\n', listColumnHeaders_Original
        
# start extraction process; exact method used depends on protocol

# YAML

# ... get table object (file) to extract from
        if self.varRadiobuttonProtocol.get().strip() == 'yaml':
# failure flag
            yamlFailure = 0
# keep track of ALL missing headers with this list
            listMissingHeadersAndDatatype_Total = []
# keep track of ALL current headers with this list, including the original headers
            listColumnHeaders_Current = listColumnHeaders_Original
            
# loop over designated rows
            for (index, row) in enumerate(row_numbers_Affected):
# define empty list for yaml.load of input object
                yamlColumnLoad = []
# list of all items extracted from yaml-formatted file; define empty list first
# get column headers from column data; put in dictionary for sorting and creating table fields
# ... each item containts [header title, value, datatype]
                listAllYamlItems = []
# ... check for empty field first; if so, or if error encountered, just skip over, 
#       but don't halt loop as other fields may NOT be empty
                try:
                    if (
                    self.varButtonExtractAllOrSelectRows.get().strip() == 'displayed'
                    or
                    self.varButtonExtractAllOrSelectRows.get().strip() == 'selected'
                    ):
# select yaml object from displayed table
                        yamlObject = self.tableValues[row][columnNumber].strip()
                        
                    elif self.varButtonExtractAllOrSelectRows.get().strip() == 'all':
# get column heading from 'columnNumber', since currently displayed columnNumber may not
#   correspond to the one on the server
                        columnHeading = self.dictColumnHeaders[columnNumber]
# find same column heading in table on server
                        stringTableStructure = (
                            'SHOW COLUMNS FROM ' + self.myDatabase + '.' + self.myTable
                            )
                        self.cursorHandleMySQL.execute(stringTableStructure)
                        structureTable = self.cursorHandleMySQL.fetchall()
                        columnNumber_Count = 0
                        columnNumber_All = -1
                        for i in range(len(structureTable)):
                            if columnHeading == structureTable[columnNumber_Count][0]:
                                columnNumber_All = columnNumber_Count
                                break
                            columnNumber_Count += 1
                        if columnNumber_All == -1:
                            stringNoColumnHeadingFound = (
                                'No column heading of\n\n' +
                                '  "%s"\n\n' +
                                'was found in table\n\n' +
                                '  %s\n\n' +
                                'on the server. This should NOT have happened!\n\n' +
                                'Check coding in method\n\n' +
                                ' %s\n\n' +
                                'in module\n\n' +
                                '%s'
                                ) % (
                                columnHeading,
                                self.myTable,
                                'def handlerExtractDataAndFillTable_AllFieldsAtOnce',
                                'module_accessMySQL.py'
                                )
                            print('\n' + stringNoColumnHeadingFound)
                            showerror(
                                'Error: no column heading found',
                                stringNoColumnHeadingFound
                                )
                            return
                            
                        autoIndexValue = listAutoIndexValuesAffected[index]
# select yaml object from table on server
                        stringSelectRow = 'select * from ' + self.myDatabase + '.' + self.myTable + \
                            ' where auto_index=' + str(int(listAutoIndexValuesAffected[index]))
                        self.cursorHandleMySQL.exectue(stringSelectRow)
                        yamlObject = self.cursorHandleMySQL.fetchall()[columnNumber_All]
                        
# allow for empty entry in selected column; if so, continue looping thru rows
                    if yamlObject == '':
                        continue
                    print('\n row %s, yamlValue = \n%s' % (row + 1,yamlObject))
# ... skip over empty fields
                except:
                    stringYamlObjectError = (
                        'Error accessing YAML object in database.\n'+
                        'Row: %s\n' +
                        'Column: %s\n' +
                        'Continuing ...\n'
                        ) % (row + 1,str(columnNumber))
                    print stringYamlObjectError
                    showerror(
                        'Error: YAML object',
                        stringYamlObjectError
                        )
                    yamlFailure = 1
                    break
                    
# ... yaml load; print exception if load fails
                try:
                    yamlColumnLoad = yaml.load(yamlObject)
                except:
                    stringYamlLoadError = (
                        'YAML load failed for this entry.\n\n' +
                        'Data in column %s does not appear to be in\n' + 
                        'required YAML format, or the data is missing.\n\n' +
                        'Choose another column and try again.'
                        ) % (columnNumber + 1)
                    print stringYamlLoadError
                    showerror(
                        'Error: not YAML format',
                        stringYamlLoadError
                        )
                    yamlFailure = 2
                    break

# ... all yaml objects (for now) are required to be of type 'dict'
                if type(yamlColumnLoad) <> dict:
                    stringYamlTypeError = (
                        'YAML load resulted in type "%s".\n\n' +
                        'The expected type is "dict".\n\n' +
                        'This probably means that the column selected does\n' +
                        'not contain properly formatted YAML data, or that\n' +
                        'the YAML type encountered has not yet been coded for.\n\n' +
                        'Try another column or cancel the EXTRACT process.'
                        ) % type(yamlColumnLoad)
                    print stringYamlTypeError
                    showerror(
                        'Error: incorrect YAML type',
                        stringYamlTypeError
                        )
                    return

                if DEBUG_YAML:
                    print 'object contents: =\n',yamlObject
                    print '\nyaml.load(yamlObject) =',yamlColumnLoad

# shorten the name to ease the pain
                d1 = yamlColumnLoad # form d1 as a pointer, not a copy of yamlColumnLoad
        
                if DEBUG_YAML:
                    print
                    print ' **** dict_within_dict ****'
                    print
                    print 'd1 =\n',d1
                    print 'len(d1) =',len(d1)
                    print 
                    print 'yaml.dump(d1) =\n',yaml.dump(d1)
                    print
            
                try:
                    dump = yaml.dump(d1)
                except:
                    stringYamlDumpError = (
                        'Content cannot be output in\n' + 
                        'typical YAML format.\n\n' +
                        'Select different content and try again.'
                        )
                    print stringYamlDumpError
                    showerror(
                        'Error: not YAML format',
                        stringYamlDumpError
                        )
                    yamlFailure = 3
                    return
        
                if DEBUG_YAML:
                    print 'type(dump) =',type(dump)
                    print
                    print 'len(dump) =',len(dump)
                    print
                    print 'dump =\n',dump
                    print

                    for (k,v) in d1.iteritems():
                        print 'key, value = %s : %s' % (k,v)
                        try:
                            print '   len(value) =',len(v)
                        except:
                            print '   len(value) = undefined'
    
                    print 
                    print '----- keys, values, lens -----'
                    print

                    print 'd1.keys()[0] =',d1.keys()[0]
                    print 'd1.values()[0] =',d1.values()[0]
                    try:
                        len0 = len(d1.values()[0])
                        print 'len(d1.values()[0]) =',len0
                    except:
                        print 'len(d1.values()[0]) = undefined'
                    print '------------------------------------'

                    print 'd1.keys()[1] =',d1.keys()[1]
                    print 'd1.values()[1] =',d1.values()[1]
                    try:
                        len1 = len(d1.values()[1])
                        print 'len(d1.values()[1]) =',len1
                    except:
                        print 'len(d1.values()[1]) = undefined'
                    print '------------------------------------'
    
                    print 'd1.keys()[2] =',d1.keys()[2]
                    print 'd1.values()[2] =',d1.values()[2]
                    try:
                        len2 = len(d1.values()[2])
                        print 'len(d1.values()[2]) =',len2
                    except:
                        print 'len(d1.values()[2]) = undefined'
                    print '------------------------------------'
        
                    print
                    print ' creating list of items in d1'
                    print
            
                try:
                    l1=d1.items()   #   l1 now becomes a list of tuples of all (key:value) pairs;
                                    #   this is easier to work with than 3-level dictionaries
                except:
                    stringError_d1 = (
                        'A list of tuple pairs cannot be created for d1.\n\n' +
                        'type(d1) = %s\n\n' +
                        'Check printout of d1 before continuing'
                        ) % d1
                    print stringError_d1
                    print
                    print 'd1 =\n',d1
                    print
                    showerror(
                        'Error: items for d1',
                        stringError_d1
                        )
                    yamlFailure = 4
                    return
        
                if DEBUG_YAML:
                    print 'l1 =\n',l1
                    print
                    print 'len(l1) =',len(l1)
                    print
        
# empty lists
                listAllItems = []
                listTemp = []
# initialize counter
                icount=1
                flagSlice = 0
                iLinesPrint = 0
# 3-level extractor for (key,value) dictionary pairs, meaning it can handle
#    dictionaries within dictionaries within dictionaries
#    Final entry will be a list of lists, not a list of tuples which is what *.items() produces
# ... this is the heart of this module    
                for item in l1: # for one-level dictionaries
                    iLinesPrint += 1
                    if DEBUG_YAML:
                        print '%s. item = %s' % (icount,item)
                    if type(item[1]) == dict:
                        string1 = item[0]
                        l2=item[1].items()
                        if DEBUG_YAML:
                            print '  l2 =',l2
                        for subItem_1 in l2:    # for two-level dictionaries
                            if DEBUG_YAML:
                                print '%sa.    subItem_1 = %s' % (icount, subItem_1)
                            if type(subItem_1[1]) == dict:
                                string2 = subItem_1[0]
                                l3=subItem_1[1].items()
                                if DEBUG_YAML:
                                    print '  l3 =',l3
                                for subItem_2 in l3:    # for three-level dictionaries
                                    if DEBUG_YAML:
                                        print '%sb.         subItem_2 = %s' % (icount, subItem_2) 
#                            listAllItems.append(subItem_2 + ',' + type(subItem_2[1]))
# formulate column header for database table; must NOT have special characters or spaces,
#   so replace any of these
                                    stringListTemp = ((string1 + '_' + string2 + '_' + subItem_2[0]).replace(' ','_'))
                                    stringListTemp = self.replaceSpecialCharacters(stringListTemp)
# insert new column header into listTemp; must be lowercase (SQL does not 
#   recognize uppercase), and 64 chars or less                               
                                    listTemp = [stringListTemp.lower()]
#                                    listTemp = [((string1 + '_' + string2 + '_' + subItem_2[0]).replace(' ','_')).lower()]
                                    if len(listTemp) > 64:
                                        print
                                        print 'BEFORE: listTemp =',listTemp
                                        listTemp = listTemp[:64]
                                        print 'AFTER: listTemp =',listTemp
                                        print
                                        flagSlice = 1
# construct format for database table entry:
# ... format is (columntitle, value, datatype)
                                    listTemp.append(subItem_2[1])
                                    mySqlType = self.typeIt(subItem_2[1]) # for database entry type
                                    listTemp.append(mySqlType)
                                    listAllItems.append(listTemp)
                                    listTemp = []
#                        break
                                continue
                            else:   # for two level dictionaries
#                        listAllItems.append(subItem_1 + ',' + type(subItem_1[1]))
                                stringListTemp = ((string1 + '_' + subItem_1[0]).replace(' ','_'))
                                stringListTemp = self.replaceSpecialCharacters(stringListTemp)
                                listTemp = [stringListTemp.lower()]
#                                listTemp = [((string1 + '_' + subItem_1[0]).replace(' ','_')).lower()]
                                if len(listTemp) > 64:
                                    print
                                    print 'BEFORE: listTemp =',listTemp
                                    listTemp = listTemp[:64]
                                    print 'AFTER: listTemp =',listTemp
                                    print
                                    flagSlice = 1
                                listTemp.append(subItem_1[1])
                                mySqlDataType = self.typeIt(subItem_1[1])
                                listTemp.append(mySqlDataType)
                                listAllItems.append(listTemp)
                                listTemp = []
                                continue
                    else:   # for one-level dictionaries
                        stringListTemp = ((item[0]).replace(' ','_'))
                        stringListTemp = self.replaceSpecialCharacters(stringListTemp)
                        listTemp = [stringListTemp.lower()]
#                        listTemp = [((item[0]).replace(' ','_')).lower()]
                        if len(listTemp) > 64:
                            print
                            print 'BEFORE: listTemp =',listTemp
                            listTemp = listTemp[:64]
                            print 'AFTER: listTemp =',listTemp
                            print
                            flagSlice = 1
                        listTemp.append(item[1])
                        mySqlDataType = self.typeIt(item[1])
                        listTemp.append(mySqlDataType)
                        listAllItems.append(listTemp)
                        listTemp = []
                
                    icount += 1  

# come out of above logic with
#   ... listAllItems = list of lists, each with [header, value, datatype]                    
                    
# sort alphabetically
                listAllItems.sort()
                if DEBUG_YAML:
                    print('\n\n** final item list:')
                    print('\n> listAllItems =\n%s' % listAllItems)
                    print('\n> len(listAllItems) = %s',len(listAllItems))
                    
# now that each item is separated and assigned a value, check for floating point numbers that
#  have been mistakenly assigned an CHAR datatype due to the fact they have no decimal in the
#  significand. The 'yaml.load' method is responsible for this problem, and this is probably a
#  yaml bug. Be that as it may, and due to the fact we don't want to wait until the problem
#  is fixed in yaml, we will correct it here.
# 
# format of listAllItems: 
#   listAllItems[n][0]: header value (type STR)
#   listAllItems[n][1]: value
#   listAllItems[n][1]: datatype
                print('\n** Correcting any floating point numbers:')
                for itemNumber,item in enumerate(listAllItems):
                    print('  %s. %s' % (number, item))
                    print('       item[1] = %s' % item[1])
                    if (
                    'e+' in item[1]
                    or
                    'e-' in item[1]
                    or
                    'E+' in item[1]
                    or
                    'E-' in item[1]
                    ):
                        if type(item[1]) == str:
# change to number instead of string
                            try:
                                item[1] = eval(item[1])
                            except:
# skip if can't convert to number; must be that 'e+' is a valid string
                                continue
                            else:
                                item[2] = self.typeIt(item[1])

                print(
                    '\nAlphabetized printout of list, with dataypes corrected for\n' +
                    '  any floating point numbers whose significand did not have a decimal:'
                    )
                for icount,item in enumerate(listAllItems):
                    print '%s. %s' % (icount, item)
                print
                if flagSlice:
                    stringSlice = (
                        'FYI: At least one of the column names has been\n' +
                        'shortened to 64 characters, as this is the maximum\n' +
                        'name length allowed by MySQL'
                        )
                    print stringSlice
                    print
                    showinfo(
                        'INFO: at least one name shortened',
                        stringSlice
                        )
                        
# show user first few lines of data which will be inserted into table if user continues
                if DEBUG_YAML:
                    print('\niLinesPrint = %s\n' % iLinesPrint)
                if iLinesPrint >= 1:
                    stringUserInfo = ''
                    stringUserInfo = (
                        'Showing the first few lines of data to be inserted into table:\n' +
                        'Format is (header_name, value, datatype)\n\n'
                        )
                    if len(listAllItems) > 10: 
                        linesPrint = 10
                    else:
                        linesPrint = len(listAllItems)
                    
                    for line in range(linesPrint):
                        stringUserInfo += (
                            '%s. %s, %s, %s'
                            ) % (
                            line + 1, 
                            listAllItems[0],
                            listAllItems[1],
                            listAllItems[2]
                            )
                        
                    stringUserInfo += (
                        '\n\nClick OK to continue, or Cancel to quit this operation'
                        )
                    try:
                        ans = askokcancel(
                            'Data snapshot',
                            stringUserInfo,
                            parent=self.toplevelExtractAndFill
                            )
                    except:
                        ans = askokcancel(
                            'Data snapshot',
                            stringUserInfo
                            )
                    if not ans:
                        return
        
                if DEBUG_YAML:
                    print 
                    print '\n**** yaml data preparation finished; inserting into table ****'
                    print
                    print 'listAllItems =',listAllItems                        

#------------------------------------
# use listAllYamlItems[item][0] to check for existence of headers (i.e., fields, a.k.a. columns);
# ... if the headers do not exist, create them; loop over list
# ... format of items: [header, value, datatype]
                listMissingHeadersAndDatatype = []
                listAllYamlHeaders = []
                listAllYamlValues = []
                if DEBUG_YAML:
                    print()
                    print('listColumnHeaders_Original =\n%s' % listColumnHeaders_Original)
                    print()
                    print('listColumnHeaders_Current = \n%s' % listColumnHeaders_Current)
                    
                for items in listAllItems:
# form list of not-yet-defined column headers; will be added to table before values are inserted
                    if items[0] not in listColumnHeaders_Current:
                        listMissingHeadersAndDatatype.append(items[0] + ' ' + items[2])
                        if DEBUG_YAML:
                            print('\nitems[0] = %s is not in listColumnHeaders_Current' % items[0])
# form list of all yaml headers
                    listAllYamlHeaders.append(items[0])
# form list of all yaml values
                    listAllYamlValues.append(items[1])
                    
# update total list of missing headers and such; use list comprehension
                [listMissingHeadersAndDatatype_Total.append(itemHeaderAndDatatype)
                    for itemHeaderAndDatatype in listMissingHeadersAndDatatype
                    if itemHeaderAndDatatype not in listMissingHeadersAndDatatype_Total 
                    ]
                    
# update current headers; use list comprehension
                [listColumnHeaders_Current.append(itemMissingHeader) 
                    for itemMissingHeader in listAllYamlHeaders
                    if itemMissingHeader not in listColumnHeaders_Current
                    ]
                    
# determine next to last column
                stringShowFields = (
                    'SHOW COLUMNS FROM ' + self.myDatabase + '.' + self.myTable
                    )
#                    print('\n%s' % stringShowFields)
                self.cursorHandleMySQL.execute(stringShowFields)
                currentFieldsTuple = self.cursorHandleMySQL.fetchall()
                
                if len(currentFieldsTuple) >= 2:
                    fieldNext2Last = currentFieldsTuple[(len(currentFieldsTuple)-1) - 1][0]
# get auto_index header and value
#                    fieldLast = currentFieldsTuple[(len(currentFieldsTuple)-1)][0]
#                    fieldLastValue = currentFieldsTuple[(len(currentFieldsTuple)-1][1]
                    print('\nNext-to-last field = %s' % fieldNext2Last)
#                    print('Last field, value = %s, %s' % (fieldLast, fieldLastValue))
                else:
                    stringErrorNumColumns = (
                        'An error has occurred regarding the number of fields\n' +
                        'of table %s.\n\n' +
                        'There should always be at least 2 or more fields for a table\n' +
                        'to exist in PylotDB. Please contact code administrator for help.'
                        ) % (table)
                    print stringErrorNumColumns
                    showerror(
                        'Error: number of columns',
                        stringErrorNumColumns
                        )
                    return  

# ADD MISSING COLUMN HEADERS
# generate MySQL command line to add missing column headers (titles) to database table
                stringMySQLAdd = ''
                if len(listMissingHeadersAndDatatype) <> 0:
                    listMissingHeadersAndDatatype.sort()
# reverse order so that each header can be inserted into a fixed position and then
#   appear alphabetically ordered
                    listMissingHeadersAndDatatype.reverse()
                    lastItem = listMissingHeadersAndDatatype[len(listMissingHeadersAndDatatype) - 1]
                    if DEBUG_YAML:
                        print '\nlistMissingHeadersAndDatatype =\n',listMissingHeadersAndDatatype
                        print '\nlastItem =',lastItem
                        if lastItem == listMissingHeadersAndDatatype[len(listMissingHeadersAndDatatype) - 1]:
                            print '\n >> lastItem and last item of listMissingHeadersAndDatatype match!\n'
                    for items in listMissingHeadersAndDatatype:
#                        if items <> lastItem:
#                            stringMySQLAdd += 'add ' + items + ' after ' + fieldNext2Last + ', ' # + '\n'
#                        else:
#                            stringMySQLAdd += 'add ' + items + ' after ' + fieldNext2Last
                        stringMySQLAdd += 'add ' + items + ' after ' + fieldNext2Last
# form string to add new headers
                        stringMySQLAdd = (
                            'alter table ' + self.myDatabase 
                            + '.' + self.myTable + ' ' + stringMySQLAdd
                            )
                        print()
                        print('stringMySQLAdd = %s\n' % stringMySQLAdd)
                        print()
# execute the command to add the new headers (fields) for table columns
                        try:
                            self.cursorHandleMySQL.execute(stringMySQLAdd)
                        except:
                            stringAddToDatabaseFailed = (
                                'Attempt to add field\n\n' +
                                '%s\n\n' +
                                'after the field\n\n' +
                                '%s\n\n' +
                                'failed in \n\n' +
                                '"' + MODULE + '/' + 'handlerExtractDataAndFillTable"\n\n' +
                                'Error might be due to duplicate column names.\n\n' +
                                'This should not have happened.\n\n' +
                                'Contact code administrator for help with fixing this problem.\n\n'
                                ) % (items, fieldNext2Last)
                            if items == listMissingHeadersAndDatatype(len(listMissingHeadersAndDatatype) - 1):
                                stringAddToDatabaseFailed += (
                                    'THIS IS THE LAST COLUMN HEADER TO INSERT.\n\n' +
                                    'CLICK "Yes" TO CONTINUE WITH DATA INSERTION PROCESS,\n' +
                                    '  "No" TO CANCEL THIS PROCESS.'
                                    )
                            else:
                                stringAddToDatabaseFailed += (
                                    'DO YOU WISH TO CONTINUE TRYING TO ADD COLUMN HEADERS?'
                                    )
                            print('\n' + stringAddToDatabaseFailed)
                            self.MySQL_Output(
                                0,
                                stringAddToDatabaseFailed
                                )
#                            showerror(
#                                'Error: invalid table alteration',
#                                stringAddToDatabaseFailed,
#                                parent=self.toplevelExtractAndFill
#                                )
                            ans = askyesno(
                                'QUESTION',
                                stringAddToDatabaseFailed
                                )
                            if not ans:
                                return

# UPDATE TABLE VALUES USING 'UPDATE' STATEMENT                                
# form table update statement using header names specifically; loop over list
                indexLast = len(listAllYamlHeaders) - 1
                lastItemHeader = listAllYamlHeaders[indexLast]
                lastItemValue = listAllYamlValues[indexLast]
                stringMySQLUpdate = 'update ' + self.myDatabase + '.' + self.myTable + ' set '
                '''
                for index in range(len(listAllYamlValues) - 1):
                    if type(listAllYamlValues[index]) == str:
                        stringMySQLUpdate += listAllYamlHeaders[index] + '=' + '\'' + listAllYamlValues[index] + '\', '
                    else:
                        stringMySQLUpdate += listAllYamlHeaders[index] + '=' + str(listAllYamlValues[index]) + ', '
     # special treatment at last item           
                if type(lastItemValue) == str:
                    stringMySQLUpdate += lastItemHeader + '=' + '\'' + lastItemValue + '\' '
                else:
                    stringMySQLUpdate += lastItemHeader + '=' + str(lastItemValue) + ' '
                '''    
                for index in range(len(listAllYamlValues) - 1):
                    stringMySQLUpdate += (
                        listAllYamlHeaders[index] + '=' + '\'' + str(listAllYamlValues[index]) + '\', '
                        )
     # special treatment at last item           
                stringMySQLUpdate += lastItemHeader + '=' + '\'' + str(lastItemValue) + '\' '
                    
                if DEBUG_YAML:
                    print
                    print('row =', row)
                    print('listAutoIndexValuesAffected[row] =')
                    print listAutoIndexValuesAffected[row]
                
# add WHERE to string
                stringMySQLUpdate += 'where auto_index = ' + str(int(listAutoIndexValuesAffected[row]))
                print
                print 'stringMySQLInsert = \n',stringMySQLUpdate  

# execute the command to insert the data into the corresponding fields
                self.cursorHandleMySQL.execute(stringMySQLUpdate)
                
# --- END of "for row in row_numbers_Affected:"

# UPDATE MAIN WINDOW AFTER ALL MODS TO TABLE
# ... refresh table
            stringRefreshTable = (
                '\nData extraction and fill have completed.\n\n' + 
                'New columns that had to be added to table "%s": %s\n\n' +
                'Table will now be refreshed.'
                ) % (
                self.myTable,
                len(listMissingHeadersAndDatatype)
                )
            print stringRefreshTable
            showinfo(
                'INFO: table refresh',
                stringRefreshTable
                )
                    
# ... update status line
            maxLinesDisplay = int(self.comboboxMaxLinesToDisplay.get())
            if maxLinesDisplay == 0 or maxLinesDisplay > len(self.tableValues):
                maxLinesDisplay = len(self.tableValues)
            
#        self.handlerStatusLineRefresh(maxLinesDisplay)
# ... adjust plot window if it's open
            self.handlerInvokeButtonToRefreshPlotXYWindow()
# ... refresh  Storage Buffer window, if mapped
            try:
                mappedBuffer = self.toplevelShowStorageBuffer.winfo_exists()
            except:
                mappedBuffer = False
                
            if mappedBuffer:
#                self.buttonTableValuesShowAll_Buffer.invoke()  
                self.handlerRefreshBufferView()
                

# update table values for EXTRACT DATA & FILL TABLE using yaml parsing
            try:
                mapped = self.toplevelTableValues.winfo_exists()
            except:
                mapped = False
                                
            if mapped:
                self.handlerDisplayLimitedRows()    # PEEK handler
            
# update filter window
                try:
                    mapped = self.toplevelSelectDisplayOrderedFields.winfo_exists()
                except:
                    mapped = False
            
                if mapped:
                    self.handlerSelectDisplayOrderedFields_Update()
            
            return
# --- done with YAML ---

 
# UNPICKLE
        elif self.varRadiobuttonProtocol.get().strip() == 'unpickle':
            stringNoProtocol = (
                'The specified Protocol "unPickle" for Extraction & Fill\n' +
                'has not yet been implemented.\n\n' +
                'Choose another Protocol and try again.'
                )
            print stringNoProtocol
            showerror(
                'Error: Protocol not implemented',
                stringNoProtocol
                )
            return  

# --- done with UNPICKLE ---  

       
   
# TEXT
        elif self.varRadiobuttonProtocol.get().strip() == 'text': 
           
# error check input
# ... if Search: Lines is specified ... 
            if self.varSearchAllLinesOrLimitedRange.get().strip() == 'limited':
# ...       make sure START and END are not empty
                lineStart = self.comboboxExtractAndFill_SearchLimited_Start.get()
                lineEnd = self.comboboxExtractAndFill_SearchLimited_End.get()
                if (
                lineStart == ''
                or
                lineEnd == ''
                ):
                    stringStartAndOrEndEmpty = (
                        'The following fields need input:\n\n'
                        )
                    if lineStart == '':
                        stringStartAndOrEndEmpty += (
                            '  Search -> Lines -> (START)\n'
                            )         
                    if lineEnd == '':
                        stringStartAndOrEndEmpty += (
                            '  Search -> Lines -> (END)\n'
                            )
                    stringStartAndOrEndEmpty += (
                        '\nSpecify proper values in the field(s) and try again.'
                        )
                    print stringStartAndOrEndEmpty
                    self.MySQL_Output(
                        0,
                        stringStartAndOrEndEmpty
                        )
                    try:
                        showerror(
                            'Error: missing values',
                            stringStartAndOrEndEmpty,
                            parent=self.toplevelExtractAndFill
                            )
                    except:
                        showerror(
                            'Error: missing values',
                            stringStartAndOrEndEmpty
                            )
                    return   
# ...       make sure entries are integers; bounds will be checked as we process fields
                stringTemp = ''
                try:
                    lineStartType = type(eval(lineStart))
                except:
                    stringTemp += (
                        '  Search -> Lines -> (START)\n'
                        )
                try:
                    lineEndType = type(eval(lineEnd))
                except:
                    stringTemp += (
                        '  Search -> Lines -> (END)\n'
                        )
                if stringTemp <> '':
                    stringStartAndOrEndType = (
                        'The following fields must have integers as input:\n\n' + 
                        stringTemp + '\n' +
                        'Specify integer values in the field(s) and try again'
                        )
                    print stringStartAndOrEndType
                    self.MySQL_Output(
                        0,
                        stringStartAndOrEndType
                        )
                    try:
                        showerror(
                            'Error: use integer values',
                            stringStartAndOrEndType,
                            parent=self.toplevelExtractAndFill
                            )
                    except:
                        showerror(
                            'Error: use integer values',
                            stringStartAndOrEndType
                            )
                    
                    return
                    
# ... make sure "Extract data to column named:" field is filled
            columnNumberAndNameToExtractTo = self.comboboxExtractAndFill_ColumnNameToExtractTo.get()
            if columnNumberAndNameToExtractTo == '':
                stringEmptyExtractToColumn = (
                    'The field for "Extract data to column named:" is empty.\n\n' +
                    'Specify either an existing column from the drop-down menu or\n' +
                    'enter a new column name and try again.'
                    )
                print stringEmptyExtractToColumn
                self.MySQL_Output(
                    0,
                    stringEmptyExtractToColumn
                    )
                try:
                    showerror(
                        'Error: no column to extract to',
                        stringEmptyExtractToColumn,
                        parent=self.toplevelExtractAndFill
                        )
                except:
                    showerror(
                        'Error: no column to extract to',
                        stringEmptyExtractToColumn
                        )
                return
                    
# --- end error check

# ... get column name where data will be inserted                   
            columnNameToExtractTo = columnNumberAndNameToExtractTo.split('.')[1].strip()              
                        
            if self.varChooseWhichTextProtocol.get().strip() == 'extract_alphanumeric':
# begin TEXT using protocol alphanumeric
                stringNoProtocol = (
                    'The specified Text protocol "Extract alphanumeric data ..."\n' +
                    'for Extraction & Fill has not yet been implemented.\n\n' +
                    'Choose another Protocol and try again.'
                    )
                print stringNoProtocol
                showerror(
                    'Error: Protocol not implemented',
                    stringNoProtocol
                    )
                return
                
# ---- end TEXT using protocol alphanumeric ----              
               
            elif self.varChooseWhichTextProtocol.get().strip() == 'extract_regex':
# begin TEXT using protocol regex
# ... check if regex field is empty
                regularExpression = self.varEntryExtractAndFill_RegularExpression.get().strip()
# error check the regular expression
# ... make sure there IS a regular expression
                if regularExpression == '':
                    stringNoRegExp = ''
                    stringNoRegExp = (
                        'You have chosen to search using a regular expression,\n' +
                        'but the associated field is empty.\n\n' +
                        'Enter a properly formatted regular expression and try again.'
                        )
                    print stringNoRegExp
                    self.MySQL_Output(
                        0,
                        stringNoRegExp
                        )
                    try:
                        showerror(
                            'Error: no regexp',
                            stringNoRegExp,
                            parent=self.toplevelExtractAndFill
                            )
                    except:
                        showerror(
                            'Error: no regexp',
                            stringNoRegExp
                            )
                    return
# ...   show it
                print('\nregularExpression = %s\n' % regularExpression)
                self.MySQL_Output(
                    1,
                    '\nRegular Expression used for search: %s\n' % regularExpression
                    )
# ...   no more than 1 pair of parentheses to capture the data in the
#       regular expression to then be inserted into a table column
                countLeftParensOnly = regularExpression.count('(')
                countLeftSlashParens = regularExpression.count('\(')
                countRightParensOnly = regularExpression.count(')')
                countRightSlashParens = regularExpression.count('\)')
                countLeftParens = countLeftParensOnly - countLeftSlashParens
                countRightParens = countRightParensOnly - countRightSlashParens
                if countLeftParens <> countRightParens:
                    stringParensNotBalanced = (
                        'Parentheses are not balanced in the regular expression \n\n' +
                        '%s' + '\n' +
                        'Left parens: %s     Right parens: %s \n\n' +
                        'Also, the regular expression cannot have more than\n' +
                        'one pair of parentheses.\n\n' +
                        'Correct the regular expression and try again.'
                        ) % (regularExpression, countLeftParens, countRightParens)
                    print(stringParensNotBalanced)
                    self.MySQL_Output(
                        0,
                        stringParensNotBalanced
                        )
                    try:
                        showerror(
                            'Error: parens not balanced',
                            stringParensNotBalanced,
                            parent=self.toplevelExtractAndFill
                            )
                    except:
                        showerror(
                            'Error: parens not balanced',
                            stringParensNotBalanced
                            )
                    return
                if countLeftParens > 1 or countRightParens > 1:
                    stringTooManyParens = ''
                    stringTooManyParens = (
                        'There are too many pairs of parentheses existing in the\n' +
                        'regular expression. Only 1 pair of parentheses are allowed.\n\n' +
                        'Correct the regular expression and try again.'
                        )
                    print(stringTooManyParens)
                    self.MySQL_Output(
                        0,
                        stringTooManyParens
                        )
                    try:
                        showerror(
                            'Error: too many pairs of parens',
                            stringTooManyParens,
                            parent=self.toplevelExtractAndFill
                            )
                    except:
                        showerror(
                            'Error: too many pairs of parens',
                            stringTooManyParens
                            )
                    return
                        
                    
# ... compile regular expression; 
                ''' NOT NEEDED!!!
# ... NOTE: this will compile even with garbage in it, so be careful; error check here and when used as well
                try:
                    regexpCompiled = re.compile(regularExpression)
                    stringCompiledOK = (
                        '  > regular expression compiled normally'
                        )
                    print(stringCompiledOK)
                    self.MySQL_Output(
                        0,
                        stringCompiledOK
                        )                        
                except:
                    stringNoRegExpCompile = (
                        'The regular expression did not compile initially.\n\n' +
                        'Check syntax, correct the expression, and try again.'
                        )
                    print stringNoRegExpCompile
                    self.MySQL_Output(
                        0,
                        stringNoRegExpCompile
                        )
                    showerror(
                        'Error: regex',
                        stringNoREgExpCompile,
                        parent=self.toplevelExtractAndFill
                        )
                    return
                '''

# --- end of error check ---

# failure flag
                textRegExFailure = 0
# keep track of ALL missing headers with this list
                listMissingHeadersAndDatatype_Total = []
# keep track of ALL current headers with this list, including the original headers
                listColumnHeaders_Current = listColumnHeaders_Original
# list of objects to be put into database table
                matchedObjects = []
# track row numbers that have no match
                rowsNotMatched = []
# track row numbers that have matched
                rowsMatched = []
# track blank rows
                rowsBlank = []
# count total number of rows searched
                rowsSearched = 0
# loop over designated rows
                for row in row_numbers_Affected:
                    rowsSearched += 1
# define empty list for yaml.load of input object
                    textRegExColumnLoad = []
# define empty temp list
#                    objects = []
# list of all items extracted from yaml-formatted file; define empty list first
# get column headers from column data; put in dictionary for sorting and creating table fields
# ... each item containts [header title, value, datatype]
                    listAlltextRegExItems = []
# ... check for empty field first; if so, or if error encountered, just skip over, 
#       but don't halt loop as other fields may NOT be empty
                    try:
# get the field object which will be searched
                        textRegExObject = self.tableValues[row][columnNumber].strip()
# allow for empty entry in selected column; if so, continue looping thru rows
                        if textRegExObject == '':
# ... append blanks to matchedObjects, and then skip over the empty fields
# ...   format: [matched_value, row_autoindex]
                            matchedObjects.append(['',int(listAutoIndexValuesAffected[row])])
                            rowsBlank.append(row+1)
                            continue
                        print('\n row %s. field value = \n%s' % (row + 1,textRegExObject))
                    except:
                        stringtextRegExObjectError = (
                            'Error accessing TEXT object in database.\n'+
                            'Row: %s\n' +
                            'Column: %s\n' +
                            'Continuing ...\n'
                            ) % (str(eval(row) + 1),str(columnNumber))
                        print stringtextRegExObjectError
                        showerror(
                            'Error: textRegEx object',
                            stringtextRegExObjectError
                            )
                        textRegExFailure = 1
                        break
                        
                    if DEBUG_TEXT_REGEX:
                        print('\ntextRegExObject:\n %s' % textRegExObject)
                        print('\nlen(textRegExObject) = %s' % len(textRegExObject))
#                        sys.exit()

# search the object for patterns expressed in regular expression for this field only
                    matches = []
                    try:
#                        matches = re.findall(regexpCompiled, textRegExObject)
                        matches = re.findall(regularExpression, textRegExObject)
                        print('\nregexp matches:\n%s' % matches)
                        print('\nnumber of matches in list: %s\n' % len(matches))    
                    except:
                        stringNoRegExpCompile = (
                            'The regular expression did not compile correctly.\n\n' +
                            'Check syntax, correct the expression, and try again.'
                            )
                        print stringNoRegExpCompile
                        self.MySQL_Output(
                            0,
                            stringNoRegExpCompile
                            )
                        try:
                            showerror(
                                'Error: regex',
                                stringNoREgExpCompile,
                                parent=self.toplevelExtractAndFill
                                )
                        except:
                            showerror(
                                'Error: regex',
                                stringNoREgExpCompile
                                )
                        return
                    
# say so if no matches in current field; append as blank and continue
                    if len(matches) == 0:
                        print('\n>>> no regex pattern matches were found for row %s\n' % row)
                        rowsNotMatched.append(row+1)
                        continue

# extract the nth occurrence here
                    nthOccurrence = int(self.comboboxExtractAndFill_NthOccurrence.get())

# error check
                    if nthOccurrence > len(matches):
                        fieldCurrent = self.comboboxExtractAndFill_ColumnNameToExtractTo.get()
                        stringNthOutOfBounds = (
                            'For row = %s in Field #%s:\n\n' +
                            '   regular expression matches = \n' +
                            '   %s\n\n' +
                            'You have chosen to select the %s-th occurrence of a matched\n' +
                            'expression, but there are only %s matches in the current row.\n\n' +
                            'This process cannot continue with the options chosen.\n\n' +
                            'Revise which occurrence of the match-list you wish to select\n' +
                            'and try again.'
                            ) % (row,fieldCurrent,matches,nthOccurrence,len(matches))
                        print stringNthOutOfBounds
                        self.MySQL_Output(
                            0,
                            '\n' + stringNthOutOfBounds
                            )
                        showerror(
                            'Error: mismatch',
                            stringNthOutOfBounds
                            )
                        return
                        
# get the match desired
                    try:
                        match = matches[nthOccurrence - 1]
                        matchedObjects.append([match,int(listAutoIndexValuesAffected[row])])
                        rowsMatched.append(row+1)
                    except:
# occurs if nthOccurrence is > len(matches)
                        matchedObjects.append(['',int(listAutoIndexValuesAffected[row])])
                        rowsNotMatched.append(row+1)

# ----- END OF FOR LOOP to extract matched objects                    
                    
# give user a snapshot of data which will be inserted into database table
                stringUserInfo = ''
                stringUserInfo = (
                    'These are the first few rows of data to be inserted:\n' +
                    ' format: row. value, auto_insert_number\n\n'
                    )
                for num,matchList in enumerate(matchedObjects):
                    match = matchList[0]
                    autoInsert = matchList[1]
# first few rows
                    if num + 1 <= 10:
                        stringUserInfo += (
                            '\n' + '%s. %s, %s'
                            ) % (num + 1,match,autoInsert)                        
# matched rows
                stringUserInfo += (
                    '\n\nNumber of matched rows: %s'
                    ) % len(rowsMatched)
                '''
                if len(rowsMatched) > 0:
                    stringUserInfo += (
                        '\n matched rows: %s'
                        ) % rowsMatched
                '''
# unmatched rows
                stringUserInfo += (
                    '\n\nNumber of unmatched rows: %s'
                    ) % len(rowsNotMatched)
                if len(rowsNotMatched) > 0:
                    stringUserInfo += (
                        '\n  unmatched rows: %s'
                        ) % rowsNotMatched
# blank rows
                stringUserInfo += (
                    '\n\nNumber of blank rows (no fields to search): %s'
                    ) % len(rowsBlank) 
                if len(rowsBlank) > 0:
                    stringUserInfo += (
                        '\n  blank rows: %s'
                        ) % rowsBlank
# total rows searched                    
                stringUserInfo += (
                    '\n\nTotal rows searched: %s'
                    ) % rowsSearched
                print(stringUserInfo)
                self.MySQL_Output(
                    0,
                    stringUserInfo
                    )
                try:
                    ans = askokcancel(
                        'Data snapshot',
                        stringUserInfo,
                        parent=self.toplevelExtractAndFill
                        )
                except:
                    ans = askokcancel(
                        'Data snapshot',
                        stringUserInfo
                        )
                if not ans:
                    return
                
                '''
                stringInsertTextRegexData = (
                    '\nData preparation finished.\n\n' +
                    'Now inserting into table.'
                    )
                self.MySQL_Output(
                    0,
                    stringInsertTextRegexData
                    )
                showinfo(
                    'Info: insert data into table',
                    stringInsertTextRegexData
                    )
                '''

# may want to put something here later                    
                if DEBUG_TEXT_REGEX:
                    pass                      

# form table insert statement using header names specifically; loop over list, inserting into
#   one row at a time (easier logic than batch submit; these are not large databases)
                
                stringMySQLUpdate_FixedString = 'update ' + self.myDatabase + '.' + self.myTable + ' set '
                
                for matchList in matchedObjects:
                
                    match = matchList[0]
                    autoInsertIndex = matchList[1]
                    
                    stringMySQLUpdate = []
                
                    stringMySQLUpdate = (
                        columnNameToExtractTo + ' = \'' + str(match) + '\' where auto_index = ' + str(autoInsertIndex) 
                        )

                    stringMySQLUpdate = stringMySQLUpdate_FixedString + stringMySQLUpdate
                
                    print('\nstringMySQLUpdate = \n%s' % stringMySQLUpdate)

# execute the command to insert the data into the corresponding fields
                    try:
                        self.cursorHandleMySQL.execute(stringMySQLUpdate)
                    except:
                        stringInsertedUpdateFailed = (
                            '\nRow %s. FAILED -- Attempt to Insert %s where auto_index = %s'
                            ) % (row, match, autoInsertIndex)
                
# --- END of "for row in row_numbers_Affected:"

# UPDATE MAIN WINDOW AFTER ALL MODS TO TABLE
# ... refresh table
            stringRefreshTable = (
                'Table %s has added data to %s rows under column %s.\n\n' +
                'Table will now be refreshed.'
                ) % (self.myTable,len(matchedObjects),columnNameToExtractTo)
            print stringRefreshTable
            showinfo(
                'INFO: table refresh',
                stringRefreshTable
                )
                    
# ... update status line
            maxLinesDisplay = int(self.comboboxMaxLinesToDisplay.get())
            if maxLinesDisplay == 0 or maxLinesDisplay > len(self.tableValues):
                maxLinesDisplay = len(self.tableValues)
            
#        self.handlerStatusLineRefresh(maxLinesDisplay)
# ... adjust plot window if it's open
            self.handlerInvokeButtonToRefreshPlotXYWindow()
# ... refresh  Storage Buffer window, if mapped
            try:
                mappedBuffer = self.toplevelShowStorageBuffer.winfo_exists()
            except:
                mappedBuffer = False
                
            if mappedBuffer:
#                self.buttonTableValuesShowAll_Buffer.invoke()  
                self.handlerRefreshBufferView()
                
# update table values for EXTRACT DATA & FILL TABLE using text parsing     
            try:
                mapped = self.toplevelTableValues.winfo_exists()
            except:
                mapped = False
                                
            if mapped:
                self.handlerDisplayLimitedRows()    # PEEK handler
# update filter window
                try:
                    mapped = self.toplevelSelectDisplayOrderedFields.winfo_exists()
                except:
                    mapped = False
                    
                if mapped:
                    self.handlerSelectDisplayOrderedFields_Update()
            
            return
            
# --- end TEXT using protocol regex ---

        else:
# PROTOCOL UNSPECIFIED
# protocol has not been specicified or it has not been implemented
            stringNoProtocol = (
                'The specified Protocol for Extraction & Fill\n' +
                'has not yet been implemented.\n\n' +
                'Choose one of the listed Protocols and try again.'
                )
            print stringNoProtocol
            showerror(
                'Error: Protocol not implemented',
                stringNoProtocol
                )
            return

# ... get all headers

# ... check if headers exist in table; if they don't, create them in the database using MySQL cmmands; 
#       check each object in case one has fields/data the others do not
#       must also have a scheme to determine datatypes

# use appropriate MySQL command to insert values into table

# NOTES:
#  make sure if table window is canceled, the Extract table also is closed.
        
        return
        
        
    def handlerExtractDataAndFillTable_OneFieldAtATime(self):
        '''
        Purpose:
            Extract data from selected table field and fill appropriate fields
            
        Notes:
            1. use 'named' fields in MySQL command to make this work; if
            fields do not exist, automatically create them. 
            This will be the most general form since extraction will
            happen regardless of whether fields are renamed by the user.
            2. sends one field at a time to the database table so as not
            to run into the limit of 8000 bytes imposed on the 'add' MySQL 
            command. The companion method
                handlerExtractDataAndFillTable_AllFieldsAtOnce(self)
            can run into this problem when extracting data from larger 
            YAML files
            3. field names must be <= 64 characters
            4. by updating one field at a time, if for some reason the field cannot
            be updated, the process can continue with other fields; if we were
            to submit all fields at once to be updated, then if one field could
            not be updated, the remainder of the command would fail, which would
            not help the robustness of PylotDB.
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerExtractDataAndFillTable')
            
# save checked fields
        self.saveCheckedFieldNames()  

# get current table and database            
        self.myTable = self.comboboxDbTableSelect.get().strip()
        self.myDatabase = self.comboboxDbSelect.get().strip()
        
# get column 
        columnNumberPlusHeader = self.comboboxExtractAndFillTableColumn.get().strip()
        
# if 'Select column to extract from' is blank, show error and return
        if columnNumberPlusHeader == '':
            stringNoValue = (
                'Specify "Column # / Column Header" and try again.'
                )
            print stringNoValue
            showerror(
                'Error: no value specified',
                stringNoValue
                )
            return
            
# determine which rows are involved
        row_numbers_Affected = []
        
# ALL ROWS
        if self.varButtonExtractAllOrSelectRows.get().strip() == 'all':
# get values from database table
            totalRows = self.totalRowsInTable()
            row_numbers_Affected = range(totalRows)
            
# DISPLAYED ROWS ONLY
        elif self.varButtonExtractAllOrSelectRows.get().strip() == 'displayed':
            row_numbers_Affected = range(len(self.tableValues))
            
# SELECTED ROWS ONLY
        elif self.varButtonExtractAllOrSelectRows.get().strip() == 'select':
            rowcount = 0
# check if any rows are checked
            if len(self.varSelectAnyRow) == 0:
                stringNoRowsChecked = (
                    'You have specified to extract from select rows, but\n' +
                    'no rows in the table have been checked.\n\n' +
                    'Select the rows you wish to extract from and try again.'
                    )
                print stringNoRowsChecked
                self.MySQL_Output(
                    0,
                    stringNoRowsChecked
                    )
                try:
                    showerror(
                        'Error: no rows checked',
                        stringNoRowsChecked,
                        parent=self.toplevelExtractAndFill,
                        )
                except:
                    showerror(
                        'Error: no rows checked',
                        stringNoRowsChecked
                        )
                return
            for var in self.varSelectAnyRow:
                print var.get()
                if var.get():
                    row_numbers_Affected.append(rowcount)
                rowcount += 1
        if DEBUG_YAML or DEBUG_TEXT_REGEX:
            print('row_numbers_Affected for extraction and fill:\n%s' % row_numbers_Affected)
        
# get column data using column selected in 'Extract & Fill Table' window
        columnNumber = eval(columnNumberPlusHeader.split('.')[0]) - 1 
        
# get all auto_index values from table in database
        '''
        listAutoIndexValuesAffected = []
        tupleAllAutoIndexValues = ()
        stringAutoIndexValues = 'select auto_index from ' + self.myDatabase + '.' + self.myTable
        print '\nstringAutoIndexValues = ',stringAutoIndexValues
        self.cursorHandleMySQL.execute(stringAutoIndexValues)
        tupleAllAutoIndexValues = self.cursorHandleMySQL.fetchall()
        for value in tupleAllAutoIndexValues:
            listAutoIndexValuesAffected.append(int(value[0]))
        if DEBUG_YAML or DEBUG_TEXT_REGEX:
            print
            print('listAutoIndexValuesAffected:')
            print listAutoIndexValuesAffected
        '''
# get auto_index values from DISPLAYED table, not from table in database

        listAutoIndexValuesAffected = []
        
        if (
        self.varButtonExtractAllOrSelectRows.get().strip() == 'displayed'
        or
        self.varButtonExtractAllOrSelectRows.get().strip() == 'selected'
        ):
            for (k,v) in self.dictColumnHeaders.iteritems():
                if k == 'auto_index':
                    print('\n> Found: key = %s, column location = %s' % (k,v))
#                for row in range(len(self.tableValues)):
                    for row in row_numbers_Affected:
                        listAutoIndexValuesAffected.append(self.tableValues[row][int(v) - 1])
                    break
                
            if k <> 'auto_index':
                stringNoAutoIndex = (
                    'No "auto_index" column could be found in the current table.\n\n' +
                    'Every table in PylotDB must have such a column.\n\n' +
                    'This is a coding error. Please contact code administrator.'
                    )
                print(stringNoAutoIndex)
                self.MySQL_Output(
                    0,
                    stringNoAutoIndex
                    )
                showerror(
                    'Error: no auto_index column',
                    stringNoAutoIndex
                    )
                return
                
        elif self.varButtonExtractAllOrSelectRows.get().strip() == 'all':
            try:
                stringAutoIndexValues = 'select auto_index from ' + self.myDatabase + '.' + self.myTable
                self.cursorHandleMySQL.execute(stringAutoIndexValues)
#turn tuple of tuples into a list like the other cases
                tuplesAutoIndexValuesAffected = ()
                tuplesAutoIndexValuesAffected = self.cursorHandleMySQL.fetchall() 
                for index in range(len(tuplesAutoIndexValuesAffected)):
                    listAutoIndexValuesAffected.append(tuplesAutoIndexValuesAffected[index][0])

            except:
                stringNoAutoIndexFoundOnServer = (
                    'There was a problem selecting the "auto_index" field from\n\n' +
                    '  DATABASE: %s\n' +
                    '  TABLE: %s\n\n' +
                    'during the Extract & Fill process.\n\n' +
                    'Exact reason is unknown, but possibly due to\n' +
                    ' - no "auto_index" field exists in table\n' +
                    ' - database server is down\n' +
                    ' - database and/or table no longer exists\n\n' +
                    'This process is halted -- returning to main program.'
                    )
                print('\n' + stringNoAutoIndexFoundOnServer)
                try:
                    showerror(
                        'Error: problem selecting "auto_index" field',
                        stringNoAutoIndexFoundOnServer,
                        parent=self.toplevelTableValues
                        )
                except:
                    showerror(
                        'Error: problem selecting "auto_index" field',
                        stringNoAutoIndexFoundOnServer
                        )
                return
            
        if DEBUG_TEXT_REGEX:
            print('\nlistAutoIndexValuesAffected in current table:\n%s' % listAutoIndexValuesAffected)
            
        print('\nDWB: listAutoIndexValuesAffected in current table\n%s' % listAutoIndexValuesAffected)

# get list of column headers from "self.dictColumnHeadersOriginal" which
#   are ALL the column headers in the database table, not just the displayed table
        listColumnHeaders_Original = []
        listColumnHeaders_Original = copy.deepcopy(self.dictColumnHeadersOriginal.keys())     
        listColumnHeaders_Original.sort()
        if DEBUG_YAML or DEBUG_TEXT_REGEX:
            print
            print '\nlistColumnHeaders_Original:\n', listColumnHeaders_Original
        

# start extraction process; exact method used depends on protocol

# = = = = = = = = = = = = = = = = = = = = = = = = =

# YAML
# ... get table object (file) to extract from
        if self.varRadiobuttonProtocol.get().strip() == 'yaml':
# failure flag
            yamlFailure = 0
# keep track of ALL missing headers with this list
            listMissingHeadersAndDatatype_Total = []
# keep track of ALL current headers with this list, including the original headers
            listColumnHeaders_Current = listColumnHeaders_Original
# keep track of number of headers added
            totalHeadersAdded = 0
                       
# setup a sequential index
###            indexCounter = 0
            
# loop over designated rows
            for (index,row) in enumerate(row_numbers_Affected):
# print row number to keep track of what's happening
                print('\n>> Updating row #%s' % (row + 1))
# listAutoIndexValuesAffected is sequentially indexed, so use a counter
###                indexCounter += 1

# define empty list for yaml.load of input object
                yamlColumnLoad = []
# list of all items extracted from yaml-formatted file; define empty list first
# get column headers from column data; put in dictionary for sorting and creating table fields
# ... each item containts [header title, value, datatype]
                listAllYamlItems = []
# ... check for empty field first; if so, or if error encountered, just skip over, 
#       but don't halt loop as other fields may NOT be empty
                try:
                    if (
                    self.varButtonExtractAllOrSelectRows.get().strip() == 'displayed'
                    or
                    self.varButtonExtractAllOrSelectRows.get().strip() == 'selected'
                    ):
# select yaml object from displayed table
                        yamlObject = self.tableValues[row][columnNumber].strip()
                        
                    elif self.varButtonExtractAllOrSelectRows.get().strip() == 'all':
 # get column heading from 'columnNumber', since currently displayed columnNumber may not
#   correspond to the one on the server
                        columnHeading = ''
                        for (k,v) in self.dictColumnHeaders.iteritems():
                            if v == columnNumber:
                                columnHeading = k
                                break
                                
                        if columnHeading == '':
                            stringColumnHeadingNotFound = (
                                'No column heading was found in table\n\n' +
                                '  %s\n\n' +
                                'for column number %s.\n\n' +
                                'This should NOT have happened.\n\n' +
                                'Please check coding in method\n\n' +
                                '  %s\n\n' +
                                'in module\n\n' +
                                '  %s\n\n' +
                                'Returning to main program.'
                                )
                            print('\n' + stringColumnHeadingNotFound)
                            try:
                                showerror(
                                    'Error: no column heading found',
                                    stringColumnHeadingNotFound,
                                    parent=self.toplevelTableValues
                                    )
                            except:
                                showerror(
                                    'Error: no column heading found',
                                    stringColumnHeadingNotFound,
                                    )
                            return
                             
                        if DEBUG_YAML:
                            print('\ncolumnHeading = %s' % columnHeading)
                                
# find same column heading in table on server
                        stringTableStructure = (
                            'SHOW COLUMNS FROM ' + self.myDatabase + '.' + self.myTable
                            )
                            
                        if DEBUG_YAML:
                            print('\ncommand to show columns:\n' )
                            print(stringTableStructure)
                        
                        self.cursorHandleMySQL.execute(stringTableStructure)
                        structureTable = self.cursorHandleMySQL.fetchall()
                        
                        if DEBUG_YAML:
                            print('\nstructureTable = ')
                            print(structureTable)
                        
                        columnNumber_Count = 0
                        columnNumber_All = -1
                        for i in range(len(structureTable)):
                            if columnHeading == structureTable[columnNumber_Count][0]:
                                columnNumber_All = columnNumber_Count
                                break
                            columnNumber_Count += 1
                        if columnNumber_All == -1:
                            stringNoColumnHeadingFound = (
                                'No column heading of\n\n' +
                                '  "%s"\n\n' +
                                'was found in table\n\n' +
                                '  %s\n\n' +
                                'on the server. This should NOT have happened!\n\n' +
                                'Check coding in method\n\n' +
                                ' %s\n\n' +
                                'in module\n\n' +
                                '%s'
                                ) % (
                                columnHeading,
                                self.myTable,
                                'def handlerExtractDataAndFillTable_AllFieldsAtOnce',
                                'module_accessMySQL.py'
                                )
                            print('\n' + stringNoColumnHeadingFound)
                            showerror(
                                'Error: no column heading found',
                                stringNoColumnHeadingFound
                                )
                            return
                            
                        autoIndexValue = listAutoIndexValuesAffected[index]
# select yaml object from table on server
                        stringSelectRow = 'select * from ' + self.myDatabase + '.' + self.myTable + \
                            ' where auto_index=' + str(autoIndexValue)

                        if DEBUG_YAML:
                            print('\nstringSelectRow:\n')
                            print(stringSelectRow)
                        
                        self.cursorHandleMySQL.execute(stringSelectRow)
                        returnObject = self.cursorHandleMySQL.fetchall()
                        if DEBUG_YAML:
                            print('\nreturnObject:\n')
                            print(returnObject)
#                        yamlObject = returnObject[0].[columnNumber_All]
                        yamlObject = list(returnObject[0])[columnNumber_All + 1]
                        if DEBUG_YAML:
                            print('\nyamlObject:\n')
                            print(yamlObject)
                            print('\nautoIndexValue = %s' % autoIndexValue)
                            print('')
                        
# allow for empty entry in selected column; if so, continue looping thru rows
                    if yamlObject == '':
                        continue
                    if DEBUG_YAML:
                        print('\n row %s, yamlObject = \n%s' % (row + 1,yamlObject))
# ... skip over empty fields
                except:
                    stringYamlObjectError = (
                        'Error accessing YAML object in database.\n'+
                        '  Row: %s\n' +
                        '  Column: %s\n' +
                        'Continuing ...\n'
                        ) % (row+ 1,str(columnNumber))
                    print('\n' + stringYamlObjectError)
                    showerror(
                        'Error: YAML object',
                        stringYamlObjectError
                        )
                    yamlFailure = 1
                    break
                    
# ... yaml load; print exception if load fails
                try:
                    yamlColumnLoad = yaml.load(yamlObject)
                except:
                    stringYamlLoadError = (
                        'YAML load failed for this entry.\n\n' +
                        'Data in column %s does not appear to be in\n' + 
                        'required YAML format, or the data is missing.\n\n' +
                        'Choose another column and try again.'
                        ) % (columnNumber + 1)
                    print stringYamlLoadError
                    showerror(
                        'Error: not YAML format',
                        stringYamlLoadError
                        )
                    yamlFailure = 2
                    break

# ... all yaml objects (for now) are required to be of type 'dict'
                if type(yamlColumnLoad) <> dict:
                    stringYamlTypeError = (
                        'YAML load resulted in type "%s".\n\n' +
                        'The expected type is "dict".\n\n' +
                        'This probably means that the column selected does\n' +
                        'not contain properly formatted YAML data, or that\n' +
                        'the YAML type encountered has not yet been coded for.\n\n' +
                        'Try another column or cancel the EXTRACT process.'
                        ) % type(yamlColumnLoad)
                    print stringYamlTypeError
                    showerror(
                        'Error: incorrect YAML type',
                        stringYamlTypeError
                        )
                    return

                if DEBUG_YAML:
                    print 'object contents: =\n',yamlObject
                    print '\nyaml.load(yamlObject) =',yamlColumnLoad

# shorten the name to ease the pain
                d1 = yamlColumnLoad # form d1 as a pointer, not a copy of yamlColumnLoad
        
                if DEBUG_YAML:
                    print
                    print ' **** dict_within_dict ****'
                    print
                    print 'd1 =\n',d1
                    print 'len(d1) =',len(d1)
                    print 
                    print 'yaml.dump(d1) =\n',yaml.dump(d1)
                    print
            
                try:
                    dump = yaml.dump(d1)
                except:
                    stringYamlDumpError = (
                        'Content cannot be output in\n' + 
                        'typical YAML format.\n\n' +
                        'Select different content and try again.'
                        )
                    print stringYamlDumpError
                    showerror(
                        'Error: not YAML format',
                        stringYamlDumpError
                        )
                    yamlFailure = 3
                    return
        
                if DEBUG_YAML:
                    print 'type(dump) =',type(dump)
                    print
                    print 'len(dump) =',len(dump)
                    print
                    print 'dump =\n',dump
                    print

                    for (k,v) in d1.iteritems():
                        print 'key, value = %s : %s' % (k,v)
                        try:
                            print '   len(value) =',len(v)
                        except:
                            print '   len(value) = 0'
    
                    print 
                    print '----- keys, values, lens -----'
                    print

                    print 'd1.keys()[0] =',d1.keys()[0]
                    print 'd1.values()[0] =',d1.values()[0]
                    try:
                        len0 = len(d1.values()[0])
                        print 'len(d1.values()[0]) =',len0
                    except:
                        print 'len(d1.values()[0]) = undefined'

                    print '------------------------------------'

                    print 'd1.keys()[1] =',d1.keys()[1]
                    print 'd1.values()[1] =',d1.values()[1]
                    try:
                        len1 = len(d1.values()[1])
                        print 'len(d1.values()[1]) =',len1
                    except:
                        print 'len(d1.values()[1]) = undefined'
                    print '------------------------------------'
    
                    print 'd1.keys()[2] =',d1.keys()[2]
                    print 'd1.values()[2] =',d1.values()[2]
                    try:
                        len2 = len(d1.values()[2])
                        print 'len(d1.values()[2]) =',len2
                    except:
                        print 'len(d1.values()[2]) = undefined'
                    print '------------------------------------'
        
                    print
                    print ' creating list of items in d1'
                    print
            
                try:
                    l1=d1.items()   #   l1 now becomes a list of tuples of all (key:value) pairs;
                                    #   this is easier to work with than 3-level dictionaries
                except:
                    stringError_d1 = (
                        'A list of tuple pairs cannot be created for d1.\n\n' +
                        'type(d1) = %s\n\n' +
                        'Check printout of d1 before continuing'
                        ) % d1
                    print stringError_d1
                    print
                    print 'd1 =\n',d1
                    print
                    showerror(
                        'Error: items for d1',
                        stringError_d1
                        )
                    yamlFailure = 4
                    return
        
                if DEBUG_YAML:
                    print 'l1 =\n',l1
                    print
                    print 'len(l1) =',len(l1)
                    print
        
# empty lists
                listAllItems = []
                listTemp = []
# initialize counter
                icount=1
                flagSlice = 0
                iLinesPrint = 0
# 3-level extractor for (key,value) dictionary pairs, meaning it can handle
#    dictionaries within dictionaries within dictionaries
#    Final entry will be a list of lists, not a list of tuples which is what *.items() produces
# ... this is the heart of this module    
                for item in l1: # for one-level dictionaries
                    iLinesPrint += 1
                    if DEBUG_YAML:
                        print '%s. item = %s' % (icount,item)
                    if type(item[1]) == dict:
                        string1 = item[0]
                        l2=item[1].items()
                        if DEBUG_YAML:
                            print '  l2 =',l2
                        for subItem_1 in l2:    # for two-level dictionaries
                            if DEBUG_YAML:
                                print '%sa.    subItem_1 = %s' % (icount, subItem_1)
                            if type(subItem_1[1]) == dict:
                                string2 = subItem_1[0]
                                l3=subItem_1[1].items()
                                if DEBUG_YAML:
                                    print '  l3 =',l3
                                for subItem_2 in l3:    # for three-level dictionaries
                                    if DEBUG_YAML:
                                        print '%sb.         subItem_2 = %s' % (icount, subItem_2) 
#                            listAllItems.append(subItem_2 + ',' + type(subItem_2[1]))
# formulate column header for database table; must not have special characters or spaces,
#   so replace any of these
                                    stringListTemp = ((string1 + '_' + string2 + '_' + subItem_2[0]).replace(' ','_'))
                                    stringListTemp = stringListTemp.replace('/','_')
                                    stringListTemp = stringListTemp.replace('\\','_')
                                    stringListTemp = stringListTemp.replace('-','_')
                                    stringListTemp = stringListTemp.replace('(','')
                                    stringListTemp = stringListTemp.replace(')','')
                                    stringListTemp = stringListTemp.replace('.','')
                                    stringListTemp = stringListTemp.replace('%','percent')
                                    stringListTemp = stringListTemp.replace(',','') 
# insert new column header into listTemp; must be lowercase (SQL does not 
#   recognize uppercase), and 64 chars or less                               
                                    listTemp = [stringListTemp.lower()]
#                                    listTemp = [((string1 + '_' + string2 + '_' + subItem_2[0]).replace(' ','_')).lower()]
                                    if len(listTemp) > 64:
                                        print
                                        print 'BEFORE: listTemp =',listTemp
                                        listTemp = listTemp[:64]
                                        print 'AFTER: listTemp =',listTemp
                                        print
                                        flagSlice = 1
# construct format for database table entry:
# ... format is (columntitle, value, datatype)
                                    listTemp.append(subItem_2[1])
                                    mySqlType = self.typeIt(subItem_2[1]) # for database entry type
                                    listTemp.append(mySqlType)
                                    listAllItems.append(listTemp)
                                    listTemp = []
#                        break
                                continue
                            else:   # for two level dictionaries
#                        listAllItems.append(subItem_1 + ',' + type(subItem_1[1]))
                                stringListTemp = ((string1 + '_' + subItem_1[0]).replace(' ','_'))
                                stringListTemp = stringListTemp.replace('/','_')
                                stringListTemp = stringListTemp.replace('\\','_')
                                stringListTemp = stringListTemp.replace('-','_')
                                stringListTemp = stringListTemp.replace('(','')
                                stringListTemp = stringListTemp.replace(')','')
                                stringListTemp = stringListTemp.replace('.','')
                                stringListTemp = stringListTemp.replace('%','percent')
                                stringListTemp = stringListTemp.replace(',','')
                                listTemp = [stringListTemp.lower()]
#                                listTemp = [((string1 + '_' + subItem_1[0]).replace(' ','_')).lower()]
                                if len(listTemp) > 64:
                                    print
                                    print 'BEFORE: listTemp =',listTemp
                                    listTemp = listTemp[:64]
                                    print 'AFTER: listTemp =',listTemp
                                    print
                                    flagSlice = 1
                                listTemp.append(subItem_1[1])
                                mySqlDataType = self.typeIt(subItem_1[1])
                                listTemp.append(mySqlDataType)
                                listAllItems.append(listTemp)
                                listTemp = []
                                continue
                    else:   # for one-level dictionaries
                        stringListTemp = ((item[0]).replace(' ','_'))
                        stringListTemp = stringListTemp.replace('/','_')
                        stringListTemp = stringListTemp.replace('\\','_')
                        stringListTemp = stringListTemp.replace('-','_')
                        stringListTemp = stringListTemp.replace('(','')
                        stringListTemp = stringListTemp.replace(')','')
                        stringListTemp = stringListTemp.replace('.','')
                        stringListTemp = stringListTemp.replace('%','percent')
                        stringListTemp = stringListTemp.replace(',','')
                        listTemp = [stringListTemp.lower()]
#                        listTemp = [((item[0]).replace(' ','_')).lower()]
                        if len(listTemp) > 64:
                            print
                            print 'BEFORE: listTemp =',listTemp
                            listTemp = listTemp[:64]
                            print 'AFTER: listTemp =',listTemp
                            print
                            flagSlice = 1
                        listTemp.append(item[1])
                        mySqlDataType = self.typeIt(item[1])
                        listTemp.append(mySqlDataType)
                        listAllItems.append(listTemp)
                        listTemp = []
                
                    icount += 1  

# come out of above logic with
#   ... listAllItems = list of lists, each with [header, value, datatype]                    
                    
# sort alphabetically
                listAllItems.sort()
                if DEBUG_YAML:
                    print('\n\n** final item list:')
                    print('\n> listAllItems =\n%s' % listAllItems)
                    print('\n> len(listAllItems) = %s' % len(listAllItems))
                    
# now that each item is separated and assigned a value, check for floating point numbers that
#  have been mistakenly assigned an CHAR datatype due to the fact they have no decimal in the
#  significand. The 'yaml.load' method is responsible for this problem, and this is probably a
#  yaml bug. Be that as it may, and due to the fact we don't want to wait until the problem
#  is fixed in yaml, we will correct it here.
# 
# format of listAllItems: 
#   listAllItems[n][0]: header value (type STR)
#   listAllItems[n][1]: value
#   listAllItems[n][1]: datatype
                if DEBUG_YAML:
                    print('\n** Correcting any floating point numbers:')
                for itemNumber,item in enumerate(listAllItems):
                    if DEBUG_YAML:
                        print('  %s. %s' % (itemNumber, item))
                        print('       item[1] = %s' % item[1])
                    if type(item[1]) == str:
                        if (
                        'e+' in item[1]
                        or
                        'e-' in item[1]
                        or
                        'E+' in item[1]
                        or
                        'E-' in item[1]
                        ):
# change to number instead of string
                            try:
                                item[1] = eval(item[1])
                            except:
# skip if can't convert to number; must be that 'e+' is a valid string
                                continue
                            else:
                                listAllItems[itemNumber][1] = item[1]
                                listAllItems[itemNumber][2] = self.typeIt(item[1])
                    
                    
                if DEBUG_YAML:
                    print(
                        '\nAlphabetized printout of list, with dataypes corrected for\n' +
                        '  any floating point numbers whose significand did not have a decimal:'
                        )
                    for icount,item in enumerate(listAllItems):
                        print '%s. %s' % (icount, item)
                    print
                    
                if flagSlice:
                    stringSlice = (
                        'FYI: At least one of the column names has been\n' +
                        'shortened to 64 characters, as this is the maximum\n' +
                        'name length allowed by MySQL'
                        )
                    print stringSlice
                    print
                    showinfo(
                        'INFO: at least one name shortened',
                        stringSlice
                        )
                        
# show user first few lines of data which will be inserted into table if user continues
                if DEBUG_YAML:
                    print('\niLinesPrint = %s\n' % iLinesPrint)
                if iLinesPrint >= 1 and index == 0:
                    stringUserInfo = ''
                    stringUserInfo = (
                        'Showing first few lines of data to be added to\n' +
                        ' TABLE: %s\n' +
                        ' ROW: %s\n' +
                        'Format is (header_name, value, datatype)\n\n'
                        ) % (
                            self.myTable,
                            row + 1
                            )
                    if len(listAllItems) > 10: 
                        linesPrint = 10
                    else:
                        linesPrint = len(listAllItems)
                    
#                    for line in range(linesPrint):
                    for lineCount in range(linesPrint):
                        stringUserInfo += (
#                        '%s. %s, %s, %s\n'
                        '%s. %s\n'
                            ) % (
                            lineCount + 1,
                            listAllItems[lineCount]
#                            listAllItems[0],
#                            listAllItems[1],
#                            listAllItems[2]
                            )
                        
                    stringUserInfo += (
                        '\nNumber of rows affected: %s\n' +
                        '\nClick OK to continue, or Cancel to quit this operation'
                        ) % len(row_numbers_Affected)
                    try:
                        ans = askokcancel(
                            'Data snapshot - first row only',
                            stringUserInfo,
                            parent=self.toplevelExtractAndFill
                            )
                    except:
                        ans = askokcancel(
                            'Data snapshot - first row only',
                            stringUserInfo
                            )
                    if not ans:
                        return
        
                if DEBUG_YAML:
                    print 
                    print '\n**** yaml data preparation finished; inserting into table ****'
                    print
                    print 'listAllItems =',listAllItems                        

#------------------------------------
# use listAllYamlItems[item][0] to check for existence of headers (i.e., fields, a.k.a. columns);
# ... if the headers do not exist, create them; loop over list
# ... format of items: [header, value, datatype]
                listMissingHeadersAndDatatype = []
                listAllYamlHeaders = []
                listAllYamlValues = []
                if DEBUG_YAML:
                    print()
                    print('listColumnHeaders_Original =\n%s' % listColumnHeaders_Original)
                    print()
                    print('listColumnHeaders_Current = \n%s' % listColumnHeaders_Current)
                    
                for items in listAllItems:
# form list of not-yet-defined column headers; will be added to table before values are inserted
                    if items[0] not in listColumnHeaders_Current:
                        listMissingHeadersAndDatatype.append(items[0] + ' ' + items[2])
                        if DEBUG_YAML:
                            print('items[0] = %s is not in listColumnHeaders_Current' % items[0])
# form list of all yaml headers
                    listAllYamlHeaders.append(items[0])
# form list of all yaml values
                    listAllYamlValues.append(items[1])
                    
# update total list of missing headers and such; use list comprehension
                [listMissingHeadersAndDatatype_Total.append(itemHeaderAndDatatype)
                    for itemHeaderAndDatatype in listMissingHeadersAndDatatype
                    if itemHeaderAndDatatype not in listMissingHeadersAndDatatype_Total 
                    ]
                    
# update current headers; use list comprehension
                [listColumnHeaders_Current.append(itemMissingHeader) 
                    for itemMissingHeader in listAllYamlHeaders
                    if itemMissingHeader not in listColumnHeaders_Current
                    ]
                    
# determine next to last column
                stringShowFields = (
                    'SHOW COLUMNS FROM ' + self.myDatabase + '.' + self.myTable
                    )
#                    print('\n%s' % stringShowFields)
                self.cursorHandleMySQL.execute(stringShowFields)
                currentFieldsTuple = self.cursorHandleMySQL.fetchall()
                
                if len(currentFieldsTuple) >= 2:
                    fieldNext2Last = currentFieldsTuple[(len(currentFieldsTuple)-1) - 1][0]
# get auto_index header and value
#                    fieldLast = currentFieldsTuple[(len(currentFieldsTuple)-1)][0]
#                    fieldLastValue = currentFieldsTuple[(len(currentFieldsTuple)-1][1]
                    if DEBUG_YAML:
                        print('\nNext-to-last field = %s' % fieldNext2Last)
#                    print('Last field, value = %s, %s' % (fieldLast, fieldLastValue))
                else:
                    stringErrorNumColumns = (
                        'An error has occurred regarding the number of fields\n' +
                        'of table %s.\n\n' +
                        'There should always be at least 2 or more fields for a table\n' +
                        'to exist in PylotDB. Please contact code administrator for help.'
                        ) % (table)
                    print stringErrorNumColumns
                    showerror(
                        'Error: number of columns',
                        stringErrorNumColumns
                        )
                    return  

# generate MySQL command line to add data to database table
                stringMySQLAdd = ''
                if len(listMissingHeadersAndDatatype) <> 0:
                    listMissingHeadersAndDatatype.sort()
# reverse order so that each header can be inserted into a fixed position and then
#   appear alphabetically ordered
                    listMissingHeadersAndDatatype.reverse()
                    lastItem = listMissingHeadersAndDatatype[len(listMissingHeadersAndDatatype) - 1]
                    if DEBUG_YAML:
                        print '\nlistMissingHeadersAndDatatype =\n',listMissingHeadersAndDatatype
                        print '\nlastItem =',lastItem
                        if lastItem == listMissingHeadersAndDatatype[len(listMissingHeadersAndDatatype) - 1]:
                            print 'lastItem and last item of listMissingHeadersAndDatatype match!\n'
                    for items in listMissingHeadersAndDatatype:
#                        if items <> lastItem:
#                            stringMySQLAdd += 'add ' + items + ' after ' + fieldNext2Last + ', ' # + '\n'
#                        else:
#                            stringMySQLAdd += 'add ' + items + ' after ' + fieldNext2Last

# form string to add new headers
                        stringMySQLAdd = 'add ' + items + ' after ' + fieldNext2Last
                        stringMySQLAdd = (
                            'alter table ' + self.myDatabase 
                            + '.' + self.myTable + ' ' + stringMySQLAdd
                            )

                        if DEBUG_YAML:
                            print('\nstringMySQLAdd = %s\n\n' % stringMySQLAdd)

# execute the command to add the new headers (fields) for table columns
                        try:
                            self.cursorHandleMySQL.execute(stringMySQLAdd)
                        except:
                            stringAddToDatabaseFailed = (
                                'Attempt to add field\n\n' +
                                '%s\n\n' +
                                'after the field\n\n' +
                                '%s\n\n' +
                                'failed in \n\n' +
                                '"' + MODULE + '/' + 'handlerExtractDataAndFillTable"\n\n' +
                                'Error might be due to duplicate column names.\n\n' +
                                'This should not have happened.\n\n' +
                                'Contact code administrator for help with fixing this problem.\n\n'
                                ) % (items, fieldNext2Last)
                            if items == listMissingHeadersAndDatatype[len(listMissingHeadersAndDatatype) - 1]:
                                stringAddToDatabaseFailed += (
                                    '\n\nTHIS IS THE LAST COLUMN HEADER TO INSERT.\n\n'
                                    )
                                showinfo(
                                    'INFO: Cannot add field',
                                    stringAddToDatabaseFailed,
                                    parent=self.toplevelExtractAndFill
                                    )
                                return
                            else:
                                stringAddToDatabaseFailed += (
                                    'DO YOU WISH TO CONTINUE TRYING TO ADD COLUMN HEADERS?\n' +
                                    'CLICK "Yes" TO CONTINUE WITH DATA INSERTION PROCESS,\n' +
                                    '  "No" TO CANCEL THIS PROCESS.'
                                    )
                            print('\n' + stringAddToDatabaseFailed)
                            self.MySQL_Output(
                                0,
                                stringAddToDatabaseFailed
                                )
#                            showerror(
#                                'Error: invalid table alteration',
#                                stringAddToDatabaseFailed,
#                                parent=self.toplevelExtractAndFill
#                                )
                            ans = askyesno(
                                'QUESTION',
                                stringAddToDatabaseFailed,
                                parent=self.toplevelExtractAndFill
                                )
                            if not ans:
                                return
                        else:
                            if DEBUG_YAML:
                                print(' SUCCESS: field has been added')
                            totalHeadersAdded += 1

# UPDATE TABLE VALUES USING 'INSERT' STATEMENT  
# form table insert statement using header names specifically; loop over list
                indexLast = len(listAllYamlHeaders) - 1
                lastItemHeader = listAllYamlHeaders[indexLast]
                lastItemValue = listAllYamlValues[indexLast]
                stringMySQLUpdate = 'update ' + self.myDatabase + '.' + self.myTable + ' set '
                '''
                for index in range(len(listAllYamlValues) - 1):
                    if type(listAllYamlValues[index]) == str:
                        stringMySQLUpdate += listAllYamlHeaders[index] + '=' + '\'' + listAllYamlValues[index] + '\', '
                    else:
                        stringMySQLUpdate += listAllYamlHeaders[index] + '=' + str(listAllYamlValues[index]) + ', '
     # special treatment at last item           
                if type(lastItemValue) == str:
                    stringMySQLUpdate += lastItemHeader + '=' + '\'' + lastItemValue + '\' '
                else:
                    stringMySQLUpdate += lastItemHeader + '=' + str(lastItemValue) + ' '
                '''
                
                for indexYaml in range(len(listAllYamlValues)):
                    stringMySQLUpdate_Add_0 = ''
                    stringMySQLUpdate_Add_0 = (
                        listAllYamlHeaders[indexYaml] + '=' + '\'' + str(listAllYamlValues[indexYaml]) + '\' '
                        )
# special treatment at last item           
#                stringMySQLUpdate += lastItemHeader + '=' + '\'' + str(lastItemValue) + '\' '
                    
                    if DEBUG_YAML:
                        print
                        print('row = %s' % (row + 1))
                        print('index = %s' % index)
                        print('listAutoIndexValuesAffected[index] = %s'
                            % listAutoIndexValuesAffected[index]
                            )
                        
# add WHERE to string
                    stringMySQLUpdate_Add_1 = 'where auto_index = ' + str(int(listAutoIndexValuesAffected[index]))
                    
                    stringMySQLUpdate_Total = (
                        stringMySQLUpdate + stringMySQLUpdate_Add_0 + stringMySQLUpdate_Add_1
                        )
                
                    if DEBUG_YAML:
                        print(
                            '%s. stringMySQLUpdate_Total = %s' 
                            ) % (
                            indexYaml + 1,
                            stringMySQLUpdate_Total
                            ) 
                        print(
                            'Length of header name: %s characters' 
                            ) % (
                            len(stringMySQLUpdate_Add_0.split('=')[0])
#                           len(stringMySQLUpdate_Add_0)
                            )

# execute the command to insert the data into the corresponding field
                    try:
                        self.cursorHandleMySQL.execute(stringMySQLUpdate_Total)
                    except:
                        if index == 0:
                            stringShowFields = (
                                'SHOW COLUMNS FROM ' + self.myDatabase + '.' + self.myTable
                                )
                            self.cursorHandleMySQL.execute(stringShowFields)
                            currentFieldsTuple = self.cursorHandleMySQL.fetchall()
                            tempFieldList = []
                            for field in currentFieldsTuple:
                                tempFieldList.append(field[0])
                            indexField = tempFieldList.index(listAllYamlHeaders[indexYaml])                   
                            stringNoInsert = (
                                'UPDATE error:\n\n' +
                                '  database = %s\n' +
                                '  table = %s\n' +
                                '  row = %s\n' +
                                '  column header = %s\n' +
                                '  column index = %s\n\n' +
                                'The following string was unable to update the table column:\n\n' +
                                '  %s\n\n' +
                                'Check statement for proper format.\n\n' +
                                'DO YOU WISH TO CONTINUE UPDATING TABLE FIELDS?'
                                ) % (
                                self.myDatabase,
                                self.myTable,
                                row + 1,
                                listAllYamlHeaders[indexYaml],
#                           index + 1,
                                indexField + 1,
                                stringMySQLUpdate_Total
                                )
                            print('\n' + stringNoInsert)
                            self.MySQL_Output(
                                0,
                                stringNoInsert
                                )
                            ans = askyesno(
                                'Question',
                                stringNoInsert,
                                parent=self.toplevelExtractAndFill
                                )
                            if not ans:
                                return
#                    else:
#                        print('UPDATE success!')
                if DEBUG_YAML:
                    print(' UPDATE success!')
       
# --- END of "for row in row_numbers_Affected:"


# UPDATE MAIN WINDOW AFTER ALL MODS TO TABLE
# ... refresh table
            stringRefreshTable = (
                '\nData extraction and fill have completed.\n\n' + 
                'Number of new columns added to table "%s": %s\n\n' +
                'Number of rows affected: %s\n\n' +
                'Table will now be refreshed.'
                ) % (
                self.myTable,
                totalHeadersAdded,
                index + 1,
#                len(listMissingHeadersAndDatatype)
                )
            print stringRefreshTable
            showinfo(
                'INFO: table refresh',
                stringRefreshTable
                )
                
# make sure window still exists
            try:
                mapped = self.toplevelTableValues.winfo_exists()
            except:
                mapped = False
            if not mapped:
                stringNoTableWindow = (
                    'The table window is no longer displayed, so the table will\n' +
                    'not be refreshed. However, any new table values will be\n' +
                    'shown the next time the table window is displayed.'
                    )
                print('\n' + stringNoTableWindow)
                try:
                    showinfo(
                        'Info: no table window',
                        stringNoTableWindow,
                        parent=self.toplevelTableFunctions
                        )
                except:
                    showinfo(
                         'Info: no table window',
                        stringNoTableWindow
                        )
                return
                    
# ... update status line
            maxLinesDisplay = int(self.comboboxMaxLinesToDisplay.get())
            if maxLinesDisplay == 0 or maxLinesDisplay > len(self.tableValues):
                maxLinesDisplay = len(self.tableValues)
            
#        self.handlerStatusLineRefresh(maxLinesDisplay)
# ... adjust plot window if it's open
            self.handlerInvokeButtonToRefreshPlotXYWindow()
            
# ... refresh  Storage Buffer window, if mapped
            try:
                mappedBuffer = self.toplevelShowStorageBuffer.winfo_exists()
            except:
                mappedBuffer = False 
                
            if mappedBuffer:
#                self.buttonTableValuesShowAll_Buffer.invoke()  
                self.handlerRefreshBufferView()
                
# update table values for EXTRACT DATA & FILL TABLE, yaml, one field at a time   
            try:
                mapped = self.toplevelTableValues.winfo_exists()
            except:
                mapped = False
                                
            if mapped:
                self.handlerDisplayLimitedRows()    # PEEK handler
            
# update filter window
                try:
                    mapped = self.toplevelSelectDisplayOrderedFields.winfo_exists()
                except:
                    mapped = False
            
                if mapped:
                    self.handlerSelectDisplayOrderedFields_Update()
                    
# reset indices for checked fields
            self.resetVarXYSelect()
                    
# restore checked fields
            self.restoreCheckedFieldNames()  
            
            return
# --- done with YAML ---

# = = = = = = = = = = = = = = = = = = = = = = = = =
            
# UNPICKLE
        elif self.varRadiobuttonProtocol.get().strip() == 'unpickle':
            stringNoProtocol = (
                'The specified Protocol "unPickle" for Extraction & Fill\n' +
                'has not yet been implemented.\n\n' +
                'Choose another Protocol and try again.'
                )
                
            print stringNoProtocol
            showerror(
                'Error: Protocol not implemented',
                stringNoProtocol
                )
                
# restore checked fields
            self.restoreCheckedFieldNames()  
                
            return  

# --- done with UNPICKLE ---  

# = = = = = = = = = = = = = = = = = = = = = = = = =     
   
# TEXT
        elif self.varRadiobuttonProtocol.get().strip() == 'text': 
           
# error check input
# ... if Search: Lines is specified ... 
            if self.varSearchAllLinesOrLimitedRange.get().strip() == 'limited':
# ...       make sure START and END are not empty
                lineStart = self.comboboxExtractAndFill_SearchLimited_Start.get()
                lineEnd = self.comboboxExtractAndFill_SearchLimited_End.get()
                if (
                lineStart == ''
                or
                lineEnd == ''
                ):
                    stringStartAndOrEndEmpty = (
                        'The following fields need input:\n\n'
                        )
                    if lineStart == '':
                        stringStartAndOrEndEmpty += (
                            '  Search -> Lines -> (START)\n'
                            )         
                    if lineEnd == '':
                        stringStartAndOrEndEmpty += (
                            '  Search -> Lines -> (END)\n'
                            )
                    stringStartAndOrEndEmpty += (
                        '\nSpecify proper values in the field(s) and try again.'
                        )
                    print stringStartAndOrEndEmpty
                    self.MySQL_Output(
                        0,
                        stringStartAndOrEndEmpty
                        )
                    try:
                        showerror(
                            'Error: missing values',
                            stringStartAndOrEndEmpty,
                            parent=self.toplevelExtractAndFill
                            )
                    except:
                        showerror(
                            'Error: missing values',
                            stringStartAndOrEndEmpty
                            )
                    return   
# ...       make sure entries are integers; bounds will be checked as we process fields
                stringTemp = ''
                try:
                    lineStartType = type(eval(lineStart))
                except:
                    stringTemp += (
                        '  Search -> Lines -> (START)\n'
                        )
                try:
                    lineEndType = type(eval(lineEnd))
                except:
                    stringTemp += (
                        '  Search -> Lines -> (END)\n'
                        )
                if stringTemp <> '':
                    stringStartAndOrEndType = (
                        'The following fields must have integers as input:\n\n' + 
                        stringTemp + '\n' +
                        'Specify integer values in the field(s) and try again'
                        )
                    print stringStartAndOrEndType
                    self.MySQL_Output(
                        0,
                        stringStartAndOrEndType
                        )
                    try:
                        showerror(
                            'Error: use integer values',
                            stringStartAndOrEndType,
                            parent=self.toplevelExtractAndFill
                            )
                    except:
                        showerror(
                            'Error: use integer values',
                            stringStartAndOrEndType
                            )
                    
                    return
                    
# ... make sure "Extract data to column named:" field is filled
            columnNumberAndNameToExtractTo = self.comboboxExtractAndFill_ColumnNameToExtractTo.get()
            if columnNumberAndNameToExtractTo == '':
                stringEmptyExtractToColumn = (
                    'The field for "Extract data to column named:" is empty.\n\n' +
                    'Specify either an existing column from the drop-down menu or\n' +
                    'enter a new column name and try again.'
                    )
                print stringEmptyExtractToColumn
                self.MySQL_Output(
                    0,
                    stringEmptyExtractToColumn
                    )
                try:
                    showerror(
                        'Error: no column to extract to',
                        stringEmptyExtractToColumn,
                        parent=self.toplevelExtractAndFill
                        )
                except:
                    showerror(
                        'Error: no column to extract to',
                        stringEmptyExtractToColumn
                        )
                return
                    
# --- end error check

# ... get column name where data will be inserted                   
            columnNameToExtractTo = columnNumberAndNameToExtractTo.split('.')[1].strip()              
               
# restore checked fields
            self.restoreCheckedFieldNames()  
               
            if self.varChooseWhichTextProtocol.get().strip() == 'extract_alphanumeric':
# begin TEXT using protocol alphanumeric
                stringNoProtocol = (
                    'The specified Text protocol "Extract alphanumeric data ..."\n' +
                    'for Extraction & Fill has not yet been implemented.\n\n' +
                    'Choose another Protocol and try again.'
                    )
                print stringNoProtocol
                showerror(
                    'Error: Protocol not implemented',
                    stringNoProtocol
                    )
                return
                
# ---- end TEXT using protocol alphanumeric ---- 

# = = = = = = = = = = = = = = = = = = = = = = = = =             
               
            elif self.varChooseWhichTextProtocol.get().strip() == 'extract_regex':
# begin TEXT using protocol regex
# ... check if regex field is empty
                regularExpression = self.varEntryExtractAndFill_RegularExpression.get().strip()
# error check the regular expression
# ... make sure there IS a regular expression
                if regularExpression == '':
                    stringNoRegExp = ''
                    stringNoRegExp = (
                        'You have chosen to search using a regular expression,\n' +
                        'but the associated field is empty.\n\n' +
                        'Enter a properly formatted regular expression and try again.'
                        )
                    print stringNoRegExp
                    self.MySQL_Output(
                        0,
                        stringNoRegExp
                        )
                    try:
                        showerror(
                            'Error: no regexp',
                            stringNoRegExp,
                            parent=self.toplevelExtractAndFill
                            )
                    except:
                        showerror(
                            'Error: no regexp',
                            stringNoRegExp
                            )
                    return
# ...   show it
                print('\nregularExpression = %s\n' % regularExpression)
                self.MySQL_Output(
                    1,
                    '\nRegular Expression used for search: %s\n' % regularExpression
                    )
# ...   no more than 1 pair of parentheses to capture the data in the
#       regular expression to then be inserted into a table column
                countLeftParensOnly = regularExpression.count('(')
                countLeftSlashParens = regularExpression.count('\(')
                countRightParensOnly = regularExpression.count(')')
                countRightSlashParens = regularExpression.count('\)')
                countLeftParens = countLeftParensOnly - countLeftSlashParens
                countRightParens = countRightParensOnly - countRightSlashParens
                if countLeftParens <> countRightParens:
                    stringParensNotBalanced = (
                        'Parentheses are not balanced in the regular expression \n\n' +
                        '%s' + '\n' +
                        'Left parens: %s     Right parens: %s \n\n' +
                        'Also, the regular expression cannot have more than\n' +
                        'one pair of parentheses.\n\n' +
                        'Correct the regular expression and try again.'
                        ) % (regularExpression, countLeftParens, countRightParens)
                    print(stringParensNotBalanced)
                    self.MySQL_Output(
                        0,
                        stringParensNotBalanced
                        )
                    try:
                        showerror(
                            'Error: parens not balanced',
                            stringParensNotBalanced,
                            parent=self.toplevelExtractAndFill
                            )
                    except:
                        showerror(
                            'Error: parens not balanced',
                            stringParensNotBalanced
                            )
                    return
                if countLeftParens > 1 or countRightParens > 1:
                    stringTooManyParens = ''
                    stringTooManyParens = (
                        'There are too many pairs of parentheses existing in the\n' +
                        'regular expression. Only 1 pair of parentheses are allowed.\n\n' +
                        'Correct the regular expression and try again.'
                        )
                    print(stringTooManyParens)
                    self.MySQL_Output(
                        0,
                        stringTooManyParens
                        )
                    try:
                        showerror(
                            'Error: too many pairs of parens',
                            stringTooManyParens,
                            parent=self.toplevelExtractAndFill
                            )
                    except:
                        showerror(
                            'Error: too many pairs of parens',
                            stringTooManyParens
                            )
                    return
                        
                    
# ... compile regular expression; 
                ''' NOT NEEDED!!!
# ... NOTE: this will compile even with garbage in it, so be careful; error check here and when used as well
                try:
                    regexpCompiled = re.compile(regularExpression)
                    stringCompiledOK = (
                        '  > regular expression compiled normally'
                        )
                    print(stringCompiledOK)
                    self.MySQL_Output(
                        0,
                        stringCompiledOK
                        )                        
                except:
                    stringNoRegExpCompile = (
                        'The regular expression did not compile initially.\n\n' +
                        'Check syntax, correct the expression, and try again.'
                        )
                    print stringNoRegExpCompile
                    self.MySQL_Output(
                        0,
                        stringNoRegExpCompile
                        )
                    showerror(
                        'Error: regex',
                        stringNoREgExpCompile,
                        parent=self.toplevelExtractAndFill
                        )
                    return
                '''

# --- end of error check ---

# failure flag
                textRegExFailure = 0
# keep track of ALL missing headers with this list
                listMissingHeadersAndDatatype_Total = []
# keep track of ALL current headers with this list, including the original headers
                listColumnHeaders_Current = listColumnHeaders_Original
# list of objects to be put into database table
                matchedObjects = []
# track row numbers that have no match
                rowsNotMatched = []
# track row numbers that have matched
                rowsMatched = []
# track blank rows
                rowsBlank = []
# count total number of rows searched
                rowsSearched = 0
# loop over designated rows
                for row in row_numbers_Affected:
                    rowsSearched += 1
# define empty list for yaml.load of input object
                    textRegExColumnLoad = []
# define empty temp list
#                    objects = []
# list of all items extracted from yaml-formatted file; define empty list first
# get column headers from column data; put in dictionary for sorting and creating table fields
# ... each item containts [header title, value, datatype]
                    listAlltextRegExItems = []
# ... check for empty field first; if so, or if error encountered, just skip over, 
#       but don't halt loop as other fields may NOT be empty
                    try:
# get the field object which will be searched
                        textRegExObject = self.tableValues[row][columnNumber].strip()
# allow for empty entry in selected column; if so, continue looping thru rows
                        if textRegExObject == '':
# ... append blanks to matchedObjects, and then skip over the empty fields
# ...   format: [matched_value, row_autoindex]
                            matchedObjects.append(['',int(listAutoIndexValuesAffected[row])])
                            rowsBlank.append(row+1)
                            continue
                        print('\n row %s. field value = \n%s' % (row + 1,textRegExObject))
                    except:
                        stringtextRegExObjectError = (
                            'Error accessing TEXT object in database.\n'+
                            'Row: %s\n' +
                            'Column: %s\n' +
                            'Continuing ...\n'
                            ) % (str(eval(row) + 1),str(columnNumber))
                        print stringtextRegExObjectError
                        showerror(
                            'Error: textRegEx object',
                            stringtextRegExObjectError
                            )
                        textRegExFailure = 1
                        break
                        
                    if DEBUG_TEXT_REGEX:
                        print('\ntextRegExObject:\n %s' % textRegExObject)
                        print('\nlen(textRegExObject) = %s' % len(textRegExObject))
#                        sys.exit()

# search the object for patterns expressed in regular expression for this field only
                    matches = []
                    try:
#                        matches = re.findall(regexpCompiled, textRegExObject)
                        matches = re.findall(regularExpression, textRegExObject)
                        print('\nregexp matches:\n%s' % matches)
                        print('\nnumber of matches in list: %s\n' % len(matches))    
                    except:
                        stringNoRegExpCompile = (
                            'The regular expression did not compile correctly.\n\n' +
                            'Check syntax, correct the expression, and try again.'
                            )
                        print stringNoRegExpCompile
                        self.MySQL_Output(
                            0,
                            stringNoRegExpCompile
                            )
                        try:
                            showerror(
                                'Error: regex',
                                stringNoREgExpCompile,
                                parent=self.toplevelExtractAndFill
                                )
                        except:
                            showerror(
                                'Error: regex',
                                stringNoREgExpCompile
                                )
                        return
                    
# say so if no matches in current field; append as blank and continue
                    if len(matches) == 0:
                        print('\n>>> no regex pattern matches were found for row %s\n' % row)
                        rowsNotMatched.append(row+1)
                        continue

# extract the nth occurrence here
                    nthOccurrence = int(self.comboboxExtractAndFill_NthOccurrence.get())

# error check
                    if nthOccurrence > len(matches):
                        fieldCurrent = self.comboboxExtractAndFill_ColumnNameToExtractTo.get()
                        stringNthOutOfBounds = (
                            'For row = %s in Field #%s:\n\n' +
                            '   regular expression matches = \n' +
                            '   %s\n\n' +
                            'You have chosen to select the %s-th occurrence of a matched\n' +
                            'expression, but there are only %s matches in the current row.\n\n' +
                            'This process cannot continue with the options chosen.\n\n' +
                            'Revise which occurrence of the match-list you wish to select\n' +
                            'and try again.'
                            ) % (row,fieldCurrent,matches,nthOccurrence,len(matches))
                        print stringNthOutOfBounds
                        self.MySQL_Output(
                            0,
                            '\n' + stringNthOutOfBounds
                            )
                        showerror(
                            'Error: mismatch',
                            stringNthOutOfBounds
                            )
                        return
                        
# get the match desired
                    try:
                        match = matches[nthOccurrence - 1]
                        matchedObjects.append([match,int(listAutoIndexValuesAffected[row])])
                        rowsMatched.append(row+1)
                    except:
# occurs if nthOccurrence is > len(matches)
                        matchedObjects.append(['',int(listAutoIndexValuesAffected[row])])
                        rowsNotMatched.append(row+1)

# ----- END OF FOR LOOP to extract matched objects                    
                    
# give user a snapshot of data which will be inserted into database table
                stringUserInfo = ''
                stringUserInfo = (
                    'These are the first few rows of data to be inserted:\n' +
                    ' format: row. value, auto_insert_number\n\n'
                    )
                for num,matchList in enumerate(matchedObjects):
                    match = matchList[0]
                    autoInsert = matchList[1]
# first few rows
                    if num + 1 <= 10:
                        stringUserInfo += (
                            '\n' + '%s. %s, %s'
                            ) % (num + 1,match,autoInsert)                        
# matched rows
                stringUserInfo += (
                    '\n\nNumber of matched rows: %s'
                    ) % len(rowsMatched)
                '''
                if len(rowsMatched) > 0:
                    stringUserInfo += (
                        '\n matched rows: %s'
                        ) % rowsMatched
                '''
# unmatched rows
                stringUserInfo += (
                    '\n\nNumber of unmatched rows: %s'
                    ) % len(rowsNotMatched)
                if len(rowsNotMatched) > 0:
                    stringUserInfo += (
                        '\n  unmatched rows: %s'
                        ) % rowsNotMatched
# blank rows
                stringUserInfo += (
                    '\n\nNumber of blank rows (no fields to search): %s'
                    ) % len(rowsBlank) 
                if len(rowsBlank) > 0:
                    stringUserInfo += (
                        '\n  blank rows: %s'
                        ) % rowsBlank
# total rows searched                    
                stringUserInfo += (
                    '\n\nTotal rows searched: %s'
                    ) % rowsSearched
                print(stringUserInfo)
                self.MySQL_Output(
                    0,
                    stringUserInfo
                    )
                try:
                    ans = askokcancel(
                        'Data snapshot',
                        stringUserInfo,
                        parent=self.toplevelExtractAndFill
                        )
                except:
                    ans = askokcancel(
                        'Data snapshot',
                        stringUserInfo
                        )
                if not ans:
                    return
                
                '''
                stringInsertTextRegexData = (
                    '\nData preparation finished.\n\n' +
                    'Now inserting into table.'
                    )
                self.MySQL_Output(
                    0,
                    stringInsertTextRegexData
                    )
                showinfo(
                    'Info: insert data into table',
                    stringInsertTextRegexData
                    )
                '''

# may want to put something here later                    
                if DEBUG_TEXT_REGEX:
                    pass                      

# form table insert statement using header names specifically; loop over list, inserting into
#   one row at a time (easier logic than batch submit; these are not large databases)
                
                stringMySQLUpdate_FixedString = 'update ' + self.myDatabase + '.' + self.myTable + ' set '
                
                for matchList in matchedObjects:
                
                    match = matchList[0]
                    autoInsertIndex = matchList[1]
                    
                    stringMySQLUpdate = []
                
                    stringMySQLUpdate = (
                        columnNameToExtractTo + ' = \'' + str(match) + '\' where auto_index = ' + str(autoInsertIndex) 
                        )

                    stringMySQLUpdate = stringMySQLUpdate_FixedString + stringMySQLUpdate
                
                    print('\nstringMySQLUpdate = \n%s' % stringMySQLUpdate)

# execute the command to insert the data into the corresponding fields
                    try:
                        self.cursorHandleMySQL.execute(stringMySQLUpdate)
                    except:
                        stringInsertedUpdateFailed = (
                            '\nRow %s. FAILED -- Attempt to Insert %s where auto_index = %s'
                            ) % (row, match, autoInsertIndex)
                
# --- END of "for row in row_numbers_Affected:"

# UPDATE MAIN WINDOW AFTER ALL MODS TO TABLE
# ... refresh table
            stringRefreshTable = (
                'Table %s has added data to %s rows under column %s.\n\n' +
                'Table will now be refreshed.'
                ) % (self.myTable,len(matchedObjects),columnNameToExtractTo)
            print stringRefreshTable
            showinfo(
                'INFO: table refresh',
                stringRefreshTable
                )
                    
# ... update status line
            maxLinesDisplay = int(self.comboboxMaxLinesToDisplay.get())
            if maxLinesDisplay == 0 or maxLinesDisplay > len(self.tableValues):
                maxLinesDisplay = len(self.tableValues)
            
#        self.handlerStatusLineRefresh(maxLinesDisplay)
# ... adjust plot window if it's open
            self.handlerInvokeButtonToRefreshPlotXYWindow()
# ... refresh  Storage Buffer window, if mapped
            try:
                mappedBuffer = self.toplevelShowStorageBuffer.winfo_exists()
            except:
                mappedBuffer = False
            if mappedBuffer:
#                self.buttonTableValuesShowAll_Buffer.invoke()  
                self.handlerRefreshBufferView()
                
# update table values for EXTRACT DATA & FILL TABLE, text, one field at a time          
            try:
                mapped = self.toplevelTableValues.winfo_exists()
            except:
                mapped = False
                                
            if mapped:
                self.handlerDisplayLimitedRows()    # PEEK handler
            
# update filter window
                try:
                    mapped = self.toplevelSelectDisplayOrderedFields.winfo_exists()
                except:
                    mapped = False
            
                if mapped:
                    self.handlerSelectDisplayOrderedFields_Update()
                    
# restore checked fields
            self.restoreCheckedFieldNames()  
            
            return
            
# --- end TEXT using protocol regex ---

# = = = = = = = = = = = = = = = = = = = = = = = = =

        else:
# PROTOCOL UNSPECIFIED
# protocol has not been specicified or it has not been implemented
            stringNoProtocol = (
                'The specified Protocol for Extraction & Fill\n' +
                'has not yet been implemented.\n\n' +
                'Choose one of the listed Protocols and try again.'
                )
            print stringNoProtocol
            showerror(
                'Error: Protocol not implemented',
                stringNoProtocol
                )

# restore checked fields
            self.restoreCheckedFieldNames() 
            
            return

# ... get all headers

# ... check if headers exist in table; if they don't, create them in the database using MySQL cmmands; 
#       check each object in case one has fields/data the others do not
#       must also have a scheme to determine datatypes

# use appropriate MySQL command to insert values into table

# NOTES:
#  make sure if table window is canceled, the Extract table also is closed.
        
        return
        
        
    def replaceSpecialCharacters(self,stringTemp):
        '''
        Purpose:
            replace special characters so that MySQL can understand
        '''
     
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'replaceSpecialCharacters')   
            
        stringTemp = stringTemp.replace('/','_')                    # 1
        stringTemp = stringTemp.replace('\\','_')                   # 2
        stringTemp = stringTemp.replace('-','_')                    # 3
        stringTemp = stringTemp.replace('(','')                      # 4
        stringTemp = stringTemp.replace(')','')                      # 5
        stringTemp = stringTemp.replace('.','')                      # 6 
        stringTemp = stringTemp.replace('%','percent')        # 7
        stringTemp = stringTemp.replace(',','')                      # 8
        stringTemp = stringTemp.replace('[\'','"\'')                # 9
        stringTemp = stringTemp.replace('\']','"\'')                # 10
        stringTemp = stringTemp.replace('["','\'"')                 # 11
        stringTemp = stringTemp.replace('"]','"\'')                 # 12
        
        if DEBUG_REPLACECHAR:
            print('\nstringTemp = %s' % stringTemp)
        
        return stringTemp
        
    def typeIt(self, var):
        '''
        Purpose:
            determine type of the variable and assign a string that can be understood by MySQL
        '''
        
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'typeIt')
        
        if type(var) == int:
            return 'INTEGER(10)'
        elif type(var) == str:
#            return 'CHAR(200)'
            return 'TEXT'
        elif type(var) == float:
            return 'FLOAT'
        elif type(var) == bool:
#            return 'BOOL'
            return 'TEXT'
        elif type(var) == long:
            return 'LONG'
        elif type(var) == list:
            return 'TEXT'
        else:
            stringTypeError = (
                (
                'The datatype of the variable,\n\n%s\n\n' +
                'has not been found in the current list of options.\n\n' +
                'Modify this method ("typeIt") to provide for this datatype.\n\n'
                )
                % (type(var))
                )
            print stringTypeError
            showerror(
                'Error: datatype not found',
                stringTypeError
                )
                
        return
            
            
    def handlerPickPossibleColumnForTextFile(self):
        '''
        Purpose:
            Attempts to choose which column has a text file
            in it and puts that column number and header
            in the field:
            self.comboboxExtractAndFillTableColumn
            where the drop-down menu columns are given by
            scrolledlist_items=self.listEnumerateHeaders
            
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerPickPossibleColumnForTextFile')
        
# search table by column headers for text > 255 chars; this would indicate 
#   a file in that column. Also check for type 'text' and not 'char'. This
#   would then strongly indicate that the column is really a file.  

        numColumns = len(self.tableValues[0]) - 1 # don't include auto_index column
        
        listItems = []
        listItems = self.tableValues[0]
        
        if DEBUG_EXTRACT_FILL_TEXT:
            print('numColumns = %s\n' % numColumns)
            print('listItems =\n')
            print(listItems)
        
# search thru upto 5 rows, if available, in case first one or two or so have empty columns
        foundIt = 0
        lenElement = 0
        searchRows = min(5,len(self.tableValues))
        for row in range(searchRows):
            if foundIt == 1: break
            for column in range(numColumns):
                try:
                    lenElement = len(self.tableValues[row][column])
                except:
                    pass
                if lenElement > 255:
                    foundIt_Row = row
                    foundIt_Column = column
                    foundIt = 1
                    break
                    
        if foundIt == 0: 
# could not find a table element greater than 255 characters, so 
#  clear combobox entry for "Column # / Column Header" and just return
            self.comboboxExtractAndFillTableColumn.setentry('')
            return
            
        if DEBUG_EXTRACT_FILL_TEXT:
            print('foundIt_Row = %s\n' % (foundIt_Row + 1))
            print('foundIt_Column = %s\n' % foundIt_Column)
            print('type(foundIt_Column) = %s\n' % type(foundIt_Column))
            print('lenElement = %s\n' % lenElement)
            for num,header in enumerate(self.dictColumnHeaders):
                print('%s. %s\n' % (num, header))
            
            
        columnHeaderName = ''
        for k,v in self.dictColumnHeaders.iteritems():
            if v == foundIt_Column + 1:
                columnHeaderName = k
                
        if columnHeaderName == '':
            stringNoHeaderNameFound = (
                'No column header name could be found for\n' +
                'the column %s.\n\n' +
                'This is a coding error. Contact code administrator'
                )
            print stringNoHeaderNameFound
            self.MySQL_Output(
                0,
                stringNoHeaderNameFound
                )
            showerror(
                'Error: no header name found',
                stringNoHeaderNameFound
                )
            return
            
        columnNumberAndHeader = (str(foundIt_Column + 1) + '. ' + columnHeaderName)
        
        if DEBUG_EXTRACT_FILL_TEXT:
            print('columnNumberAndHeader = %s\n' % columnNumberAndHeader)
        
# set entry field to header found
#        self.comboboxExtractAndFillTableColumn.setentry(columnNumberAndHeader)  
        if foundIt:
            self.comboboxExtractAndFillTableColumn.selectitem(
                self.listEnumerateHeaders[foundIt_Column]
                )
#            self.varXSelect.set(foundIt)
        else:
            self.comboboxExtractAndFillTableColumn.setentry('')
#        self.comboboxExtractAndFillTableColumn.selectitem(foundIt_Column,1)  
        
# select this column in table using self.varXSelect
        self.varXSelect.set(foundIt_Column + 1)
        
# enable all widgets associated with text search
        self.radiobuttonExtractAndFill_SearchAll.configure(state=NORMAL)
        self.radiobuttonExtractAndFill_SearchLimited.configure(state=NORMAL)
        self.comboboxExtractAndFill_SearchLimited_Start.configure(
            entry_state='normal',
            )
        self.comboboxExtractAndFill_SearchLimited_End.configure(
            entry_state='normal',
            )
        self.comboboxExtractAndFill_ColumnNameToExtractTo.configure(
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black'
            )
        self.buttonExtractAndFill_CreateNewField.configure(state=NORMAL)
        self.entryExtractAndFill_ColumnNameToExtractTo_Datatype.configure(
            state=DISABLED,
            disabledbackground='white',
            disabledforeground='black'
            )
        '''
        self.comboboxExtractAndFill_ColumnNameToExtractTo_Datatype.configure(
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black'
            )
        self.entryExtractAndFill_ColumnNameToExtractTo_Length.configure(state=NORMAL)
        '''
        
        self.comboboxExtractAndFill_NthOccurrence.configure(entry_state='normal')
        
        self.radiobuttonProtocolAlphanumeric.configure(state=NORMAL)
        self.radiobuttonLocation_Following.configure(state=NORMAL)
        self.radiobuttonLocation_Preceding.configure(state=NORMAL)
        self.radiobuttonLocation_Equal.configure(state=NORMAL)
        self.entryExtractAndFill_NthOccurrence.configure(state=NORMAL)
        self.comboboxExtractAndFill_StopExtracting.configure(
            entry_state='normal'
            )
        self.radiobuttonProtocolRegex.configure(state=NORMAL)
        self.entryExtractAndFill_RegularExpression.configure(state=NORMAL)
        
        return


    def handlerExtractAndFillCancel(self):
        '''
        Purpose:
            close the toplevel window associated with Extract And Fill
            window
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerExtractAndFillCancel')
            
        self.toplevelExtractAndFill.destroy()
        
        return
        
    def updateXSelectFromExtractAndFill(self, entry):
        '''
        Purpose:
            update the X-Select radiobutton selected based on
            entry to Extract & Fill window's combobox
        '''
        
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'updateXSelectFromExtractAndFill')
        
        stringEntry = entry.strip()
        if stringEntry == '':
            return
        else:
            column = eval(stringEntry.split('.')[0])
            self.varXSelect.set(column)
        
        return
        

    def destroyAllDatabaseTableFieldFrames(self):
        '''
        Purpose:
            destroy any and all frames so that frames
            don't accumulate on screen while working
            with databases, tables, fields, and/or
            backup & restore processes
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'destroyAllDatabaseTableFieldFrames')

# close BACKUP / RESTORE window            
        try:
            self.toplevelBackupRestore.destroy()
        except: 
            pass

# DATABASES
# ... database create
        try:
            self.toplevelDatabaseCreate.destroy()
        except:
            pass
# ... database delete
        try:
            self.toplevelDatabaseDelete.destroy()
        except:
            pass
# ... database rename
        try:
            self.toplevelDatabaseRename.destroy()
        except:
            pass
            
# TABLES
# ... table create
        try:
            self.toplevelTableCreate.destroy()
        except:
            pass
# ... table delete
        try:
            self.toplevelTableDelete.destroy()
        except:
            pass
# ... table functions
        try:
            self.toplevelTableFunctions.destroy()
        except:
            pass
            
# FIELDS
# ... fields add
        try:
            self.toplevelFieldAdd.destroy()
        except:
            pass
# ... fields delete
        try:
            self.toplevelFieldDelete.destroy()
        except:
            pass
# ... fields edit
        try:
            self.toplevelFieldNameEdit.destroy()
        except:
            pass
      
        return
            
            
    def handlerResetAllSingleGroupPerPlotBuffer(self):
        '''
        Purpose:
            Reset all values to default in the 
            'PLOT LABELS \n For Single Curve per Plot' window
            for Storage Buffer data
        '''
        '''
        self.comboboxPlotLabelSeparatorSingle.selectitem(
           self.separatorsPlotLabelsAndLegends[0]
           )
        '''
        
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerShowGroupLabelsBuffer')
            
        if self.entryfieldXUserLabelSingleGroupPerPlotBuffer.get().strip() <> '':
            self.entryfieldXUserLabelSingleGroupPerPlotBuffer.setvalue('')
        if self.comboboxY1LabelSingleGroupPerPlotBuffer.get().strip() <> '':
            self.comboboxY1LabelSingleGroupPerPlotBuffer.setentry('')
        if self.comboboxY2LabelSingleGroupPerPlotBuffer.get().strip() <> '':
            self.comboboxY2LabelSingleGroupPerPlotBuffer.setentry('')
        if self.comboboxY3LabelSingleGroupPerPlotBuffer.get().strip() <> '':
            self.comboboxY3LabelSingleGroupPerPlotBuffer.setentry('')
        if self.entryfieldYUserLabelSingleGroupPerPlotBuffer.get().strip() <> '':
            self.entryfieldYUserLabelSingleGroupPerPlotBuffer.setvalue('')
        
        self.entryfieldXLabelShowBuffer_Kiviat.setvalue('')
        self.entryfieldYLabelShowBuffer_Kiviat.setvalue('')
       
        return


# ============ kiviat start ===================         
            
    def handlerUpdateKiviatPlots_Table_Initialize(self):
        '''
        Purpose:
            initialize the Kiviat Plotting Specs window; implemented by pressing
            'Kiviat Plots' button on left side of table in Values for Table window
            
        Called by:
            handlerTableFunctionsShowValues(self)
        '''
        
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerUpdateKiviatPlots_Table_Initialize **')
                
# set last button pressed
        self.lastButtonPressed(
            BUTTONLABEL_KIVIATPLOTS
            )
                
# check if a table has even been read in 
        emptyTableCheck = self.checkIfEmptyTable()
        if emptyTableCheck:
            return
        
# check if previous window exists
        try:
            mapped = self.toplevelKiviatPlotPreprocess.winfo_exists()
        except:
            mapped = False

# if previous window exists, ask user if ok to close previous window and start another
        if mapped:
            ans = askokcancel(
                'Initialize plot window',
                'To start a new "Kiviat Plotting Specs" window, click on OK,\n\n' +
                'This will destroy the old window and initialize a new\n' +
                'window with no Table or Buffer curves specified.\n\n' +
                'Otherwise, click Cancel to continue with the "Kiviat Plotting\n' +
                'Specs" window as is.',
                parent=self.toplevelKiviatPlotPreprocess
                )
            if not ans:
                return
                
# if ok to start another, initialize curves and labels
        if mapped:
            self.toplevelKiviatPlotPreprocess.destroy()
            
# legend labels 
        self.legendLabelStringTable_Kiviat_Default = []
# no need for legend title
           
# ... following values used in 'handlerKiviatPlotPreprocess' to set table and buffer curves to zero
        self.jcountTable_Kiviat = 0
        self.jcountBuffer_Kiviat = 0
        self.listWhichBufferGroupsAreChecked_Kiviat = []
        
# ... header names
        self.headerNames_Y_Table_Kiviat = [] 
        self.headerNames_Y_Buffer_Kiviat = []
            
# if any y values are checked, go thru 'handlerUpdateKiviatPlots_Table' instead of here
        count_Y = 0
        count_X = 0
        for var in self.varYSelect:
            if var.get():
                count_Y += 1 
# make sure an X-select column is chosen for the legend
        count_X = self.varXSelect.get()
# make sure at least 3 spokes are in the group; if not, cannot plot kiviat diagram     
        stringErrorCount = ''
        if(
          (count_Y < 3)         # not enough spokes
          or
          (count_X == 0)         # no legend value for circular curves
          ):
            if count_Y < 3:
# everything looks good so far        
                stringErrorCount += (
                    'Numerical Y-select values (table columns) must be at\n' +
                    'least 3 to draw a valid kiviat diagram.\n\n' +
                    'You have currently specified %s Y-select values.\n\n' +
                    'Specify at least 3 Y-select values to draw a valid\n' +
                    'Kiviat diagram.'
                    ) % count_Y
            if count_X == 0:
                stringErrorCount += (
                    '\n\nA numerical X-select value (table column) must be selected\n' +
                    'to be used for the legend.'
                    )
            print stringErrorCount
            self.MySQL_Output(
                0,
                stringErrorCount
                )
            okay = askokcancel(
                'Warning: improper values for kiviat diagram',
                stringErrorCount +
                '\n\n----------\n\n' +
                'Click "OK" to display Kiviat Plotting Specs with\n' +
                ' "Number of groups to plot from table" set to zero.\n\n' +
                'Click "Cancel" to return to table.'
                )
            if okay:
# graph Kiviat Plotting Specs window with self.jcountTable_Kiviat = 0, etc.
                self.handlerKiviatPlotPreprocess()
            return
              
# only one group from table can ever be defined
        self.jcountTable_Kiviat = 1
        self.handlerUpdateKiviatPlots_Table()
        
        return


    def handlerUpdateKiviatPlots_Table(self):
        '''
        Purpose: 
            update Kiviat Plotting Specs window with table selection
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerUpdateKiviatPlots_Table')
        
# check if a table has even been read in 
        emptyTableCheck = self.checkIfEmptyTable()
        if emptyTableCheck:
            return

# determine which Y table columns are checked
# get Y headers
        self.jcountTable_Kiviat = 0
# ... determine how many y-values are checked; then, display; also get headers
# ...       note that self.headerNames_Y_Table_Kiviat is used in "Plot a selected group's curves"
        self.headerNames_Y_Table_Kiviat = []
        self.index_Y_Table_Kiviat = []
        jindex=1
        try:
            for var in self.varYSelect:
                if var.get():
                    for key,value in self.dictColumnHeaders.iteritems():
                        if value == jindex:
                            self.headerNames_Y_Table_Kiviat.append(key)
                            self.index_Y_Table_Kiviat.append(value - 1)
#                   self.jcountTable_Kiviat += 1
                jindex += 1
        except:
            pass    # means self.varYSelect has yet to be defined
            
        self.label_X_Table_Kiviat = ''
        columnX = -1
        try:
            jindex = self.varXSelect.get()
        except:
            pass    # self.varXSelect not yet defined
            
        if DEBUG_KIVIAT:
            print('jindex = %s' % jindex)
            print('self.dictColumnHeaders =\n%s' % self.dictColumnHeaders)
        for key,value in self.dictColumnHeaders.iteritems():
            if value == jindex:
                self.label_X_Table_Kiviat = key
                columnX = jindex - 1
                break        
      
# find which rows have been selected in table
        self.rowsSelectedTable_Kiviat = []
        rowCount_Kiviat = 0
        rowNum = 0
        try:
            for var in self.varSelectAnyRow:
                if var.get():
                    self.rowsSelectedTable_Kiviat.append(rowNum)
                    rowCount_Kiviat += 1
                rowNum += 1 
        except:
            pass    # means self.varSelectAnyRow has yet to be defined
            
        if DEBUG_KIVIAT_TABLE:
            print()
            print('='*50)
            print('self.dictColumnHeaders = \n%s' % 
                self.dictColumnHeaders
                )
            print('\nself.headerNames_Y_Table_Kiviat =\n%s' %
                self.headerNames_Y_Table_Kiviat
                )
            try:
                print('\nself.varYSelect =\n%s' %
                    self.varYSelect
                    )
            except:
                pass    # self.varYSelect not yet defined
            print('\nself.headerNames_Y_Table_Kiviat:\n%s' % self.headerNames_Y_Table_Kiviat)
            print('\nself.rowsSelectedTable_Kiviat:\n%s' % self.rowsSelectedTable_Kiviat)
            print('='*50 + '\n')              
                
                
# ----------------------------------- ERROR CHECKING -------------------------------------
# initialize flag
        flag_NoYSelect = 0   
# check existence of Kiviat plot window
        try:
            mappedPlotPreprocess_Kiviat = self.toplevelKiviatPlotPreprocess.winfo_exists()
        except:
            mappedPlotPreprocess_Kiviat = False
            
# check length of self.index_Y_Table_Kiviat          
        try:
            if len(self.index_Y_Table_Kiviat):
                lenIndex_Y = len(self.index_Y_Table_Kiviat)
            else:  
                lenIndex_Y = 0
        except:
            lenIndex_Y = 0 
            
        if (
         (not mappedPlotPreprocess_Kiviat)
          and
         (lenIndex_Y == 0)
          and
         (columnX == -1)
          and
         (len(self.rowsSelectedTable_Kiviat) == 0)
         ):
            errorCheck = False
        else:
            errorCheck = True
            
        if errorCheck:    
#            if len(self.index_Y_Table_Kiviat) == 0:
            if len(self.index_Y_Table_Kiviat) < 3:
# ... not enough Y-Select values have been chosen; must have at least 3 selections to plot
#       a kiviat diagram from the table
                flag_NoYSelect=1
            elif len(self.index_Y_Table_Kiviat) > len(self.varYSelect):
# self.index_Y_Table_Kiviat was not properly formed, or not properly zeroed before being formed
                stringIndexYError = (
                    'len(self.index_Y_Table_Kiviat) error.'
                    )
                print (
                    ('Error: ' + stringIndexYError + '\n' + 
                    '   len(self.index_Y_Table_Kiviat) = %s\n' +
                    '   len(self.varYSelect = %s') % 
                    (len(self.index_Y_Table_Kiviat), len(self.varYSelect))
                    )
                self.MySQL_Output(
                    1,
                    ('Error: ' + stringIndexYError + '\n\n' +
                    ' len(self.index_Y_Table_Kiviat) = %s\n' +
                    ' len(self.varYSelect = %s') % 
                    (len(self.index_Y_Table_Kiviat), len(self.varYSelect))
                    )
                try:
                    showerror(
                        'Error: IndexYError',
                        ('\n' + stringIndexYError + '\n\n' +
                        ' len(self.index_Y_Table_Kiviat) = %s\n' +
                        ' len(self.varYSelect = %s') % 
                        (len(self.index_Y_Table_Kiviat), len(self.varYSelect)),
                        parent=self.toplevelTableValues,
                        )
                except:
                    showerror(
                        'Error: IndexYError',
                        ('\n' + stringIndexYError + '\n\n' +
                        ' len(self.index_Y_Table_Kiviat) = %s\n' +
                        ' len(self.varYSelect = %s') % 
                        (len(self.index_Y_Table_Kiviat), len(self.varYSelect))
                        )
                return  
            
# print error if both X-Select and Y-Select are blank (no table curves) AND buffer curves 
#   are to be plotted but no buffer storage curves are checked
            if (
              (flag_NoYSelect) 
#               and 
#              self.jcountBuffer_Kiviat == 0
              ):
# ... not enough Y values from table or rows from buffer have been selected
                if flag_NoYSelect:
                    stringNoKiviatSelect_Y = (
                        'Not enough Y values have been selected for plotting from\n' +
                        'the table.\n\n' + # nor any groups from the storage buffer.\n\n' +
                        'Select at least 3 Y-values from table and/or at least one\n' +
                        ' group (row) from the storage buffer and try again.' 
                        )
                    print '\nError: ' + stringNoKiviatSelect_Y
                    self.MySQL_Output(
                        1,
                        'Error: ' + stringNoKiviatSelect_Y
                        )
                    try:
                        showerror(
                            'Error: no plot values',
                            stringNoKiviatSelect_Y,
                            parent=self.toplevelTableValues,
                            )
                    except:
                        showerror(
                            'Error: no plot values',
                            stringNoKiviatSelect_Y
                            )
                    return
                    
# ... no row values selected
            if (
                (len(self.index_Y_Table_Kiviat) > 0)
                and
                (columnX >= 0)
                and
                (rowCount_Kiviat == 0)
                ):
                stringNoKiviatSelect_Rows = (
                    'No rows have been selected for plotting from\n' +
                    'the table, although Y-values and/or an X-value have\n' +
                    'been selected.\n\n' +
                    'Select at least one row from the table and try again.'
                    )
                print '\nError: ' + stringNoKiviatSelect_Rows
                self.MySQL_Output(
                    1,
                    'Error: ' + stringNoKiviatSelect_Rows
                    )
                try:
                    showerror(
                        'Error: no rows selected',
                        stringNoKiviatSelect_Rows,
                        parent=self.toplevelTableValues,
                        )
                except:
                    showerror(
                        'Error: no rows selected',
                        stringNoKiviatSelect_Rows
                        )
                return
                
# ... no X-column selected
            if (columnX == -1):
                stringNoKiviatXColumnFromTable = (
                    'No X-select column has been selected for legend labels.\n\n' +
                    'Select an X column and try again.'
                    )
                print stringNoKiviatXColumnFromTable
                self.MySQL_Output(
                    1,
                    'Error: ' + stringNoKiviatXColumnFromTable
                    )
                try:
                    showerror(
                        'Error: no X-column selected',
                        stringNoKiviatXColumnFromTable,
                        parent=self.toplevelTableValues,
                        )
                except:
                    showerror(
                        'Error: no X-column selected',
                        stringNoKiviatXColumnFromTable
                        )
                return
                    
# X labels are used only for legend; these can be text or numbers, so no need to determine if they are strictly text or not
                        
# check that the Y-Select values are numerical fields; can't plot text!
            jcount=0
            flag_FieldYIsNotNumerical = 0
# see which column checkboxes have been checked
            for varY in self.varYSelect:
                jcount+=1
                if varY.get():
# find corresponding column number and title            
                    for key,columnNumber in self.dictColumnHeaders.iteritems():
                        columnHeader = key
                        if columnNumber == jcount:
# when column header is matched with checkbox, get first two characters of datatype and 
#   check if field is numerical
                            varfirst2 = self.tableStructure[jcount-1][1][0:2]
#                        print ' self.tableStructureOriginal = ',self.tableStructureOriginal
                            fieldYIsNumerical = self.checkIsFieldNumerical(varfirst2)
                            if not fieldYIsNumerical:
# y-select field is NOT numerical
                                flag_FieldYIsNotNumerical = 1
                                print('\nError: Y-Select field "%s" for plotting is not numerical' % key)
                                self.MySQL_Output(
                                    1,
                                    'Error: Y-Select field "%s" for plotting is not numerical' % (key)
                                    )
                            else:
# y-select field is numerical, so OK
                                if DEBUG_ISNUMERICALFIELD:
                                    print('\nY-Select field "%s" is a numerical field' % key)

# if Y-Select is not numerical, return                            
            if flag_FieldYIsNotNumerical: # or flag_FieldXIsNotNumerical:
                try:
                    mappedToplevelKiviatPlotPreprocess = self.toplevelKiviatPlotPreprocess.winfo_exists()
                except:
                    mappedToplevelKiviatPlotPreprocess = False
                    
                if mappedToplevelKiviatPlotPreprocess:
# gray out Plot button in Plotting Specs        
                    self.buttonKiviatPlottingSpecsPlot.configure(state='disabled')
                    
                stringFieldError = '' 
                stringFieldError += (
                    'Y-Select field(s) not numerical.' + '\n\n'
                    'Select numerical fields for Y' + '\n' +
                    '  and try again.'
                    )
                try:    
                    showerror(
                        'Error: field(s) not numerical',
                        stringFieldError,
                        parent=self.toplevelTableValues,
                        )
                except:
                    showerror(
                        'Error: field(s) not numerical',
                        stringFieldError
                        )
                return  
                

# check if rows have been selected
            if len(self.rowsSelectedTable_Kiviat) == 0:
                stringNoRowsSelected = (
                    'No rows have been selected for Kiviat plots.\n\n' +
                    'Select desired rows from table and try again.'
                    )
                print stringNoRowsSelected
                self.MySQL_Output(
                    0,
                    stringNoRowsSelected
                    )
                showerror(
                    'Error: no rows selected',
                    stringNoRowsSelected
                    )
                return

# ---------- END OF ERROR CHECKING ----------

# if we get this far, everything is ok
        if self.index_Y_Table_Kiviat == []:
            self.jcountTable_Kiviat = 0
        else:
            self.jcountTable_Kiviat = 1     # can only have one group from the table, no more
        
# Default label values if needed, for single group per plot
# default values for legend labels, if needed  
        self.legendLabelStringTable_Kiviat_Default = []
        for index in self.rowsSelectedTable_Kiviat:
            self.legendLabelStringTable_Kiviat_Default.append(self.tableValues[index][columnX])
# no need for X label; its default will just be 'Legend'

        if DEBUG_KIVIAT_TABLE:
            print('\nself.index_Y_Table_Kiviat =\n%s\n' % self.index_Y_Table_Kiviat)
            print('\nself.rowsSelectedTable_Kiviat =\n%s\n' % self.rowsSelectedTable_Kiviat)
            print(
                '\nself.legendLabelStringTable_Kiviat_Default:\n%s\n' % 
                    self.legendLabelStringTable_Kiviat_Default
                )
                
  
# ... get y labels - just rename here
        self.label_Y_Table_Kiviat = self.headerNames_Y_Table_Kiviat
        
# get legend labels associated with the y values, for legend
        self.plot_X_Table_Kiviat = []  
        for row in self.rowsSelectedTable_Kiviat:
            self.plot_X_Table_Kiviat.append(self.tableValues[row][columnX])

# define Y data lists
        self.plot_Y_Table_Kiviat = []     
# store each row of Y values in a list, and append to master list
# ... this means the first element of each Y list comprises the first curve, 2nd element the 2nd curve, and so on
#        if self.varNumberOfTableCurves.get() <> 0:
#        if len(self.index_Y_Table_Kiviat) <> 0:
# define all y values for current table selections
# define columns with j
        for column in self.index_Y_Table_Kiviat:
            tempY_Kiviat=[]
# define rows with i; use only selected rows
#                for i in range(len(self.tableValues)):
            for row in self.rowsSelectedTable_Kiviat:
                tempY_Kiviat.append(self.tableValues[row][column])
            self.plot_Y_Table_Kiviat.append(tempY_Kiviat) 
                
# get max values for each column (spoke); use all values 
#   in a table column, not just selected rows
# max value for each spoke in table
        self.maxValuesYColumnsLocalTable_Kiviat = []
# max value for each group (plot) in table + storage buffer
        self.maxValuesForEachGroupLocal_Kiviat = []
# max value for all groups, table + storage buffer
        self.maxValueForAllGroupsGlobal_Kiviat = ''
        
# determine max value for each selected table column
        tempMax_Kiviat = []
        
        if DEBUG_KIVIAT:
            print('\nself.index_Y_Table_Kiviat:')
            print(self.index_Y_Table_Kiviat)
            print('\nlen(self.tableValues) = %s' % len(self.tableValues))
        
        for j in self.index_Y_Table_Kiviat: # columns
            tempColumnValues_Kiviat = []
            for i in range(len(self.tableValues)):  # rows
                tempColumnValues_Kiviat.append(self.tableValues[i][j])
#            tempMax_Kiviat.append(max(tempColumnValues_Kiviat))
# store in a list format, each list corresponding to a group (plot)

#            self.maxValuesYColumnsLocalTable_Kiviat.append(tempMax_Kiviat) 
            self.maxValuesYColumnsLocalTable_Kiviat.append(max(tempColumnValues_Kiviat)) 
            
        if len(self.maxValuesYColumnsLocalTable_Kiviat) == 0:
            stringNoMaxValues = (
                'No data has been selected to update kiviat plots.'
                )
            print('\n' + stringNoMaxValues)
            self.MySQL_Output(
                0,
                stringNoMaxValues
                )
            showinfo(
                'Info: no data for update',
                stringNoMaxValues,
                parent=self.toplevelTableValues
                )
            return

# NOTE: Kiviat groups have not been implemented in the Storage Buffer yet, so
#   just include 1 group from table for now; groups from Storage Buffer will be
#   implemented later         
# store a list of max values for each individual group, not each spoke; (only one group at this point)
#   used for 'local maximum'
        '''
        for group in range(len(max(self.maxValuesYColumnsLocalTable_Kiviat)):
            self.maxValuesForEachGroupLocal_Kiviat.append(
                max(max(self.maxValuesYColumnsLocalTable_Kiviat[group])
                )
        '''
        self.maxValuesForEachGroupLocal_Kiviat.append(max(self.maxValuesYColumnsLocalTable_Kiviat))
                
# max for all groups; (only one group at this point)
#   used for 'global maximum'
        '''
        self.maxValueForAllGroupsGlobal_Kiviat = \
            max(self.maxValuesForEachGroupLocal_Kiviat)
        '''
        self.maxValueForAllGroupsGlobal_Kiviat = max(self.maxValuesForEachGroupLocal_Kiviat) # same as above
# determine index of the max value
        self.indexMaxValue_Kiviat = None
        indexMaxValue = 0
        for eachValue in self.maxValuesYColumnsLocalTable_Kiviat:
            if eachValue == self.maxValueForAllGroupsGlobal_Kiviat:
                self.indexMaxValue_Kiviat = indexMaxValue
                break
            else:
                indexMaxValue += 1
                
        if DEBUG_KIVIAT:
            print('')
            print('*** max values for Kiviat plots:')
            print('self.maxValuesYColumnsLocalTable_Kiviat = %s' % self.maxValuesYColumnsLocalTable_Kiviat)
            print('self.maxValuesForEachGroupLocal_Kiviat = %s' % self.maxValuesForEachGroupLocal_Kiviat)
            print('self.maxValueForAllGroupsGlobal_Kiviat = %s' % self.maxValueForAllGroupsGlobal_Kiviat)
            print('self.indexMaxValue_Kiviat = %s' % self.indexMaxValue_Kiviat)
                
# --- error check ---
        if self.indexMaxValue_Kiviat == None:
            stringIndexMaxValue = (
                'There is an error in searching for an index\n' +
                '  for the max value for Kiviat diagrams.\n\n' +
                'This is a coding error. Please contact the\n' +
                '  code administrator.'
                )
            print stringIndexMaxValue
            self.MySQL_Output(
                0,
                stringIndexMaxValue
                )
            showerror(
                'Error: no max value index',
                stringIndexMaxValue
                )
            return
# --- end of error check ---

# now that spoke labels are defined...
#           self.labelMaxValue_Kiviat = self.justSpokeLabelsTable_Kiviat[self.indexMaxValue]
        
                
        '''    
        print('\n' + '+'*50 + '\n')
        print('Max values for each spoke:')
        print('max(self.maxValuesYColumnsLocalTable_Kiviat =\n%s' % max(self.maxValuesYColumnsLocalTable_Kiviat)
        print('')
        print('For local maximum, each group:')
        print('self.maxValuesForEachGroupLocal_Kiviat = \n%s' % self.maxValuesForEachGroupLocal_Kiviat)
        print('')
        print('For global maximum, all groups:')
        print('self.maxValueForAllGroupsGlobal_Kiviat = \n%s' % self.maxValueForAllGroupsGlobal_Kiviat)
        print('\n' + '+'*50)
        '''

# get global max values; just a list, not a list of lists
        '''
        self.maxValuesYColumnsGlobal_Kiviat = []
        if len(max(self.maxValuesYColumnsLocalTable_Kiviat) == 1:
            for value in max(self.maxValuesYColumnsLocalTable_Kiviat:
                self.maxValuesYColumnsGlobal_Kiviat.append(value)
        elif len(max(self.maxValuesYColumnsLocalTable_Kiviat) == 0:
            pass
        else:
            for itemCount in range(len(max(self.maxValuesYColumnsLocalTable_Kiviat[0])):
                tempList = []
                for listCount in range(len(max(self.maxValuesYColumnsLocalTable_Kiviat)):
                    tempList.append(self.maxValuesYColumnsLocal[listCount][itemCount])
                self.maxValuesYColumnsGlobal_Kiviat.append(max(tempList))
        '''
                
# print lists
        if DEBUG_KIVIAT_TABLE:
            print('\n' + '-'*50 + '\n')
            print('\n\nself.label_Y_Table_Kiviat =\n%s' % self.label_Y_Table_Kiviat)
            print('')
            print('\nself.index_Y_Table_Kiviat =\n%s' % self.index_Y_Table_Kiviat)
            print('')
            print('self.plot_Y_Table_Kiviat = \n%s' % self.plot_Y_Table_Kiviat)
            print('')
            print('\nself.label_X_Table_Kiviat (legend title) =\n%s' % self.label_X_Table_Kiviat)
            print('')
            print('self.plot_X_Table_Kiviat (legend labels) = \n%s' % self.plot_X_Table_Kiviat)
            print('')
            '''
            print('max(self.maxValuesYColumnsLocalTable_Kiviat = \n%s' % max(self.maxValuesYColumnsLocalTable_Kiviat)
            print('')
            print('self.maxValuesYColumnsGlobal_Kiviat = \n%s' % self.maxValuesYColumnsGlobal_Kiviat)
            print('')
            '''
            print('Max values for each spoke:')
            print('max(self.maxValuesYColumnsLocalTable_Kiviat =\n%s' % self.maxValuesYColumnsLocalTable_Kiviat)
            print('')
            print('For local maximum, each group:')
            print('self.maxValuesForEachGroupLocal_Kiviat = \n%s' % self.maxValuesForEachGroupLocal_Kiviat)
            print('')
            print('For global maximum, all groups:')
            print('self.maxValueForAllGroupsGlobal_Kiviat = \n%s' % self.maxValueForAllGroupsGlobal_Kiviat)
            print('\n' + '-'*50 + '\n')   


# refresh Kiviat Plotting Specs window; define spoke labels, etc.
        self.handlerKiviatPlotPreprocess()
        
        if clearSelectionsFromTable_Kiviat:
# clear X and Y entries from table
            self.handlerClearAllY()
            self.handlerDeselectX()       
# clear selected rows
            for var in self.varSelectAnyRow:
                var.set(0)
           
        return 
        

    def handlerKiviatPlotPreprocess(self):
        '''
        widgets for preprocessing Kiviat plots
        
        Calls:
            handlerPlotKiviatSelect
            
        Called by:
            handlerTableFunctionsShowValues_Kiviat
            
        Significant variables:
            self.varNumberOfTableGroups_Kiviat                  IntVar                  entry field
                (self.entryNumberOfTableGroups_Kiviat)
            self.varNumberOfStorageBufferGroups_Kiviat                 IntVar                  entry field
                (self.entryNumberOfBufferGroups_Kiviat)
            self.varNumberOfTotalGroups_Kiviat                  IntVar                  entry field
                (self.entryNumberOfTotalGroups_Kiviat)
            -----
            self.varSingleCurvePerPlot_Kiviat                   IntVar                  radiobutton
                (self.radiobuttonSingleGroupPerPlot_Kiviat)
            -----
            self.checkbuttonShowGrid_SingleCurvePerPlot_Kiviat                          checkbutton
            -----
            self.varAllCurvesOnePlot_Kiviat                     IntVar                  radiobutton
                (self.radiobuttonAllCurvesOnePlot_Kiviat)
            -----
            self.checkbuttonShowTitle_AllCurvesOnePlot_Kiviat                           checkbutton
            -----
            self.varEntryShowTitle_AllCurvesOnePlot_Kiviat           StringVar               entry field
                (self.entryShowTitle_AllCurvesOnePlot_Kiviat)
            -----
            self.varShowLabelY_AllCurvesOnePlot_Kiviat          StringVar               entry field
                (self.entryShowLabelY_AllCurvesOnePlot_Kiviat)
            -----
            self.checkbuttonShowLabelX_AllCurvesOnePlot_Kiviat                          checkbutton
            -----
            self.comboboxShowLabelX_AllCurvesOnePlot_Kiviat
#DELETE            self.varShowLabelX_AllCurvesOnePlot_Kiviat   StringVar               entry field
#DELETE                (self.entryShowLabelX_AllCurvesOnePlot_Kiviat)
            -----
            self.checkbuttonShowGrid_AllCurvesOnePlot_Kiviat                            checkbutton
            -----
            self.checkbuttonShowReferenceCurve_AllCurvesOnePlot_Kiviat                  checkbutton
            -----
            self.comboboxShowReferenceCurveMultiplier_AllCurvesOnePlot_Kiviat           combobox
            -----
            self.comboboxShowReferenceCurveLabeled_AllCurvesOnePlot_Kiviat              combobox
            -----
            
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerKiviatPlotPreprocess')
            
        self.MySQL_Output(
            0,
            '  Database: ' + self.myDatabase + '  Table: ' +
            self.myTable
            )
        
# background color
        colorbg='lightgreen'        
        
# if plot window is mapped (displayed), then if 'Include select curves from Storage Buffer' is checked, calculate number of curves
# ... if not, leave count at zero.
# if plot window is NOT mapped, then assume 'Include select curves from Storage Buffer' is checked if self.jcountBuffer is greater than zero
# ... otherwise, if self.jcountBuffer is zero, leave unchecked
        
# always destroy and regenerate plot label generation window
# save location of label windows
        try:
# for option 1 - all groups per window
            self.labels_xWindowLocation_AllGroupsPerWindow_Kiviat = \
                self.toplevelLabels_AllGroupsPerWindow_Kiviat.winfo_rootx() - self.offsetWindowX
            self.labels_yWindowLocation_AllGroupsPerWindow_Kiviat = \
                self.toplevelLabels_AllGroupsPerWindow_Kiviat.winfo_rooty() - self.offsetWindowY
            self.toplevelLabels_AllGroupsPerWindow_Kiviat.destroy()
        except:
            pass
# for option 2 - one group per window
        try:
            self.labels_xWindowLocation_OneGroupPerWindow_Kiviat = \
                self.toplevelLabels_OneGroupPerWindow_Kiviat.winfo_rootx() - self.offsetWindowX
            self.labels_yWindowLocation_OneGroupPerWindow_kiviat = \
                self.toplevelLabels_OneGroupPerWindow_Kiviat.winfo_rooty() - self.offsetWindowY
            self.toplevelLabels_OneGroupPerWindow_Kiviat.destroy()
        except:
            pass
# for option 3 - one curve per plot
        try:
            self.labels_xWindowLocation_OneCurvePerPlot_Kiviat = \
                self.toplevelLabels_OneCurvePerPlot_Kiviat.winfo_rootx() - self.offsetWindowX
            self.labels_yWindowLocation_OneCurvePerPlot_kiviat = \
                self.toplevelLabels_OneCurvePerPlot_Kiviat.winfo_rooty() - self.offsetWindowY
            self.toplevelLabels_OneCurvePerPlot_Kiviat.destroy()
        except:
            pass
        

# determine if toplevel Kiviat Plottting Specs window is open                
        try:
            mappedKiviatPlotPreprocess = self.toplevelKiviatPlotPreprocess.winfo_exists()
        except:
            mappedKiviatPlotPreprocess = False

# determine if toplevel Storage Buffer window is open            
        try:
            mappedShowStorageBuffer = self.toplevelShowStorageBuffer.winfo_exists()
        except:
            mappedShowStorageBuffer = False

# if plot window exists, determine how many kiviat-labeled storage buffer rows have been selected        
        jcountBuffer_Kiviat = 0
        self.listWhichBufferRowsAreChecked_Kiviat = []
        
        if mappedShowStorageBuffer:
            for (inum,var) in enumerate(self.varSelectAnyRow_Buffer):
#                inumWhichBufferRowsAreChecked += 1
                if var.get(): 
# DWB -------
# make sure that if checked, the row is labeled 'kiviat'
# DWB -------
                    jcountBuffer_Kiviat += 1
                    self.listWhichBufferRowsAreChecked_Kiviat.append(
#                        inumWhichBufferRowsAreChecked
                        inum + 1
                        )
# storage buffer window is displayed
            if mappedKiviatPlotPreprocess:
# Kiviat Plotting Specs window is displayed
                if self.jcountTable_Kiviat <> self.varNumberOfTableGroups_Kiviat.get():
                    if DEBUG_KIVIAT:
                        print '\n#1'
                    if self.varCheckbuttonBufferData_Kiviat.get():
                        self.jcountBuffer_Kiviat = jcountBuffer_Kiviat
                    else:
                        self.jcountBuffer_Kiviat = 0
                    
                elif (
                 self.varCheckbuttonBufferData_Kiviat.get()
                  and
                 self.varNumberOfStorageBufferGroups_Kiviat.get() == jcountBuffer_Kiviat
                  and
                 self.varNumberOfStorageBufferGroups_Kiviat.get() <> 0
                  ):
                    if DEBUG_KIVIAT:
                        print '\n#2'
                    self.jcountBuffer_Kiviat = jcountBuffer_Kiviat
                    
                elif (
                 self.varCheckbuttonBufferData_Kiviat.get()
                  and
                 self.varNumberOfStorageBufferGroups_Kiviat.get() == 0
                  ):
                    if jcountBuffer_Kiviat == 0:
                        if DEBUG_KIVIAT:
                            print '\n#3'
                        self.jcountBuffer_Kiviat = 0
                    else:
                        self.jcountBuffer_Kiviat = jcountBuffer_Kiviat
                    
                elif (
                 self.varNumberOfStorageBufferGroups_Kiviat.get() == 0
                  and
                 jcountBuffer_Kiviat > 0
                  ):
                    if DEBUG_KIVIAT:
                        print '\n#4'
                    self.varCheckbuttonBufferData_Kiviat.set(1)
                    self.jcountBuffer_Kiviat = jcountBuffer_Kiviat
                    
                elif (
                self.varNumberOfStorageBufferGroups_Kiviat.get() <> 0
                and
                self.varCheckbuttonBufferData_Kiviat.get() == 1
                ):
                    if DEBUG_KIVIAT:
                        print '\n#5'
                    self.jcountBuffer_Kiviat = jcountBuffer_Kiviat
                    
                else:
                    if DEBUG_KIVIAT:
                        print '\n#6'
                    self.jcountBuffer_Kiviat = 0
            else:
                if DEBUG_KIVIAT:
                    print '\n#7'
                self.jcountBuffer_Kiviat = jcountBuffer_Kiviat
        else:
# storage buffer window is NOT displayed
            if mappedKiviatPlotPreprocess:
                if self.varCheckbuttonBufferData_Kiviat.get():
                    if DEBUG_KIVIAT:
                        print '\n#8'
                    self.jcountBuffer_Kiviat = jcountBuffer_Kiviat
                else:
                    if DEBUG_KIVIAT:
                        print '\n#9'
                    self.jcountBuffer_Kiviat = 0
            else:
                if DEBUG_KIVIAT:
                    print '\n#10'
                self.jcountBuffer_Kiviat = jcountBuffer_Kiviat
                            

        if mappedKiviatPlotPreprocess:
# Kiviat Plotting Specs window exists
            self.previousWindow_Kiviat = True
# save current state of window variables, to restore after toplevel is regenerated

# HEADER
# ... number of table groups
            numberOfPreviousTableGroups = self.varNumberOfTableGroups_Kiviat.get()
# ... number of storage buffer groups
            numberOfPreviousStorageBufferGroups = self.varNumberOfStorageBufferGroups_Kiviat.get()
# ... total plots max
            numberOfTotalGroupsMax = self.varNumberOfTotalGroups_Kiviat.get()
# ... curves per group from table
            numberOfCurvesPerGroupFromTable = self.varNumberOfTableCurves_Kiviat.get()
# ... curves per group from storage buffer
            numberOfCurvesPerGroupFromStorageBuffer = self.varNumberOfStorageBufferCurves_Kiviat.get()
            
# GLOBAL PLOT PARAMETERS            
# ... background color
            background_color_Kiviat = self.comboboxColorBackground_Kiviat.get()
# ... interior color
            interior_color_Kiviat = self.comboboxColorInterior_Kiviat.get()
# ... line width
            linewidth_Kiviat = self.comboboxLineWidth_Kiviat.get()
# ... fill color opacity
            line_enclosed_color_opacity_Kiviat = self.comboboxFillColorOpacity_Kiviat.get()
# ... figure width
            figure_size_width_Kiviat = self.comboboxFigureSizeWidth_Kiviat.get()
# ... figure height
            figure_size_height_Kiviat = self.comboboxFigureSizeHeight_Kiviat.get()
            
# NORMALIZATION FACTOR
# ... local or global
            normalization_factor_status_Kiviat = self.varButtonNormalizationMethod_Kiviat.get()
            
# PLOT FORMAT
# ... asIs or complement
            plot_format_Kiviat = self.varRadiobuttonPlotFormat_Kiviat.get()
            
# REPLOT            
# ... checkbutton
            replot_checkbutton_status_Kiviat = self.varReplotInCurrentWindow_Kiviat.get()
            
# MAIN TITLE
# ... checkbutton
            show_title_checkbutton_Kiviat = self.varCheckbuttonShowTitle_Kiviat.get()
# ... entry
            show_title_entry_Kiviat = self.varEntryShowTitle_Kiviat.get()
# ... font size
            show_title_font_Kiviat = self.comboboxFontTitle_Kiviat.get()
# ... color
            show_title_color_Kiviat = self.comboboxColorTitle_Kiviat.get()
# ... weight
            show_title_weight_Kiviat = self.comboboxFontWeightTitle_Kiviat.get()
# ... x location
            show_title_x_location_Kiviat = self.comboboxXLocationTitle_Kiviat.get()
# ... y location
            show_title_y_location_Kiviat = self.comboboxYLocationTitle_Kiviat.get()

# SUBTITLES (above each plot)
# ... checkbox
            show_subtitle_checkbutton_Kiviat = self.varCheckbuttonShowSubTitle_Kiviat.get()
# ... entry
#            show_subtitle_entry_Kiviat = self.varEntryShowSubTitle_Kiviat.get()
# ... size
            show_subtitle_size_Kiviat = self.comboboxFontSubTitle_Kiviat.get()
# ... color
            show_subtitle_color_Kiviat = self.comboboxColorSubTitle_Kiviat.get()
# ... weight
            show_subtitle_weight_Kiviat = self.comboboxFontWeightSubTitle_Kiviat.get()
# ... x location
            show_subtitle_x_location_Kiviat = self.comboboxXLocationSubTitle_Kiviat.get()
# ... y location
            show_subtitle_y_location_Kiviat = self.comboboxYLocationSubTitle_Kiviat.get()

# SPOKE LABELS
# ... checkbutton
            show_spoke_labels_Kiviat = self.varShowLabels_Kiviat.get()
# ... size
            show_spoke_labels_size_Kiviat = self.comboboxFontLabels_Kiviat.get()
# ... color
            show_spoke_labels_color_Kiviat = self.comboboxColorLabels_Kiviat.get()
      
# GRID            
# ... checkbutton
            show_grids_checkbutton_Kiviat = self.varShowGrid_Kiviat.get()
# ... size
            show_grids_radial_font_labels_Kiviat = self.comboboxFontGridLabels_Kiviat.get()
# ... line width
            show_grids_radial_line_width_Kiviat =  self.comboboxGridLineWidth_Kiviat.get()
# ... line style
            show_grids_radial_line_style_Kiviat = self.comboboxGridLineStyle_Kiviat.get()
# ... increment
            show_grids_radial_increment_Kiviat = self.comboboxGridIncrement_Kiviat.get()
# ... color
            show_grids_grid_color = self.comboboxGridColor_Kiviat.get()
# ... tick color
            show_grids_grid_tick_color = self.comboboxGridColorLabels_Kiviat.get()

# LEGEND
# ... checkbutton
            show_legend_checkbutton_Kiviat = self.varCheckbuttonShowLegend_Kiviat.get()
# ... title (optional)
#            show_legend_title_Kiviat = self.varEntryLegendTitle_Kiviat.get()
            show_legend_title_Kiviat = self.legendTitleStringTable_Kiviat
# ... size
            show_legend_size_Kiviat = self.comboboxLegendTitleFont_Kiviat.get()
# ... columns
            show_legend_number_of_columns_Kiviat = self.comboboxLegendNumColumns_Kiviat.get()
# ... label spacing
            show_legend_spacing_Kiviat = self.comboboxLegendLabelSpacing_Kiviat.get()
# ... border padding
            show_legend_padding_Kiviat = self.comboboxLegendBorderPadding_Kiviat.get()
# ... x location
            show_legend_x_location_Kiviat = self.comboboxXLocationLegend_Kiviat.get()
# ... y location
            show_legend_y_location_Kiviat = self.comboboxYLocationLegend_Kiviat.get()

# SET MAX PLOT RADIUS
# ... checkbutton
            set_max_plot_radius_Kiviat = self.varCheckbuttonSetMaxPlotRadius_Kiviat.get()
# ... radius
            value_max_plot_radius_Kiviat = self.comboboxSetMaxPlotRadius_Kiviat.get()

            
# SELECT GROUP            
# ... select group for plotting
            plot_Selection_Kiviat = self.varGroupsSelection_Kiviat.get()

# PLOTS 1            
# for all plots in one window
# ... plot group from table - checkbutton
            plot_group_from_table_checkbutton_AllGroupsPerWindow_Kiviat = \
                self.varCheckbuttonTableData_AllGroupsPerWindow_Kiviat.get()
# ... plot groups from storage buffer - checkbutton
            plot_groups_from_storage_buffer_checkbutton_AllGroupsPerWindow_Kiviat = \
                self.varCheckbuttonBufferData_AllGroupsPerWindow_Kiviat.get()
# ... use local or global maximum - radiobutton
            use_local_or_global_maxima_AllGroupsPerWindow_Kiviat = \
                self.varLocalOrGlobalMax_AllGroupsPerWindow_Kiviat.get()

# PLOTS 2
# for one plot per window
# ... plot group from table - checkbutton
            plot_group_from_table_checkbutton_OneGroupPerWindow_Kiviat = \
                self.varCheckbuttonTableData_OneGroupPerWindow_Kiviat.get()
# ... plot groups from storage buffer - checkbutton
            plot_groups_from_storage_buffer_checkbutton_OneGroupPerWindow_Kiviat = \
                self.varCheckbuttonBufferData_OneGroupPerWindow_Kiviat.get()
# ... use local or global maximum - radiobutton
            use_local_or_global_maxima_OneGroupPerWindow_Kiviat = \
                self.varLocalOrGlobalMax_OneGroupPerWindow_Kiviat.get()

# PLOTS 3
# for all plots in one window, one curve per plot
# ... plot group from either table or buffer but not both - radiobutton
            plot_group_from_table_or_storage_buffer_radiobutton_OneCurvePerPlot_Kiviat = \
                self.varUseTableOrStorageBuffer_OneCurvePerPlot_Kiviat.get()
            
# now destroy window; will regenerate below and re-apply settings
            self.plottingspecs_xWindowLocation_Kiviat = \
                self.toplevelKiviatPlotPreprocess.winfo_rootx() - self.offsetWindowX
            self.plottingspecs_yWindowLocation_Kiviat = \
                self.toplevelKiviatPlotPreprocess.winfo_rooty() - self.offsetWindowY
            self.toplevelKiviatPlotPreprocess.destroy()


        else:
# plot window does not exist
            if DEBUG_KIVIAT:
                print(
                    'DEBUG: not saving state'
                    )
            self.previousWindow_Kiviat = False

# open Toplevel frame Kiviat Plotting Specs
        self.toplevelKiviatPlotPreprocess = Toplevel(
            self.toplevelTableValues,
            bg=colorbg,
            )
        self.toplevelKiviatPlotPreprocess.title(
            'Server: ' + self.comboServerMySQL.get() + '     ' +
            'Database: ' + self.varTableFunctionsSelectDatabase.get() + '     ' +
            'Table: ' + self.varEntryTableFunctionsSelectTable.get().strip()
            )
        self.toplevelKiviatPlotPreprocess.transient(self.toplevelTableValues)
# place the top window
        x_Windows = self.plottingspecs_xWindowLocation_Kiviat
        y_Windows = self.plottingspecs_yWindowLocation_Kiviat
        self.toplevelKiviatPlotPreprocess.geometry(
            '+%d+%d' % (
                        x_Windows,
                        y_Windows
                        )
            )        
            
# ============ FRAMES ========================

# Row 0
        rowFrame = 0
        
# frame_00 title frame
        frame_00 = Frame(
            self.toplevelKiviatPlotPreprocess,
            bg=colorbg,
#            relief=RIDGE,
#            borderwidth=2,
            )
        frame_00.grid(
            row=rowFrame,
            column=0,
            padx=2,
            pady=1,
#            sticky=E+W,
            )
            
# frame_05 number of Table, Buffer, and Total groups
        rowFrame += 1
        frame_05 = Frame(
            self.toplevelKiviatPlotPreprocess,
            bg=colorbg,
            )
        frame_05.grid(
            row=rowFrame,
            column=0,
            padx=5,
            pady=5,
            sticky=E+W,
            )
            
# frame_10 global options
        rowFrame += 1
        frame_10 = Frame(
            self.toplevelKiviatPlotPreprocess,
            bg=colorbg,
            )
        frame_10.grid(
            row=rowFrame,
            column=0,
            padx=5,
            pady=5,
            sticky=E+W,
            )
            
# frame_12 normalization factor
        rowFrame += 1
        frame_12 = Frame(
            self.toplevelKiviatPlotPreprocess,
            bg=colorbg,
            )
        frame_12.grid(
            row=rowFrame,
            column=0,
            padx=5,
            pady=5,
            sticky=E+W,
            )
            
# frame_13 plot format
        rowFrame += 1
        frame_13 = Frame(
            self.toplevelKiviatPlotPreprocess,
            bg=colorbg,
            )
        frame_13.grid(
            row=rowFrame,
            column=0,
            padx=5,
            pady=5,
            sticky=E+W,
            )
         
# frame_15 - replot in current plot window
        rowFrame += 1
        frame_15 = Frame(
            self.toplevelKiviatPlotPreprocess,
            bg=colorbg,
            )
        frame_15.grid(  
            row=rowFrame,
            column=0,
            padx=5,
            pady=10,
            sticky=E+W,
            )
            
# frame_20 - normalize each spoke with local max, or entire plot with global max
        rowFrame += 1
        frame_20 = Frame(
            self.toplevelKiviatPlotPreprocess,
            bg=colorbg,
            )
        frame_20.grid(  
            row=rowFrame,
            column=0,
            padx=5,
            pady=10,
            sticky=E+W,
            )
            
# frame_25 - show title, font, color, etc.
        rowFrame += 1
        frame_25 = Frame(
            self.toplevelKiviatPlotPreprocess,
            bg=colorbg,
            )
        frame_25.grid(  
            row=rowFrame,
            column=0,
            padx=5,
            pady=10,
            sticky=E+W,
            )
            
# frame_27 - show subtitles, font, color, etc.
        rowFrame += 1
        frame_27 = Frame(
            self.toplevelKiviatPlotPreprocess,
            bg=colorbg,
            )
        frame_27.grid(  
            row=rowFrame,
            column=0,
            padx=5,
            pady=10,
            sticky=E+W,
            )

# frame_30 - show y headers from table, font, color
        rowFrame += 1
        frame_30 = Frame(
            self.toplevelKiviatPlotPreprocess,
            bg=colorbg,
            )
        frame_30.grid(  
            row=rowFrame,
            column=0,
            padx=5,
            pady=10,
            sticky=E+W,
            )
# frame_35 - show grid, label size and color, tick size and color
        rowFrame += 1
        frame_35 = Frame(
            self.toplevelKiviatPlotPreprocess,
            bg=colorbg,
            )
        frame_35.grid(  
            row=rowFrame,
            column=0,
            padx=5,
            pady=10,
            sticky=E+W,
            )
            
# frame_40 - show legend, location, font
        rowFrame += 1
        frame_40 = Frame(
            self.toplevelKiviatPlotPreprocess,
            bg=colorbg,
            )
        frame_40.grid(  
            row=rowFrame,
            column=0,
            padx=5,
            pady=10,
            sticky=E+W,
            )
            
# frame_42 - set max plot radius
        rowFrame += 1
        frame_42 = Frame(
            self.toplevelKiviatPlotPreprocess,
            bg=colorbg,
            )
        frame_42.grid(  
            row=rowFrame,
            column=0,
            padx=5,
            pady=10,
            sticky=E+W,
            )

# frame_45 - for line separator
        rowFrame += 1
        frame_45 = Frame(
            self.toplevelKiviatPlotPreprocess,
            bg=colorbg,
            )
        frame_45.grid(  
            row=rowFrame,
            column=0,
            padx=2,
            pady=1,
            sticky=E+W,
            )

# frame_50 - single or multiple plots, one group per plot, etc.
        rowFrame += 1
        frame_50 = Frame(
            self.toplevelKiviatPlotPreprocess,
            bg=colorbg,
            )
        frame_50.grid(
            row=rowFrame,
            column=0,
            padx=10,
#            pady=10,
            sticky=W,
            )        
# ... all plots in one window
        frame_50a = Frame(
            frame_50,
            bg=colorbg,
            )
        frame_50a.grid(
            row=0,
            column=0,
            padx=0,
            pady=1,
            sticky=W,
            )     
# ... plot groups from table and/or buffer
        frame_50b = Frame(
            frame_50,
            bg=colorbg,
            )
        frame_50b.grid(
            row=1,
            column=0,
            padx=30,
            pady=1,
            sticky=W,
            )         
# ... for all plots, use...
        frame_50c = Frame(
            frame_50,
            bg=colorbg,
            )
        frame_50c.grid(
            row=2,
            column=0,
            padx=50,
            pady=1,
            sticky=W,
            )
# ... local or global
        frame_50d = Frame(
            frame_50,
            bg=colorbg,
            )
        frame_50d.grid(
            row=3,
            column=0,
            padx=50,
            pady=1,
            sticky=W,
            )
        

# -----
# frame_55 - Main frame for multiple plots, one plot per window
        rowFrame += 1
        frame_55 = Frame(
            self.toplevelKiviatPlotPreprocess,
            bg=colorbg,
            )
        frame_55.grid(
            row=rowFrame,
            column=0,
            padx=10,
#            pady=10,
            sticky=W,
            )     
# ... one plot per window
        frame_55a = Frame(
            frame_55,
            bg=colorbg,
            )
        frame_55a.grid(
            row=0,
            column=0,
            padx=0,
            pady=1,
            sticky=W,
            )
# ... plot groups from table and/or storage buffer
        frame_55b = Frame(
            frame_55,
            bg=colorbg,
            )
        frame_55b.grid(
            row=1,
            column=0,
            padx=30,
            pady=1,
            sticky=W,
            )
# ... for all plots, use ...
        frame_55c = Frame(
            frame_55,
            bg=colorbg,
            )
        frame_55c.grid(
            row=2,
            column=0,
            padx=50,
            pady=1,
            sticky=W,
            )
# ... local maxima or global maximum
        frame_55d = Frame(
            frame_55,
            bg=colorbg,
            )
        frame_55d.grid(
            row=3,
            column=0,
            padx=50,
            pady=1,
            sticky=W,
            )
                   
# ----- 
           
# frame_60 - Main frame for group curves, one curve per plot
        rowFrame += 1
        frame_60 = Frame(
            self.toplevelKiviatPlotPreprocess,
            bg=colorbg,
            )
        frame_60.grid(
            row=rowFrame,
            column=0,
            padx=10,
#            pady=10,
            sticky=W,
            )
# ... radiobutton: all curves from one group, one plot per curve
        frame_60a = Frame(
            frame_60,
            bg=colorbg,
            )
        frame_60a.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            sticky=W,
            )
# ... choose whether select group comes from table or storage buffer
        frame_60b = Frame(
            frame_60,
            bg=colorbg,
            )
        frame_60b.grid(
            row=1,
            column=0,
            padx=30,
            pady=0,
            sticky=W,
            )
        
# -----   
            
# frame_999 - plot or cancel
        frame_999 = Frame(
            self.toplevelKiviatPlotPreprocess,
            bg=colorbg,
            )
        frame_999.grid(
            row=999,
            column=0,
            padx=1,
            pady=1,
#            sticky=E+W,
            )
            
# ========== END OF FRAMES ========================

# ============ WIDGETS =============================

# FRAME 0
            
# ... title
        labelTitle = Label(
            frame_00,
            text=(
                'KIVIAT PLOT SPECS\n' +
                'plot data normalized by either local or global maxima'
                ),
            justify=CENTER,
            anchor=CENTER,
            font=self.titleFontBig,
            bg=colorbg,
            )
        labelTitle.grid(
            row=0,
            column=0,
            padx=0,
            pady=10,
            )
            
# FRAME 5

# HEADER          
#... table groups
        rowCount = 0
        labelNumberOfTableGroups = Label(
            frame_05,
#            text='Number of groups to plot from table:',
            text='Number of plots to generate from table:',
            justify=RIGHT,
            bg=colorbg,
            )
        labelNumberOfTableGroups.grid(
            row=rowCount,
            column=0,
            padx=2,
            pady=0,
            sticky=E,
            )
# ... entry field
        self.varNumberOfTableGroups_Kiviat = IntVar()
        self.entryNumberOfTableGroups_Kiviat = Entry(
            frame_05,
            width=5,
            justify=LEFT,
            textvariable=self.varNumberOfTableGroups_Kiviat,
            disabledbackground='white',
            disabledforeground='black',
            )
        self.entryNumberOfTableGroups_Kiviat.grid(
            row=rowCount,
            column=1,
            padx=0,
            pady=0,
            sticky=W,
            )
        self.entryNumberOfTableGroups_Kiviat.configure(state='disabled')
        
# ...   buffer curves
        labelNumberOfBufferGroups = Label(
            frame_05,
            text='  from storage buffer:',
            justify=RIGHT,
            bg=colorbg,
            )
        '''
        labelNumberOfBufferGroups.grid(
            row=rowCount,
            column=2,
            padx=2,
            pady=0,
            sticky=E,
            )
        '''
# ... entry field
        self.varNumberOfStorageBufferGroups_Kiviat = IntVar()
        self.entryNumberOfBufferGroups_Kiviat = Entry(
            frame_05,
            width=5,
            justify=LEFT,
            textvariable=self.varNumberOfStorageBufferGroups_Kiviat,
            disabledbackground='white',
            disabledforeground='black',
            )
        '''
        self.entryNumberOfBufferGroups_Kiviat.grid(
            row=rowCount,
            column=3,
            padx=0,
            pady=0,
            sticky=W,
            )
#        self.varNumberOfStorageBufferGroups_Kiviat.set(self.jcountBuffer_Kiviat)
        self.entryNumberOfBufferGroups_Kiviat.configure(state='disabled')
        '''

        if DEBUG_KIVIAT:
            print
            print('-'*50)
            print('\nself.headerNames_Y_Table_Kiviat = %s' % self.headerNames_Y_Table_Kiviat)
            print('\nself.headerNames_Y_Buffer_Kiviat = %s' % self.headerNames_Y_Buffer_Kiviat)
            print('\nself.jcountTable_Kiviat = %s' % self.jcountTable_Kiviat)
            print('\nself.jcountBuffer_Kiviat = %s' % self.jcountBuffer_Kiviat)
            print('-'*50)
        
# ...   total curves
        labelNumberOfTotalGroups = Label(
            frame_05,
            text='  Total groups (max 25):',
            justify=RIGHT,
            bg=colorbg,
            )
        '''
        labelNumberOfTotalGroups.grid(
            row=rowCount,
            column=4,
            padx=2,
            pady=0,
            sticky=E,
            )
        '''
# ... entry field
        self.varNumberOfTotalGroups_Kiviat = IntVar()
        self.entryNumberOfTotalGroups_Kiviat = Entry(
            frame_05,
            width=5,
            justify=LEFT,
            textvariable=self.varNumberOfTotalGroups_Kiviat,
            disabledbackground='white',
            disabledforeground='black',
            )
        '''
        self.entryNumberOfTotalGroups_Kiviat.grid(
            row=rowCount,
            column=5,
            padx=0,
            pady=0,
            sticky=W,
            )
#        self.varNumberOfTotalGroups_Kiviat.set(self.jcountTable_Kiviat + self.jcountBuffer_Kiviat)
        self.entryNumberOfTotalGroups_Kiviat.configure(state='disabled')
        '''
# Kiviat number of curves (not groups)
# ... from table
# ...   label
#        rowCount += 1
        labelNumberOfTableCurves = Label(
            frame_05,
#            text='Number of circumferential curves per group from table:',
            text='Number of circumferential curves to plot from table:',
            justify=RIGHT,
            bg=colorbg,
            )
        labelNumberOfTableCurves.grid(
            row=rowCount,
            column=2,
            padx=2,
            pady=0,
            sticky=E,
            )
# ...   entry field
        self.varNumberOfTableCurves_Kiviat = IntVar()
        self.entryNumberOfTableCurves_Kiviat = Entry(
            frame_05,
            width=5,
            justify=LEFT,
            textvariable=self.varNumberOfTableCurves_Kiviat,
            disabledbackground='white',
            disabledforeground='black',
            )
        self.entryNumberOfTableCurves_Kiviat.grid(
            row=rowCount,
            column=3,
            padx=0,
            pady=0,
            sticky=W,
            )
        self.entryNumberOfTableCurves_Kiviat.configure(state='disabled')

# ... from storage buffer
# ...   label
        labelNumberOfStorageBufferCurves = Label(
            frame_05,
            text='  from storage buffer:',
            justify=RIGHT,
            bg=colorbg,
            )
        '''
        labelNumberOfStorageBufferCurves.grid(
            row=rowCount,
            column=2,
            padx=2,
            pady=0,
            sticky=E,
            )
        '''
# ...   entry field
        self.varNumberOfStorageBufferCurves_Kiviat = IntVar()
        self.entryNumberOfStorageBufferCurves_Kiviat = Entry(
            frame_05,
            width=5,
            justify=LEFT,
            textvariable=self.varNumberOfStorageBufferCurves_Kiviat,
            disabledbackground='white',
            disabledforeground='black',
            )
        '''
        self.entryNumberOfStorageBufferCurves_Kiviat.grid(
            row=rowCount,
            column=3,
            padx=0,
            pady=0,
            sticky=W,
            )
        self.entryNumberOfStorageBufferCurves_Kiviat.configure(state='disabled')
        '''

# ... show buffer details
        buttonDisplayBufferData = Button(
#            self.frame_35_Kiviat,
            frame_05,
            textvariable=self.countDisplayStorageBuffer,
            width=20,
            font=self.buttonFontSmallest,
            borderwidth=3,
            relief=RAISED,
            background='white',
            foreground='blue',
            command=self.handlerDisplayStorageBufferValues_Call,
            )
        '''
        buttonDisplayBufferData.grid(
            row=rowCount,
            column=4,
            columnspan=2,
            padx=0,
            pady=0,
#            sticky=E,
            )
        '''

# FRAME 10
            
# GLOBAL PLOT PARAMETERS            
# ... background color
        rowCount = 0
        self.comboboxColorBackground_Kiviat = Pmw.ComboBox(
            frame_10,
            scrolledlist_items=self.colorsChartBackground_Kiviat,
            listheight=150,
            label_text='Plot-window background color:',
            label_background=colorbg,
            entry_state='disabled',
#            entry_disabledbackground='white',  # this is set elsewhere
            entry_disabledforeground='black',
            labelpos='w',
            entry_width=10,
            scrolledlist_hull_width=500,
            )
        self.comboboxColorBackground_Kiviat.grid(
            row=rowCount,
            column=0,
            padx=5,
            pady=2,
            sticky=E,
            ) 
# ... interior color
        self.comboboxColorInterior_Kiviat = Pmw.ComboBox(
            frame_10,
            scrolledlist_items=self.colorsChartInterior_Kiviat,
            listheight=150,
            label_text='Plot interior color:',
            label_background=colorbg,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            labelpos='w',
            entry_width=10,
            scrolledlist_hull_width=500,
            )
        self.comboboxColorInterior_Kiviat.grid(
            row=rowCount,
            column=1,
            padx=5,
            pady=2,
            sticky=E,
            ) 
# ... line width
        self.comboboxLineWidth_Kiviat = Pmw.ComboBox(
            frame_10,
            scrolledlist_items=self.lineWidth_Kiviat,
            listheight=150,
            label_text='Line width:',
            label_background=colorbg,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            labelpos='w',
            entry_width=5,
            scrolledlist_hull_width=500,
            )
        self.comboboxLineWidth_Kiviat.grid(
            row=rowCount,
            column=2,
            padx=5,
            pady=2,
            sticky=E,
            ) 
# ... line-enclosed fill color opacity
        rowCount += 1
        self.comboboxFillColorOpacity_Kiviat = Pmw.ComboBox(
            frame_10,
            scrolledlist_items=self.lineEnclosedOpacity_Kiviat,
            listheight=150,
            label_text='Line-enclosed fill-color opacity:',
            label_background=colorbg,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            labelpos='w',
            entry_width=5,
            scrolledlist_hull_width=500,
            )
        self.comboboxFillColorOpacity_Kiviat.grid(
            row=rowCount,
            column=0,
            padx=5,
            pady=2,
            sticky=E,
            ) 
# ... figure size, W x H
        self.comboboxFigureSizeWidth_Kiviat = Pmw.ComboBox(
            frame_10,
            scrolledlist_items=self.sizeFigure_Kiviat,
            listheight=110,
            label_text='Plot-window size: Width',
            label_background=colorbg,
            entry_state='disabled',
#            entry_disabledbackground='gray',   # this is set elsewhere
            entry_disabledforeground='black',
            labelpos='w',
            entry_width=5,
            scrolledlist_hull_width=500,
            )
        self.comboboxFigureSizeWidth_Kiviat.grid(
            row=rowCount,
            column=1,
            padx=5,
            pady=5,
            sticky=E,
            ) 
        self.comboboxFigureSizeHeight_Kiviat = Pmw.ComboBox(
            frame_10,
            scrolledlist_items=self.sizeFigure_Kiviat,
            listheight=110,
            label_text='and Height',
            label_background=colorbg,
            entry_state='disabled',
#            entry_disabledbackground='gray',   # this is set elsewhere
            entry_disabledforeground='black',
            labelpos='w',
            entry_width=5,
            scrolledlist_hull_width=500,
            )
        self.comboboxFigureSizeHeight_Kiviat.grid(
            row=rowCount,
            column=2,
            padx=3,
            pady=5,
            sticky=E,
            ) 
            
# FRAME 12
# NORMALIZATION FACTOR
# ... label
        labelPickNormalizationFactor = Label(
            frame_12,
            text='Select normalization method: ',
            bg=colorbg,
            justify=LEFT,
            )
        labelPickNormalizationFactor.grid(
            row=rowCount,
            column=0,
            padx=0,
            pady=0,
            sticky=W,
            )
            
        self.varButtonNormalizationMethod_Kiviat = StringVar()
# ... 'local' button
        buttonNormalizeLocal = Radiobutton(
            frame_12,
            text='local maximum to normalize each spoke',
            bg=colorbg,
            variable=self.varButtonNormalizationMethod_Kiviat,
            value='localNorm',
            )
        buttonNormalizeLocal.grid(
            row=rowCount,
            column=1,
            padx=0,
            pady=0,
            sticky=W,
            )
# ... 'global' button
        buttonNormalizeGlobal = Radiobutton(
            frame_12,
            text='global maximum to normalize all spokes',
            bg=colorbg,
            variable=self.varButtonNormalizationMethod_Kiviat,
            value='globalNorm',
            )
        buttonNormalizeGlobal.grid(
            row=rowCount,
            column=2,
            padx=0,
            pady=0,
            sticky=W,
            )
            
# FRAME 13
# PLOT FORMAT
# ... label
        labelPlotFormat = Label(
            frame_13,
            text='Select plot format: ',
            bg=colorbg,
            justify=LEFT,
            )
        labelPlotFormat.grid(
            row=rowCount,
            column=0,
            padx=0,
            pady=0,
            sticky=W,
            )
            
        self.varRadiobuttonPlotFormat_Kiviat = StringVar()
# ... 'local' button
        buttonPlotFormatAsIs = Radiobutton(
            frame_13,
            text='Y as selected',
            bg=colorbg,
            variable=self.varRadiobuttonPlotFormat_Kiviat,
            value='asIs',
            )
        buttonPlotFormatAsIs.grid(
            row=rowCount,
            column=1,
            padx=0,
            pady=0,
            sticky=W,
            )
# ... 'global' button
        buttonPlotFormatComplement = Radiobutton(
            frame_13,
            text='(1-Y), best when radial plot values grow inversely to legend values',
            bg=colorbg,
            variable=self.varRadiobuttonPlotFormat_Kiviat,
            value='complement',
            )
        buttonPlotFormatComplement.grid(
            row=rowCount,
            column=2,
            padx=0,
            pady=0,
            sticky=W,
            )      
        
# FRAME 15
# REPLOT            
# ... checkbutton
        rowCount = 0
        self.varReplotInCurrentWindow_Kiviat = IntVar()
        self.checkbuttonReplotInCurrentWindow_Kiviat = Checkbutton(
            frame_15,
            bg=colorbg,
            variable=self.varReplotInCurrentWindow_Kiviat,
            command=self.handlerReplotInCurrentWindow_Kiviat,
            )
        self.checkbuttonReplotInCurrentWindow_Kiviat.grid(
            row=rowCount,
            column=0,
            padx=0,
            pady=0,
            sticky=W,
            )
# ... label
        labelReplotInCurrentWindow = Label(
            frame_15,
            text=(
                'Plot subsequent plots in current plot window (erases current plot)'
                ),
            justify=LEFT,
            bg=colorbg,
            )
        labelReplotInCurrentWindow.grid(
            row=rowCount,
            column=1,
            columnspan=99,
            padx=0,
            pady=0,
            sticky=W,
            )
            
# FRAME 20  
       
# ... not currently used
            
# FRAME 25

# MAIN TITLE
# ... checkbox            
        rowCount=0
        self.varCheckbuttonShowTitle_Kiviat = IntVar()
        self.checkbuttonShowTitle_Kiviat = Checkbutton(
            frame_25,
            bg=colorbg,
            variable=self.varCheckbuttonShowTitle_Kiviat,
#            command=self.handlerShowTitle_AllCurvesOnePlot_Kiviat,
            )
        self.checkbuttonShowTitle_Kiviat.grid(
            row=rowCount,
            column=0,
            padx=0,
            pady=1,
            sticky=W,
            ) 
# ... entry label            
        labelShowTitle = Label(
            frame_25,
            text='Show main title: ',
            bg=colorbg,
            justify=LEFT,
            )
        labelShowTitle.grid(
            row=rowCount,
            column=1,
            padx=0,
            pady=0,
            sticky=W,
            )
# ... entry
        self.varEntryShowTitle_Kiviat = StringVar()
        self.entryShowTitle_Kiviat = Entry(
            frame_25,
            width=20,
            textvariable=self.varEntryShowTitle_Kiviat,
            disabledbackground='lightgray',
            )
        self.entryShowTitle_Kiviat.grid(
            row=rowCount,
            column=2,
            padx=5,
            pady=0,
            sticky=W,
            )
# ... font size
        self.comboboxFontTitle_Kiviat = Pmw.ComboBox(
            frame_25,
            scrolledlist_items=self.fontsizesKiviatTitle,
            listheight=150,
            label_text='size:',
            label_background=colorbg,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            labelpos='w',
            entry_width=5,
            scrolledlist_hull_width=500,
            )
        self.comboboxFontTitle_Kiviat.grid(
            row=rowCount,
            column=3,
            padx=5,
            pady=0,
            sticky=E,
            )
# ... color    
        self.comboboxColorTitle_Kiviat = Pmw.ComboBox(
            frame_25,
            scrolledlist_items=self.colorsChartLabels_Kiviat,
            listheight=150,
            label_text='color:',
            label_background=colorbg,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            labelpos='w',
            entry_width=10,
            scrolledlist_hull_width=500,
            )
        self.comboboxColorTitle_Kiviat.grid(
            row=rowCount,
            column=4,
            padx=5,
            pady=0,
            sticky=E,
            )  
# ... weight
        self.comboboxFontWeightTitle_Kiviat = Pmw.ComboBox(
            frame_25,
            scrolledlist_items=self.weightFonts_Kiviat,
            listheight=50,
            label_text='weight:',
            label_background=colorbg,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            labelpos='w',
            entry_width=10,
            scrolledlist_hull_width=500,
            )
        self.comboboxFontWeightTitle_Kiviat.grid(
            row=rowCount,
            column=5,
            padx=5,
            pady=0,
            sticky=E,
            )
# ... x-location
        rowCount += 1
        self.comboboxXLocationTitle_Kiviat = Pmw.ComboBox(
            frame_25,
            scrolledlist_items=self.xLocationTitle_Kiviat,
            listheight=150,
            label_text='X location:',
            label_background=colorbg,
            entry_state='normal',
            labelpos='w',
            entry_width=10,
            scrolledlist_hull_width=500,
            )
        self.comboboxXLocationTitle_Kiviat.grid(
            row=rowCount,
            column=3,
            padx=5,
            pady=0,
            sticky=E,
            )
# ... y location
        self.comboboxYLocationTitle_Kiviat = Pmw.ComboBox(
            frame_25,
            scrolledlist_items=self.yLocationTitle_Kiviat,
            listheight=150,
            label_text='Y location:',
            label_background=colorbg,
            entry_state='normal',
            labelpos='w',
            entry_width=10,
            scrolledlist_hull_width=500,
            )
        self.comboboxYLocationTitle_Kiviat.grid(
            row=rowCount,
            column=4,
            padx=5,
            pady=0,
            sticky=E,
            )
            
# FRAME 27

# SUBTITLES
# ... checkbox           
        rowCount=0
        self.varCheckbuttonShowSubTitle_Kiviat = IntVar()
        self.checkbuttonShowSubTitle_Kiviat = Checkbutton(
            frame_27,
            bg=colorbg,
            variable=self.varCheckbuttonShowSubTitle_Kiviat,
#            command=self.handlerShowTitle_AllCurvesOnePlot_Kiviat,
            )
        self.checkbuttonShowSubTitle_Kiviat.grid(
            row=rowCount,
            column=0,
            padx=0,
            pady=1,
            sticky=W,
            ) 
# ... entry label            
        labelShowSubTitle = Label(
            frame_27,
            text='Show "Normalization factor" subtitle: ',
            bg=colorbg,
            justify=LEFT,
            )
        labelShowSubTitle.grid(
            row=rowCount,
            column=1,
            padx=0,
            pady=0,
            sticky=W,
            )
# ... entry
        '''
        self.varEntryShowSubTitle_Kiviat = StringVar()
        self.entryShowSubTitle_Kiviat = Entry(
            frame_27,
            width=20,
            textvariable=self.varEntryShowSubTitle_Kiviat,
            disabledbackground='lightgray',
            )
        self.entryShowSubTitle_Kiviat.grid(
            row=rowCount,
            column=2,
            padx=5,
            pady=0,
            sticky=W,
            )
        '''
# ... size
        self.comboboxFontSubTitle_Kiviat = Pmw.ComboBox(
            frame_27,
            scrolledlist_items=self.fontsizesKiviatSubTitle,
            listheight=150,
            label_text='size:',
            label_background=colorbg,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            labelpos='w',
            entry_width=5,
            scrolledlist_hull_width=500,
            )
        self.comboboxFontSubTitle_Kiviat.grid(
            row=rowCount,
            column=2,
            padx=5,
            pady=0,
            sticky=E,
            )
# ... color    
        self.comboboxColorSubTitle_Kiviat = Pmw.ComboBox(
            frame_27,
            scrolledlist_items=self.colorsChartLabels_Kiviat,
            listheight=150,
            label_text='color:',
            label_background=colorbg,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            labelpos='w',
            entry_width=10,
            scrolledlist_hull_width=500,
            )
        self.comboboxColorSubTitle_Kiviat.grid(
            row=rowCount,
            column=3,
            padx=5,
            pady=0,
            sticky=E,
            )  
# ... weight
        self.comboboxFontWeightSubTitle_Kiviat = Pmw.ComboBox(
            frame_27,
            scrolledlist_items=self.weightFonts_Kiviat,
            listheight=50,
            label_text='weight:',
            label_background=colorbg,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            labelpos='w',
            entry_width=10,
            scrolledlist_hull_width=500,
            )
        self.comboboxFontWeightSubTitle_Kiviat.grid(
            row=rowCount,
            column=4,
            padx=5,
            pady=0,
            sticky=E,
            )
# ... x location
        rowCount += 1
        self.comboboxXLocationSubTitle_Kiviat = Pmw.ComboBox(
            frame_27,
            scrolledlist_items=self.xLocationSubTitle_Kiviat,
            listheight=150,
            label_text='X location:',
            label_background=colorbg,
            entry_state='normal',
            labelpos='w',
            entry_width=10,
            scrolledlist_hull_width=500,
            )
        self.comboboxXLocationSubTitle_Kiviat.grid(
            row=rowCount,
            column=2,
            padx=5,
            pady=0,
            sticky=E,
            )
# ... y location
        self.comboboxYLocationSubTitle_Kiviat = Pmw.ComboBox(
            frame_27,
            scrolledlist_items=self.yLocationSubTitle_Kiviat,
            listheight=150,
            label_text='Y location:',
            label_background=colorbg,
            entry_state='normal',
            labelpos='w',
            entry_width=10,
            scrolledlist_hull_width=500,
            )
        self.comboboxYLocationSubTitle_Kiviat.grid(
            row=rowCount,
            column=3,
            padx=5,
            pady=0,
            sticky=E,
            )
        

# FRAME 30

# SPOKE LABELS       
# ... checkbox 
        rowCount = 0
        self.varShowLabels_Kiviat = IntVar()
        self.checkbuttonShowLabels_Kiviat = Checkbutton(
            frame_30,
            bg=colorbg,
            variable=self.varShowLabels_Kiviat,
#            command=self.handlerShowTitles_SingleCurvePerPlot_Kiviat,
            )
        self.checkbuttonShowLabels_Kiviat.grid(
            row=rowCount,
            column=0,
            padx=0,
            pady=1,
            sticky=W,
            )
            
# ... label
        labelShowLabels_Kiviat = Label(
            frame_30,
            text='Show Y-select headers from table as spoke labels:',
            bg=colorbg,
            )
        labelShowLabels_Kiviat.grid(
            row=rowCount,
            column=1,
            padx=0,
            pady=1,
            sticky=W
            )
            
# ... size
        self.comboboxFontLabels_Kiviat = Pmw.ComboBox(
            frame_30,
            scrolledlist_items=self.fontsizesKiviatSpokeLabels,
            listheight=150,
            label_text='size:',
            label_background=colorbg,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            labelpos='w',
            entry_width=5,
            scrolledlist_hull_width=500,
            )
        self.comboboxFontLabels_Kiviat.grid(
            row=rowCount,
            column=2,
            padx=5,
            pady=1,
            sticky=W,
            )  
            
# ... color   
        self.comboboxColorLabels_Kiviat = Pmw.ComboBox(
            frame_30,
            scrolledlist_items=self.colorsChartLabels,
            listheight=150,
            label_text='color:',
            label_background=colorbg,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            labelpos='w',
            entry_width=10,
            scrolledlist_hull_width=500,
            )
        self.comboboxColorLabels_Kiviat.grid(
            row=rowCount,
            column=3,
            padx=0,
            pady=0,
            sticky=W,
            ) 

# FRAME 35  

# GRID         
# ... checkbutton
        rowCount = 0
        self.varShowGrid_Kiviat = IntVar()
        self.checkbuttonShowGrid_Kiviat = Checkbutton(
            frame_35,
            bg=colorbg,
            variable=self.varShowGrid_Kiviat,
            )
        self.checkbuttonShowGrid_Kiviat.grid(
            row=rowCount,
            column=0,
            padx=0,
            pady=1,
            sticky=W,
            )
# ... label
        labelShowGrid_Kiviat = Label(
            frame_35,
            text='Show grid:',
            bg=colorbg,
            )
        labelShowGrid_Kiviat.grid(
            row=rowCount,
            column=1,
            padx=0,
            pady=1,
            sticky=W
            )
        self.checkbuttonShowGrid_Kiviat.select() 
# ... grid color
        self.comboboxGridColor_Kiviat = Pmw.ComboBox(
            frame_35,
            scrolledlist_items=self.colorGrid_Kiviat,
            listheight=150,
            label_text='grid color:',
            label_background=colorbg,
            labelpos='w',
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            entry_width=10,
            scrolledlist_hull_width=500,
            )
        self.comboboxGridColor_Kiviat.grid(
            row=rowCount,
            column=2,
            padx=4,
            pady=0,
            sticky=E,
            )
# ... tick color
        self.comboboxGridColorLabels_Kiviat = Pmw.ComboBox(
            frame_35,
            scrolledlist_items=self.colorGridTick_Kiviat,
            listheight=150,
            label_text='tick color:',
            label_background=colorbg,
            labelpos='w',
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            entry_width=10,
            scrolledlist_hull_width=500,
            )
        self.comboboxGridColorLabels_Kiviat.grid(
            row=rowCount,
            column=3,
            padx=4,
            pady=0,
            sticky=E,
            )            
# ... tick size
        self.comboboxFontGridLabels_Kiviat = Pmw.ComboBox(
            frame_35,
            scrolledlist_items=self.sizeGridLabels_Kiviat,
            label_text='size:',
            label_background=colorbg,
            labelpos='w',
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            listheight=160,
            entry_width=5,
            scrolledlist_hull_width=500,
            )
        self.comboboxFontGridLabels_Kiviat.grid(
            row=rowCount,
            column=4,
            padx=4,
            pady=0,
            sticky=E,
            )
# ... line width
        rowCount += 1
        self.comboboxGridLineWidth_Kiviat = Pmw.ComboBox(
            frame_35,
            scrolledlist_items=self.widthGridLine_Kiviat,
            listheight=110,
            label_text='line width:',
            label_background=colorbg,
            labelpos='w',
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            entry_width=5,
            scrolledlist_hull_width=500,
            )
        self.comboboxGridLineWidth_Kiviat.grid(
            row=rowCount,
            column=2,
            padx=4,
            pady=0,
            sticky=E,
            )
# ... line style
        self.comboboxGridLineStyle_Kiviat = Pmw.ComboBox(
            frame_35,
            scrolledlist_items=self.styleGridLine_Kiviat,
            listheight=80,
            label_text='line style:',
            label_background=colorbg,
            labelpos='w',
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            entry_width=10,
            scrolledlist_hull_width=500,
            )
        self.comboboxGridLineStyle_Kiviat.grid(
            row=rowCount,
            column=3,
            padx=4,
            pady=0,
            sticky=E,
            )
# ... increment
        self.comboboxGridIncrement_Kiviat = Pmw.ComboBox(
            frame_35,
            scrolledlist_items=self.incrementGrid_Kiviat,
            listheight=80,
            label_text='increment:',
            label_background=colorbg,
            labelpos='w',
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            entry_width=5,
            scrolledlist_hull_width=500,
            )
        self.comboboxGridIncrement_Kiviat.grid(
            row=rowCount,
            column=4,
            padx=4,
            pady=0,
            sticky=E,
            )


# FRAME 40

# LEGEND
# ... checkbutton
        rowCount = 0
        self.varCheckbuttonShowLegend_Kiviat = IntVar()
        self.checkbuttonShowLegend_Kiviat = Checkbutton(
            frame_40,
            bg=colorbg,
            variable=self.varCheckbuttonShowLegend_Kiviat,
#            command=self.handlerShowLegend_AllCurvesOnePlot_Kiviat,
            )
        self.checkbuttonShowLegend_Kiviat.grid(
            row=rowCount,
            column=0,
            padx=0,
            pady=1,
            sticky=W,
            )
#        self.checkbuttonShowLegend_AllCurvesOnePlot.configure(state='disabled')
# ... label
        labelShowLegend_Kiviat = Label(
            frame_40,
            text='Show legend:',
            justify=LEFT,
            bg=colorbg,
            )
        labelShowLegend_Kiviat.grid(
            row=rowCount,
            column=1,
            padx=0,
            pady=0,
            sticky=W
            )
# ... label
        '''
        labelLegendTitle = Label(
            frame_40,
            text='title (optional): ',
            bg=colorbg,
            justify=LEFT,
            )
        labelLegendTitle.grid(
            row=rowCount,
            column=2,
            padx=0,
            pady=0,
            sticky=E,
            )
# ... title (optional)
        self.varEntryLegendTitle_Kiviat = StringVar()
        self.entryLegendTitle_Kiviat = Entry(
            frame_40,
            width=20,
            textvariable=self.varEntryLegendTitle_Kiviat,
            disabledbackground='lightgray',
            )
        self.entryLegendTitle_Kiviat.grid(
            row=rowCount,
            column=3,
            padx=0,
            pady=0,
            sticky=W,
            )
        '''
# ... title (optional)
        self.legendTitleStringTable_Kiviat = ''
# ... size
        self.comboboxLegendTitleFont_Kiviat = Pmw.ComboBox(
            frame_40,
            scrolledlist_items=self.fontsizesKiviatLegend,
            label_text='size:',
            label_background=colorbg,
            labelpos='w',
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            listheight=150,
            entry_width=5,
            scrolledlist_hull_width=500,
            )
        self.comboboxLegendTitleFont_Kiviat.grid(
            row=rowCount,
            column=2,
            padx=4,
            pady=0,
            sticky=E,
            )
# ... columns
        self.comboboxLegendNumColumns_Kiviat = Pmw.ComboBox(
            frame_40,
            scrolledlist_items=self.legendNumColumns,
            label_text='columns:',
            label_background=colorbg,
            labelpos='w',
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            listheight=80,
            entry_width=3,
            scrolledlist_hull_width=500,
            )
        self.comboboxLegendNumColumns_Kiviat.grid(
            row=rowCount,
            column=3,
            padx=4,
            pady=0,
            sticky=E,
            )
# ... label spacing
        self.comboboxLegendLabelSpacing_Kiviat = Pmw.ComboBox(
            frame_40,
            scrolledlist_items=self.legendLabelSpacing_Kiviat,
            label_text='label spacing:',
            label_background=colorbg,
            labelpos='w',
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            listheight=125,
            entry_width=3,
            scrolledlist_hull_width=500,
            )
        self.comboboxLegendLabelSpacing_Kiviat.grid(
            row=rowCount,
            column=4,
            padx=4,
            pady=0,
            sticky=E,
            )       
# ... border padding
        rowCount += 1
        self.comboboxLegendBorderPadding_Kiviat = Pmw.ComboBox(
            frame_40,
            scrolledlist_items=self.legendBorderPadding_Kiviat,
            label_text='border padding:',
            label_background=colorbg,
            labelpos='w',
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            listheight=125,
            entry_width=3,
            scrolledlist_hull_width=500,
            )
        self.comboboxLegendBorderPadding_Kiviat.grid(
            row=rowCount,
            column=2,
            padx=4,
            pady=0,
            sticky=E,
            )       
# ... x location
        self.comboboxXLocationLegend_Kiviat = Pmw.ComboBox(
            frame_40,
            scrolledlist_items=self.xLocationLegend_Kiviat,
            label_text='X location:',
            label_background=colorbg,
            labelpos='w',
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            listheight=200,
            entry_width=5,
            scrolledlist_hull_width=500,
            )
        self.comboboxXLocationLegend_Kiviat.grid(
            row=rowCount,
            column=3,

#            columnspan=2,
            padx=4,
            pady=0,
            sticky=E,
            )
# ... y location
        self.comboboxYLocationLegend_Kiviat = Pmw.ComboBox(
            frame_40,
            scrolledlist_items=self.yLocationLegend_Kiviat,
            label_text='Y location:',
            label_background=colorbg,
            labelpos='w',
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            listheight=200,
            entry_width=5,
            scrolledlist_hull_width=500,
            )
        self.comboboxYLocationLegend_Kiviat.grid(
            row=rowCount,
            column=4,
#            columnspan=2,
            padx=4,
            pady=0,
            sticky=E,
            )
            
# FRAME 42

# SET MAX PLOT RADIUS
# ... checkbutton
        rowCount = 0
        self.varCheckbuttonSetMaxPlotRadius_Kiviat = IntVar()
        self.checkbuttonSetMaxPlotRadius_Kiviat = Checkbutton(
            frame_42,
            bg=colorbg,
            variable=self.varCheckbuttonSetMaxPlotRadius_Kiviat,
#            command=self.handlerShowLegend_AllCurvesOnePlot_Kiviat,
            )
        self.checkbuttonSetMaxPlotRadius_Kiviat.grid(
            row=rowCount,
            column=0,
            padx=0,
            pady=1,
            sticky=W,
            )
# ... label
        labelSetMaxPlotRadius_Kiviat = Label(
            frame_42,
            text='Set max plot radius to: ',
            justify=LEFT,
            bg=colorbg,
            )
        labelSetMaxPlotRadius_Kiviat.grid(
            row=rowCount,
            column=1,
            padx=0,
            pady=0,
            sticky=W
            )
# ... radius
        self.comboboxSetMaxPlotRadius_Kiviat = Pmw.ComboBox(
            frame_42,
            scrolledlist_items=self.setMaxPlotRadius_Kiviat,
#            label_text='??',
#            label_background=colorbg,
#            labelpos='w',
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            listheight=150,
            entry_width=5,
            scrolledlist_hull_width=500,
            )
        self.comboboxSetMaxPlotRadius_Kiviat.grid(
            row=rowCount,
            column=2,
            padx=5,
            pady=0,
            sticky=W,
            )  
# ... text
        labelTextForMaxPlotRadius = Label(
            frame_42,
            text=(
                'NOTE: If unchecked, max plot radius will be set to the maximum normalized value\n' +
                ' derived from the selected table data.'
#                each plot\'s local data, so that each plot will have a different max plot radius.'
                ),
            justify=LEFT,
            bg=colorbg,
            )
        labelTextForMaxPlotRadius.grid(
            row=rowCount,
            column=3,
            rowspan=2,
            padx=0,
            pady=0,
            sticky=W,
            )
        
     
# FRAME 45
     
# ... separator line
        rowCount = 0
        labelSeparatorLine = Label(
            frame_45,
            text='-'*100,
            bg=colorbg,
            justify=CENTER,
            )
        '''
        labelSeparatorLine.grid(
            row=rowCount,
            column=0,
            columnspan=99,
            padx=5,
            pady=1,
            )
        '''
            
# FRAME 50

# MANY GROUPS, ONE GROUP PER PLOT, ALL PLOTS IN ONE WINDOW    
# ... single group per plot, all plots in one window
        rowCount = 0
        self.varGroupsSelection_Kiviat = StringVar()
        radiobuttonSingleGroupPerPlot_Kiviat = Radiobutton(
            frame_50a,
            bg=colorbg,
            variable=self.varGroupsSelection_Kiviat,
            value=self.dictPlotParams_Defaults_Kiviat['plot_choice_group_1'],
            command=self.handlerEnablePlotChoiceGroup_Kiviat,
            )
        '''
        radiobuttonSingleGroupPerPlot_Kiviat.grid(
            row=rowCount,
            column=0,
            padx=2,
            pady=1,
            )
        '''
        labelSingleGroupPerPlot = Label(
            frame_50a,
            bg=colorbg,
            text=(
                '1 - All plots in one window, single or multiple plots, one group per plot\n' +
                ' - each group (i.e., plot) must have identical legend (X-Select) values\n' +
                ' - each group may have a different number of spokes\n' +
                ' - max %s plots'
                ) % (str(plotsMaxNumber_Kiviat)),
            justify=LEFT,
            font=self.subtitleFont,
            )
        '''
        labelSingleGroupPerPlot.grid(
            row=rowCount,
            column=1,
            padx=0,
            pady=1,
            )
        '''
            
# Plot groups from Table 
        self.varCheckbuttonTableData_AllGroupsPerWindow_Kiviat = IntVar()
        self.checkbuttonTableData_AllGroupsPerWindow_Kiviat = Checkbutton(
            frame_50b,
            bg=colorbg,
            variable=self.varCheckbuttonTableData_AllGroupsPerWindow_Kiviat,
#            command=self.handlerRefreshReferenceCurveList_Kiviat,
            )
        '''
        self.checkbuttonTableData_AllGroupsPerWindow_Kiviat.grid(
            row=rowCount,
            column=0,
            padx=0,
            pady=0,
            sticky=W,
            )    
        '''
        labelTableData = Label(
            frame_50b,
            text='Plot group from Table',
            justify=LEFT,
            bg=colorbg,
            )
        '''
        labelTableData.grid(
            row=rowCount,
            column=1,
            padx=0,
            pady=0,
            sticky=W,
            )
        '''
            
# filler label
        labelFiller = Label(
            frame_50b,
            text='       ',
            justify=CENTER,
            bg=colorbg,
            )
        '''
        labelFiller.grid(
            row=rowCount,
            column=2,
            padx=0,
            pady=0,
            )
        '''
# Plot groups from Storage Buffer
        self.varCheckbuttonBufferData_AllGroupsPerWindow_Kiviat = IntVar()
        self.checkbuttonBufferData_AllGroupsPerWindow_Kiviat = Checkbutton(
            frame_50b,
            bg=colorbg,
            variable=self.varCheckbuttonBufferData_AllGroupsPerWindow_Kiviat,
#            command=self.handlerRefreshReferenceCurveList_Kiviat,
            )
        '''
        self.checkbuttonBufferData_AllGroupsPerWindow_Kiviat.grid(
            row=rowCount,
            column=3,
            padx=0,
            pady=0,
            sticky=W,
            )
        '''
# ... label
        labelBufferData = Label(
            frame_50b,
            text='Plot groups from Storage Buffer',
            justify=LEFT,
            bg=colorbg,
            )
        '''
        labelBufferData.grid(
            row=rowCount,
            column=4,
            padx=0,
            pady=0,
            sticky=W,
            )
        '''
            
# ... use local or global max values  
        labelLocalOrGlobalMax = Label(
            frame_50c,
            text='For all plots, use...',
            justify=LEFT,
            bg=colorbg,
            )
        '''
        labelLocalOrGlobalMax.grid(
            row=rowCount,
            column=0,
            padx=0,
            pady=0,
            sticky=W,
            )
        '''
        self.varLocalOrGlobalMax_AllGroupsPerWindow_Kiviat = StringVar()
        self.radiobuttonLocal_AllGroupsPerWindow_Kiviat = Radiobutton(
            frame_50d,
            text='local maxima for each plot',
            justify=LEFT,
            variable=self.varLocalOrGlobalMax_AllGroupsPerWindow_Kiviat,
            value='local',
            bg=colorbg,
            )
        '''
        self.radiobuttonLocal_AllGroupsPerWindow_Kiviat.grid(
            row=rowCount,
            column=0,
            padx=0,
            pady=0,
            sticky=W,
            )
        '''
        self.radiobuttonGlobal_AllGroupsPerWindow_Kiviat = Radiobutton(
            frame_50d,
            text='global maximum for all plots',
            justify=LEFT,
            variable=self.varLocalOrGlobalMax_AllGroupsPerWindow_Kiviat,
            value='global',
            bg=colorbg,
            )
        '''
        self.radiobuttonGlobal_AllGroupsPerWindow_Kiviat.grid(
            row=rowCount,
            column=1,
            padx=10,
            pady=0,
            sticky=W,
            )
        '''
# ... default to local
        self.varLocalOrGlobalMax_AllGroupsPerWindow_Kiviat.set('local')
          
# ----------------------------------

# FRAME 55

# PLOT MULTIPLE PLOTS, ONE GROUP PER PLOT, EACH PLOT IN SEPARATE WINDOW
#   IMPLIES
#   -- EACH PLOT CAN HAVE DIFFERENT LEGENDS (X-SELECT) VALUES SINCE ONLY
#       ONE LEGEND IS ALLOWED PER PLOT
# MANY GROUPS, ONE GROUP PER PLOT, ALL PLOTS IN ONE WINDOW    
# ... single group per plot, all plots in one window

        radiobuttonSingleGroupPerPlotPerWindow_Kiviat = Radiobutton(
            frame_55a,
            bg=colorbg,
            variable=self.varGroupsSelection_Kiviat,
            value=self.dictPlotParams_Defaults_Kiviat['plot_choice_group_2'],
            command=self.handlerEnablePlotChoiceGroup_Kiviat,
            )
        '''
        radiobuttonSingleGroupPerPlotPerWindow_Kiviat.grid(
            row=rowCount,
            column=0,
            padx=2,
            pady=1,
            )
        '''
        
        labelSingleGroupPerPlotPerWindow = Label(
            frame_55a,
            bg=colorbg,
            text=(
                '2 - One plot per window, single or multiple plots, one group per plot\n' +
                ' - each group (i.e., plot) may have different legend values (X-Select values)\n' +
                ' - each group may have a different number of spokes (Y-Select values)\n' +
                ' - max %s plots'
                ) % (str(plotsMaxNumber_Kiviat)),
            justify=LEFT,
            font=self.subtitleFont,
            )
        '''
        labelSingleGroupPerPlotPerWindow.grid(
            row=rowCount,
            column=1,
            padx=0,
            pady=1,
            )  
        '''
            
# ... Plot groups from Table 
        rowCount = 0
        self.varCheckbuttonTableData_OneGroupPerWindow_Kiviat = IntVar()
        self.checkbuttonTableData_OneGroupPerWindow_Kiviat = Checkbutton(
            frame_55b,
            bg=colorbg,
            variable=self.varCheckbuttonTableData_OneGroupPerWindow_Kiviat,
#            command=self.handlerRefreshReferenceCurveList_Kiviat,
            command=self.notYetImplemented,
            )
        '''
        self.checkbuttonTableData_OneGroupPerWindow_Kiviat.grid(
            row=rowCount,
            column=0,
            padx=0,
            pady=0,
            sticky=W,
            )  
        '''
        labelTableData = Label(
            frame_55b,
            text='Plot group from Table',
            justify=LEFT,
            bg=colorbg,
            )
        '''
        labelTableData.grid(
            row=rowCount,
            column=1,
            padx=0,
            pady=0,
            sticky=W,
            ) 
        '''
# filler label
        labelFiller = Label(
            frame_55b,
            text='       ',
            justify=CENTER,
            bg=colorbg,
            )
        '''
        labelFiller.grid(
            row=rowCount,
            column=2,
            padx=0,
            pady=0,
            ) 
        '''            
# Plot groups from Storage Buffer
        self.varCheckbuttonBufferData_OneGroupPerWindow_Kiviat = IntVar()
        self.checkbuttonBufferData_OneGroupPerWindow_Kiviat = Checkbutton(
            frame_55b,
            bg=colorbg,
            variable=self.varCheckbuttonBufferData_OneGroupPerWindow_Kiviat,
#            command=self.handlerRefreshReferenceCurveList_Kiviat,
            )
        '''
        self.checkbuttonBufferData_OneGroupPerWindow_Kiviat.grid(
            row=rowCount,
            column=3,
            padx=0,
            pady=0,
            sticky=W,
            )
        '''
# ... label
        labelBufferData = Label(
            frame_55b,
            text='Plot groups from Storage Buffer:',
            justify=LEFT,
            bg=colorbg,
            )
        '''
        labelBufferData.grid(
            row=rowCount,
            column=4,
            padx=0,
            pady=0,
            sticky=W,
            )
        '''    
# ... for all plots, use ...
        rowCount = 0
        labelLocalOrGlobalMax = Label(
            frame_55c,
            text='For all plots, use...',
            justify=LEFT,
            bg=colorbg,
            )
        '''
        labelLocalOrGlobalMax.grid(
            row=rowCount,
            column=0,
            padx=0,
            pady=0,
            sticky=W,
            )
        '''
            
# ... local maxima or global maximum
        rowCount = 0
        self.varLocalOrGlobalMax_OneGroupPerWindow_Kiviat = StringVar()
        self.radiobuttonLocal_OneGroupPerWindow_Kiviat = Radiobutton(
            frame_55d,
            text='local maxima for each plot',
            justify=LEFT,
            variable=self.varLocalOrGlobalMax_OneGroupPerWindow_Kiviat,
            value='local',
            bg=colorbg,
            )
        '''
        self.radiobuttonLocal_OneGroupPerWindow_Kiviat.grid(
            row=rowCount,
            column=0,
            padx=0,
            pady=0,
            sticky=W,
            )
        '''
        self.radiobuttonGlobal_OneGroupPerWindow_Kiviat = Radiobutton(
            frame_55d,
            text='global maximum for all plots',
            justify=LEFT,
            variable=self.varLocalOrGlobalMax_OneGroupPerWindow_Kiviat,
            value='global',
            bg=colorbg,
            )
        '''
        self.radiobuttonGlobal_OneGroupPerWindow_Kiviat.grid(
            row=rowCount,
            column=1,
            padx=10,
            pady=0,
            sticky=W,
            )
        '''
# ... default to local
        self.varLocalOrGlobalMax_OneGroupPerWindow_Kiviat.set('local')        

# ----------------------------------

# FRAME 90

#  ONE GROUP, BUT ONLY ONE STREAMER (CURVE) PER PLOT
        rowCount = 0
        self.radiobuttonOneGroupSeparatePlots_Kiviat = Radiobutton(
            frame_60a,
            bg=colorbg,
            variable=self.varGroupsSelection_Kiviat,
            value=self.dictPlotParams_Defaults_Kiviat['plot_choice_group_3'],
            command=self.handlerEnablePlotChoiceGroup_Kiviat,
            )
        '''
        self.radiobuttonOneGroupSeparatePlots_Kiviat.grid(
            row=rowCount,
            column=0,
            padx=2,
            pady=0,
            )
        '''
# -----
#        self.radiobuttonAllCurvesOnePlot.deselect()
        labelOneGroupSeparatePlots = Label(
            frame_60a,
            bg=colorbg,
            text=(
                '3 - All plots in one window, one selected group\'s curves, one curve per plot\n' +
                '- max %s curves'
                ) % (str(plotsMaxNumber_Kiviat)),
            justify=LEFT,
            font=self.subtitleFont,
            )
        '''
        labelOneGroupSeparatePlots.grid(
            row=rowCount,
            column=1,
            padx=2,
            pady=1,
            )
        '''
# ... choose whether select group comes from table or storage buffer  
        labelTableOrStorageBuffer = Label(
            frame_60b,
            text='Plot single group from ',
            justify=LEFT,
            bg=colorbg,
            )
        '''
        labelTableOrStorageBuffer.grid(
            row=rowCount,
            column=0,
            padx=0,
            pady=0,
            sticky=W,
            )
        '''
        self.varUseTableOrStorageBuffer_OneCurvePerPlot_Kiviat = StringVar()
        self.radiobuttonUseTable_OneCurvePerPlot_Kiviat = Radiobutton(
            frame_60b,
            text='table',
            justify=LEFT,
            variable=self.varUseTableOrStorageBuffer_OneCurvePerPlot_Kiviat,
            value='table',
            bg=colorbg,
            command=self.notYetImplemented,
            )
        '''
        self.radiobuttonUseTable_OneCurvePerPlot_Kiviat.grid(
            row=rowCount,
            column=1,
            padx=0,
            pady=0,
            sticky=W,
            )
        '''
        self.radiobuttonUseBuffer_OneCurvePerPlot_Kiviat = Radiobutton(
            frame_60b,
            text='storage buffer',
            justify=LEFT,
            variable=self.varUseTableOrStorageBuffer_OneCurvePerPlot_Kiviat,
            value='buffer',
            bg=colorbg,
            )
        '''
        self.radiobuttonUseBuffer_OneCurvePerPlot_Kiviat.grid(
            row=rowCount,
            column=2,
            padx=10,
            pady=0,
            sticky=W,
            )
        '''
        self.varUseTableOrStorageBuffer_OneCurvePerPlot_Kiviat.set('table')
# -----


# frame_999
# ... reset all
        rowCount = 0
        buttonResetAllPlots = Button(
            frame_999,
            text='Reset plot options',
            width=14,
            background='white',
            foreground='blue',
            font=self.buttonFontSmall,
            relief=RAISED,
            borderwidth=3,
            command=self.handlerResetAllPlotKiviatSelect,
            )
        buttonResetAllPlots.grid(
            row=rowCount,
            column=0,
            padx=5,
            pady=1,
            )
# ... close all plots if plots are present
        buttonCloseAllPlots = Button(
            frame_999,
            text='Close all plots',
            width=14,
            font=self.buttonFontSmall,
            relief=RAISED,
            borderwidth=3,
            command=self.handlerCloseAllKiviatPlots,
            )
        buttonCloseAllPlots.grid(
            row=rowCount,
            column=1,
            padx=5,
            pady=1,
            )
            
# ... plot
        rowCount += 1
        self.buttonXYPlottingSpecsPlot_Kiviat = Button(
            frame_999,
            text='Plot',
            width=15,
            relief=RAISED,
            borderwidth=5,
            command=self.handlerPlotKiviatSelect,
            )
        self.buttonXYPlottingSpecsPlot_Kiviat.grid(
            row=rowCount,
            column=0,
            padx=5,
            pady=2,
            )
# ... cancel
        buttonCancel = Button(
            frame_999,
            text='Cancel',
            width=15,
            relief=RAISED,
            borderwidth=5,
            command=self.destroyPlotPreprocess_Kiviat,
            )
        buttonCancel.grid(
            row=rowCount,
            column=1,
            padx=1,
            pady=2,
            )
            
# ---------------------------------------

# set all variables, depending on whether there was a previous window
        if self.previousWindow_Kiviat:
# restore previous state of window, or recalculate values if necessary

# HEADER
# ... number of table groups
            self.varNumberOfTableGroups_Kiviat.set(
                self.jcountTable_Kiviat
                )
# ... number of storage buffer groups
            self.varNumberOfStorageBufferGroups_Kiviat.set(
                self.jcountBuffer_Kiviat
                )
# ... total plots max
            self.varNumberOfTotalGroups_Kiviat.set(
                self.jcountTable_Kiviat + self.jcountBuffer_Kiviat
                )
# ... curves per group from table
            try:
                self.varNumberOfTableCurves_Kiviat.set(
                    len(self.plot_X_Table_Kiviat)
                    )
            except:
                self.varNumberOfTableCurves_Kiviat.set(0)
# ... curves per group from storage buffer
            try:
                self.varNumberOfStorageBufferCurves_Kiviat.set(
                    len(self.plot_X_Buffer_Kiviat) 
                    )
            except:
                self.varNumberOfStorageBufferCurves_Kiviat.set(0)


# GLOBAL PLOT PARAMETERS                
# ... background color
            self.comboboxColorBackground_Kiviat.setentry(
                background_color_Kiviat
                )
# ... interior color
            self.comboboxColorInterior_Kiviat.setentry(
                interior_color_Kiviat
                )
# ... line width
            self.comboboxLineWidth_Kiviat.setentry(
                linewidth_Kiviat
                )
# ... line-enclosed color opacity
            self.comboboxFillColorOpacity_Kiviat.setentry(
                line_enclosed_color_opacity_Kiviat
                )
# ... figure width
            self.comboboxFigureSizeWidth_Kiviat.setentry(
                figure_size_width_Kiviat
                )
# ... figure height
            self.comboboxFigureSizeHeight_Kiviat.setentry(
                figure_size_height_Kiviat
                )

# NORMALIZATION FACTOR
# ... local or global
            self.varButtonNormalizationMethod_Kiviat.set(normalization_factor_status_Kiviat)
            
# PLOT FORMAT
# ... asIs or complement
            self.varRadiobuttonPlotFormat_Kiviat.set(plot_format_Kiviat)
            
# REPLOT                
# ... checkbutton
            self.varReplotInCurrentWindow_Kiviat.set(replot_checkbutton_status_Kiviat)
# ... configure widgets for background color, plot width, and plot height
#       based on above checkbutton
            self.handlerReplotInCurrentWindow_Kiviat()
            
# SHOW MAIN TITLE
# ... checkbutton
            self.varCheckbuttonShowTitle_Kiviat.set(
                show_title_checkbutton_Kiviat
                )
# ... entry
            self.varEntryShowTitle_Kiviat.set(
                show_title_entry_Kiviat
                )
# ... font size
            self.comboboxFontTitle_Kiviat.setentry(
                show_title_font_Kiviat
                )
# ... color
            self.comboboxColorTitle_Kiviat.setentry(
                show_title_color_Kiviat
                )
# ... weight
            self.comboboxFontWeightTitle_Kiviat.setentry(
                show_title_weight_Kiviat
                )
# ... x location
            self.comboboxXLocationTitle_Kiviat.setentry(
                show_title_x_location_Kiviat
                )
# ... y location
            self.comboboxYLocationTitle_Kiviat.setentry(
                show_title_y_location_Kiviat
                )
                
# SHOW SUBTITLES (above each plot)
# ... checkbox
            self.varCheckbuttonShowSubTitle_Kiviat.set(
                show_subtitle_checkbutton_Kiviat
                )
# ... entry
#            self.varEntryShowSubTitle_Kiviat.set(
#                show_subtitle_entry_Kiviat
#                )
# ... size
            self.comboboxFontSubTitle_Kiviat.setentry(
                show_subtitle_size_Kiviat
                )
# ... color
            self.comboboxColorSubTitle_Kiviat.setentry(
                show_subtitle_color_Kiviat
                )
# ... weight
            self.comboboxFontWeightSubTitle_Kiviat.setentry(
                show_subtitle_weight_Kiviat
                )
# ... x location
            self.comboboxXLocationSubTitle_Kiviat.setentry(
                show_subtitle_x_location_Kiviat
                )
# ... y location
            self.comboboxYLocationSubTitle_Kiviat.setentry(
                show_subtitle_y_location_Kiviat
                )
                
# SHOW SPOKE LABELS
# ... checkbutton
            self.varShowLabels_Kiviat.set(
                show_spoke_labels_Kiviat
                )
# ... size
            self.comboboxFontLabels_Kiviat.setentry(
                show_spoke_labels_size_Kiviat
                )
# ... color
            self.comboboxColorLabels_Kiviat.setentry(
                show_spoke_labels_color_Kiviat
                )

# SHOW GRID
# ... checkbutton
            self.varShowGrid_Kiviat.set(
                show_grids_checkbutton_Kiviat
                )
# ... size
            self.comboboxFontGridLabels_Kiviat.setentry(
                show_grids_radial_font_labels_Kiviat
                )
# ... line width
            self.comboboxGridLineWidth_Kiviat.setentry(
                show_grids_radial_line_width_Kiviat
                )
# ... line style
            self.comboboxGridLineStyle_Kiviat.setentry(
                show_grids_radial_line_style_Kiviat
                )
# ... increment
            self.comboboxGridIncrement_Kiviat.setentry(
                show_grids_radial_increment_Kiviat
                )
# ... color
            self.comboboxGridColor_Kiviat.setentry(
                show_grids_grid_color
                )
# ... tick color
            self.comboboxGridColorLabels_Kiviat.setentry(
                show_grids_grid_tick_color
                )

# SHOW LEGEND
# ... checkbutton
            self.varCheckbuttonShowLegend_Kiviat.set(
                show_legend_checkbutton_Kiviat
                )
# ... title (optional)
#            self.varEntryLegendTitle_Kiviat.set(
#                show_legend_title_Kiviat
#                )
            self.legendTitleStringTable_Kiviat = show_legend_title_Kiviat
# ... size
            self.comboboxLegendTitleFont_Kiviat.setentry(
                show_legend_size_Kiviat
                )
# ... columns
            self.comboboxLegendNumColumns_Kiviat.setentry(
                show_legend_number_of_columns_Kiviat
                )
# ... label spacing
            self.comboboxLegendLabelSpacing_Kiviat.setentry(
                show_legend_spacing_Kiviat
                )
# ... border padding
            self.comboboxLegendBorderPadding_Kiviat.setentry(
                show_legend_padding_Kiviat
                )
# ... x location
            self.comboboxXLocationLegend_Kiviat.setentry(
                show_legend_x_location_Kiviat
                )
# ... y location
            self.comboboxYLocationLegend_Kiviat.setentry(
                show_legend_y_location_Kiviat
                )
                
# SET MAX PLOT RADIUS
# ... checkbutton
            self.varCheckbuttonSetMaxPlotRadius_Kiviat.set(
                set_max_plot_radius_Kiviat
                )
# ... radius
            self.comboboxSetMaxPlotRadius_Kiviat.setentry(
                value_max_plot_radius_Kiviat
                )
                
# PLOTS              
# ... select group for plotting    
            self.varGroupsSelection_Kiviat.set(
                plot_Selection_Kiviat
                )

# PLOTS 1
# for all plots in one window
# ... plot group from table - checkbutton
            self.varCheckbuttonTableData_AllGroupsPerWindow_Kiviat.set(
                plot_group_from_table_checkbutton_AllGroupsPerWindow_Kiviat
                )
# ... plot groups from storage buffer - checkbutton
            self.varCheckbuttonBufferData_AllGroupsPerWindow_Kiviat.set(
                plot_groups_from_storage_buffer_checkbutton_AllGroupsPerWindow_Kiviat
                )
# ... use local or global maximum - radiobutton
            self.varLocalOrGlobalMax_AllGroupsPerWindow_Kiviat.set(
                use_local_or_global_maxima_AllGroupsPerWindow_Kiviat
                )

# ... whether to include table data for plots
            self.varNumberOfTableGroups_Kiviat.set(self.jcountTable_Kiviat)
            if (
                numberOfPreviousTableGroups == 0
                and
                self.varNumberOfTableGroups_Kiviat.get() <> 0
                ):
                self.varCheckbuttonTableData_AllGroupsPerWindow_Kiviat.set(1)
            elif (
                numberOfPreviousTableGroups <> 0
                and
                self.varNumberOfTableGroups_Kiviat.get() <> 0
                ):
                self.varCheckbuttonTableData_AllGroupsPerWindow_Kiviat.set(
                    plot_group_from_table_checkbutton_AllGroupsPerWindow_Kiviat
                    )
            else:
                self.varCheckbuttonTableData_AllGroupsPerWindow_Kiviat.set(0)         
# ... whether to include buffer data for plots
            try:
#                print('\nself.jcountBuffer_Kiviat = %s' % self.jcountBuffer_Kiviat)
                self.varNumberOfBufferGroups_AllGroupsPerWindow_Kiviat.set(
                    self.jcountBuffer_Kiviat
                    )
            except:
                self.varNumberOfStorageBufferGroups_Kiviat.set(0)
            if (
                numberOfPreviousStorageBufferGroups == 0
                and
                self.varNumberOfStorageBufferGroups_Kiviat.get() <> 0
                ):
                self.varCheckbuttonBufferData_AllGroupsPerWindow_Kiviat.set(1)
            elif (
                numberOfPreviousStorageBufferGroups <> 0
                and
                self.varNumberOfStorageBufferGroups_Kiviat.get() <> 0
                ):
                self.varCheckbuttonBufferData_AllGroupsPerWindow_Kiviat.set(
                    plot_groups_from_storage_buffer_checkbutton_AllGroupsPerWindow_Kiviat
                    )
            else:
                self.varCheckbuttonBufferData_AllGroupsPerWindow_Kiviat.set(0)

# PLOTS 2                
# for one plot per window
# ... plot group from table - checkbutton
            self.varCheckbuttonTableData_OneGroupPerWindow_Kiviat.set(
                plot_group_from_table_checkbutton_OneGroupPerWindow_Kiviat
                )
# ... plot groups from storage buffer - checkbutton
            self.varCheckbuttonBufferData_OneGroupPerWindow_Kiviat.set(
                plot_groups_from_storage_buffer_checkbutton_OneGroupPerWindow_Kiviat
                )
# ... use local or global maximum
            self.varLocalOrGlobalMax_OneGroupPerWindow_Kiviat.set(
                use_local_or_global_maxima_OneGroupPerWindow_Kiviat
                )
# ... whether to include table data for plots
            self.varNumberOfTableGroups_Kiviat.set(self.jcountTable_Kiviat)
            if (
                numberOfPreviousTableGroups == 0
                and
                self.varNumberOfTableGroups_Kiviat.get() <> 0
                ):
                self.varCheckbuttonTableData_OneGroupPerWindow_Kiviat.set(1)
            elif (
                numberOfPreviousTableGroups <> 0
                and
                self.varNumberOfTableGroups_Kiviat.get() <> 0
                ):
                self.varCheckbuttonTableData_OneGroupPerWindow_Kiviat.set(
                    plot_group_from_table_checkbutton_OneGroupPerWindow_Kiviat
                    )
            else:
                self.varCheckbuttonTableData_OneGroupPerWindow_Kiviat.set(0)
                
# ... whether to include buffer data for plots
            try:
#                print('\nself.jcountBuffer_Kiviat = %s' % self.jcountBuffer_Kiviat)
                self.varNumberOfStorageBufferGroups_Kiviat.set(self.jcountBuffer_Kiviat)
            except:
                self.varNumberOfStorageBufferGroups_Kiviat.set(0)
            if (
                numberOfPreviousStorageBufferGroups == 0
                and
                self.varNumberOfStorageBufferGroups_Kiviat.get() <> 0
                ):
                self.varCheckbuttonBufferData_OneGroupPerWindow_Kiviat.set(1)
            elif (
                numberOfPreviousStorageBufferGroups <> 0
                and
                self.varNumberOfStorageBufferGroups_Kiviat.get() <> 0
                ):
                self.varCheckbuttonBufferData_OneGroupPerWindow_Kiviat.set(
                    plot_groups_from_storage_buffer_checkbutton_OneGroupPerWindow_Kiviat
                    )
            else:
                self.varCheckbuttonBufferData_OneGroupPerWindow_Kiviat.set(0)
                
# PLOT 3
# for all plots in one window, one curve per plot
# ... plot group from either table or buffer but not both - radiobutton
            self.varUseTableOrStorageBuffer_OneCurvePerPlot_Kiviat.set(
                plot_group_from_table_or_storage_buffer_radiobutton_OneCurvePerPlot_Kiviat
                )   

            
# ... disable/enable checkbuttons and radiobuttons for plot groups
#       based on setting for self.varGroupsSelection_Kiviat.set()      
            success = self.handlerEnablePlotChoiceGroup_Kiviat()
            if not success: 
                return
     
                
        else:
# plot window did not exist
# DEFAULT SETTINGS
#   define settings first that are not defined in a global dict or that
#     have already been set
# ... number of groups to plot from table
            
            self.jcountBuffer_Kiviat = 0
            
            if DEBUG_KIVIAT:
                print('\n\n***** self.jcountTable_Kiviat = %s' % self.jcountTable_Kiviat)
                print('\n      self.jcountBuffer_Kiviat = %s' % self.jcountBuffer_Kiviat)
            
            self.varNumberOfTableGroups_Kiviat.set(self.jcountTable_Kiviat)
            self.varNumberOfStorageBufferGroups_Kiviat.set(self.jcountBuffer_Kiviat)
# ... total number of groups
            self.varNumberOfTotalGroups_Kiviat.set(
                self.jcountTable_Kiviat + self.jcountBuffer_Kiviat
                )  
                
# ... number of curves per group
# ...   from table
            if self.varNumberOfTableGroups_Kiviat.get() > 0 :
                try:
                    self.varNumberOfTableCurves_Kiviat.set(
                        len(self.plot_X_Table_Kiviat)
                        )
                except:
                    self.varNumberOfTableCurves_Kiviat.set(0)
            else:
                self.varNumberOfTableCurves_Kiviat.set(0)
# ...   from storage buffer
            if self.varNumberOfStorageBufferGroups_Kiviat.get() > 0:
                try:
                    self.varNumberOfStorageBufferCurves_Kiviat.set(
                        len(self.plot_X_Buffer_Kiviat) 
                        )
                except:
                    self.varNumberOfStorageBufferCurves_Kiviat.set(0)
            else:
                self.varNumberOfStorageBufferCurves_Kiviat.set(0)
                
# ------------  general plotting specs for Kiviat diagrams -------------
            self.dictPlotParams_Kiviat = copy.deepcopy(self.dictPlotParams_Defaults_Kiviat)

# GLOBAL PLOT PARAMETERS          
# ...  background color
#            self.comboboxColorBackground_SingleCurvePerPlot._entryWidget['state'] = NORMAL
            self.comboboxColorBackground_Kiviat.setentry(
                self.dictPlotParams_Defaults_Kiviat['colorChartBackground']
                )
# ... interior color
            self.comboboxColorInterior_Kiviat.setentry(
                self.dictPlotParams_Defaults_Kiviat['colorChartInterior']
                )
# ... line width
            self.comboboxLineWidth_Kiviat.setentry(
                self.dictPlotParams_Defaults_Kiviat['lineWidth']
                )
# ... fill color opacity
            self.comboboxFillColorOpacity_Kiviat.setentry(
                self.dictPlotParams_Defaults_Kiviat['fillColorOpacity']
                )
# ... figure width
            self.comboboxFigureSizeWidth_Kiviat.setentry(
                self.dictPlotParams_Defaults_Kiviat['figureSize'][0]
                )
# ... figure height
            self.comboboxFigureSizeHeight_Kiviat.setentry(
                self.dictPlotParams_Defaults_Kiviat['figureSize'][1]
                ) 

            
# NORMALIZATION FACTOR
# ... local or global
            self.varButtonNormalizationMethod_Kiviat.set(
                self.dictPlotParams_Defaults_Kiviat['normalizationMethod']
                )  

# PLOT FORMAT
# ... asIs or complement
            self.varRadiobuttonPlotFormat_Kiviat.set(
                self.dictPlotParams_Defaults_Kiviat['plotFormat']
                )

# REPLOT                
# ...  replot in current plot window
            self.varReplotInCurrentWindow_Kiviat.set(
                self.dictPlotParams_Defaults_Kiviat['replotInCurrentWindows']
                )
# ... configure widgets for background color, plot width, and plot height
#       based on above checkbutton
            self.handlerReplotInCurrentWindow_Kiviat()
                
# MAIN TITLE
# ... checkbox
            self.varCheckbuttonShowTitle_Kiviat.set(
                self.dictPlotParams_Defaults_Kiviat['showTitle']
                )
# ... title
            self.varEntryShowTitle_Kiviat.set(
                self.dictPlotParams_Defaults_Kiviat['defaultTitle']
                )
# ... title font
            self.comboboxFontTitle_Kiviat.setentry(
                self.dictPlotParams_Defaults_Kiviat['fontsizeTitle']
                )
# ... title color
            self.comboboxColorTitle_Kiviat.setentry(
                self.dictPlotParams_Defaults_Kiviat['colorTitle']
                )
# ... title weight
            self.comboboxFontWeightTitle_Kiviat.setentry(
                self.dictPlotParams_Defaults_Kiviat['weightTitle']
                )
# ... x location
            self.comboboxXLocationTitle_Kiviat.setentry(
                self.dictPlotParams_Defaults_Kiviat['xLocationTitle']
                )
# ... y location
            self.comboboxYLocationTitle_Kiviat.setentry(
                self.dictPlotParams_Defaults_Kiviat['yLocationTitle']
                )

# SUBTITLES
# ... checkbox
            self.varCheckbuttonShowSubTitle_Kiviat.set(
                self.dictPlotParams_Defaults_Kiviat['showSubTitles']
                )
# ... entry
#            self.varEntryShowSubTitle_Kiviat.set(
#                self.dictPlotParams_Defaults_Kiviat['entrySubTitles']
#                )
# ... size
            self.comboboxFontSubTitle_Kiviat.setentry(
                self.dictPlotParams_Defaults_Kiviat['fontsizeSubTitles']
                )
# ... color
            self.comboboxColorSubTitle_Kiviat.setentry(
                self.dictPlotParams_Defaults_Kiviat['colorSubTitles']
                )
# ... weight
            self.comboboxFontWeightSubTitle_Kiviat.setentry(
                self.dictPlotParams_Defaults_Kiviat['weightSubTitles']
                )
# ... x location
            self.comboboxXLocationSubTitle_Kiviat.setentry(
                self.dictPlotParams_Defaults_Kiviat['xlocationSubTitles']
                )
# ... y location
            self.comboboxYLocationSubTitle_Kiviat.setentry(
                self.dictPlotParams_Defaults_Kiviat['ylocationSubTitles']
                )

# SPOKE LABELS
# ... checkbox
            self.varShowLabels_Kiviat.set(
                self.dictPlotParams_Defaults_Kiviat['showSpokeLabels']
                )  
# ... size
            self.comboboxFontLabels_Kiviat.setentry(
                self.dictPlotParams_Defaults_Kiviat['fontsizeSpokeLabels']
                )
# ... color 
            self.comboboxColorLabels_Kiviat.setentry(
                self.dictPlotParams_Defaults_Kiviat['colorSpokeLabels']
                )
                
# GRID                
# ... checkbox
            self.varShowGrid_Kiviat.set(
                self.dictPlotParams_Defaults_Kiviat['showGrid']
                )
# ... grid color
            self.comboboxGridColor_Kiviat.setentry(
                self.dictPlotParams_Defaults_Kiviat['colorGrid']
                )
# ... grid ticks color
            self.comboboxGridColorLabels_Kiviat.setentry(
                self.dictPlotParams_Defaults_Kiviat['colorGridTicks']
                )
# ... grid ticks size
            self.comboboxFontGridLabels_Kiviat.setentry(
                self.dictPlotParams_Defaults_Kiviat['fontsizeGridTicks']
                )
# ... line width
            self.comboboxGridLineWidth_Kiviat.setentry(
                self.dictPlotParams_Defaults_Kiviat['lineWidthGrid']
                )
# ... line style
            self.comboboxGridLineStyle_Kiviat.setentry(
                self.dictPlotParams_Defaults_Kiviat['lineStyleGrid']
                )
# ... increment  
            self.comboboxGridIncrement_Kiviat.setentry(
                self.dictPlotParams_Defaults_Kiviat['incrementGrid']
                )
                
# LEGEND
# ... checkbox
            self.varCheckbuttonShowLegend_Kiviat.set(
                self.dictPlotParams_Defaults_Kiviat['showLegend']
                )
# ... title
#            self.varEntryLegendTitle_Kiviat.set(
#                self.dictPlotParams_Defaults_Kiviat['titleLegend']
#                )
            self.legendTitleStringTable_Kiviat = copy.deepcopy(self.dictPlotParams_Defaults_Kiviat['titleLegend'])
# ... size
            self.comboboxLegendTitleFont_Kiviat.setentry(
                self.dictPlotParams_Defaults_Kiviat['fontsizeLegend']
                )
# ... columns
            self.comboboxLegendNumColumns_Kiviat.setentry(
                self.dictPlotParams_Defaults_Kiviat['columnsLegend']
                )
# ... spacing
            self.comboboxLegendLabelSpacing_Kiviat.setentry(
                self.dictPlotParams_Defaults_Kiviat['labelspacingLegend']
                )
# ... padding
            self.comboboxLegendBorderPadding_Kiviat.setentry(
                self.dictPlotParams_Defaults_Kiviat['borderpaddingLegend']
                )
# ... x location, bounding box
            self.comboboxXLocationLegend_Kiviat.setentry(
                self.dictPlotParams_Defaults_Kiviat['locationBoundingBoxLegend'][0]
                )
# ... y location, bounding box
            self.comboboxYLocationLegend_Kiviat.setentry(
                self.dictPlotParams_Defaults_Kiviat['locationBoundingBoxLegend'][1]
                )
                
# SET MAX PLOT RADIUS
# ... checkbox
            self.varCheckbuttonSetMaxPlotRadius_Kiviat.set(
                self.dictPlotParams_Defaults_Kiviat['setMaxPlotRadius']
                )
# ... max plot radius
            self.comboboxSetMaxPlotRadius_Kiviat.setentry(
                self.dictPlotParams_Defaults_Kiviat['valueMaxPlotRadius']
                )
                
# PLOTS
# ... group
            self.varGroupsSelection_Kiviat.set(
                self.dictPlotParams_Defaults_Kiviat['plot_Selection_Kiviat']
                ) 

# ... radial-labels, radial-ticks, y-ticks fonts and colors; background color
#            self.handlerRefreshColors_Kiviat(1)
          
# ... if number of buffer groups is non-zero, check the 
#       'Plot groups from Storage Buffer' checkbutton
            if self.varNumberOfTableGroups_Kiviat.get() <> 0:
                self.varCheckbuttonTableData_AllGroupsPerWindow_Kiviat.set(1)
                self.varCheckbuttonTableData_OneGroupPerWindow_Kiviat.set(1)
            else:
                self.varCheckbuttonTableData_AllGroupsPerWindow_Kiviat.set(0)
                self.varCheckbuttonTableData_OneGroupPerWindow_Kiviat.set(0)
# ... if number of buffer groups is non-zero, check the 
#       'Include select curves from Storage Buffer' checkbutton
            if self.varNumberOfStorageBufferGroups_Kiviat.get() <> 0:
                self.varCheckbuttonBufferData_AllGroupsPerWindow_Kiviat.set(1)
                self.varCheckbuttonBufferData_OneGroupPerWindow_Kiviat.set(1)
            else:
                self.varCheckbuttonBufferData_AllGroupsPerWindow_Kiviat.set(0)
                self.varCheckbuttonBufferData_OneGroupPerWindow_Kiviat.set(0)
                
# set default setting for selecting which group to plot
            self.varGroupsSelection_Kiviat.set(
                self.dictPlotParams_Defaults_Kiviat['plot_choice_group_1']
                )
# ... disable/enable checkbuttons and radiobuttons for plot groups
#       based on setting for self.varGroupsSelection_Kiviat.set()      
            success = self.handlerEnablePlotChoiceGroup_Kiviat()
            if not success: 
                return
          
                
# Now call plot labeling methods, depending on which group to plot
# ... if 'plot all groups per window' is selected
        if self.varGroupsSelection_Kiviat.get().strip() == \
            self.dictPlotParams_Defaults_Kiviat['plot_choice_group_1']:
            self.labels_AllGroupsPerWindow_Kiviat(
                self.labels_xWindowLocation_AllGroupsPerWindow_Kiviat,
                self.labels_yWindowLocation_AllGroupsPerWindow_Kiviat
                )
# ... if 'plot one group per window' is selected
        elif self.varGroupsSelection_Kiviat.get().strip() == \
            self.dictPlotParams_Defaults_Kiviat['plot_choice_group_2']:
            self.labels_OneGroupPerWindow_Kiviat(
                self.labels_xWindowLocation_OneGroupPerWindow_Kiviat,
                self.labels_yWindowLocation_OneGroupPerWindow_Kiviat
                )
        
# ... if 'plot a selected groups curves' is selected
        elif self.varGroupsSelection_Kiviat.get().strip() == \
            self.dictPlotParams_Defaults_Kiviat['plot_choice_group_3']:
            self.labels_OneCurvePerPlot_Kiviat(
                self.labels_xWindowLocation_OneCurvePerPlot_Kiviat,
                self.labels_yWindowLocation_OneCurvePerPlot_Kiviat
                )
        else:
            stringErrorCurvesSelection = (
                'Variable undefined for curve selection:\n\n' +
                '     self.varGroupsSelection_Kiviat = %s\n\n' + 
                'in\n\n' +
                MODULE + '/' + 'handlerKiviatPlotPreprocess\n\n' +
                'Pls contact code administrator to correct code error.'
                ) % (self.varGroupsSelection_Kiviat.get())
            showerror(
                'Error: undefined value',
                stringErrorCurvesSelection
                )
            return
            
# ... use local or global maximum
            self.varLocalOrGlobalMaxima_AllGroupsPerWindow.set(
                self.dictPlotParams_Defaults_Kiviat['plot_local_global_maxima_AllGroupsPerWindow']
                )
            self.varLocalOrGlobalMaxima_OneGroupPerWindow.set(
                self.dictPlotParams_Defaults_Kiviat['plot_local_global_maxima__OneGroupPerWindow']
                )
        
        return
        
        
    def handlerReplotInCurrentWindow_Kiviat(self):
        '''
        Purpose:
            to set foregrounds of following widgets to gray when
            the "Plot subsequent plots in current window..." is checked
            in the KIVIAT PLOTTING SPECS WINDOW:
            1. background color
                self.comboboxColorBackground_Kiviat
            2. plot-window size: width
                self.comboboxFigureSizeWidth_Kiviat
            3. plot-window size: height
                self.comboboxFigureSizeHeight_Kiviat
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerReplotInCurrentWindow_Kiviat')
        
        if self.varReplotInCurrentWindow_Kiviat.get():
            self.comboboxColorBackground_Kiviat.configure(entry_disabledbackground='gray')
            self.comboboxFigureSizeWidth_Kiviat.configure(entry_disabledbackground='gray')
            self.comboboxFigureSizeHeight_Kiviat.configure(entry_disabledbackground='gray')
        else:
            self.comboboxColorBackground_Kiviat.configure(entry_disabledbackground='white')
            self.comboboxFigureSizeWidth_Kiviat.configure(entry_disabledbackground='white')
            self.comboboxFigureSizeHeight_Kiviat.configure(entry_disabledbackground='white')
            
        return
        

    def labels_AllGroupsPerWindow_Kiviat(self,xwin,ywin):
        '''
         Purpose:
            Generate labels for group 1 'All Groups Per Window' mode
            
         Plot label separators:
            '  (space)',
            '\ (back slash)',
            '/ (forward slash)',
            ', (comma+space)',
            '- (dash)',
            '_ (underscore)',
            '+ (plus)',
            '* (asterisk)',
            '> (greater than)',
            '< (less than)'
         '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'labels_AllGroupsPerWindow_Kiviat')
            
        colorbg='lightgreen'  
# open Toplevel frame for entering database name
        self.toplevelLabels_AllGroupsPerWindow_Kiviat = Toplevel(
            self.toplevelKiviatPlotPreprocess,
            bg=colorbg,
            )
        self.toplevelLabels_AllGroupsPerWindow_Kiviat.title(
            'KIVIAT PLOT LABELS - ALL GROUPS PER WINDOW'
            )
#        self.toplevelLabelsSinglePlotPerCurve.transient(self.toplevelTableValues)
        self.toplevelLabels_AllGroupsPerWindow_Kiviat.transient(self.toplevelKiviatPlotPreprocess)
# place the top window
        x_Windows=xwin
        y_Windows=ywin
        self.toplevelLabels_AllGroupsPerWindow_Kiviat.geometry(
            '+%d+%d' % (x_Windows, y_Windows)
            )
            
# determine list of text fields in current table
        listOfTextFields = []
# insert blank for clearing field
        listOfTextFields.append('')
        for row in range(len(self.tableStructure)):
#            fieldType = self.tableStructure[row][1]
            myField, myDatatype, myNull, myKey, myDefault, myExtra = \
                self.tableStructure[row]
            varfirst2 = myDatatype[0:2]
# check if text
            fieldNameIsText = self.checkIsFieldText(varfirst2)
            if fieldNameIsText:
                listOfTextFields.append(myField)  
       
# FRAMES 
# ... title
        Row = 0
        frame_00 = Frame(
            self.toplevelLabels_AllGroupsPerWindow_Kiviat,
            bg=colorbg,
            )
        frame_00.grid(
            row=Row,
            column=0,
            padx=2,
            pady=2,
            )
# ... plot label separator
        Row += 1
        frame_10 = Frame(
            self.toplevelLabels_AllGroupsPerWindow_Kiviat,
            bg=colorbg,
            )
        frame_10.grid(
            row=Row,
            column=0,
            padx=2,
            pady=2,
            )
# ... frame for TABLE data
        Row += 1
        frameTable = Frame(
            self.toplevelLabels_AllGroupsPerWindow_Kiviat,
            bg=colorbg,
            relief=RIDGE,
            borderwidth=2,
            )
        frameTable.grid(
            row=Row,
            column=0,
            padx=2,
            pady=5,
            )
# ... frame for Buffer data
        Row += 1
        frameBuffer = Frame(
            self.toplevelLabels_AllGroupsPerWindow_Kiviat,
            bg=colorbg,
            relief=RIDGE,
            borderwidth=2,
            )
        '''
        frameBuffer.grid(
            row=Row,
            column=0,
            padx=2,
            pady=5
            )
        '''
         
# frames for TABLE frame     
        refFrame = frameTable
# ... sub-title
        Row = 0
        frame_00_Table = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_00_Table.grid(
            row=Row,
            column=0,
            padx=2,
            pady=2,
            )
# ... SPOKE LABELS
        Row += 1
        frame_10_Table = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_10_Table.grid(
            row=Row,
            column=0,
            padx=2,
            pady=2,
            sticky=W,
            )
# ...       x-label defined
        Row += 1
        frame_20_Table = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_20_Table.grid(
            row=Row,
            column=0,
            padx=10,
            pady=2,
            )
# ...   subframes for frame_20_Table
        frame_20_Table_0 = Frame(
            frame_20_Table,
            bg=colorbg,
            )
        frame_20_Table_0.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
        frame_20_Table_1 = Frame(
            frame_20_Table,
            bg=colorbg,
            )
        frame_20_Table_1.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            )
# ...   sub-subframes for frame_20_Table_1
        frame_20_Table_10 = Frame(
            frame_20_Table_1,
            bg=colorbg,
            )
        frame_20_Table_10.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            sticky=W,
            )
        frame_20_Table_11 = Frame(
            frame_20_Table_1,
            bg=colorbg,
            )
        frame_20_Table_11.grid(
            row=1,
            column=0,
            padx=0,
            pady=0,
            sticky=W,
            )
        frame_20_Table_12 = Frame(
            frame_20_Table_1,
            bg=colorbg,
            )
        frame_20_Table_12.grid(
            row=2,
            column=0,
            padx=0,
            pady=0,
            sticky=W,
            )
        frame_20_Table_13 = Frame(
            frame_20_Table_1,
            bg=colorbg,
            )
        frame_20_Table_13.grid(
            row=3,
            column=0,
            padx=0,
            pady=0,
            sticky=W,
            )
# ...   back to subframes
        frame_20_Table_2 = Frame(
            frame_20_Table,
            bg=colorbg,
            )
        frame_20_Table_2.grid(
            row=0,
            column=2,
            padx=0,
            pady=0,
            )
        frame_20_Table_3 = Frame(
            frame_20_Table,
            bg=colorbg,
            )
        frame_20_Table_3.grid(
            row=0,
            column=3,
            padx=0,
            pady=0,
            )
        frame_20_Table_4 = Frame(
            frame_20_Table,
            bg=colorbg,
            )
        frame_20_Table_4.grid(
            row=0,
            column=4,
            padx=0,
            pady=0,
            )
        frame_20_Table_5 = Frame(
            frame_20_Table,
            bg=colorbg,
            )
        frame_20_Table_5.grid(
            row=0,
            column=5,
            padx=0,
            pady=0,
            )
            
# ... LEGEND TITLE
        Row += 1
        frame_30_Table = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_30_Table.grid(
            row=Row,
            column=0,
            padx=2,
            pady=2,
            sticky=W,
            )
# ...       y-label defined
        Row += 1
        frame_40_Table = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_40_Table.grid(
            row=Row,
            column=0,
            padx=10,
            pady=2,
            )
            
# ... LEGEND LABELS
        Row += 1
        frame_50_Table = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_50_Table.grid(
            row=Row,
            column=0,
            padx=2,
            pady=2,
            sticky=W,
            )
        Row += 1
        frame_55_Table = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_55_Table.grid(
            row=Row,
            column=0,
            padx=10,
            pady=2,
            )
            
# ... PREVIEW LABELS
        Row += 1
        frame_60_Table = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_60_Table.grid(
            row=Row,
            column=0,
            padx=10,
            pady=5,
            )
# ... CLEAR ALL
        Row += 1
        frame_70_Table = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_70_Table.grid(
            row=Row,
            column=0,
            padx=2,
            pady=10,
            )
       
# ... frames for BUFFER frame
        refFrame = frameBuffer
# ... sub-title
        Row = 0
        frame_00_Buffer = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_00_Buffer.grid(
            row=Row,
            column=0,
            padx=2,
            pady=2,
            )
# ... x-label
        Row += 1
        frame_10_Buffer = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_10_Buffer.grid(
            row=Row,
            column=0,
            padx=2,
            pady=2,
            sticky=W,
            )
# ...       x-label defined
        Row += 1
        frame_20_Buffer = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_20_Buffer.grid(
            row=Row,
            column=0,
            padx=10,
            pady=2,
            )
# ... y-label
        Row += 1
        frame_30_Buffer = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_30_Buffer.grid(
            row=Row,
            column=0,
            padx=2,
            pady=2,
            sticky=W,
            )
# ...       y-label defined
        Row += 1
        frame_40_Buffer = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_40_Buffer.grid(
            row=Row,
            column=0,
            padx=10,
            pady=2,
            )
# ... preview labels
        Row += 1
        frame_60_Buffer = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_60_Buffer.grid(
            row=Row,
            column=0,
            padx=10,
            pady=5,
            )
# ... clear all
        Row += 1
        frame_70_Buffer = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_70_Buffer.grid(
            row=Row,
            column=0,
            padx=2,
            pady=10,
            )

      
# WIDGETS
# ... title
        label = Label(
            frame_00,
            text=(
                'KIVIAT PLOT LABELS\n' +
                'For Option 1 - All Plots in one window\n'
                ),
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=0,
            padx=2,
            pady=2,
            )
# ... plot label separator
        label = Label(
            frame_10,
            text=(
                'Plot label separator: '
                ),
            bg=colorbg,
            justify=RIGHT,
            )
        label.grid(
            row=0,
            column=0,
            padx=5,
            pady=0,
            )
        self.comboboxPlotLabelSeparator_AllGroupsPerWindow_Kiviat = Pmw.ComboBox(
            frame_10,
            scrolledlist_items=self.separatorsPlotLabelsAndLegends,
            listheight=190,
            entry_width=20,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxPlotLabelSeparator_AllGroupsPerWindow_Kiviat.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            sticky=W,
            )
        self.comboboxPlotLabelSeparator_AllGroupsPerWindow_Kiviat.selectitem(
           self.separatorsPlotLabelsAndLegends[0]
           )
           
# WIDGETS FOR TABLE DATA          
# ... sub-title for TABLE data
        label = Label(
            frame_00_Table,
            text=(
                'LABELS FOR DATA FROM CURRENT TABLE'
                ),
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
            
# ... SPOKE LABELS
        label = Label(
            frame_10_Table,
            text=(
                'SPOKE LABELS\n' +
                ' '*5 + 'Table Y-select header' +   #' (all or part)' +
                ' + user text + max value from each Y-select column'
                ),
            bg=colorbg,
            justify=LEFT,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
        self.varCheckbuttonSpokeLabelTable_AllGroupsPerWindow_Kiviat = IntVar()
        self.checkbuttonSpokeLabelTable_AllGroupsPerWindow_Kiviat = Checkbutton(
            frame_20_Table_0,
            text=' Y header',
            variable=self.varCheckbuttonSpokeLabelTable_AllGroupsPerWindow_Kiviat,
            bg=colorbg,
            relief=FLAT,
#            width=10,
#            command=???
            )
        self.checkbuttonSpokeLabelTable_AllGroupsPerWindow_Kiviat.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
        self.varCheckbuttonSpokeLabelTable_AllGroupsPerWindow_Kiviat.set(1)
        '''
         SHORTENING SPOKE LABELS OBTAINED FROM Y-SELECT HEADERS
         
 DWB Notes: 
            1. the below should be opened in another toplevel window; only parameters set in toplevel,
           no actual title parsing done until 'Preview first labels' or 'Plot' is pressed.
            2. above subtitle should read
                Table Y-select header (all or part) + ...
# radiobuttons and comboboxes to select all or part of y-header        
        self.varRadiobuttonSpokeLabelAllFirstLast_AllGroupsPerWindow_Kiviat = StringVar()
        self.varRadiobuttonSpokeLabelAllFirstLast_AllGroupsPerWindow_Kiviat.set(
            'include_all_chars'
            )
# ...   include all chars
        self.radiobuttonSpokeLabel_IncludeAllChars_AllGroupsPerWindow_Kiviat = Radiobutton(
            frame_20_Table_10,
            text='all characters',
            variable=self.varRadiobuttonSpokeLabelAllFirstLast_AllGroupsPerWindow_Kiviat,
            value='include_all_chars',
            justify=LEFT,
            bg=colorbg,
            )
        self.radiobuttonSpokeLabel_IncludeAllChars_AllGroupsPerWindow_Kiviat.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
# ...   include first chars
        self.radiobuttonSpokeLabel_IncludeFirstChars_AllGroupsPerWindow_Kiviat = Radiobutton(
            frame_20_Table_11,
            text='include first',
            variable=self.varRadiobuttonSpokeLabelAllFirstLast_AllGroupsPerWindow_Kiviat,
            value='include_first_chars',
            justify=LEFT,
            bg=colorbg,
            )
        self.radiobuttonSpokeLabel_IncludeFirstChars_AllGroupsPerWindow_Kiviat.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
        self.comboboxSpokeLabel_IncludeFirstChars_AllGroupsPerWindow_Kiviat = Pmw.ComboBox(
            frame_20_Table_11,
            scrolledlist_items=self.listSpokeLabel_IncludeFirstChars,
            entry_font=self.buttonFontSmallest,
            listheight=100,
            entry_width=5,
            dropdown=1,
            label_text=' characters',
            labelpos='e',
            label_background=colorbg,
#            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            )
        self.comboboxSpokeLabel_IncludeFirstChars_AllGroupsPerWindow_Kiviat.grid(
            row=0,
            column=1,
            padx=1,
            pady=0,
            )
# ...   include last chars
        self.radiobuttonSpokeLabel_IncludeLastChars_AllGroupsPerWindow_Kiviat = Radiobutton(
            frame_20_Table_12,
            text='include last ',
            variable=self.varRadiobuttonSpokeLabelAllFirstLast_AllGroupsPerWindow_Kiviat,
            value='include_last_chars',
            justify=LEFT,
            bg=colorbg,
            )
        self.radiobuttonSpokeLabel_IncludeLastChars_AllGroupsPerWindow_Kiviat.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
        self.comboboxSpokeLabel_IncludeLastChars_AllGroupsPerWindow_Kiviat = Pmw.ComboBox(
            frame_20_Table_12,
            scrolledlist_items=self.listSpokeLabel_IncludeLastChars,
            entry_font=self.buttonFontSmallest,
            listheight=100,
            entry_width=5,
            dropdown=1,
            label_text=' characters',
            labelpos='e',
            label_background=colorbg,
#            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            )
        self.comboboxSpokeLabel_IncludeLastChars_AllGroupsPerWindow_Kiviat.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            )
# ...   exclude first chars
        self.radiobuttonSpokeLabel_ExcludeFirstChars_AllGroupsPerWindow_Kiviat = Radiobutton(
            frame_20_Table_13,
            text='exclude first',
            variable=self.varRadiobuttonSpokeLabelAllFirstLast_AllGroupsPerWindow_Kiviat,
            value='exclude_first_chars',
            justify=LEFT,
            bg=colorbg,
            )
        self.radiobuttonSpokeLabel_ExcludeFirstChars_AllGroupsPerWindow_Kiviat.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
        self.comboboxSpokeLabel_ExcludeFirstChars_AllGroupsPerWindow_Kiviat = Pmw.ComboBox(
            frame_20_Table_13,
            scrolledlist_items=self.listSpokeLabel_ExcludeFirstChars,
            entry_font=self.buttonFontSmallest,
            listheight=100,
            entry_width=5,
            dropdown=1,
            label_text=' characters',
            labelpos='e',
            label_background=colorbg,
#            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            )
        self.comboboxSpokeLabel_ExcludeFirstChars_AllGroupsPerWindow_Kiviat.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            )
# ...   include characters upto xth occurrence of (comma+space, space, backward slash, forward slash,
#           dash, underscore, plus, asterisk, greater than, less than)
# ...   include characters past xth ....
# ...   exclude characters upto xth ...
# ...   exclude characters past xth ...
        '''
            
            
        label = Label(
            frame_20_Table_2,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
        self.entryfieldSpokeLabelTable_AllGroupsPerWindow_Kiviat = Pmw.EntryField(
            frame_20_Table_3,
            entry_width=20,
            value='',
            )
        self.entryfieldSpokeLabelTable_AllGroupsPerWindow_Kiviat.grid(
            row=0,
            column=0,
            columnspan=3,
            padx=0,
            pady=2,
            sticky=W,
            )
        self.entryfieldSpokeLabelTable_AllGroupsPerWindow_Kiviat.setvalue('')
        label = Label(
            frame_20_Table_4,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
# ...   max spoke value
        self.varCheckbuttonMaxSpokeValueTable_AllGroupsPerWindow_Kiviat = IntVar()
        self.checkbuttonMaxSpokeValueTable_AllGroupsPerWindow_Kiviat = Checkbutton(
            frame_20_Table_5,
            text=' max value from each Y-select column',
            variable=self.varCheckbuttonMaxSpokeValueTable_AllGroupsPerWindow_Kiviat,
            bg=colorbg,
            relief=FLAT,
            )
        self.checkbuttonMaxSpokeValueTable_AllGroupsPerWindow_Kiviat.grid(
            row=0,
            column=0,
            padx=0,
            pady=0
            )
        self.varCheckbuttonMaxSpokeValueTable_AllGroupsPerWindow_Kiviat.set(1)
   
# ... LEGEND TITLE
        label = Label(
            frame_30_Table,
            text=(
                'LEGEND TITLE\n' +
                ' '*5 + 'Table X-select header (all or part) + '
                'user text + number of curves in legend' 
                ),
            bg=colorbg,
            justify=LEFT,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
        self.varCheckbuttonLegendTitleTable_AllGroupsPerWindow_Kiviat = IntVar()
        self.checkbuttonLegendTitleTable_AllGroupsPerWindow_Kiviat = Checkbutton(
            frame_40_Table,
            text=' X header',
            variable=self.varCheckbuttonLegendTitleTable_AllGroupsPerWindow_Kiviat,
            bg=colorbg,
            relief=FLAT,
            )
        self.checkbuttonLegendTitleTable_AllGroupsPerWindow_Kiviat.grid(
            row=0,
            column=0,
            padx=0,
            pady=0
            )
        self.varCheckbuttonLegendTitleTable_AllGroupsPerWindow_Kiviat.set(1)
        label = Label(
            frame_40_Table,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            )        
        self.entryfieldLegendTitleTable_User_AllGroupsPerWindow_Kiviat = Pmw.EntryField(
            frame_40_Table,
            entry_width=30,
            value='',
            )
        self.entryfieldLegendTitleTable_User_AllGroupsPerWindow_Kiviat.grid(
            row=0,
            column=2,
            padx=0,
            pady=0,
            )
        self.entryfieldLegendTitleTable_User_AllGroupsPerWindow_Kiviat.setvalue('')
# ...... number of legend items listed
        label = Label(
            frame_40_Table,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=3,
            padx=0,
            pady=0,
            )
        self.varLegendIncludeNumberOfCurves_Kiviat = IntVar()
        self.checkbuttonLegendIncludeNumberOfCurves_Kiviat = Checkbutton(
            frame_40_Table,
            text='number of curves in legend',
            variable=self.varLegendIncludeNumberOfCurves_Kiviat,
            bg=colorbg,
            relief=FLAT,
            )
        self.checkbuttonLegendIncludeNumberOfCurves_Kiviat.grid(
            row=0,
            column=4,
            padx=0,
            pady=0
            )
        self.varLegendIncludeNumberOfCurves_Kiviat.set(1)

# ... LEGEND LABELS
        label = Label(
            frame_50_Table,
            text=(
                'LEGEND LABELS\n' +
                ' '*5 + 'Table X-values + ' +
                'corresponding values from any of 3 text fields + ' +
                'user text'
                ),
            bg=colorbg,
            justify=LEFT,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
        self.varCheckbuttonLegendLabelsTable_AllGroupsPerWindow_Kiviat = IntVar()
        self.checkbuttonLegendLabelsTable_AllGroupsPerWindow_Kiviat = Checkbutton(
            frame_55_Table,
            text=' X values',
            variable=self.varCheckbuttonLegendLabelsTable_AllGroupsPerWindow_Kiviat,
            bg=colorbg,
            relief=FLAT,
            )
        self.checkbuttonLegendLabelsTable_AllGroupsPerWindow_Kiviat.grid(
            row=0,
            column=0,
            padx=0,
            pady=0
            )
        self.varCheckbuttonLegendLabelsTable_AllGroupsPerWindow_Kiviat.set(1)
        label = Label(
            frame_55_Table,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            )
            
        tempListOfAllFields = []
        for number,field in enumerate(self.myDatabaseFields):
            tempListOfAllFields.append(str(number + 1) + '. ' + field)           
            
        self.comboboxLegendLabelTable_1_AllGroupsPerWindow_Kiviat = Pmw.ComboBox(
            frame_55_Table,
            scrolledlist_items=tempListOfAllFields,
            listheight=150,
            entry_width=15,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxLegendLabelTable_1_AllGroupsPerWindow_Kiviat.grid(
            row=0,
            column=2,
            padx=0,
            pady=0,
            )
        self.comboboxLegendLabelTable_1_AllGroupsPerWindow_Kiviat.setentry('')
        
        label = Label(
            frame_55_Table,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=3,
            padx=0,
            pady=0,
            )
            
        self.comboboxLegendLabelTable_2_AllGroupsPerWindow_Kiviat = Pmw.ComboBox(
            frame_55_Table,
            scrolledlist_items=tempListOfAllFields,
            listheight=150,
            entry_width=15,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxLegendLabelTable_2_AllGroupsPerWindow_Kiviat.grid(
            row=0,
            column=4,
            padx=0,
            pady=0,
            )
        self.comboboxLegendLabelTable_2_AllGroupsPerWindow_Kiviat.setentry('')
        
        label = Label(
            frame_55_Table,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=5,
            padx=0,
            pady=0,
            )
            
        self.comboboxLegendLabelTable_3_AllGroupsPerWindow_Kiviat = Pmw.ComboBox(
            frame_55_Table,
            scrolledlist_items=tempListOfAllFields,
            listheight=150,
            entry_width=15,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxLegendLabelTable_3_AllGroupsPerWindow_Kiviat.grid(
            row=0,
            column=6,
            padx=0,
            pady=0,
            )
        self.comboboxLegendLabelTable_3_AllGroupsPerWindow_Kiviat.setentry('')
        
        label = Label(
            frame_55_Table,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=1,
            column=1,
            padx=0,
            pady=0,
            )
            
        self.entryfieldLegendLabelTable_User_AllGroupsPerWindow_Kiviat = Pmw.EntryField(
            frame_55_Table,
            entry_width=30,
            value='',
            )
        self.entryfieldLegendLabelTable_User_AllGroupsPerWindow_Kiviat.grid(
            row=1,
            column=2,
            columnspan=3,
            padx=0,
            pady=2,
            sticky=W,
            )
        self.entryfieldLegendLabelTable_User_AllGroupsPerWindow_Kiviat.setvalue('')
        
# ... PREVIEW LABELS
        label = Label(
            frame_60_Table,
            text='SPOKE LABEL: ',
            bg=colorbg,
            justify=RIGHT,
            )
        label.grid(
            row=0,
            column=1,
            padx=0,
            pady=2,
            )
        self.entryfieldSpokeLabelTable_Preview_AllGroupsPerWindow_Kiviat = Pmw.EntryField(
            frame_60_Table,
            entry_width=50,
            value='',
            entry_state='normal',
# need to scroll across field, so do NOT disable
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            )
        self.entryfieldSpokeLabelTable_Preview_AllGroupsPerWindow_Kiviat.grid(
            row=0,
            column=2,
            padx=0,
            pady=2,
            ) 
        self.entryfieldSpokeLabelTable_Preview_AllGroupsPerWindow_Kiviat.setvalue('')
        label = Label(
            frame_60_Table,
            text='LEGEND TITLE: ',
            bg=colorbg,
            justify=RIGHT,
            )
        label.grid(
            row=1,
            column=1,
            padx=0,
            pady=0,
            )
        self.entryfieldLegendTitleTable_Preview_AllGroupsPerWindow_Kiviat = Pmw.EntryField(
            frame_60_Table,
            entry_width=50,
            value='',
            entry_state='normal',
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            )
        self.entryfieldLegendTitleTable_Preview_AllGroupsPerWindow_Kiviat.grid(
            row=1,
            column=2,
            padx=0,
            pady=0,
            )
        self.entryfieldLegendTitleTable_Preview_AllGroupsPerWindow_Kiviat.setvalue('')
        label = Label(
            frame_60_Table,
            text='LEGEND LABEL: ',
            bg=colorbg,
            justify=RIGHT,
            )
        label.grid(
            row=2,
            column=1,
            padx=0,
            pady=0,
            )
        self.entryfieldLegendLabelTable_Preview_AllGroupsPerWindow_Kiviat = Pmw.EntryField(
            frame_60_Table,
            entry_width=50,
            value='',
            entry_state='normal',
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            )
        self.entryfieldLegendLabelTable_Preview_AllGroupsPerWindow_Kiviat.grid(
            row=2,
            column=2,
            padx=0,
            pady=0,
            )
        self.entryfieldLegendLabelTable_Preview_AllGroupsPerWindow_Kiviat.setvalue('')            
        
        buttonShowKiviatLabelsTable_Preview_AllGroupsPerWindow_Kiviat = Button(
            frame_60_Table,
            text='Preview first labels',
            width=18,
            font=self.buttonFontSmall,
            relief=RAISED,
            borderwidth=3,
            justify=CENTER,
            command=self.handlerShowLabelsTable_Preview_AllGroupsPerWindow_Kiviat,
            )
        buttonShowKiviatLabelsTable_Preview_AllGroupsPerWindow_Kiviat.grid(
            row=0,
            column=0,
            rowspan=2,
            padx=5,
            pady=2,
            )
            
# ... clear all
        self.buttonResetAllTable_AllGroupsPerWindow_Kiviat = Button(
            frame_70_Table,
            text='Reset all',
            width=12,
            bg='white',
            fg='blue',
            font=self.buttonFontSmall,
            relief=RAISED,
            borderwidth=3,
            justify=CENTER,
            command=self.handlerResetAllTable_AllGroupsPerWindow_Kiviat,
            )
        self.buttonResetAllTable_AllGroupsPerWindow_Kiviat.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
            
# check 'Number of groups to plot from table' in 'Kiviat Plotting Specs' window;
#    if <> 0, list initial values for spoke label, legend title, legend label
        '''
        if(
        self.varNumberOfTableGroups_Kiviat.get() <> 0 
        and 
        self.varNumberOfTableGroups_Kiviat.get() <> ''
        ):
            buttonShowKiviatLabelsTable_Preview_AllGroupsPerWindow_Kiviat.invoke()
        '''
      
      
# WIDGETS FOR BUFFER DATA          
# ... sub-title for BUFFER data
        label = Label(
            frame_00_Buffer,
            text=(
                'LABELS FOR DATA FROM STORAGE BUFFER'
                ),
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
# ... x-label
        label = Label(
            frame_10_Buffer,
            text=(
                'X LABEL\n' +
                ' '*5 + 'Buffer X-header (default)' +
                ' + user text (optional)'
                ),
            bg=colorbg,
            justify=LEFT,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
# ...       x-label defined
        label = Label( 
            frame_20_Buffer,
            text=(
                'X-header (Buffer) + '
                ),
            bg=colorbg,
            justify=RIGHT,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
        self.entryfieldXUserLabel_AllGroupsPerWindow_Kiviat = Pmw.EntryField(
            frame_20_Buffer,
            entry_width=30,
            value='',
            )
        self.entryfieldXUserLabel_AllGroupsPerWindow_Kiviat.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            )
        self.entryfieldXUserLabel_AllGroupsPerWindow_Kiviat.setvalue('')

# ... y-label
        label = Label(
            frame_30_Buffer,
            text=(
                'Y LABEL\n' +
                ' '*5 + 'Buffer Y-header (default)' +
                ' + first values from 3 Buffer fields (optional)' +
                ' + user text (optional)'
                ),
            bg=colorbg,
            justify=LEFT,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )

# ...       y-label defined
        label = Label( 
            frame_40_Buffer,
            text=(
                'Y-header (Buffer)'
                ),
            bg=colorbg,
            justify=RIGHT,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
        label = Label(
            frame_40_Buffer,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            )
        self.comboboxY1Label_AllGroupsPerWindow_Kiviat = Pmw.ComboBox(
            frame_40_Buffer,
            scrolledlist_items=self.labelNamesBufferStorage,
            listheight=130,
            entry_width=15,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxY1Label_AllGroupsPerWindow_Kiviat.grid(
            row=0,
            column=2,
            padx=0,
            pady=0,
            )
        self.comboboxY1Label_AllGroupsPerWindow_Kiviat.setentry('')
        label = Label(
            frame_40_Buffer,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=3,
            padx=0,
            pady=0,
            )
        self.comboboxY2Label_AllGroupsPerWindow_Kiviat = Pmw.ComboBox(
            frame_40_Buffer,
            scrolledlist_items=self.labelNamesBufferStorage,
            listheight=130,
            entry_width=15,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxY2Label_AllGroupsPerWindow_Kiviat.grid(
            row=0,
            column=4,
            padx=0,
            pady=0,
            )
        self.comboboxY2Label_AllGroupsPerWindow_Kiviat.setentry('')
        label = Label(
            frame_40_Buffer,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=5,
            padx=0,
            pady=0,
            )
        self.comboboxY3Label_AllGroupsPerWindow_Kiviat = Pmw.ComboBox(
            frame_40_Buffer,
            scrolledlist_items=self.labelNamesBufferStorage,
            listheight=130,
            entry_width=15,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxY3Label_AllGroupsPerWindow_Kiviat.grid(
            row=0,
            column=6,
            padx=0,
            pady=0,
            )
        self.comboboxY3Label_AllGroupsPerWindow_Kiviat.setentry('')
        label = Label(
            frame_40_Buffer,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=1,
            column=1,
            padx=0,
            pady=0,
            )
        self.entryfieldYUserLabel_AllGroupsPerWindow_Kiviat = Pmw.EntryField(
            frame_40_Buffer,
            entry_width=30,
            value='',
            )
        self.entryfieldYUserLabel_AllGroupsPerWindow_Kiviat.grid(
            row=1,
            column=2,
            columnspan=3,
            padx=0,
            pady=2,
            sticky=W,
            )
        self.entryfieldYUserLabel_AllGroupsPerWindow_Kiviat.setvalue('')

# ... show labels
# ...       show labels widgets
        label = Label(
            frame_60_Buffer,
            text='X LABEL: ',
            bg=colorbg,
            justify=RIGHT,
            )
        label.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            )
        self.entryfieldXLabelShowBuffer_AllGroupsPerWindow_Kiviat = Pmw.EntryField(
            frame_60_Buffer,
            entry_width=50,
            value='',
            entry_state='normal',
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            )
        self.entryfieldXLabelShowBuffer_AllGroupsPerWindow_Kiviat.grid(
            row=0,
            column=2,
            padx=0,
            pady=0,
            )
        self.entryfieldXLabelShowBuffer_AllGroupsPerWindow_Kiviat.setvalue('')
        label = Label(
            frame_60_Buffer,
            text='Y LABEL: ',
            bg=colorbg,
            justify=RIGHT,
            )
        label.grid(
            row=1,
            column=1,
            padx=0,
            pady=2,
            )
        self.entryfieldYLabelShowBuffer_AllGroupsPerWindow_Kiviat = Pmw.EntryField(
            frame_60_Buffer,
            entry_width=50,
            value='',
            entry_state='normal',
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            )
        self.entryfieldYLabelShowBuffer_AllGroupsPerWindow_Kiviat.grid(
            row=1,
            column=2,
            padx=0,
            pady=2,
            ) 
        self.entryfieldYLabelShowBuffer_AllGroupsPerWindow_Kiviat.setvalue('')
        buttonShowKiviatLabelsBuffer = Button(
            frame_60_Buffer,
            text='Preview first labels',
            width=18,
            font=self.buttonFontSmall,
            relief=RAISED,
            borderwidth=3,
            justify=CENTER,
            command=self.handlerShowLabelsBuffer_Preview_AllGroupsPerWindow_Kiviat,
            )
        buttonShowKiviatLabelsBuffer.grid(
#            row=2,
#            column=1,
            row=0,
            column=0,
            rowspan=2,
            padx=5,
            pady=2,
            )
# ... reset all
        self.buttonResetAll_AllGroupsPerWindow_Kiviat = Button(
            frame_70_Buffer,
            text='Reset all',
            width=12,
            bg='white',
            fg='blue',
            font=self.buttonFontSmall,
            relief=RAISED,
            borderwidth=3,
            justify=CENTER,
            command=self.handlerResetAllBuffer_AllGroupsPerWindow_Kiviat,
            )
        self.buttonResetAll_AllGroupsPerWindow_Kiviat.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
            
# call 'Preview' handlers to show default labels
        self.handlerShowLabelsTable_Preview_NoErrMsg_AllGroupsPerWindow_Kiviat()
#        self.handlerShowLabelsBuffer_Preview_NoErrMsg_AllGroupsPerWindow_Kiviat()

        return
        

    def labels_OneGroupPerWindow_Kiviat(self,xwin,ywin):
        '''
         Purpose:
            Generate labels for group 2 'One Group Per Plot Per Window' mode
            
         Plot label separators:
            '  (space)',
            '\ (back slash)',
            '/ (forward slash)',
            ', (comma+space)',
            '- (dash)',
            '_ (underscore)',
            '+ (plus)',
            '* (asterisk)',
            '> (greater than)',
            '< (less than)'
         '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'labels_OneGroupPerWindow_Kiviat')        
 
        colorbg='lightgreen'  
        
# define toplevel
        self.toplevelLabels_OneGroupPerWindow_Kiviat = Toplevel(
            self.toplevelKiviatPlotPreprocess,
            bg=colorbg,
            )
        self.toplevelLabels_OneGroupPerWindow_Kiviat.title(
            'KIVIAT PLOT LABELS - ONE GROUP PER PLOT PER WINDOW'
            )
        self.toplevelLabels_OneGroupPerWindow_Kiviat.transient(
            self.toplevelKiviatPlotPreprocess
            )
# place the top window
        x_Windows=xwin
        y_Windows=ywin
        self.toplevelLabels_OneGroupPerWindow_Kiviat.geometry(
            '+%d+%d' % (x_Windows, y_Windows)
            )
            
# determine list of text fields in current table
        listOfTextFields = []
        for row in range(len(self.tableStructure)):
#            fieldType = self.tableStructure[row][1]
            myField, myDatatype, myNull, myKey, myDefault, myExtra = \
                self.tableStructure[row]
            varfirst2 = myDatatype[0:2]
# check if text
            fieldNameIsText = self.checkIsFieldText(varfirst2)
            if fieldNameIsText:
                listOfTextFields.append(myField)  
           
# FRAMES 
# ... title
        Row = 0
        frame_00 = Frame(
            self.toplevelLabels_OneGroupPerWindow_Kiviat,
            bg=colorbg,
            )
        frame_00.grid(
            row=Row,
            column=0,
            padx=2,
            pady=2,
            )
# ... plot label separator
        Row += 1
        frame_10 = Frame(
            self.toplevelLabels_OneGroupPerWindow_Kiviat,
            bg=colorbg,
            )
        frame_10.grid(
            row=Row,
            column=0,
            padx=2,
            pady=2,
            )
# ... frame for TABLE data
        Row += 1
        frameTable = Frame(
            self.toplevelLabels_OneGroupPerWindow_Kiviat,
            bg=colorbg,
            relief=RIDGE,
            borderwidth=2,
            )
        frameTable.grid(
            row=Row,
            column=0,
            padx=2,
            pady=5,
            )
# ... frame for Buffer data
        Row += 1
        frameBuffer = Frame(
            self.toplevelLabels_OneGroupPerWindow_Kiviat,
            bg=colorbg,
            relief=RIDGE,
            borderwidth=2,
            )
        frameBuffer.grid(
            row=Row,
            column=0,
            padx=2,
            pady=5
            )
         
# frames for TABLE frame     
        refFrame = frameTable
# ... sub-title
        Row = 0
        frame_00_Table = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_00_Table.grid(
            row=Row,
            column=0,
            padx=2,
            pady=2,
            )
# ... x-label
        Row += 1
        frame_10_Table = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_10_Table.grid(
            row=Row,
            column=0,
            padx=2,
            pady=2,
            sticky=W,
            )
# ...       x-label defined
        Row += 1
        frame_20_Table = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_20_Table.grid(
            row=Row,
            column=0,
            padx=10,
            pady=2,
            )
# ... y-label
        Row += 1
        frame_30_Table = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_30_Table.grid(
            row=Row,
            column=0,
            padx=2,
            pady=2,
            sticky=W,
            )
# ...       y-label defined
        Row += 1
        frame_40_Table = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_40_Table.grid(
            row=Row,
            column=0,
            padx=10,
            pady=2,
            )
# ... show labels
# ...       show labels widgets
        Row += 1
        frame_60_Table = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_60_Table.grid(
            row=Row,
            column=0,
            padx=10,
            pady=5,
            )
# ... reset all
        Row += 1
        frame_70_Table = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_70_Table.grid(
            row=Row,
            column=0,
            padx=2,
            pady=10,
            )
        
# ... frames for BUFFER frame
        refFrame = frameBuffer
# ... sub-title
        Row = 0
        frame_00_Buffer = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_00_Buffer.grid(
            row=Row,
            column=0,
            padx=2,
            pady=2,
            )
# ... x-label
        Row += 1
        frame_10_Buffer = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_10_Buffer.grid(
            row=Row,
            column=0,
            padx=2,
            pady=2,
            sticky=W,
            )
# ...       x-label defined
        Row += 1
        frame_20_Buffer = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_20_Buffer.grid(
            row=Row,
            column=0,
            padx=10,
            pady=2,
            )
# ... y-label
        Row += 1
        frame_30_Buffer = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_30_Buffer.grid(
            row=Row,
            column=0,
            padx=2,
            pady=2,
            sticky=W,
            )
# ...       y-label defined
        Row += 1
        frame_40_Buffer = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_40_Buffer.grid(
            row=Row,
            column=0,
            padx=10,
            pady=2,
            )
# ... show labels
# ...       show labels widgets
        Row += 1
        frame_60_Buffer = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_60_Buffer.grid(
            row=Row,
            column=0,
            padx=10,
            pady=5,
            )
# ... reset all
        Row += 1
        frame_70_Buffer = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_70_Buffer.grid(
            row=Row,
            column=0,
            padx=2,
            pady=10,
            )

      
# WIDGETS
# ... title
        label = Label(
            frame_00,
            text=(
                'KIVIAT PLOT LABELS\n' +
                'Option 2 - One Plot Per Window\n'
                ),
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=0,
            padx=2,
            pady=2,
            )
# ... plot label separator
        label = Label(
            frame_10,
            text=(
                'Plot label separator: '
                ),
            bg=colorbg,
            justify=RIGHT,
            )
        label.grid(
            row=0,
            column=0,
            padx=5,
            pady=0,
            )
        self.comboboxPlotLabelSeparator_OneGroupPerWindow_Kiviat = Pmw.ComboBox(
            frame_10,
            scrolledlist_items=self.separatorsPlotLabelsAndLegends,
            listheight=190,
            entry_width=20,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxPlotLabelSeparator_OneGroupPerWindow_Kiviat.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            sticky=W,
            )
        self.comboboxPlotLabelSeparator_OneGroupPerWindow_Kiviat.selectitem(
           self.separatorsPlotLabelsAndLegends[0]
           )
           
# WIDGETS FOR TABLE DATA          
# ... sub-title for TABLE data
        label = Label(
            frame_00_Table,
            text=(
                'LABELS FOR DATA FROM CURRENT TABLE'
                ),
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
# ... x-label
        label = Label(
            frame_10_Table,
            text=(
                'X LABEL\n' +
                ' '*5 + 'Table X-header (default)' +
                ' + user text (optional)'
                ),
            bg=colorbg,
            justify=LEFT,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
# ...       x-label defined
        label = Label( 
            frame_20_Table,
            text=(
                'X-header (Table) + '
                ),
            bg=colorbg,
            justify=RIGHT,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
        self.entryfieldXUserLabelSingleGroupPerPlotTable_OneGroupPerWindow_Kiviat = Pmw.EntryField(
            frame_20_Table,
            entry_width=30,
            value='',
            )
        self.entryfieldXUserLabelSingleGroupPerPlotTable_OneGroupPerWindow_Kiviat.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            )
        self.entryfieldXUserLabelSingleGroupPerPlotTable_OneGroupPerWindow_Kiviat.setvalue('')

# ... y-label
        label = Label(
            frame_30_Table,
            text=(
                'Y LABEL\n' +
                ' '*5 + 'Table Y-header (default)' +
                ' + first values from 3 text fields (optional)' +
                ' + user text (optional)'
                ),
            bg=colorbg,
            justify=LEFT,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )

# ...       y-label defined
        label = Label( 
            frame_40_Table,
            text=(
                'Y-header (Table)'
                ),
            bg=colorbg,
            justify=RIGHT,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
        label = Label(
            frame_40_Table,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            )
            
        tempListOfAllFields = []
        for number,field in enumerate(self.myDatabaseFields):
            tempListOfAllFields.append(str(number + 1) + '. ' + field)
            
        self.comboboxY1LabelSingleGroupPerPlotTable_OneGroupPerWindow_Kiviat = Pmw.ComboBox(
            frame_40_Table,
            scrolledlist_items=tempListOfAllFields,
            listheight=150,
            entry_width=15,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxY1LabelSingleGroupPerPlotTable_OneGroupPerWindow_Kiviat.grid(
            row=0,
            column=2,
            padx=0,
            pady=0,
            )
        self.comboboxY1LabelSingleGroupPerPlotTable_OneGroupPerWindow_Kiviat.setentry('')
        label = Label(
            frame_40_Table,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=3,
            padx=0,
            pady=0,
            )
        self.comboboxY2LabelSingleGroupPerPlotTable_OneGroupPerWindow_Kiviat = Pmw.ComboBox(
            frame_40_Table,
            scrolledlist_items=tempListOfAllFields,
            listheight=150,
            entry_width=15,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxY2LabelSingleGroupPerPlotTable_OneGroupPerWindow_Kiviat.grid(
            row=0,
            column=4,
            padx=0,
            pady=0,
            )
        self.comboboxY2LabelSingleGroupPerPlotTable_OneGroupPerWindow_Kiviat.setentry('')
        label = Label(
            frame_40_Table,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=5,
            padx=0,
            pady=0,
            )
        self.comboboxY3LabelSingleGroupPerPlotTable_OneGroupPerWindow_Kiviat = Pmw.ComboBox(
            frame_40_Table,
            scrolledlist_items=tempListOfAllFields,
            listheight=150,
            entry_width=15,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxY3LabelSingleGroupPerPlotTable_OneGroupPerWindow_Kiviat.grid(
            row=0,
            column=6,
            padx=0,
            pady=0,
            )
        self.comboboxY3LabelSingleGroupPerPlotTable_OneGroupPerWindow_Kiviat.setentry('')
        label = Label(
            frame_40_Table,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=1,
            column=1,
            padx=0,
            pady=0,
            )
        self.entryfieldYUserLabelSingleGroupPerPlotTable_OneGroupPerWindow_Kiviat = Pmw.EntryField(
            frame_40_Table,
            entry_width=30,
            value='',
            )
        self.entryfieldYUserLabelSingleGroupPerPlotTable_OneGroupPerWindow_Kiviat.grid(
            row=1,
            column=2,
            columnspan=3,
            padx=0,
            pady=2,
            sticky=W,
            )
        self.entryfieldYUserLabelSingleGroupPerPlotTable_OneGroupPerWindow_Kiviat.setvalue('')
        
# ...       show labels widgets
        label = Label(
            frame_60_Table,
            text='X LABEL: ',
            bg=colorbg,
            justify=RIGHT,
            )
        label.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            )
        self.entryfieldXLabelShowTableSingleGroup_OneGroupPerWindow_Kiviat = Pmw.EntryField(
            frame_60_Table,
            entry_width=50,
            value='',
            entry_state='normal',
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            )
        self.entryfieldXLabelShowTableSingleGroup_OneGroupPerWindow_Kiviat.grid(
            row=0,
            column=2,
            padx=0,
            pady=0,
            )
        self.entryfieldXLabelShowTableSingleGroup_OneGroupPerWindow_Kiviat.setvalue('')
        label = Label(
            frame_60_Table,
            text='Y LABEL: ',
            bg=colorbg,
            justify=RIGHT,
            )
        label.grid(
            row=1,
            column=1,
            padx=0,
            pady=2,
            )
        self.entryfieldYLabelShowTableSingleGroup_OneGroupPerWindow_Kiviat = Pmw.EntryField(
            frame_60_Table,
            entry_width=50,
            value='',
            entry_state='normal',
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            )
        self.entryfieldYLabelShowTableSingleGroup_OneGroupPerWindow_Kiviat.grid(
            row=1,
            column=2,
            padx=0,
            pady=2,
            ) 
        self.entryfieldYLabelShowTableSingleGroup_OneGroupPerWindow_Kiviat.setvalue('')
        buttonShowKiviatLabelsTable_OneGroupPerWindow_Kiviat = Button(
            frame_60_Table,
            text='Preview first labels',
            width=18,
            font=self.buttonFontSmall,
            relief=RAISED,
            borderwidth=3,
            justify=CENTER,
            command=self.handlerShowLabelsTable_Preview_OneGroupPerWindow_Kiviat,
            )
        buttonShowKiviatLabelsTable_OneGroupPerWindow_Kiviat.grid(
            row=0,
            column=0,
            rowspan=2,
            padx=5,
            pady=2,
            )
# ... reset all
        self.buttonResetAllTable_OneGroupPerWindow_Kiviat = Button(
            frame_70_Table,
            text='Clear all',
            width=12,
            bg='white',
            fg='blue',
            font=self.buttonFontSmall,
            relief=RAISED,
            borderwidth=3,
            justify=CENTER,
            command=self.handlerResetAllTable_OneGroupPerWindow_Kiviat,
            )
        self.buttonResetAllTable_OneGroupPerWindow_Kiviat.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
            
# WIDGETS FOR BUFFER DATA          
# ... sub-title for BUFFER data
        label = Label(
            frame_00_Buffer,
            text=(
                'LABELS FOR DATA FROM STORAGE BUFFER'
                ),
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
# ... x-label
        label = Label(
            frame_10_Buffer,
            text=(
                'X LABEL\n' +
                ' '*5 + 'Buffer X-header (default)' +
                ' + user text (optional)'
                ),
            bg=colorbg,
            justify=LEFT,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
# ...       x-label defined
        label = Label( 
            frame_20_Buffer,
            text=(
                'X-header (Buffer) + '
                ),
            bg=colorbg,
            justify=RIGHT,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
        self.entryfieldXUserLabelSingleGroupPerPlotBuffer_OneGroupPerWindow_Kiviat = Pmw.EntryField(
            frame_20_Buffer,
            entry_width=30,
            value='',
            )
        self.entryfieldXUserLabelSingleGroupPerPlotBuffer_OneGroupPerWindow_Kiviat.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            )
        self.entryfieldXUserLabelSingleGroupPerPlotBuffer_OneGroupPerWindow_Kiviat.setvalue('')

# ... y-label
        label = Label(
            frame_30_Buffer,
            text=(
                'Y LABEL\n' +
                ' '*5 + 'Buffer Y-header (default)' +
                ' + first values from 3 Buffer fields (optional)' +
                ' + user text (optional)'
                ),
            bg=colorbg,
            justify=LEFT,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )

# ...       y-label defined
        label = Label( 
            frame_40_Buffer,
            text=(
                'Y-header (Buffer)'
                ),
            bg=colorbg,
            justify=RIGHT,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
        label = Label(
            frame_40_Buffer,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            )
        self.comboboxY1LabelSingleGroupPerPlotBuffer_OneGroupPerWindow_Kiviat = Pmw.ComboBox(
            frame_40_Buffer,
            scrolledlist_items=self.labelNamesBufferStorage,
            listheight=130,
            entry_width=15,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxY1LabelSingleGroupPerPlotBuffer_OneGroupPerWindow_Kiviat.grid(
            row=0,
            column=2,
            padx=0,
            pady=0,
            )
        self.comboboxY1LabelSingleGroupPerPlotBuffer_OneGroupPerWindow_Kiviat.setentry('')
        label = Label(
            frame_40_Buffer,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=3,
            padx=0,
            pady=0,
            )
        self.comboboxY2LabelSingleGroupPerPlotBuffer_OneGroupPerWindow_Kiviat = Pmw.ComboBox(
            frame_40_Buffer,
            scrolledlist_items=self.labelNamesBufferStorage,
            listheight=130,
            entry_width=15,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxY2LabelSingleGroupPerPlotBuffer_OneGroupPerWindow_Kiviat.grid(
            row=0,
            column=4,
            padx=0,
            pady=0,
            )
        self.comboboxY2LabelSingleGroupPerPlotBuffer_OneGroupPerWindow_Kiviat.setentry('')
        label = Label(
            frame_40_Buffer,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=5,
            padx=0,
            pady=0,
            )
        self.comboboxY3LabelSingleGroupPerPlotBuffer_OneGroupPerWindow_Kiviat = Pmw.ComboBox(
            frame_40_Buffer,
            scrolledlist_items=self.labelNamesBufferStorage,
            listheight=130,
            entry_width=15,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxY3LabelSingleGroupPerPlotBuffer_OneGroupPerWindow_Kiviat.grid(
            row=0,
            column=6,
            padx=0,
            pady=0,
            )
        self.comboboxY3LabelSingleGroupPerPlotBuffer_OneGroupPerWindow_Kiviat.setentry('')
        label = Label(
            frame_40_Buffer,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=1,
            column=1,
            padx=0,
            pady=0,
            )
        self.entryfieldYUserLabelSingleGroupPerPlotBuffer_OneGroupPerWindow_Kiviat = Pmw.EntryField(
            frame_40_Buffer,
            entry_width=30,
            value='',
            )
        self.entryfieldYUserLabelSingleGroupPerPlotBuffer_OneGroupPerWindow_Kiviat.grid(
            row=1,
            column=2,
            columnspan=3,
            padx=0,
            pady=2,
            sticky=W,
            )
        self.entryfieldYUserLabelSingleGroupPerPlotBuffer_OneGroupPerWindow_Kiviat.setvalue('')

# ... show labels
# ...       show labels widgets
        label = Label(
            frame_60_Buffer,
            text='X LABEL: ',
            bg=colorbg,
            justify=RIGHT,
            )
        label.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            )
        self.entryfieldXLabelShowBuffer_OneGroupPerWindow_Kiviat = Pmw.EntryField(
            frame_60_Buffer,
            entry_width=50,
            value='',
            entry_state='normal',
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            )
        self.entryfieldXLabelShowBuffer_OneGroupPerWindow_Kiviat.grid(
            row=0,
            column=2,
            padx=0,
            pady=0,
            )
        self.entryfieldXLabelShowBuffer_OneGroupPerWindow_Kiviat.setvalue('')
        label = Label(
            frame_60_Buffer,
            text='Y LABEL: ',
            bg=colorbg,
            justify=RIGHT,
            )
        label.grid(
            row=1,
            column=1,
            padx=0,
            pady=2,
            )
        self.entryfieldYLabelShowBuffer_OneGroupPerWindow_Kiviat = Pmw.EntryField(
            frame_60_Buffer,
            entry_width=50,
            value='',
            entry_state='normal',
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            )
        self.entryfieldYLabelShowBuffer_OneGroupPerWindow_Kiviat.grid(
            row=1,
            column=2,
            padx=0,
            pady=2,
            ) 
        self.entryfieldYLabelShowBuffer_OneGroupPerWindow_Kiviat.setvalue('')
        buttonShowKiviatLabelsBuffer = Button(
            frame_60_Buffer,
            text='Preview first labels',
            width=18,
            font=self.buttonFontSmall,
            relief=RAISED,
            borderwidth=3,
            justify=CENTER,
            command=self.handlerShowLabelsBuffer_Preview_OneGroupPerWindow_Kiviat,
            )
        buttonShowKiviatLabelsBuffer.grid(
#            row=2,
#            column=1,
            row=0,
            column=0,
            rowspan=2,
            padx=5,
            pady=2,
            )
# ... reset all
        self.buttonResetAllBuffer_OneGroupPerWindow_Kiviat = Button(
            frame_70_Buffer,
            text='Clear all',
            width=12,
            bg='white',
            fg='blue',
            font=self.buttonFontSmall,
            relief=RAISED,
            borderwidth=3,
            justify=CENTER,
            command=self.handlerResetAllBuffer_OneGroupPerWindow_Kiviat,
            )
        self.buttonResetAllBuffer_OneGroupPerWindow_Kiviat.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
            
# call 'Preview' handlers to show default labels
        self.handlerShowLabelsTable_Preview_NoErrMsg_OneGroupPerWindow_Kiviat()
        self.handlerShowLabelsBuffer_Preview_NoErrMsg_OneGroupPerWindow_Kiviat()

        return
        
        
    def labels_OneCurvePerPlot_Kiviat(self,xwin,ywin):
        '''
         Purpose:
            generate labels for group 3 'one curve per plot'
         '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'labels_OneCurvePerPlot_Kiviat')
        
        colorbg='lightgreen' 
        
# define toplevel
        self.toplevelLabels_OneCurvePerPlot_Kiviat = Toplevel(
            self.toplevelKiviatPlotPreprocess,
            bg=colorbg,
            )
        self.toplevelLabels_OneCurvePerPlot_Kiviat.title(
            'KIVIAT PLOT LABELS - ONE CURVE PER PLOT'
            )
        self.toplevelLabels_OneCurvePerPlot_Kiviat.transient(self.toplevelKiviatPlotPreprocess)
# place the top window
        x_Windows=xwin
        y_Windows=ywin
        self.toplevelLabels_OneCurvePerPlot_Kiviat.geometry(
            '+%d+%d' % (x_Windows, y_Windows)
            )
            
# determine list of text fields in current table
        listOfTextFields = []
        for row in range(len(self.tableStructure)):
#            fieldType = self.tableStructure[row][1]
            myField, myDatatype, myNull, myKey, myDefault, myExtra = \
                self.tableStructure[row]
            varfirst2 = myDatatype[0:2]
# check if text
            fieldNameIsText = self.checkIsFieldText(varfirst2)
            if fieldNameIsText:
                listOfTextFields.append(myField)  

            
# FRAMES 
# ... title
        Row = 0
        frame_00 = Frame(
            self.toplevelLabels_OneCurvePerPlot_Kiviat,
            bg=colorbg,
            )
        frame_00.grid(
            row=Row,
            column=0,
            padx=2,
            pady=2,
            )
# ... plot label separator
        Row += 1
        frame_10 = Frame(
            self.toplevelLabels_OneCurvePerPlot_Kiviat,
            bg=colorbg,
            )
        frame_10.grid(
            row=Row,
            column=0,
            padx=2,
            pady=2,
            )
# ... frame for TABLE data
        Row += 1
        frameTable = Frame(
            self.toplevelLabels_OneCurvePerPlot_Kiviat,
            bg=colorbg,
            relief=RIDGE,
            borderwidth=2,
            )
        frameTable.grid(
            row=Row,
            column=0,
            padx=2,
            pady=5,
            )
# ... frame for Buffer data
        Row += 1
        frameBuffer = Frame(
            self.toplevelLabels_OneCurvePerPlot_Kiviat,
            bg=colorbg,
            relief=RIDGE,
            borderwidth=2,
            )
        frameBuffer.grid(
            row=Row,
            column=0,
            padx=2,
            pady=5
            )
         
# frames for TABLE frame     
        refFrame = frameTable
# ... sub-title
        Row = 0
        frame_00_Table = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_00_Table.grid(
            row=Row,
            column=0,
            padx=2,
            pady=2,
            )
# ... x-label
        Row += 1
        frame_10_Table = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_10_Table.grid(
            row=Row,
            column=0,
            padx=2,
            pady=2,
            sticky=W,
            )
# ...       x-label defined
        Row += 1
        frame_20_Table = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_20_Table.grid(
            row=Row,
            column=0,
            padx=10,
            pady=2,
            )
# ... y-label
        Row += 1
        frame_30_Table = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_30_Table.grid(
            row=Row,
            column=0,
            padx=2,
            pady=2,
            sticky=W,
            )
# ...       y-label defined
        Row += 1
        frame_40_Table = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_40_Table.grid(
            row=Row,
            column=0,
            padx=10,
            pady=2,
            )
# ... show labels
# ...       show labels widgets
        Row += 1
        frame_60_Table = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_60_Table.grid(
            row=Row,
            column=0,
            padx=10,
            pady=5,
            )
# ... reset all
        Row += 1
        frame_70_Table = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_70_Table.grid(
            row=Row,
            column=0,
            padx=2,
            pady=10,
            )
        
# ... frames for BUFFER frame
        refFrame = frameBuffer
# ... sub-title
        Row = 0
        frame_00_Buffer = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_00_Buffer.grid(
            row=Row,
            column=0,
            padx=2,
            pady=2,
            )
# ... x-label
        Row += 1
        frame_10_Buffer = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_10_Buffer.grid(
            row=Row,
            column=0,
            padx=2,
            pady=2,
            sticky=W,
            )
# ...       x-label defined
        Row += 1
        frame_20_Buffer = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_20_Buffer.grid(
            row=Row,
            column=0,
            padx=10,
            pady=2,
            )
# ... y-label
        Row += 1
        frame_30_Buffer = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_30_Buffer.grid(
            row=Row,
            column=0,
            padx=2,
            pady=2,
            sticky=W,
            )
# ...       y-label defined
        Row += 1
        frame_40_Buffer = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_40_Buffer.grid(
            row=Row,
            column=0,
            padx=10,
            pady=2,
            )
# ... show labels
# ...       show labels widgets
        Row += 1
        frame_60_Buffer = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_60_Buffer.grid(
            row=Row,
            column=0,
            padx=10,
            pady=5,
            )
# ... reset all
        Row += 1
        frame_70_Buffer = Frame(
            refFrame,
            bg=colorbg,
            )
        frame_70_Buffer.grid(
            row=Row,
            column=0,
            padx=2,
            pady=10,
            )

      
# WIDGETS
# ... title
        label = Label(
            frame_00,
            text=(
                'KIVIAT PLOT LABELS\n' +
                'Option 3 - One Curve Per Plot\n'
                ),
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=0,
            padx=2,
            pady=2,
            )
# ... plot label separator
        label = Label(
            frame_10,
            text=(
                'Plot label separator: '
                ),
            bg=colorbg,
            justify=RIGHT,
            )
        label.grid(
            row=0,
            column=0,
            padx=5,
            pady=0,
            )
        self.comboboxPlotLabelSeparator_OneCurvePerPlot_Kiviat = Pmw.ComboBox(
            frame_10,
            scrolledlist_items=self.separatorsPlotLabelsAndLegends,
            listheight=190,
            entry_width=20,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxPlotLabelSeparator_OneCurvePerPlot_Kiviat.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            sticky=W,
            )
        self.comboboxPlotLabelSeparator_OneCurvePerPlot_Kiviat.selectitem(
           self.separatorsPlotLabelsAndLegends[0]
           )
           
# WIDGETS FOR TABLE DATA          
# ... sub-title for TABLE data
        label = Label(
            frame_00_Table,
            text=(
                'LABELS FOR DATA FROM CURRENT TABLE'
                ),
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
# ... x-label
        label = Label(
            frame_10_Table,
            text=(
                'X LABEL\n' +
                ' '*5 + 'Table X-header (default)' +
                ' + user text (optional)'
                ),
            bg=colorbg,
            justify=LEFT,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
# ...       x-label defined
        label = Label( 
            frame_20_Table,
            text=(
                'X-header (Table) + '
                ),
            bg=colorbg,
            justify=RIGHT,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
        self.entryfieldXUserLabelSingleGroupPerPlotTable_OneCurvePerPlot_Kiviat = Pmw.EntryField(
            frame_20_Table,
            entry_width=30,
            value='',
            )
        self.entryfieldXUserLabelSingleGroupPerPlotTable_OneCurvePerPlot_Kiviat.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            )
        self.entryfieldXUserLabelSingleGroupPerPlotTable_OneCurvePerPlot_Kiviat.setvalue('')

# ... y-label
        label = Label(
            frame_30_Table,
            text=(
                'Y LABEL\n' +
                ' '*5 + 'Table Y-header (default)' +
                ' + first values from 3 text fields (optional)' +
                ' + user text (optional)'
                ),
            bg=colorbg,
            justify=LEFT,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )

# ...       y-label defined
        label = Label( 
            frame_40_Table,
            text=(
                'Y-header (Table)'
                ),
            bg=colorbg,
            justify=RIGHT,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
        label = Label(
            frame_40_Table,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            )
            
        tempListOfAllFields = []
        for number,field in enumerate(self.myDatabaseFields):
            tempListOfAllFields.append(str(number + 1) + '. ' + field)
            
        self.comboboxY1LabelSingleGroupPerPlotTable_OneCurvePerPlot_Kiviat = Pmw.ComboBox(
            frame_40_Table,
            scrolledlist_items=tempListOfAllFields,
            listheight=150,
            entry_width=15,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxY1LabelSingleGroupPerPlotTable_OneCurvePerPlot_Kiviat.grid(
            row=0,
            column=2,
            padx=0,
            pady=0,
            )
        self.comboboxY1LabelSingleGroupPerPlotTable_OneCurvePerPlot_Kiviat.setentry('')
        
        label = Label(
            frame_40_Table,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=3,
            padx=0,
            pady=0,
            )
            
        self.comboboxY2LabelSingleGroupPerPlotTable_OneCurvePerPlot_Kiviat = Pmw.ComboBox(
            frame_40_Table,
            scrolledlist_items=tempListOfAllFields,
            listheight=150,
            entry_width=15,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxY2LabelSingleGroupPerPlotTable_OneCurvePerPlot_Kiviat.grid(
            row=0,
            column=4,
            padx=0,
            pady=0,
            )
        self.comboboxY2LabelSingleGroupPerPlotTable_OneCurvePerPlot_Kiviat.setentry('')
        
        label = Label(
            frame_40_Table,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=5,
            padx=0,
            pady=0,
            )
            
        self.comboboxY3LabelSingleGroupPerPlotTable_OneCurvePerPlot_Kiviat = Pmw.ComboBox(
            frame_40_Table,
            scrolledlist_items=tempListOfAllFields,
            listheight=150,
            entry_width=15,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxY3LabelSingleGroupPerPlotTable_OneCurvePerPlot_Kiviat.grid(
            row=0,
            column=6,
            padx=0,
            pady=0,
            )
        self.comboboxY3LabelSingleGroupPerPlotTable_OneCurvePerPlot_Kiviat.setentry('')
        
        label = Label(
            frame_40_Table,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=1,
            column=1,
            padx=0,
            pady=0,
            )
            
        self.entryfieldYUserLabelSingleGroupPerPlotTable_OneCurvePerPlot_Kiviat = Pmw.EntryField(
            frame_40_Table,
            entry_width=30,
            value='',
            )
        self.entryfieldYUserLabelSingleGroupPerPlotTable_OneCurvePerPlot_Kiviat.grid(
            row=1,
            column=2,
            columnspan=3,
            padx=0,
            pady=2,
            sticky=W,
            )
        self.entryfieldYUserLabelSingleGroupPerPlotTable_OneCurvePerPlot_Kiviat.setvalue('')
        
# ...       show labels widgets
        label = Label(
            frame_60_Table,
            text='X LABEL: ',
            bg=colorbg,
            justify=RIGHT,
            )
        label.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            )
        self.entryfieldXLabelShowTableSingleGroup_OneCurvePerPlot_Kiviat = Pmw.EntryField(
            frame_60_Table,
            entry_width=50,
            value='',
            entry_state='normal',
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            )
        self.entryfieldXLabelShowTableSingleGroup_OneCurvePerPlot_Kiviat.grid(
            row=0,
            column=2,
            padx=0,
            pady=0,
            )
        self.entryfieldXLabelShowTableSingleGroup_OneCurvePerPlot_Kiviat.setvalue('')
        label = Label(
            frame_60_Table,
            text='Y LABEL: ',
            bg=colorbg,
            justify=RIGHT,
            )
        label.grid(
            row=1,
            column=1,
            padx=0,
            pady=2,
            )
        self.entryfieldYLabelShowTableSingleGroup_OneCurvePerPlot_Kiviat = Pmw.EntryField(
            frame_60_Table,
            entry_width=50,
            value='',
            entry_state='normal',
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            )
        self.entryfieldYLabelShowTableSingleGroup_OneCurvePerPlot_Kiviat.grid(
            row=1,
            column=2,
            padx=0,
            pady=2,
            ) 
        self.entryfieldYLabelShowTableSingleGroup_OneCurvePerPlot_Kiviat.setvalue('')
        buttonShowKiviatLabelsTable_OneCurvePerPlot_Kiviat = Button(
            frame_60_Table,
            text='Preview first labels',
            width=18,
            font=self.buttonFontSmall,
            relief=RAISED,
            borderwidth=3,
            justify=CENTER,
            command=self.handlerShowLabelsTable_Preview_OneCurvePerPlot_Kiviat,
            )
        buttonShowKiviatLabelsTable_OneCurvePerPlot_Kiviat.grid(
            row=0,
            column=0,
            rowspan=2,
            padx=5,
            pady=2,
            )
# ... reset all
        self.buttonResetAllTable_OneCurvePerPlot_Kiviat = Button(
            frame_70_Table,
            text='Clear all',
            width=12,
            bg='white',
            fg='blue',
            font=self.buttonFontSmall,
            relief=RAISED,
            borderwidth=3,
            justify=CENTER,
            command=self.handlerResetAllTable_OneCurvePerPlot_Kiviat,
            )
        self.buttonResetAllTable_OneCurvePerPlot_Kiviat.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
            
# WIDGETS FOR BUFFER DATA          
# ... sub-title for BUFFER data
        label = Label(
            frame_00_Buffer,
            text=(
                'LABELS FOR DATA FROM STORAGE BUFFER'
                ),
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
# ... x-label
        label = Label(
            frame_10_Buffer,
            text=(
                'X LABEL\n' +
                ' '*5 + 'Buffer X-header (default)' +
                ' + user text (optional)'
                ),
            bg=colorbg,
            justify=LEFT,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
# ...       x-label defined
        label = Label( 
            frame_20_Buffer,
            text=(
                'X-header (Buffer) + '
                ),
            bg=colorbg,
            justify=RIGHT,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
        self.entryfieldXUserLabelSingleGroupPerPlotBuffer_OneCurvePerPlot_Kiviat = Pmw.EntryField(
            frame_20_Buffer,
            entry_width=30,
            value='',
            )
        self.entryfieldXUserLabelSingleGroupPerPlotBuffer_OneCurvePerPlot_Kiviat.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            )
        self.entryfieldXUserLabelSingleGroupPerPlotBuffer_OneCurvePerPlot_Kiviat.setvalue('')

# ... y-label
        label = Label(
            frame_30_Buffer,
            text=(
                'Y LABEL\n' +
                ' '*5 + 'Buffer Y-header (default)' +
                ' + first values from 3 Buffer fields (optional)' +
                ' + user text (optional)'
                ),
            bg=colorbg,
            justify=LEFT,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )

# ...       y-label defined
        label = Label( 
            frame_40_Buffer,
            text=(
                'Y-header (Buffer)'
                ),
            bg=colorbg,
            justify=RIGHT,
            )
        label.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
        label = Label(
            frame_40_Buffer,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            )
        self.comboboxY1LabelSingleGroupPerPlotBuffer_OneCurvePerPlot_Kiviat = Pmw.ComboBox(
            frame_40_Buffer,
            scrolledlist_items=self.labelNamesBufferStorage,
            listheight=130,
            entry_width=15,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxY1LabelSingleGroupPerPlotBuffer_OneCurvePerPlot_Kiviat.grid(
            row=0,
            column=2,
            padx=0,
            pady=0,
            )
        self.comboboxY1LabelSingleGroupPerPlotBuffer_OneCurvePerPlot_Kiviat.setentry('')
        label = Label(
            frame_40_Buffer,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=3,
            padx=0,
            pady=0,
            )
        self.comboboxY2LabelSingleGroupPerPlotBuffer_OneCurvePerPlot_Kiviat = Pmw.ComboBox(
            frame_40_Buffer,
            scrolledlist_items=self.labelNamesBufferStorage,
            listheight=130,
            entry_width=15,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxY2LabelSingleGroupPerPlotBuffer_OneCurvePerPlot_Kiviat.grid(
            row=0,
            column=4,
            padx=0,
            pady=0,
            )
        self.comboboxY2LabelSingleGroupPerPlotBuffer_OneCurvePerPlot_Kiviat.setentry('')
        label = Label(
            frame_40_Buffer,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=0,
            column=5,
            padx=0,
            pady=0,
            )
        self.comboboxY3LabelSingleGroupPerPlotBuffer_OneCurvePerPlot_Kiviat = Pmw.ComboBox(
            frame_40_Buffer,
            scrolledlist_items=self.labelNamesBufferStorage,
            listheight=130,
            entry_width=15,
            dropdown=1,
            entry_state='disabled',
            entry_disabledbackground='white',
            entry_disabledforeground='black',
            scrolledlist_hull_width=500,
            )
        self.comboboxY3LabelSingleGroupPerPlotBuffer_OneCurvePerPlot_Kiviat.grid(
            row=0,
            column=6,
            padx=0,
            pady=0,
            )
        self.comboboxY3LabelSingleGroupPerPlotBuffer_OneCurvePerPlot_Kiviat.setentry('')
        label = Label(
            frame_40_Buffer,
            text=' + ',
            bg=colorbg,
            justify=CENTER,
            )
        label.grid(
            row=1,
            column=1,
            padx=0,
            pady=0,
            )
        self.entryfieldYUserLabelSingleGroupPerPlotBuffer_OneCurvePerPlot_Kiviat = Pmw.EntryField(
            frame_40_Buffer,
            entry_width=30,
            value='',
            )
        self.entryfieldYUserLabelSingleGroupPerPlotBuffer_OneCurvePerPlot_Kiviat.grid(
            row=1,
            column=2,
            columnspan=3,
            padx=0,
            pady=2,
            sticky=W,
            )
        self.entryfieldYUserLabelSingleGroupPerPlotBuffer_OneCurvePerPlot_Kiviat.setvalue('')

# ... show labels
# ...       show labels widgets
        label = Label(
            frame_60_Buffer,
            text='X LABEL: ',
            bg=colorbg,
            justify=RIGHT,
            )
        label.grid(
            row=0,
            column=1,
            padx=0,
            pady=0,
            )
        self.entryfieldXLabelShowBuffer_OneCurvePerPlot_Kiviat = Pmw.EntryField(
            frame_60_Buffer,
            entry_width=50,
            value='',
            entry_state='normal',
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            )
        self.entryfieldXLabelShowBuffer_OneCurvePerPlot_Kiviat.grid(
            row=0,
            column=2,
            padx=0,
            pady=0,
            )
        self.entryfieldXLabelShowBuffer_OneCurvePerPlot_Kiviat.setvalue('')
        label = Label(
            frame_60_Buffer,
            text='Y LABEL: ',
            bg=colorbg,
            justify=RIGHT,
            )
        label.grid(
            row=1,
            column=1,
            padx=0,
            pady=2,
            )
        self.entryfieldYLabelShowBuffer_OneCurvePerPlot_Kiviat = Pmw.EntryField(
            frame_60_Buffer,
            entry_width=50,
            value='',
            entry_state='normal',
#            entry_state='disabled',
#            entry_disabledbackground='white',
#            entry_disabledforeground='black',
            )
        self.entryfieldYLabelShowBuffer_OneCurvePerPlot_Kiviat.grid(
            row=1,
            column=2,
            padx=0,
            pady=2,
            ) 
        self.entryfieldYLabelShowBuffer_OneCurvePerPlot_Kiviat.setvalue('')
        buttonShowKiviatLabelsBuffer = Button(
            frame_60_Buffer,
            text='Preview first labels',
            width=18,
            font=self.buttonFontSmall,
            relief=RAISED,
            borderwidth=3,
            justify=CENTER,
            command=self.handlerShowLabelsBuffer_Preview_OneCurvePerPlot_Kiviat,
            )
        buttonShowKiviatLabelsBuffer.grid(
#            row=2,
#            column=1,
            row=0,
            column=0,
            rowspan=2,
            padx=5,
            pady=2,
            )
# ... reset all
        self.buttonResetAllBuffer_OneCurvePerPlot_Kiviat = Button(
            frame_70_Buffer,
            text='Clear all',
            width=12,
            bg='white',
            fg='blue',
            font=self.buttonFontSmall,
            relief=RAISED,
            borderwidth=3,
            justify=CENTER,
            command=self.handlerResetAllBuffer_OneCurvePerPlot_Kiviat,
            )
        self.buttonResetAllBuffer_OneCurvePerPlot_Kiviat.grid(
            row=0,
            column=0,
            padx=0,
            pady=0,
            )
            
# call 'Preview' handlers to show default labels
        self.handlerShowLabelsTable_Preview_NoErrMsg_OneCurvePerPlot_Kiviat()
        self.handlerShowLabelsBuffer_Preview_NoErrMsg_OneCurvePerPlot_Kiviat()

        return
     
        
    def handlerResetAllBuffer_AllGroupsPerWindow_Kiviat(self):
        '''
        Purpose:
            Reset all values to default in the 
            'PLOT LABELS - All Groups Per Window' window
            for Storage Buffer data
            
        toplevel window:
            self.toplevelLabels_AllGroupsPerWindow_Kiviat
        '''
        
        if DEBUG_PRINT_METHOD:
            print(
                '\n** In ' + MODULE + '/' + 
                'handlerResetAllBuffer_AllGroupsPerWindow_Kiviat'
                )
            
        if self.entryfieldXUserLabelSingleGroupPerPlotBuffer.get().strip() <> '':
            self.entryfieldXUserLabelSingleGroupPerPlotBuffer.setvalue('')
        if self.comboboxY1LabelSingleGroupPerPlotBuffer.get().strip() <> '':
            self.comboboxY1LabelSingleGroupPerPlotBuffer.setentry('')
        if self.comboboxY2LabelSingleGroupPerPlotBuffer.get().strip() <> '':
            self.comboboxY2LabelSingleGroupPerPlotBuffer.setentry('')
        if self.comboboxY3LabelSingleGroupPerPlotBuffer.get().strip() <> '':
            self.comboboxY3LabelSingleGroupPerPlotBuffer.setentry('')
        if self.entryfieldYUserLabelSingleGroupPerPlotBuffer.get().strip() <> '':
            self.entryfieldYUserLabelSingleGroupPerPlotBuffer.setvalue('')
        
        self.entryfieldXLabelShowBuffer_Kiviat.setvalue('')
        self.entryfieldYLabelShowBuffer_Kiviat.setvalue('')
       
        return
        
        
    def handlerResetAllBuffer_OneGroupPerWindow_Kiviat(self):
        '''
        Purpose:
            Reset all values to default in the 
            'PLOT LABELS - One Group Per Window' window
            for Storage Buffer data
            
        toplevel window:
            self.toplevelLabels_OneGroupPerWindow_Kiviat
        '''
        
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerResetAllBuffer_OneGroupPerWindow_Kiviat')
            
        if self.entryfieldXUserLabelSingleGroupPerPlotBuffer.get().strip() <> '':
            self.entryfieldXUserLabelSingleGroupPerPlotBuffer.setvalue('')
        if self.comboboxY1LabelSingleGroupPerPlotBuffer.get().strip() <> '':
            self.comboboxY1LabelSingleGroupPerPlotBuffer.setentry('')
        if self.comboboxY2LabelSingleGroupPerPlotBuffer.get().strip() <> '':
            self.comboboxY2LabelSingleGroupPerPlotBuffer.setentry('')
        if self.comboboxY3LabelSingleGroupPerPlotBuffer.get().strip() <> '':
            self.comboboxY3LabelSingleGroupPerPlotBuffer.setentry('')
        if self.entryfieldYUserLabelSingleGroupPerPlotBuffer.get().strip() <> '':
            self.entryfieldYUserLabelSingleGroupPerPlotBuffer.setvalue('')
        
        self.entryfieldXLabelShowBuffer_Kiviat.setvalue('')
        self.entryfieldYLabelShowBuffer_Kiviat.setvalue('')
       
        return
        
        
    def handlerResetAllBuffer_OneCurvePerPlot_Kiviat(self):
        '''
        Purpose:
            Reset all values to default in the 
            'PLOT LABELS - One Curve Per Pot' window
            for Storage Buffer data
            
        toplevel window:
            self.toplevelLabels_OneCurvePerPlot_Kiviat
        '''
        
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerResetAllBuffer_OneCurvePerPlot_Kiviat')
            
        if self.entryfieldXUserLabelSingleGroupPerPlotBuffer.get().strip() <> '':
            self.entryfieldXUserLabelSingleGroupPerPlotBuffer.setvalue('')
        if self.comboboxY1LabelSingleGroupPerPlotBuffer.get().strip() <> '':
            self.comboboxY1LabelSingleGroupPerPlotBuffer.setentry('')
        if self.comboboxY2LabelSingleGroupPerPlotBuffer.get().strip() <> '':
            self.comboboxY2LabelSingleGroupPerPlotBuffer.setentry('')
        if self.comboboxY3LabelSingleGroupPerPlotBuffer.get().strip() <> '':
            self.comboboxY3LabelSingleGroupPerPlotBuffer.setentry('')
        if self.entryfieldYUserLabelSingleGroupPerPlotBuffer.get().strip() <> '':
            self.entryfieldYUserLabelSingleGroupPerPlotBuffer.setvalue('')
        
        self.entryfieldXLabelShowBuffer_Kiviat.setvalue('')
        self.entryfieldYLabelShowBuffer_Kiviat.setvalue('')
       
        return

        
    def handlerShowLabelsBuffer_Preview_AllGroupsPerWindow_Kiviat(self):
        '''
        Purpose:
            take user input from designated widgets and display
            X and Y Labels for plots in respective display fields.
            
            Initiated by 'Preview first labels' in toplevel window
            "self.toplevelLabels_AllGroupsPerWindow_Kiviat"
            
            All X and Y Kiviat labels for Storage Buffer data is determined here.
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerShowLabelsBuffer_Preview_AllGroupsPerWindow_Kiviat')
                
# set to 1 to print
        DEBUG_SHOWLABELSBUFFER = 0
            
        showinfo(
            'Not yet implemented',
            'This function not yet implemented\n' +
            'for kiviat diagrams. In method\n' +
            '   "handlerShowLabelsBuffer_Preview_AllGroupsPerWindow_Kiviat"'
            )
        return
            
            
            
#        if self.varNumberOfStorageBufferCurves.get() == 0:
#            return

# ... determine first row checked in Storage Buffer
#   (number of Storage Buffer curves total: len(self.varSelectAnyRow_Buffer)
# ... if no Buffer Rows are checked, return
        if len(self.listWhichBufferRowsAreChecked) == 0:
            stringNoBufferRowsSelected = (
                'No data rows have been selected from the Storage Buffer\n' +
                'for plotting.\n' 
                )
            print stringNoBufferRowsSelected
            self.MySQL_Output(
                0,
                stringNoBufferRowsSelected
                )
            try:
                showerror(
                    'Error: no data',
                    stringNoBufferRowsSelected,
                    parent=self.toplevelLabelsSinglePlotPerCurve,
                    )
            except:
                showerror(
                    'Error: no data',
                    stringNoBufferRowsSelected
                    )
            return
# determine row index and x-y headers       
        indexBufferRow = self.listWhichBufferRowsAreChecked
        if DEBUG_SHOWLABELSBUFFER:
            print '\n*** self.listWhichBufferRowsAreChecked =',self.listWhichBufferRowsAreChecked
            print '\n*** self.bufferRowStore =\n',self.bufferRowStore
            print
        
        # determine plot label separator
        separator = self.determinePlotLabelSeparator(
            self.comboboxPlotLabelSeparatorSingle.get()
            )
        
        self.xLabelStringBuffer = []
        self.yLabelStringBuffer = []
        
        icount = 0
        for indexBufferRow in self.listWhichBufferRowsAreChecked:
            index=indexBufferRow - 1
            self.xLabelStringBuffer.append(self.bufferRowStore[index][5])
            self.yLabelStringBuffer.append(self.bufferRowStore[index][6])      
# concatenate X-label string with user text
            if self.entryfieldXUserLabelSingleCurvePerPlotBuffer.get().strip() <> '':
                self.xLabelStringBuffer[icount] += separator + (
                    self.entryfieldXUserLabelSingleCurvePerPlotBuffer.get()
                    )            
# concatenate Y-label strings
            yLabelString = ''
            if self.comboboxY1LabelSingleCurvePerPlotBuffer.get().strip() <> '':
                field1 = self.comboboxY1LabelSingleCurvePerPlotBuffer.get()
                for key,value in self.dictNamesBufferStorage.iteritems():
                    if key == field1:
                        yLabelString += separator + self.bufferRowStore[index][value]
                        break
            if self.comboboxY2LabelSingleCurvePerPlotBuffer.get().strip() <> '':
                field2 = self.comboboxY2LabelSingleCurvePerPlotBuffer.get()
                for key,value in self.dictNamesBufferStorage.iteritems():
                    if key == field2:
                        yLabelString += separator + self.bufferRowStore[index][value]
                        break
            if self.comboboxY3LabelSingleCurvePerPlotBuffer.get().strip() <> '':
                field3 = self.comboboxY3LabelSingleCurvePerPlotBuffer.get()
                for key,value in self.dictNamesBufferStorage.iteritems():
                    if key == field3:
                        yLabelString += separator + self.bufferRowStore[index][value]
                        break
            if self.entryfieldYUserLabelSingleCurvePerPlotBuffer.get().strip() <> '':
                yLabelString += separator + self.entryfieldYUserLabelSingleCurvePerPlotBuffer.get()
            self.yLabelStringBuffer[icount] += yLabelString
            
            icount += 1
            
# show strings in respective fields
        self.entryfieldXLabelShowBuffer.setvalue(self.xLabelStringBuffer[0])
        self.entryfieldYLabelShowBuffer.setvalue(self.yLabelStringBuffer[0])
                 
        return

            
    def handlerShowLabelsBuffer_Preview_OneGroupPerWindow_Kiviat(self):
        '''
         Purpose:
            take user input from designated widgets and display
            X and Y Labels for plots in respective display fields.
            
            Initiated by 'Preview first labels' in toplevel window
            "self.toplevelLabels_OneGroupPerWindow_Kiviat"
            
            All X and Y Kiviat labels for Storage Buffer data is determined here.
         '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerShowLabelsBuffer_Preview_OneGroupPerWindow_Kiviat')
                
# set to 1 to print
        DEBUG_SHOWLABELSBUFFER = 0
            
        showinfo(
            'Not yet implemented',
            'This function not yet implemented\n' +
            'for kiviat diagrams. In method\n' +
            '   "handlerShowLabelsBuffer_Preview_OneGroupPerWindow_Kiviat"'
            )
        return
   
            
#        if self.varNumberOfStorageBufferCurves.get() == 0:
#            return

# ... determine first row checked in Storage Buffer
#   (number of Storage Buffer curves total: len(self.varSelectAnyRow_Buffer)
# ... if no Buffer Rows are checked, return
        if len(self.listWhichBufferRowsAreChecked) == 0:
            stringNoBufferRowsSelected = (
                'No data rows have been selected from the Storage Buffer\n' +
                'for plotting.\n' 
                )
            print stringNoBufferRowsSelected
            self.MySQL_Output(
                0,
                stringNoBufferRowsSelected
                )
            try:
                showerror(
                    'Error: no data',
                    stringNoBufferRowsSelected,
                    parent=self.toplevelLabelsSinglePlotPerCurve,
                    )
            except:
                showerror(
                    'Error: no data',
                    stringNoBufferRowsSelected
                    )
            return
# determine row index and x-y headers       
        indexBufferRow = self.listWhichBufferRowsAreChecked
        if DEBUG_SHOWLABELSBUFFER:
            print '\n*** self.listWhichBufferRowsAreChecked =',self.listWhichBufferRowsAreChecked
            print '\n*** self.bufferRowStore =\n',self.bufferRowStore
            print
        
        # determine plot label separator
        separator = self.determinePlotLabelSeparator(
            self.comboboxPlotLabelSeparatorSingle.get()
            )
        
        self.xLabelStringBuffer = []
        self.yLabelStringBuffer = []
        
        icount = 0
        for indexBufferRow in self.listWhichBufferRowsAreChecked:
            index=indexBufferRow - 1
            self.xLabelStringBuffer.append(self.bufferRowStore[index][5])
            self.yLabelStringBuffer.append(self.bufferRowStore[index][6])      
# concatenate X-label string with user text
            if self.entryfieldXUserLabelSingleCurvePerPlotBuffer.get().strip() <> '':
                self.xLabelStringBuffer[icount] += separator + (
                    self.entryfieldXUserLabelSingleCurvePerPlotBuffer.get()
                    )            
# concatenate Y-label strings
            yLabelString = ''
            if self.comboboxY1LabelSingleCurvePerPlotBuffer.get().strip() <> '':
                field1 = self.comboboxY1LabelSingleCurvePerPlotBuffer.get()
                for key,value in self.dictNamesBufferStorage.iteritems():
                    if key == field1:
                        yLabelString += separator + self.bufferRowStore[index][value]
                        break
            if self.comboboxY2LabelSingleCurvePerPlotBuffer.get().strip() <> '':
                field2 = self.comboboxY2LabelSingleCurvePerPlotBuffer.get()
                for key,value in self.dictNamesBufferStorage.iteritems():
                    if key == field2:
                        yLabelString += separator + self.bufferRowStore[index][value]
                        break
            if self.comboboxY3LabelSingleCurvePerPlotBuffer.get().strip() <> '':
                field3 = self.comboboxY3LabelSingleCurvePerPlotBuffer.get()
                for key,value in self.dictNamesBufferStorage.iteritems():
                    if key == field3:
                        yLabelString += separator + self.bufferRowStore[index][value]
                        break
            if self.entryfieldYUserLabelSingleCurvePerPlotBuffer.get().strip() <> '':
                yLabelString += separator + self.entryfieldYUserLabelSingleCurvePerPlotBuffer.get()
            self.yLabelStringBuffer[icount] += yLabelString
            
            icount += 1
            
# show strings in respective fields
        self.entryfieldXLabelShowBuffer.setvalue(self.xLabelStringBuffer[0])
        self.entryfieldYLabelShowBuffer.setvalue(self.yLabelStringBuffer[0])
                 
        return

        
    def handlerShowLabelsBuffer_Preview_OneCurvePerPlot_Kiviat(self):
        '''
         Purpose:
            take user input from designated widgets and display
            X and Y Labels for plots in respective display fields.
            
            Initiated by 'Preview first labels' in toplevel window
            "self.toplevelLabels_OneCurvePerPlot_Kiviat"
            
            All X and Y Kiviat labels for Storage Buffer data is determined here.
         '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerShowXYLabelsBuffer_OneCurvePerPlot_Kiviat')
                
# set to 1 to print
        DEBUG_SHOWLABELSBUFFER = 0
            
        showinfo(
            'Not yet implemented',
            'This function not yet implemented\n' +
            'for kiviat diagrams. In method\n' +
            '   "handlerShowLabelsBuffer_Preview_OneCurvePerPlot_Kiviat"'
            )
        return
            
            
            
#        if self.varNumberOfStorageBufferCurves.get() == 0:
#            return

# ... determine first row checked in Storage Buffer
#   (number of Storage Buffer curves total: len(self.varSelectAnyRow_Buffer)
# ... if no Buffer Rows are checked, return
        if len(self.listWhichBufferRowsAreChecked) == 0:
            stringNoBufferRowsSelected = (
                'No data rows have been selected from the Storage Buffer\n' +
                'for plotting.\n' 
                )
            print stringNoBufferRowsSelected
            self.MySQL_Output(
                0,
                stringNoBufferRowsSelected
                )
            try:
                showerror(
                    'Error: no data',
                    stringNoBufferRowsSelected,
                    parent=self.toplevelLabelsSinglePlotPerCurve,
                    )
            except:
                showerror(
                    'Error: no data',
                    stringNoBufferRowsSelected
                    )
            return
# determine row index and x-y headers       
        indexBufferRow = self.listWhichBufferRowsAreChecked
        if DEBUG_SHOWLABELSBUFFER:
            print '\n*** self.listWhichBufferRowsAreChecked =',self.listWhichBufferRowsAreChecked
            print '\n*** self.bufferRowStore =\n',self.bufferRowStore
            print
        
        # determine plot label separator
        separator = self.determinePlotLabelSeparator(
            self.comboboxPlotLabelSeparatorSingle.get()
            )
        
        self.xLabelStringBuffer = []
        self.yLabelStringBuffer = []
        
        icount = 0
        for indexBufferRow in self.listWhichBufferRowsAreChecked:
            index=indexBufferRow - 1
            self.xLabelStringBuffer.append(self.bufferRowStore[index][5])
            self.yLabelStringBuffer.append(self.bufferRowStore[index][6])      
# concatenate X-label string with user text
            if self.entryfieldXUserLabelSingleCurvePerPlotBuffer.get().strip() <> '':
                self.xLabelStringBuffer[icount] += separator + (
                    self.entryfieldXUserLabelSingleCurvePerPlotBuffer.get()
                    )            
# concatenate Y-label strings
            yLabelString = ''
            if self.comboboxY1LabelSingleCurvePerPlotBuffer.get().strip() <> '':
                field1 = self.comboboxY1LabelSingleCurvePerPlotBuffer.get()
                for key,value in self.dictNamesBufferStorage.iteritems():
                    if key == field1:
                        yLabelString += separator + self.bufferRowStore[index][value]
                        break
            if self.comboboxY2LabelSingleCurvePerPlotBuffer.get().strip() <> '':
                field2 = self.comboboxY2LabelSingleCurvePerPlotBuffer.get()
                for key,value in self.dictNamesBufferStorage.iteritems():
                    if key == field2:
                        yLabelString += separator + self.bufferRowStore[index][value]
                        break
            if self.comboboxY3LabelSingleCurvePerPlotBuffer.get().strip() <> '':
                field3 = self.comboboxY3LabelSingleCurvePerPlotBuffer.get()
                for key,value in self.dictNamesBufferStorage.iteritems():
                    if key == field3:
                        yLabelString += separator + self.bufferRowStore[index][value]
                        break
            if self.entryfieldYUserLabelSingleCurvePerPlotBuffer.get().strip() <> '':
                yLabelString += separator + self.entryfieldYUserLabelSingleCurvePerPlotBuffer.get()
            self.yLabelStringBuffer[icount] += yLabelString
            
            icount += 1
            
# show strings in respective fields
        self.entryfieldXLabelShowBuffer.setvalue(self.xLabelStringBuffer[0])
        self.entryfieldYLabelShowBuffer.setvalue(self.yLabelStringBuffer[0])
                 
        return
        
        
    def handlerShowLabelsTable_Preview_NoErrMsg_AllGroupsPerWindow_Kiviat(self):
        '''
         Purpose:
            take user input from designated widgets in toplevel window
            "self.toplevelLabels_AllGroupsPerWindow_Kiviat" and display
            X and Y Labels for plots in respective display fields,
            but do not display error msg if no data to choose from
         '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 
                'handlerShowLabelsTable_Preview_NoErrMsg_AllGroupsPerWindow_Kiviat'
                )
                
        if self.varNumberOfTableCurves_Kiviat.get() == 0:
            return
        
        '''
        if(
        self.varNumberOfTableCurves_Kiviat.get() == 0
        and
        self.varNumberOfStorageBufferCurves_Kiviat.get() == 0
        ):
            stringNoGroups = (
                'No groups (sets of curves) have been selected from either\n' +
                'the current table or the storage buffer.\n\n' +
                'Select at least one group and try again.'
                )
            print stringNoGroups
            self.MySQL_Output(
                0,
                stringNoGroups
                )
            showerror(
                'Error: no groups to plot',
                stringNoGroups
                )
            return
        '''
            
        '''
# determine plot label separator
        separator = self.determinePlotLabelSeparator(
            self.comboboxPlotLabelSeparator_AllGroupsPerWindow_Kiviat.get()
            )
        '''
 
# determine spoke labels
        self.spokeLabelsTable_Kiviat, self.justSpokeLabelsTable_Kiviat = \
            self.assembleSpokeLabelsTable_Kiviat()                    
            
# determine legend title
# ... from 'handlerUpdateKiviatPlots_Table'
        legendTitle = self.label_X_Table_Kiviat
        
# determine x-values from selected rows, for legend values
        x_column = self.varXSelect.get() - 1

# determine legend labels; make sure all elements are strings
        legendLabels = [str(label) for label in self.plot_X_Table_Kiviat]
        
# circumferential plot values
        self.spoke_plot_values_circumferential = []  
        for itemCount in range(len(self.plot_Y_Table_Kiviat[0])):
            tempList = []
            for listCount in range(len(self.plot_Y_Table_Kiviat)):
                tempList.append(self.plot_Y_Table_Kiviat[listCount][itemCount])
            self.spoke_plot_values_circumferential.append(tempList)    

        if DEBUG_PRINT_PREVIEW_KIVIAT:
            print('\n' + '-'*80)
            print('x_column =\n%s' % x_column)
            print('')
            print('x_rows (self.rowsSelectedTable_Kiviat) =\n%s' % self.rowsSelectedTable_Kiviat)
            print(' ')
            print('y_columns (self.index_Y_Table_Kiviat) =\n%s' % self.index_Y_Table_Kiviat)
            print('')
            print('spokeLabels (self.spokeLabelsTable_Kiviat) =\n%s' % self.spokeLabelsTable_Kiviat)           
            print('')
            print('JUST the spoke labels (self.justSpokeLabelsTable_Kiviat) =\n%s' % self.justSpokeLabelsTable_Kiviat)
            print('')
            print('legendTitle (self.label_X_Table_Kiviat) =\n%s' % legendTitle)
            print('')
            print('legendLabels =\n%s' % legendLabels)
            print('')
            print('spoke plot values radial =\n%s' % self.plot_Y_Table_Kiviat)
            print('')
            print('spoke plot values circumferential =\n%s' % self.spoke_plot_values_circumferential)
            print('')
            print('spoke max values local =\n%s' % self.maxValuesYColumnsLocalTable_Kiviat)
            print('')
            print('spoke max value local =\n%s' % self.maxValuesForEachGroupLocal_Kiviat)
            print('')
            print('spoke max value global =\n%s' % self.maxValueForAllGroupsGlobal_Kiviat)
            print('-'*80 + '\n')

# concatenate legend title string
        self.legendTitleStringTable_Kiviat = (
            self.assembleLegendTitleString_Kiviat(legendTitle)
            )

# concatenate legend label strings
        self.legendLabelStringTable_Kiviat = self.assembleLegendLabelStringTable_Kiviat(legendLabels)

# show strings in respective fields
#	self.entryfieldSpokeLabelTable_Preview_AllGroupsPerWindow_Kiviat
#		spoke label
#	self.entryfieldLegendTitleTable_Preview_AllGroupsPerWindow_Kiviat
#		legend title
#	self.entryfieldLegendLabelTable_Preview_AllGroupsPerWindow_Kiviat
#		legend label
        self.entryfieldSpokeLabelTable_Preview_AllGroupsPerWindow_Kiviat.setvalue(
			self.spokeLabelsTable_Kiviat[0]
			)
        self.entryfieldLegendTitleTable_Preview_AllGroupsPerWindow_Kiviat.setvalue(
			self.legendTitleStringTable_Kiviat
			)
        self.entryfieldLegendLabelTable_Preview_AllGroupsPerWindow_Kiviat.setvalue(
            self.legendLabelStringTable_Kiviat[0]
            )
                 
        return

        
    def handlerShowLabelsTable_Preview_NoErrMsg_OneGroupPerWindow_Kiviat(self):
        '''
         Purpose:
            take user input from designated widgets and display
            X and Y Labels for plots in respective display fields,
            but do not display error msg if no data to choose from
         '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 
                'handlerShowLabelsTable_Preview_NoErrMsg_OneGroupPerWindow_Kiviat'
                )
        
        showerror(
            'Error: under construction',
            'Method\n\n' +
            '  handlerShowLabelsTable_Preview_NoErrMsg_OneGroupPerWindow_Kiviat\n\n' +
            'under construction'
            )
        return
        
        if self.varNumberOfTableCurves_Kiviat.get() == 0:
            return
# determine x index and header
#        index_X = self.varXSelect.get() - 1
        '''
         xHeader = self.tableStructure[self.index_X][0]
         '''
        xHeader = self.headerNames_X_Table[0]
        
        print ' xHeader =',xHeader
 
# determine y index and header; only need the first one here 
        '''
        i = 0
        j = 0
        yHeaders = []
        index_Y = []
        for var in self.varYSelect:
            if var.get():
                index_Y.append(j)
                yHeaders.append(self.tableStructure[index_Y[i]][0])
                i += 1
            j+=1 

        print ' yHeaders =\n', yHeaders
         '''

        yHeaders = self.headerNames_Y_Table
        print ' yHeaders =\n',yHeaders

# determine plot label separator
        separator = self.determinePlotLabelSeparator(
            self.comboboxPlotLabelSeparatorSingle.get()
            )

# concatenate X-label string
        self.xLabelStringTable = []
        self.xLabelStringTable.append(xHeader)
        if self.entryfieldXUserLabelSingleCurvePerPlotTable.get().strip() <> '':
            self.xLabelStringTable += separator + self.entryfieldXUserLabelSingleCurvePerPlotTable.get()
        
# concatenate Y-label strings
        self.yLabelStringTable = []
        for header in yHeaders:
            yLabelString = header
            if self.comboboxY1LabelSingleCurvePerPlotTable.get().strip() <> '':
                field1 = self.comboboxY1LabelSingleCurvePerPlotTable.get()
                for key,value in self.dictColumnHeaders.iteritems():
                    if key == field1:
                        yLabelString += separator + self.tableValues[0][value-1]
                        break
            if self.comboboxY2LabelSingleCurvePerPlotTable.get().strip() <> '':
                field2 = self.comboboxY2LabelSingleCurvePerPlotTable.get()
                for key,value in self.dictColumnHeaders.iteritems():
                    if key == field2:
                        yLabelString += separator + self.tableValues[0][value-1]
                        break
            if self.comboboxY3LabelSingleCurvePerPlotTable.get().strip() <> '':
                field3 = self.comboboxY3LabelSingleCurvePerPlotTable.get()
                for key,value in self.dictColumnHeaders.iteritems():
                    if key == field3:
                        yLabelString += separator + self.tableValues[0][value-1]
                        break
            if self.entryfieldYUserLabelSingleCurvePerPlotTable.get().strip() <> '':
                yLabelString += separator + self.entryfieldYUserLabelSingleCurvePerPlotTable.get()
            self.yLabelStringTable.append(yLabelString)
            
# show strings in respective fields
        self.entryfieldXLabelShowTable.setvalue(self.xLabelStringTable[0])
        self.entryfieldYLabelShowTable.setvalue(self.yLabelStringTable[0])
                 
        return
        
        
    def handlerShowLabelsTable_Preview_NoErrMsg_OneCurvePerPlot_Kiviat(self):
        '''
         Purpose:
            take user input from designated widgets and display
            X and Y Labels for plots in respective display fields,
            but do not display error msg if no data to choose from
         '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 
                'handlerShowLabelsTable_Preview_NoErrMsg_OneCurvePerPlot_Kiviat'
                )
        
        showerror(
            'Error: under construction',
            'Method\n\n' +
            '  handlerShowLabelsTable_Preview_NoErrMsg_OneCurvePerPlot_Kiviat\n\n' +
            'under construction'
            )
        return
        
        if self.varNumberOfTableCurves_Kiviat.get() == 0:
            return
# determine x index and header
#        index_X = self.varXSelect.get() - 1
        '''
         xHeader = self.tableStructure[self.index_X][0]
         '''
        xHeader = self.headerNames_X_Table[0]
 
# determine y index and header; only need the first one here 
        '''
        i = 0
        j = 0
        yHeaders = []
        index_Y = []
        for var in self.varYSelect:
            if var.get():
                index_Y.append(j)
                yHeaders.append(self.tableStructure[index_Y[i]][0])
                i += 1
            j+=1 

        print ' yHeaders =\n', yHeaders
         '''

        yHeaders = self.headerNames_Y_Table
        print ' yHeaders =\n',yHeaders

# determine plot label separator
        separator = self.determinePlotLabelSeparator(
            self.comboboxPlotLabelSeparatorSingle.get()
            )

# concatenate X-label string
        self.xLabelStringTable = []
        self.xLabelStringTable.append(xHeader)
        if self.entryfieldXUserLabelSingleCurvePerPlotTable.get().strip() <> '':
            self.xLabelStringTable += separator + self.entryfieldXUserLabelSingleCurvePerPlotTable.get()
        
# concatenate Y-label strings
        self.yLabelStringTable = []
        for header in yHeaders:
            yLabelString = header
            if self.comboboxY1LabelSingleCurvePerPlotTable.get().strip() <> '':
                field1 = self.comboboxY1LabelSingleCurvePerPlotTable.get()
                for key,value in self.dictColumnHeaders.iteritems():
                    if key == field1:
                        yLabelString += separator + self.tableValues[0][value-1]
                        break
            if self.comboboxY2LabelSingleCurvePerPlotTable.get().strip() <> '':
                field2 = self.comboboxY2LabelSingleCurvePerPlotTable.get()
                for key,value in self.dictColumnHeaders.iteritems():
                    if key == field2:
                        yLabelString += separator + self.tableValues[0][value-1]
                        break
            if self.comboboxY3LabelSingleCurvePerPlotTable.get().strip() <> '':
                field3 = self.comboboxY3LabelSingleCurvePerPlotTable.get()
                for key,value in self.dictColumnHeaders.iteritems():
                    if key == field3:
                        yLabelString += separator + self.tableValues[0][value-1]
                        break
            if self.entryfieldYUserLabelSingleCurvePerPlotTable.get().strip() <> '':
                yLabelString += separator + self.entryfieldYUserLabelSingleCurvePerPlotTable.get()
            self.yLabelStringTable.append(yLabelString)
            
# show strings in respective fields
        self.entryfieldXLabelShowTable.setvalue(self.xLabelStringTable[0])
        self.entryfieldYLabelShowTable.setvalue(self.yLabelStringTable[0])
                 
        return
        
        
    def handlerShowLabelsBuffer_Preview_NoErrMsg_AllGroupsPerWindow_Kiviat(self):
        '''
        Purpose:
            take user input from designated widgets and display
            X and Y Labels for plots in respective display fields,
            but do not display error msg if no data to choose from
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 
                'handlerShowLabelsBuffer_Preview_NoErrMsg_AllGroupsPerWindow_Kiviat'
                )
                
        showerror(
            'Error: under construction',
            'Method\n\n' +
            '  handlerShowLabelsBuffer_Preview_NoErrMsg_AllGroupsPerWindow_Kiviat\n\n' +
            'under construction'
            )
        return
        
# set to 1 to print
        DEBUG_SHOWLABELSBUFFER_PREVIEW = 0
            
# ... determine first row checked in Storage Buffer
#   (number of Storage Buffer curves total: len(self.varSelectAnyRow_Buffer)
# ... if no Buffer Rows are checked, return
        if len(self.listWhichBufferRowsAreChecked) == 0:
            return
# determine row index and x-y headers       
        indexBufferRow = self.listWhichBufferRowsAreChecked
        if DEBUG_SHOWLABELSBUFFER_PREVIEW:
            print '\n*** self.listWhichBufferRowsAreChecked =',self.listWhichBufferRowsAreChecked
            print '\n*** self.bufferRowStore =\n',self.bufferRowStore
            print
        
        # determine plot label separator
        separator = self.determinePlotLabelSeparator(
            self.comboboxPlotLabelSeparatorSingle.get()
            )
        
        self.xLabelStringBuffer = []
        self.yLabelStringBuffer = []
        
        icount = 0
        for indexBufferRow in self.listWhichBufferRowsAreChecked:
            index=indexBufferRow - 1
            self.xLabelStringBuffer.append(self.bufferRowStore[index][5])
            self.yLabelStringBuffer.append(self.bufferRowStore[index][6])      
# concatenate X-label string with user text
            if self.entryfieldXUserLabelSingleCurvePerPlotBuffer.get().strip() <> '':
                self.xLabelStringBuffer[icount] += separator + (
                    self.entryfieldXUserLabelSingleCurvePerPlotBuffer.get()
                    )            
# concatenate Y-label strings
            yLabelString = ''
            if self.comboboxY1LabelSingleCurvePerPlotBuffer.get().strip() <> '':
                field1 = self.comboboxY1LabelSingleCurvePerPlotBuffer.get()
                for key,value in self.dictNamesBufferStorage.iteritems():
                    if key == field1:
                        yLabelString += separator + self.bufferRowStore[index][value]
                        break
            if self.comboboxY2LabelSingleCurvePerPlotBuffer.get().strip() <> '':
                field2 = self.comboboxY2LabelSingleCurvePerPlotBuffer.get()
                for key,value in self.dictNamesBufferStorage.iteritems():
                    if key == field2:
                        yLabelString += separator + self.bufferRowStore[index][value]
                        break
            if self.comboboxY3LabelSingleCurvePerPlotBuffer.get().strip() <> '':
                field3 = self.comboboxY3LabelSingleCurvePerPlotBuffer.get()
                for key,value in self.dictNamesBufferStorage.iteritems():
                    if key == field3:
                        yLabelString += separator + self.bufferRowStore[index][value]
                        break
            if self.entryfieldYUserLabelSingleCurvePerPlotBuffer.get().strip() <> '':
                yLabelString += separator + self.entryfieldYUserLabelSingleCurvePerPlotBuffer.get()
            self.yLabelStringBuffer[icount] += yLabelString
            
            icount += 1
            
# show strings in respective fields
        self.entryfieldXLabelShowBuffer.setvalue(self.xLabelStringBuffer[0])
        self.entryfieldYLabelShowBuffer.setvalue(self.yLabelStringBuffer[0])
                 
        return
        
        
    def handlerShowLabelsBuffer_Preview_NoErrMsg_OneGroupPerWindow_Kiviat(self):
        '''
        Purpose:
            take user input from designated widgets and display
            X and Y Labels for plots in respective display fields,
            but do not display error msg if no data to choose from
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 
                'handlerShowLabelsBuffer_Preview_NoErrMsg_OneGroupPerWindow_Kiviat'
                )

        showerror(
            'Error: under construction',
            'Method\n\n' +
            '  handlerShowLabelsBuffer_Preview_NoErrMsg_OneGroupPerWindow_Kiviat\n\n' +
            'under construction'
            )
        return
        
# set to 1 to print
        DEBUG_SHOWLABELSBUFFER_PREVIEW = 0
# ... determine first row checked in Storage Buffer
#   (number of Storage Buffer curves total: len(self.varSelectAnyRow_Buffer)
# ... if no Buffer Rows are checked, return
        if len(self.listWhichBufferRowsAreChecked) == 0:
            return
# determine row index and x-y headers       
        indexBufferRow = self.listWhichBufferRowsAreChecked
        if DEBUG_SHOWLABELSBUFFER_PREVIEW:
            print '\n*** self.listWhichBufferRowsAreChecked =',self.listWhichBufferRowsAreChecked
            print '\n*** self.bufferRowStore =\n',self.bufferRowStore
            print
        
# determine plot label separator
        separator = self.determinePlotLabelSeparator(
            self.comboboxPlotLabelSeparatorSingle.get()
            )
        
        self.xLabelStringBuffer = []
        self.yLabelStringBuffer = []
        
        icount = 0
        for indexBufferRow in self.listWhichBufferRowsAreChecked:
            index=indexBufferRow - 1
            self.xLabelStringBuffer.append(self.bufferRowStore[index][5])
            self.yLabelStringBuffer.append(self.bufferRowStore[index][6])      
# concatenate X-label string with user text
            if self.entryfieldXUserLabelSingleCurvePerPlotBuffer.get().strip() <> '':
                self.xLabelStringBuffer[icount] += separator + (
                    self.entryfieldXUserLabelSingleCurvePerPlotBuffer.get()
                    )            
# concatenate Y-label strings
            yLabelString = ''
            if self.comboboxY1LabelSingleCurvePerPlotBuffer.get().strip() <> '':
                field1 = self.comboboxY1LabelSingleCurvePerPlotBuffer.get()
                for key,value in self.dictNamesBufferStorage.iteritems():
                    if key == field1:
                        yLabelString += separator + self.bufferRowStore[index][value]
                        break
            if self.comboboxY2LabelSingleCurvePerPlotBuffer.get().strip() <> '':
                field2 = self.comboboxY2LabelSingleCurvePerPlotBuffer.get()
                for key,value in self.dictNamesBufferStorage.iteritems():
                    if key == field2:
                        yLabelString += separator + self.bufferRowStore[index][value]
                        break
            if self.comboboxY3LabelSingleCurvePerPlotBuffer.get().strip() <> '':
                field3 = self.comboboxY3LabelSingleCurvePerPlotBuffer.get()
                for key,value in self.dictNamesBufferStorage.iteritems():
                    if key == field3:
                        yLabelString += separator + self.bufferRowStore[index][value]
                        break
            if self.entryfieldYUserLabelSingleCurvePerPlotBuffer.get().strip() <> '':
                yLabelString += separator + self.entryfieldYUserLabelSingleCurvePerPlotBuffer.get()
            self.yLabelStringBuffer[icount] += yLabelString
            
            icount += 1
            
# show strings in respective fields
        self.entryfieldXLabelShowBuffer.setvalue(self.xLabelStringBuffer[0])
        self.entryfieldYLabelShowBuffer.setvalue(self.yLabelStringBuffer[0])
                 
        return
        
        
    def handlerShowLabelsBuffer_Preview_NoErrMsg_OneCurvePerPlot_Kiviat(self):
        '''
         Purpose:
            take user input from designated widgets and display
            X and Y Labels for plots in respective display fields,
            but do not display error msg if no data to choose from
         '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 
                'handlerShowLabelsBuffer_Preview_NoErrMsg_OneCurvePerPlot_Kiviat'
                )

        showerror(
            'Error: under construction',
            'Method\n\n' +
            '  handlerShowLabelsBuffer_Preview_NoErrMsg_OneCurvePerPlot_Kiviat\n\n' +
            'under construction'
            )
        return
        
# set to 1 to print
        DEBUG_SHOWLABELSBUFFER = 0
            
# ... determine first row checked in Storage Buffer
#   (number of Storage Buffer curves total: len(self.varSelectAnyRow_Buffer)
# ... if no Buffer Rows are checked, return
        if len(self.listWhichBufferRowsAreChecked) == 0:
            return
# determine row index and x-y headers       
        indexBufferRow = self.listWhichBufferRowsAreChecked
        if DEBUG_SHOWLABELSBUFFER:
            print '\n*** self.listWhichBufferRowsAreChecked =',self.listWhichBufferRowsAreChecked
            print '\n*** self.bufferRowStore =\n',self.bufferRowStore
            print
        
        # determine plot label separator
        separator = self.determinePlotLabelSeparator(
            self.comboboxPlotLabelSeparatorSingle.get()
            )
        
        self.xLabelStringBuffer = []
        self.yLabelStringBuffer = []
        
        icount = 0
        for indexBufferRow in self.listWhichBufferRowsAreChecked:
            index=indexBufferRow - 1
            self.xLabelStringBuffer.append(self.bufferRowStore[index][5])
            self.yLabelStringBuffer.append(self.bufferRowStore[index][6])      
# concatenate X-label string with user text
            if self.entryfieldXUserLabelSingleCurvePerPlotBuffer.get().strip() <> '':
                self.xLabelStringBuffer[icount] += separator + (
                    self.entryfieldXUserLabelSingleCurvePerPlotBuffer.get()
                    )            
# concatenate Y-label strings
            yLabelString = ''
            if self.comboboxY1LabelSingleCurvePerPlotBuffer.get().strip() <> '':
                field1 = self.comboboxY1LabelSingleCurvePerPlotBuffer.get()
                for key,value in self.dictNamesBufferStorage.iteritems():
                    if key == field1:
                        yLabelString += separator + self.bufferRowStore[index][value]
                        break
            if self.comboboxY2LabelSingleCurvePerPlotBuffer.get().strip() <> '':
                field2 = self.comboboxY2LabelSingleCurvePerPlotBuffer.get()
                for key,value in self.dictNamesBufferStorage.iteritems():
                    if key == field2:
                        yLabelString += separator + self.bufferRowStore[index][value]
                        break
            if self.comboboxY3LabelSingleCurvePerPlotBuffer.get().strip() <> '':
                field3 = self.comboboxY3LabelSingleCurvePerPlotBuffer.get()
                for key,value in self.dictNamesBufferStorage.iteritems():
                    if key == field3:
                        yLabelString += separator + self.bufferRowStore[index][value]
                        break
            if self.entryfieldYUserLabelSingleCurvePerPlotBuffer.get().strip() <> '':
                yLabelString += separator + self.entryfieldYUserLabelSingleCurvePerPlotBuffer.get()
            self.yLabelStringBuffer[icount] += yLabelString
            
            icount += 1
            
# show strings in respective fields
        self.entryfieldXLabelShowBuffer.setvalue(self.xLabelStringBuffer[0])
        self.entryfieldYLabelShowBuffer.setvalue(self.yLabelStringBuffer[0])
                 
        return
        
        
    def handlerResetAllTable_AllGroupsPerWindow_Kiviat(self):
        '''
        Purpose:
            Reset all values to default in the 
            'KIVIT PLOT LABELS - All Groups Per Window' window
            
        affects toplevel window
             "self.toplevelLabels_AllGroupsPerWindow_Kiviat"
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerResetAllTable_AllGroupsPerWindow_Kiviat')
                
# FOR TABLE            
# ... spoke labels        
        self.varCheckbuttonSpokeLabelTable_AllGroupsPerWindow_Kiviat.set(1)
        self.entryfieldSpokeLabelTable_AllGroupsPerWindow_Kiviat.setvalue('')
        self.varCheckbuttonMaxSpokeValueTable_AllGroupsPerWindow_Kiviat.set(1)
# ... legend title
        self.varCheckbuttonLegendTitleTable_AllGroupsPerWindow_Kiviat.set(1)
        self.entryfieldLegendTitleTable_User_AllGroupsPerWindow_Kiviat.setvalue('')
# ... legend labels
        self.varCheckbuttonLegendLabelsTable_AllGroupsPerWindow_Kiviat.set(1)
        self.comboboxLegendLabelTable_1_AllGroupsPerWindow_Kiviat.setentry('')
        self.comboboxLegendLabelTable_2_AllGroupsPerWindow_Kiviat.setentry('')
        self.comboboxLegendLabelTable_3_AllGroupsPerWindow_Kiviat.setentry('')
        self.entryfieldLegendLabelTable_User_AllGroupsPerWindow_Kiviat.setvalue('')
# ... preview spoke label
        self.entryfieldSpokeLabelTable_Preview_AllGroupsPerWindow_Kiviat.setvalue('')
# ... preview legend title
        self.entryfieldLegendTitleTable_Preview_AllGroupsPerWindow_Kiviat.setvalue('')
# ... preview legend label
        self.entryfieldLegendLabelTable_Preview_AllGroupsPerWindow_Kiviat.setvalue('')
    
        return
        
        
    def handlerResetAllTable_OneGroupPerWindow_Kiviat(self):
        '''
        Purpose:
            Reset all values to default in the 
            'KIVIT PLOT LABELS - All Groups Per Window' window
            
            affects toplevel window
             "self.toplevelLabels_AllGroupsPerWindow_Kiviat"
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerResetAllTable_OneGroupPerWindow_Kiviat')
            
        showinfo(
            'not yet implemented',
            'This function not yet implemented\n' +
            'for kiviat diagrams. In method\n'
            '   "handlerResetAllTable_OneGroupPerWindow_Kiviat"'
            )
        return
        
        if self.entryfieldXUserLabelSingleGroupPerPlotTable.get().strip() <> '':
            self.entryfieldXUserLabelSingleGroupPerPlotTable.setvalue('')
        if self.comboboxY1LabelSingleGroupPerPlotTable.get().strip() <> '':
            self.comboboxY1LabelSingleGroupPerPlotTable.setentry('')
        if self.comboboxY2LabelSingleGroupPerPlotTable.get().strip() <> '':
            self.comboboxY2LabelSingleGroupPerPlotTable.setentry('')
        if self.comboboxY3LabelSingleGroupPerPlotTable.get().strip() <> '':
            self.comboboxY3LabelSingleGroupPerPlotTable.setentry('')
        if self.entryfieldYUserLabelSingleGroupPerPlotTable.get().strip() <> '':
            self.entryfieldYUserLabelSingleGroupPerPlotTable.setvalue('')
        
        self.entryfieldXLabelShowTable_Kiviat.setvalue('')
        self.entryfieldYLabelShowTable_Kiviat.setvalue('')
       
        return
        
        
    def handlerResetAllTable_OneCurvePerPlot_Kiviat(self):
        '''
        Purpose:
            Reset all values to default in the 
            'KIVIT PLOT LABELS - One Curve Per Plot' window
            
            affects toplevel window
             "self.toplevelLabels_OneCurvePerPlot_Kiviat"
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerResetAllTable_OneCurvePerPlot_Kiviat')
            
        showinfo(
            'not yet implemented',
            'This function not yet implemented\n' +
            'for kiviat diagrams. In method\n' +
            '   "handlerResetAllTable_OneCurvePerPlot_Kiviat"'
            )
        return
        
        if self.entryfieldXUserLabelSingleGroupPerPlotTable.get().strip() <> '':
            self.entryfieldXUserLabelSingleGroupPerPlotTable.setvalue('')
        if self.comboboxY1LabelSingleGroupPerPlotTable.get().strip() <> '':
            self.comboboxY1LabelSingleGroupPerPlotTable.setentry('')
        if self.comboboxY2LabelSingleGroupPerPlotTable.get().strip() <> '':
            self.comboboxY2LabelSingleGroupPerPlotTable.setentry('')
        if self.comboboxY3LabelSingleGroupPerPlotTable.get().strip() <> '':
            self.comboboxY3LabelSingleGroupPerPlotTable.setentry('')
        if self.entryfieldYUserLabelSingleGroupPerPlotTable.get().strip() <> '':
            self.entryfieldYUserLabelSingleGroupPerPlotTable.setvalue('')
        
        self.entryfieldXLabelShowTable_Kiviat.setvalue('')
        self.entryfieldYLabelShowTable_Kiviat.setvalue('')
       
        return
        
        
    def handlerShowLabelsTable_Preview_AllGroupsPerWindow_Kiviat(self):
        '''
         Purpose:
            take user input from designated widgets in toplevel window
            "self.toplevelLabels_AllGroupsPerWindow_Kiviat"
            and display X and Y Labels for Kiviat plots in respective display fields;
            display error msg if no data to choose from
         '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 
                'handlerShowLabelsTable_Preview_AllGroupsPerWindow_Kiviat'
                )
                
# ------- ERROR CHECKING -------
# check if at least one group has been selected            
        if (
         self.varNumberOfTableGroups_Kiviat.get() == 0
           and
         self.varNumberOfStorageBufferCurves_Kiviat.get() == 0
         ):
            stringNoTableColumnsSelected = (
                'No columns have been selected from the current table\n' +
                'and no data has been selected from the storage buffer for\n' +
                'plotting kiviat diagrams.\n\n' +
                'At least 3 Y-select columns (for data) and 1 X-select\n' +
                'column (for legend) must be selected from the table, or\n' +
                'one group from the storage buffer, to continue.\n\n' +
                'Select proper data from table or storage buffer and try again.'
                )
            print(stringNoTableColumnsSelected)
            self.MySQL_Output(
                0,
                stringNoTableColumnsSelected
                )
            try:
                showerror(
                    'Error: no data',
                    stringNoTableColumnsSelected,
                    parent=self.toplevelLabels_AllGroupsPerWindow_Kiviat,
                    )
            except:
                showerror(
                    'Error: no data',
                    stringNoTableColumnsSelected
                    )
            return
# check if curves have been selected from table group, and also that
#   the "Plot group from Table" checkbutton is checked; if checkbutton is not
#   checked, it won't matter if any curves have been selected from table group
        if(
        self.varNumberOfTableCurves_Kiviat.get() == 0
            and
        (self.varCheckbuttonTableData_AllGroupsPerWindow_Kiviat.get() == 1
            or
        self.varCheckbuttonTableData_OneGroupPerWindow_Kiviat.get() == 1
            or
        self.varUseTableOrStorageBuffer_OneCurvePerPlot_Kiviat.get().strip() == 'table')
            ):
            stringNoTableRowsSelected = (
                'No rows have been selected from the table group.\n\n' +
                'Select at least one row of data and try again.'
                )
            print(stringNoTableRowsSelected)
            self.MySQL_Output(
                0,
                stringNoTableRowsSelected
                )
            showerror(
                'Error: no rows',
                stringNoTableRowsSelected
                )
            return
            
        if(
        self.varNumberOfStorageBufferGroups_Kiviat.get() <> 0
            and
        self.varNumberOfStorageBufferCurves_Kiviat.get() == 0
            and
        (
        (self.varGroupsSelection_Kiviat.get().strip() == copy.deepcopy(self.dictPlotParams_Defaults_Kiviat['plot_choice_group_1'])
            and
        self.varCheckbuttonBufferData_AllGroupsPerWindow_Kiviat.get() == 1
        )
            or
        (self.varGroupsSelection_Kiviat.get().strip() == copy.deepcopy(self.dictPlotParams_Defaults_Kiviat['plot_choice_group_2'])
            and
        self.varCheckbuttonBufferData_OneGroupPerWindow_Kiviat.get() == 1
        )
            or
        (self.varGroupsSelection_Kiviat.get().strip() == copy.deepcopy(self.dictPlotParams_Defaults_Kiviat['plot_choice_group_3'])
            and
        self.varUseTableOrStorageBuffer_OneCurvePerPlot_Kiviat.get().strip() == 'storage buffer'
        )
        )
        ):
            stringNoBufferRowsSelected = (
                'Buffer data has been selected but no rows are available\n' +
                'in the data for plotting.\n\n' +
                'Re-submit the storage buffer data or select another group\n' +
                'from the storage buffer.'
                )
            print(stringNoBufferRowsSelected)
            self.MySQL_Output(
                0,
                stringNoBufferRowsSelected
                )
            showerror(
                'Error: no rows',
                stringNoBufferRowsSelected
                )
            return
# ------- END OF ERROR CHECKING -------

# determine plot label separator
        separator = self.determinePlotLabelSeparator(
            self.comboboxPlotLabelSeparator_AllGroupsPerWindow_Kiviat.get()
            )
            
# determine x index and header
        '''
         index_X = self.varXSelect.get() - 1
         xHeader = self.tableStructure[index_X][0]
        '''
        
#        xHeader = self.headerNames_X[0]
 
# determine spoke labels
        self.spokeLabelsTable_Kiviat, self.justSpokeLabelsTable_Kiviat = \
            self.assembleSpokeLabelsTable_Kiviat()  
            
# determine legend title
# ... from 'handlerUpdateKiviatPlots_Table'
        legendTitle = self.label_X_Table_Kiviat
        
# determine x-values from selected rows, for legend values
        x_column = self.varXSelect.get() - 1

# determine legend labels; make sure all elements are strings
        legendLabels = [str(label) for label in self.plot_X_Table_Kiviat]
        
# circumferential plot values
        '''
        self.spokePlotValuesCircumferentialTable_Kiviat = []  
        for itemCount in range(len(self.plot_Y_Table_Kiviat[0])):
            tempList = []
            for listCount in range(len(self.plot_Y_Table_Kiviat)):
                tempList.append(self.plot_Y_Table_Kiviat[listCount][itemCount])
            self.spokePlotValuesCircumferentialTable_Kiviat.append(tempList)  
        '''

        if DEBUG_PRINT_PREVIEW_KIVIAT:
            print('\n' + '-'*80)
            print('\nIn handlerShowLabelsTable_Preview_AllGroupsPerWindow_Kiviat:')
            print('')
            print('x_column =\n%s' % x_column)
            print('')
            print('x_rows (self.rowsSelectedTable_Kiviat) =\n%s' % self.rowsSelectedTable_Kiviat)
            print(' ')
            print('y_columns (self.index_Y_Table_Kiviat) =\n%s' % self.index_Y_Table_Kiviat)
            print('')
            print('spokeLabels (self.spokeLabelsTable_Kiviat) =\n%s' % self.spokeLabelsTable_Kiviat)           
            print('')
            print('JUST the spoke labels (self.justSpokeLabelsTable_Kiviat) =\n%s' % self.justSpokeLabelsTable_Kiviat)
            print('')
            print('legendTitle (self.label_X_Table_Kiviat) =\n%s' % legendTitle)
            print('')
            print('legendLabels =\n%s' % legendLabels)
            print('')
            print('spoke plot values radial =\n%s' % self.plot_Y_Table_Kiviat)
            print('')
#            print('spoke plot values circumferential =\n%s' % self.spokePlotValuesCircumferentialTable_Kiviat)
#            print('')
            print('spoke max values =\n%s' % max(self.maxValuesYColumnsLocalTable_Kiviat))
            print('-'*80 + '\n')

# concatenate legend title string
        self.legendTitleStringTable_Kiviat = self.assembleLegendTitleString_Kiviat(legendTitle)
            
# concatenate legend label strings
        self.legendLabelStringTable_Kiviat = self.assembleLegendLabelStringTable_Kiviat(legendLabels)
            
# show strings in respective fields
#	self.entryfieldSpokeLabelTable_Preview_AllGroupsPerWindow_Kiviat
#		spoke label
#	self.entryfieldLegendTitleTable_Preview_AllGroupsPerWindow_Kiviat
#		legend title
#	self.entryfieldLegendLabelTable_Preview_AllGroupsPerWindow_Kiviat
#		legend label
        self.entryfieldSpokeLabelTable_Preview_AllGroupsPerWindow_Kiviat.setvalue(
			self.spokeLabelsTable_Kiviat[0]
			)
        self.entryfieldLegendTitleTable_Preview_AllGroupsPerWindow_Kiviat.setvalue(
			self.legendTitleStringTable_Kiviat
			)
        self.entryfieldLegendLabelTable_Preview_AllGroupsPerWindow_Kiviat.setvalue(
            self.legendLabelStringTable_Kiviat[0]
            )
                 
        return
        
    
    def assembleLegendLabelStringTable_Kiviat(self, legendLabels):
        '''
        Purpose:
            assemble legend label strings for Kiviat plots
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'assembleLegendLabelString_Kiviat')     
                
# determine plot label separator
        separator = self.determinePlotLabelSeparator(
            self.comboboxPlotLabelSeparator_AllGroupsPerWindow_Kiviat.get()
            )
            
# determine which rows are checked
        rowsChecked = []
        rowsCheckedIndex = 0
        for var in self.varSelectAnyRow:
            if var.get():
                rowsChecked.append(rowsCheckedIndex)
            rowsCheckedIndex += 1
            
# VARIABLES (taken from module "labels_AllGroupsPerWindow_Kiviat"
#	self.varCheckbuttonLegendLabelsTable_AllGroupsPerWindow_Kiviat
#		check if using x-values from table in the legend; can use numeric or text data
#	legendLabels
#		labels taken from x-column in table
# 	self.comboboxLegendLabelTable_1_AllGroupsPerWindow_Kiviat
#		first of any 3 text fields
#	self.comboboxLegendLabelTable_2_AllGroupsPerWindow_Kiviat
#		second of any 3 text fields
#	self.comboboxLegendLabelTable_3_AllGroupsPerWindow_Kiviat
# 		third of any 3 text fields
#	self.entryfieldLegendTitleTable_Preview_AllGroupsPerWindow_Kiviat
#		user entry field
        legendLabelStringTable_Kiviat = []
        rowCountIndex = 0
        for label in legendLabels:
            row = rowsChecked[rowCountIndex]
            legendLabelString = ''
            if self.varCheckbuttonLegendLabelsTable_AllGroupsPerWindow_Kiviat.get():
                legendLabelString += label
                
            field1=''
            try:
                field1 = self.comboboxLegendLabelTable_1_AllGroupsPerWindow_Kiviat.get().split('.')[1].strip()
            except:
                pass
            if field1:
                for key,value in self.dictColumnHeaders.iteritems():
                    if key == field1:                    
                        if(
                        self.tableValues[row][value-1] <> None
                        and
                        self.tableValues[row][value-1] <> ''
                        ):
                            if legendLabelString <> '':
                                legendLabelString += separator + str(self.tableValues[row][value-1])
                            else:
                                legendLabelString = str(self.tableValues[row][value-1])
                            break
                        else:
                            stringNoValue = (
                                'No value associated with field\n' +
                                '  - %s\n\n' +
                                'Select another field.'
                                ) % (
                                key
                                )
                            print('\n' + stringNoValue)
                            self.MySQL_Output(
                                0,
                                stringNoValue
                                )
                            try:
                                showerror(
                                    'Error: no value',
                                    stringNoValue,
                                    parent=self.toplevelKiviatPlotPreprocess
                                    )
                            except:
                                showerror(
                                    'Error: no value',
                                    stringNoValue
                                    )
                            return
                            
            field2=''
            try:
                field2 = self.comboboxLegendLabelTable_2_AllGroupsPerWindow_Kiviat.get().split('.')[1].strip()
            except:
                pass
            if field2:
                for key,value in self.dictColumnHeaders.iteritems():
                    if key == field2:
                        if(
                        self.tableValues[row][value-1] <> None
                        and
                        self.tableValues[row][value-1] <> ''
                        ):
                            if legendLabelString <> '':
                                legendLabelString += separator + str(self.tableValues[row][value-1])
                            else:
                                legendLabelString = str(self.tableValues[row][value-1])
                            break
                        else:
                            stringNoValue = (
                                'No value associated with field\n' +
                                '  - %s\n\n' +
                                'Select another field.'
                                ) % (
                                key
                                )
                            print('\n' + stringNoValue)
                            self.MySQL_Output(
                                0,
                                stringNoValue
                                )
                            try:
                                showerror(
                                    'Error: no value',
                                    stringNoValue,
                                    parent=self.toplevelKiviatPlotPreprocess
                                    )
                            except:
                                showerror(
                                    'Error: no value',
                                    stringNoValue
                                    )
                            return

            field3=''
            try:
                field3 = self.comboboxLegendLabelTable_3_AllGroupsPerWindow_Kiviat.get().split('.')[1].strip()
            except:
                pass
            if field3:
                for key,value in self.dictColumnHeaders.iteritems():
                    if key == field3:
                        if(
                        self.tableValues[row][value-1] <> None
                        and
                        self.tableValues[row][value-1] <> ''
                        ):
                            if legendLabelString <> '':
                                legendLabelString += separator + str(self.tableValues[row][value-1])
                            else:
                                legendLabelString = str(self.tableValues[row][value-1])
                            break
                        else:
                            stringNoValue = (
                                'No value associated with field\n' +
                                '  - %s\n\n' +
                                'Select another field.'
                                ) % (
                                key
                                )
                            print('\n' + stringNoValue)
                            self.MySQL_Output(
                                0,
                                stringNoValue
                                )
                            try:
                                showerror(
                                    'Error: no value',
                                    stringNoValue,
                                    parent=self.toplevelKiviatPlotPreprocess
                                    )
                            except:
                                showerror(
                                    'Error: no value',
                                    stringNoValue
                                    )
                            return
            
            userField = ''
            userField = self.entryfieldLegendLabelTable_User_AllGroupsPerWindow_Kiviat.get().strip()
            if userField:
                if legendLabelString == '':
                    legendLabelString = userField
                else:
                    legendLabelString += separator + userField
                    
            rowCountIndex += 1
            
            legendLabelStringTable_Kiviat.append(legendLabelString)
            
            
        return legendLabelStringTable_Kiviat
            

    def assembleSpokeLabelsTable_Kiviat(self):
        '''
        Purpose:
            Assemble text for spoke labels, depending on widget selection
            in 'KIVIAT PLOT LABELS' window
            
        Variables:
            self.varCheckbuttonSpokeLabelTable_AllGroupsPerWindow_Kiviat
        		int; checked if using y header for part of spoke label
            self.entryfieldSpokeLabelTable_AllGroupsPerWindow_Kiviat
                text; constant; user entry field
            self.varCheckbuttonMaxSpokeValueTable_AllGroupsPerWindow_Kiviat
                int; checked if using y-max value for part of spoke label
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'assembleSpokeLabelsTable_Kiviat')
                
# determine plot label separator
        separator = self.determinePlotLabelSeparator(
            self.comboboxPlotLabelSeparator_AllGroupsPerWindow_Kiviat.get()
            )

# spoke labels with max value appended
        spokeLabelsTable_Kiviat = []
# spoke labels without anything appended
        justSpokeLabels_Kiviat = []
        if DEBUG_KIVIAT:
            print('dwb: self.varNumberOfTableGroups_Kiviat.get() = %s' % self.varNumberOfTableGroups_Kiviat.get())
# iterate over each group (only 1 table group for now)
        for groupNumber in range(self.varNumberOfTableGroups_Kiviat.get()):
            if DEBUG_KIVIAT:
                print('dwb:....groupNumber = %s' % groupNumber)
# ... iterate over number of columns (spokes) selected (must be 3 or more; can't plot Kiviat diagrams with < 3 spokes!)
            for count in range(len(self.headerNames_Y_Table_Kiviat)):
                if DEBUG_KIVIAT:
                    print('dwb:........count = %s' % count)
                spokeLabel = ''
# if checked, include Y header in spoke label            
                if self.varCheckbuttonSpokeLabelTable_AllGroupsPerWindow_Kiviat.get():
                    spokeLabel = self.headerNames_Y_Table_Kiviat[count]
                
# if 'Y header' is checked and entry field is not empty, include entry in spoke label
#   preceded by a separator               
                if (
                self.varCheckbuttonSpokeLabelTable_AllGroupsPerWindow_Kiviat.get()
                and
                self.entryfieldSpokeLabelTable_AllGroupsPerWindow_Kiviat.get().strip() <> '' 
                ):
                    if DEBUG_KIVIAT:
                        print('dwb: #1')
                    spokeLabel += separator + self.entryfieldSpokeLabelTable_AllGroupsPerWindow_Kiviat.get().strip()
# if 'Y header is NOT checked and entry field is not empty, include entry in spoke label
#   NOT preceded by a separator
                elif self.entryfieldSpokeLabelTable_AllGroupsPerWindow_Kiviat.get().strip() <> '' :
                    if DEBUG_KIVIAT:
                        print('dwb: #2')
                    spokeLabel = self.entryfieldSpokeLabelTable_AllGroupsPerWindow_Kiviat.get().strip()
# just the spoke label without any appends is needed for plot subtitle
                justSpokeLabels_Kiviat.append(spokeLabel)
# if checked, include max value from each separate Y-select column            
                if self.varCheckbuttonMaxSpokeValueTable_AllGroupsPerWindow_Kiviat.get():
# if either of these is true, use a separator before showing max spoke value
                    if (
                    self.varCheckbuttonSpokeLabelTable_AllGroupsPerWindow_Kiviat.get()
                    or
                    self.entryfieldSpokeLabelTable_AllGroupsPerWindow_Kiviat.get().strip() <> ''
                    ):
# append separator and max value from each Y-select column
                        if DEBUG_KIVIAT:
                            print('dwb: #3')
                            print('self.varGroupsSelection_Kiviat.get().strip() = %s' % self.varGroupsSelection_Kiviat.get())
                            print("self.dictPlotParams_Defaults_Kiviat['plot_choice_group_1'] = %s " %
                                self.dictPlotParams_Defaults_Kiviat['plot_choice_group_1']
                                )
                            print("self.dictPlotParams_Defaults_Kiviat['plot_choice_group_2'] = %s " %
                                self.dictPlotParams_Defaults_Kiviat['plot_choice_group_2']
                                )
                        '''
                        if(
                        self.varGroupsSelection_Kiviat.get().strip() == self.dictPlotParams_Defaults_Kiviat['plot_choice_group_1']
                        or
                        self.varGroupsSelection_Kiviat.get().strip() == self.dictPlotParams_Defaults_Kiviat['plot_choice_group_2']
                        ):
                        
#                            spokeLabel += separator + '(' + str(self.maxValuesYColumnsLocalTable_Kiviat[count]) + ')'
                        '''
                        spokeLabel +=  '\n (max: ' + str(self.maxValuesYColumnsLocalTable_Kiviat[count]) + ')'
 
                    else:
# if no other parameters appear, append and show just the max value from each Y-select column
                        if DEBUG_KIVIAT:
                            print('dwb: #4')
                        spokeLabel = ' (max: ' + str(max(self.maxValuesYColumnsLocalTable_Kiviat[count]) + ')')

# append spoke label to list of all spoke labels from Table                            
                spokeLabelsTable_Kiviat.append(spokeLabel)   
        
        return (spokeLabelsTable_Kiviat,justSpokeLabels_Kiviat)
            
        
    def assembleLegendTitleString_Kiviat(self, legendTitle):
        '''
        Purpose:
            assemble title string for Kiviat plots
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'assembleTitleString_Kiviat')
                
# determine plot label separator
        separator = self.determinePlotLabelSeparator(
            self.comboboxPlotLabelSeparator_AllGroupsPerWindow_Kiviat.get()
            )
        
# VARIABLES:
#   self.varCheckbuttonLegendTitleTable_AllGroupsPerWindow_Kiviat
#       int; if checked, use x-header in legend title
#   self.entryfieldLegendTitleTable_User_AllGroupsPerWindow_Kiviat
#       user entry field
        legendTitleStringTable_Kiviat = ''
        if self.varCheckbuttonLegendTitleTable_AllGroupsPerWindow_Kiviat.get():
            legendTitleStringTable_Kiviat = legendTitle
            if self.entryfieldLegendTitleTable_User_AllGroupsPerWindow_Kiviat.get().strip() <> '':
                legendTitleStringTable_Kiviat += separator + \
                    self.entryfieldLegendTitleTable_User_AllGroupsPerWindow_Kiviat.get().strip()
            if self.varLegendIncludeNumberOfCurves_Kiviat.get():
                totalNumberOfCurvesToPlot_Kiviat = (
                    self.varNumberOfTableCurves_Kiviat.get() + self.varNumberOfStorageBufferCurves_Kiviat.get()
                    )
                legendTitleStringTable_Kiviat += ' (' + str(totalNumberOfCurvesToPlot_Kiviat) + ' curves)'
            
        elif self.entryfieldLegendTitleTable_User_AllGroupsPerWindow_Kiviat.get().strip() <> '':
            legendTitleStringTable_Kiviat += \
                self.entryfieldLegendTitleTable_User_AllGroupsPerWindow_Kiviat.get().strip()
            if self.varLegendIncludeNumberOfCurves_Kiviat.get():
                legendTitleStringTable_Kiviat += ' (' + str(len(self.totalNumberOfCurvesToPlot_Kiviat)) + ' curves)'
        elif self.varLegendIncludeNumberOfCurves_Kiviat.get():
            legendTitleStringTable_Kiviat = '(' + str(len(self.totalNumberOfCurvesToPlot_Kiviat)) + ' curves)'
        else:
            pass
            
        if DEBUG_KIVIAT:
            print('\n>>> legendTitleStringTable_Kiviat = %s' % legendTitleStringTable_Kiviat)

        return legendTitleStringTable_Kiviat
        
        
    def handlerShowLabelsTable_Preview_OneGroupPerWindow_Kiviat(self):
        '''
         Purpose:
            take user input from designated widgets in toplevel window
               "self.toplevelLabels_OneGroupPerWindow_Kiviat"
            and display X and Y Labels for Kiviat plots in respective display fields
         '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerShowLabelsTable_Preview_OneGroupPerWindow_Kiviat')
            
        showinfo(
            '',
            'handlerShowLabelsTable_Preview_OneGroupPerWindow_Kiviat\n' +
            'under construction'
            )
        return
        
        if (
         self.varNumberOfTableCurves.get() == 0
           and
         self.varNumberOfStorageBufferCurves.get() == 0
         ):
            stringNoTableRowsSelected = (
                'No data have been selected from the current table\n' +
                'or the buffer for plotting.\n\n' +
                'Please select at least one data pair and try again.'
                )
            print stringNoTableRowsSelected
            self.MySQL_Output(
                0,
                stringNoTableRowsSelected
                )
            try:
                showerror(
                    'Error: no data',
                    stringNoTableRowsSelected,
                    parent=self.toplevelLabelsSinglePlotPerCurve,
                    )
            except:
                showerror(
                    'Error: no data',
                    stringNoTableRowsSelected
                    )
            return
# determine x index and header
        '''
        index_X = self.varXSelect.get() - 1
        xHeader = self.tableStructure[index_X][0]
        '''
        
#        xHeader = self.headerNames_X[0]
 
# determine y index and header; only need the first one here 
        '''
        i = 0
        j = 0
        yHeaders = []
        index_Y = []
        for var in self.varYSelect:
            if var.get():
                index_Y.append(j)
                yHeaders.append(self.tableStructure[index_Y[i]][0])
                i += 1
            j+=1    
        '''
        yHeaders = []
        yHeaders.extend(self.headerNames_Y_Table)
        print ' yHeaders =\n',yHeaders        

# determine plot label separator
        separator = self.determinePlotLabelSeparator(
            self.comboboxPlotLabelSeparatorSingle.get()
            )

# concatenate X-label string
        self.xLabelStringTable = []
#        self.xLabelStringTable.append(xHeader)
        self.xLabelStringTable.append(self.headerNames_X_Table[0])
        if self.entryfieldXUserLabelSingleCurvePerPlotTable.get().strip() <> '':
            self.xLabelStringTable[0] += separator + self.entryfieldXUserLabelSingleCurvePerPlotTable.get()
        
# concatenate Y-label strings
        self.yLabelStringTable = []
        for header in yHeaders:
            yLabelString = header
            if self.comboboxY1LabelSingleCurvePerPlotTable.get().strip() <> '':
                field1 = self.comboboxY1LabelSingleCurvePerPlotTable.get()
                for key,value in self.dictColumnHeaders.iteritems():
                    if key == field1:
                        yLabelString += separator + self.tableValues[0][value-1]
                        break
            if self.comboboxY2LabelSingleCurvePerPlotTable.get().strip() <> '':
                field2 = self.comboboxY2LabelSingleCurvePerPlotTable.get()
                for key,value in self.dictColumnHeaders.iteritems():
                    if key == field2:
                        yLabelString += separator + self.tableValues[0][value-1]
                        break
            if self.comboboxY3LabelSingleCurvePerPlotTable.get().strip() <> '':
                field3 = self.comboboxY3LabelSingleCurvePerPlotTable.get()
                for key,value in self.dictColumnHeaders.iteritems():
                    if key == field3:
                        yLabelString += separator + self.tableValues[0][value-1]
                        break
            if self.entryfieldYUserLabelSingleCurvePerPlotTable.get().strip() <> '':
                yLabelString += separator + self.entryfieldYUserLabelSingleCurvePerPlotTable.get()
            self.yLabelStringTable.append(yLabelString)
            
# show strings in respective fields
        self.entryfieldXLabelShowTable.setvalue(self.xLabelStringTable[0])
        self.entryfieldYLabelShowTable.setvalue(self.yLabelStringTable[0])
                 
        return
             
        
    def handlerShowLabelsTable_Preview_OneCurvePerPlot_Kiviat(self):
        '''
         Purpose:
            take user input from designated widgets in toplevel window
               "self.toplevelLabels_OneCurvePerPlot_Kiviat"
            and display X and Y Labels for Kiviat plots in respective display fields
         '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 
                'handlerShowLabelsTable_Preview_OneCurvePerPlot_Kiviat'
                )
                
        showinfo(
            '',
            'handlerShowLabelsTable_Preview_OneCurvePerPlot_Kiviat\n' +
            'under construction'
            )
        return
            
        if (
         self.varNumberOfTableCurves.get() == 0
           and
         self.varNumberOfStorageBufferCurves.get() == 0
         ):
            stringNoTableRowsSelected = (
                'No data have been selected from the current table\n' +
                'or the buffer for plotting.\n\n' +
                'Please select at least one data pair and try again.'
                )
            print stringNoTableRowsSelected
            self.MySQL_Output(
                0,
                stringNoTableRowsSelected
                )
            try:
                showerror(
                    'Error: no data',
                    stringNoTableRowsSelected,
                    parent=self.toplevelLabelsSinglePlotPerCurve,
                    )
            except:
                showerror(
                    'Error: no data',
                    stringNoTableRowsSelected
                    )
            return
# determine x index and header
        '''
        index_X = self.varXSelect.get() - 1
        xHeader = self.tableStructure[index_X][0]
        '''
        
#        xHeader = self.headerNames_X[0]
 
# determine y index and header; only need the first one here 
        '''
        i = 0
        j = 0
        yHeaders = []
        index_Y = []
        for var in self.varYSelect:
            if var.get():
                index_Y.append(j)
                yHeaders.append(self.tableStructure[index_Y[i]][0])
                i += 1
            j+=1    
        '''
        yHeaders = []
        yHeaders.extend(self.headerNames_Y_Table)
        print ' yHeaders =\n',yHeaders        

# determine plot label separator
        separator = self.determinePlotLabelSeparator(
            self.comboboxPlotLabelSeparatorSingle.get()
            )

# concatenate X-label string
        self.xLabelStringTable = []
#        self.xLabelStringTable.append(xHeader)
        self.xLabelStringTable.append(self.headerNames_X_Table[0])
        if self.entryfieldXUserLabelSingleCurvePerPlotTable.get().strip() <> '':
            self.xLabelStringTable[0] += separator + self.entryfieldXUserLabelSingleCurvePerPlotTable.get()
        
# concatenate Y-label strings
        self.yLabelStringTable = []
        for header in yHeaders:
            yLabelString = header
            if self.comboboxY1LabelSingleCurvePerPlotTable.get().strip() <> '':
                field1 = self.comboboxY1LabelSingleCurvePerPlotTable.get()
                for key,value in self.dictColumnHeaders.iteritems():
                    if key == field1:
                        yLabelString += separator + self.tableValues[0][value-1]
                        break
            if self.comboboxY2LabelSingleCurvePerPlotTable.get().strip() <> '':
                field2 = self.comboboxY2LabelSingleCurvePerPlotTable.get()
                for key,value in self.dictColumnHeaders.iteritems():
                    if key == field2:
                        yLabelString += separator + self.tableValues[0][value-1]
                        break
            if self.comboboxY3LabelSingleCurvePerPlotTable.get().strip() <> '':
                field3 = self.comboboxY3LabelSingleCurvePerPlotTable.get()
                for key,value in self.dictColumnHeaders.iteritems():
                    if key == field3:
                        yLabelString += separator + self.tableValues[0][value-1]
                        break
            if self.entryfieldYUserLabelSingleCurvePerPlotTable.get().strip() <> '':
                yLabelString += separator + self.entryfieldYUserLabelSingleCurvePerPlotTable.get()
            self.yLabelStringTable.append(yLabelString)
            
# show strings in respective fields
        self.entryfieldXLabelShowTable.setvalue(self.xLabelStringTable[0])
        self.entryfieldYLabelShowTable.setvalue(self.yLabelStringTable[0])
                 
        return


    def handlerEnablePlotChoiceGroup_Kiviat(self):
        '''
         Purpose:
            to enable or disable plot selections checkbuttons depending on
                whether user selects choice 1, 2, or 3 for Kiviat diagrams
            
         Called by:
            handlerKiviatPlotPreprocess
        
         Calls:
                
         '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerEnablePlotChoiceGroup_Kiviat')
            
        plot_Selection_Kiviat = self.varGroupsSelection_Kiviat.get().strip()       
     
        if plot_Selection_Kiviat == self.dictPlotParams_Defaults_Kiviat['plot_choice_group_1']:
# ALL GROUPS PER WINDOW
# ... enable Plot Group From Table
            self.checkbuttonTableData_AllGroupsPerWindow_Kiviat.configure(state='normal')
# ... enable Plot Groups from Storage Buffer
            self.checkbuttonBufferData_AllGroupsPerWindow_Kiviat.configure(state='normal')
# ... disable Plot Group From Table for plot_one_group_per_window
            self.checkbuttonTableData_OneGroupPerWindow_Kiviat.configure(state='disable')
# ... disable Plot Groups from Storage Buffer for plot_one_group_per_window
            self.checkbuttonBufferData_OneGroupPerWindow_Kiviat.configure(state='disable')
# ... disable radiobuttons for Plot One Curve Per Window
            self.radiobuttonUseTable_OneCurvePerPlot_Kiviat.configure(state='disabled')
            self.radiobuttonUseBuffer_OneCurvePerPlot_Kiviat.configure(state='disabled')
# ... radiobuttons for local or global maximum
            self.radiobuttonLocal_AllGroupsPerWindow_Kiviat.configure(state='normal')
            self.radiobuttonGlobal_AllGroupsPerWindow_Kiviat.configure(state='normal')
            self.radiobuttonLocal_OneGroupPerWindow_Kiviat.configure(state='disabled')
            self.radiobuttonGlobal_OneGroupPerWindow_Kiviat.configure(state='disabled')
            
# ... update Buffer: Display

# ... kill other 'Kiviat Plot Labels' windows
# ...       kill 2nd option labels
            try:
                self.toplevelLabels_OneGroupPerWindow_Kiviat.destroy()
            except:
                pass
# ...       kill 3rd option labels
            try:
                self.toplevelLabels_OneCurvePerPlot_Kiviat.destroy()
            except:
                pass

        elif plot_Selection_Kiviat == self.dictPlotParams_Defaults_Kiviat['plot_choice_group_2']:
# ONE GROUP PER WINDOW
# ... enable Plot Group From Table
            self.checkbuttonTableData_AllGroupsPerWindow_Kiviat.configure(state='disable')
# ... enable Plot Groups from Storage Buffer
            self.checkbuttonBufferData_AllGroupsPerWindow_Kiviat.configure(state='disable')
# ... disable Plot Group From Table for plot_one_group_per_window
            self.checkbuttonTableData_OneGroupPerWindow_Kiviat.configure(state='normal')
# ... disable Plot Groups from Storage Buffer for plot_one_group_per_window
            self.checkbuttonBufferData_OneGroupPerWindow_Kiviat.configure(state='normal')
# ... disable radiobuttons for Plot One Curve Per Window
            self.radiobuttonUseTable_OneCurvePerPlot_Kiviat.configure(state='disabled')
            self.radiobuttonUseBuffer_OneCurvePerPlot_Kiviat.configure(state='disabled')
# ... radiobuttons for local or global maximum
            self.radiobuttonLocal_AllGroupsPerWindow_Kiviat.configure(state='disabled')
            self.radiobuttonGlobal_AllGroupsPerWindow_Kiviat.configure(state='disabled')
            self.radiobuttonLocal_OneGroupPerWindow_Kiviat.configure(state='normal')
            self.radiobuttonGlobal_OneGroupPerWindow_Kiviat.configure(state='normal')
            
            try:
                showerror(
                    'Error: not implemented',
                    'Plot function 2 has not been implemented',
                    parent=self.toplevelKiviatPlotPreprocess,
                    )
            except:
                showerror(
                    'Error: not implemented',
                    'Plot function 2 has not been implemented'
                    )
            return
            
# ... kill other 'Kiviat Plot Labels' windows
# ...       kill 1st option labels
            try:
                self.toplevelLabels_AllGroupsPerWindow_Kiviat.destroy()
            except:
                pass
# ...       kill 3rd option labels
            try:
                self.toplevelLabels_OneCurvePerPlot_Kiviat.destroy()
            except:
                pass

        elif plot_Selection_Kiviat == self.dictPlotParams_Defaults_Kiviat['plot_choice_group_3']:
# ONE CURVE PER WINDOW
# ... disable Plot Group From Table
            self.checkbuttonTableData_AllGroupsPerWindow_Kiviat.configure(state='disabled')
# ... disable Plot Groups from Storage Buffer
            self.checkbuttonBufferData_AllGroupsPerWindow_Kiviat.configure(state='disabled')
# ... disable Plot Group From Table for plot_one_group_per_window
            self.checkbuttonTableData_OneGroupPerWindow_Kiviat.configure(state='disable')
# ... disable Plot Groups from Storage Buffer for plot_one_group_per_window
            self.checkbuttonBufferData_OneGroupPerWindow_Kiviat.configure(state='disable')
# ... enable radiobuttons for Plot One Curve Per Window
            self.radiobuttonUseTable_OneCurvePerPlot_Kiviat.configure(state='normal')
            self.radiobuttonUseBuffer_OneCurvePerPlot_Kiviat.configure(state='normal')
# ... radiobuttons for local or global maximum
            self.radiobuttonLocal_AllGroupsPerWindow_Kiviat.configure(state='disabled')
            self.radiobuttonGlobal_AllGroupsPerWindow_Kiviat.configure(state='disabled')
            self.radiobuttonLocal_OneGroupPerWindow_Kiviat.configure(state='disabled')
            self.radiobuttonGlobal_OneGroupPerWindow_Kiviat.configure(state='disabled')
            
            try:
                showerror(
                    'Error: not implemented',
                    'Plot function 3 has not been implemented',
                    parent=self.toplevelKiviatPlotPreprocess,
                    )
            except:
                showerror(
                    'Error: not implemented',
                    'Plot function 3 has not been implemented'
                    )
            return
            
# ... kill other 'Kiviat Plot Labels' windows
# ...       kill 1st option labels
            try:
                self.toplevelLabels_AllGroupsPerWindow_Kiviat.destroy()
            except:
                pass
# ...       kill 2nd option labels
            try:
                self.toplevelLabels_OneGroupPerWindow_Kiviat.destroy()
            except:
                pass

        else:
            
# ERROR in plotSelection
            stringErrorplot_Selection_Kiviat = (
                'Error in module\n\n' +
                '  handlerEnablePlotChoiceGroup_Kiviat\n\n' +
                'The variable "plotSelection" has the value\n\n' +
                '  plotSelection = %s\n\n' +
                'and the value should be either\n\n' +
                '  - %s\n' +
                '  - %s\n' +
                '  - %s\n\n' +
                'Contact code administrator to correct this.'
                ) % (
                    plot_Selection_Kiviat,
                    self.dictPlotParams_Defaults_Kiviat['plot_choice_group_1'],
                    self.dictPlotParams_Defaults_Kiviat['plot_choice_group_2'],
                    self.dictPlotParmas_Defualts_Kiviat['plot_choice_group_3']
                    )
            print stringErrorplot_Selection_Kiviat
            self.MySQL_Output(
                 0,
                 stringErrorPlotSelectionKivait
                 )
            return 0
                 
        return 1

   
    def destroyPlotPreprocess_Kiviat(self):
        '''
        Purpose:
            close Kiviat Plotting Specs window and all related child windows
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'destroyPlotPreprocess_Kiviat')
            
# save location of label windows if toplevel exists
# ... for option 1 - all groups per window
        try: 
            self.labels_xWindowLocation_AllGroupsPerWindow_Kiviat = \
                self.toplevelLabels_AllGroupsPerWindow_Kiviat.winfo_rootx() - self.offsetWindowX
            self.labels_yWindowLocation_AllGroupsPerWindow_Kiviat = \
                self.toplevelLabels_AllGroupsPerWindow_Kiviat.winfo_rooty() - self.offsetWindowY
        except:
            pass

# ... for option 2 - one group per window
        try:
            self.labels_xWindowLocation_OneGroupPerWindow_Kiviat = \
                self.toplevelLabels_OneGroupPerWindow_Kiviat.winfo_rootx() - self.offsetWindowX
            self.labels_yWindowLocation_OneGroupPerWindow_kiviat = \
                self.toplevelLabels_OneGroupPerWindow_Kiviat.winfo_rooty() - self.offsetWindowY
        except:
            pass
# ... for option 3 - one curve per plot
        try: 
            self.labels_xWindowLocation_OneCurvePerPlot_Kiviat = \
                self.toplevelLabels_OneCurvePerPlot_Kiviat.winfo_rootx() - self.offsetWindowX
            self.labels_yWindowLocation_OneCurvePerPlot_kiviat = \
                self.toplevelLabels_OneCurvePerPlot_Kiviat.winfo_rooty() - self.offsetWindowY
        except:
            pass
        
# save location, then destroy main 'kiviat plotting specs' window,
#   which will destroy all child windows
        try:
            self.plottingspecs_xWindowLocation_Kiviat = self.toplevelKiviatPlotPreprocess.winfo_rootx() - self.offsetWindowX
            self.plottingspecs_yWindowLocation_Kiviat = self.toplevelKiviatPlotPreprocess.winfo_rooty() - self.offsetWindowY
            self.toplevelKiviatPlotPreprocess.destroy()
        except:
            pass
            
        return
        
        
    def handlerResetAllPlotKiviatSelect(self):
        '''
         Purpose: 
            reset all values in 'Kiviat Plotting Specs' window to default values
            
         '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerResetAllPlotKiviatSelect')
            
        self.plottingspecs_xWindowLocation_Kiviat = self.toplevelKiviatPlotPreprocess.winfo_rootx() - self.offsetWindowX
        self.plottingspecs_yWindowLocation_Kiviat = self.toplevelKiviatPlotPreprocess.winfo_rooty() - self.offsetWindowY
        self.toplevelKiviatPlotPreprocess.destroy()
# if NOT keeping the same groups to plot from previous, uncomment the following
# set number of groups to zero
#        self.jcountTable_Kiviat = 0
#        self.jcountBuffer_Kiviat = 0
# set number of checked rows and columns to zero
#        self.plot_Y_Table_Kiviat = []
#        self.plot_X_Table_Kiviat = []
#        self.plot_Y_Buffer_Kiviat = []
#        self.plot_X_Buffer_Kiviat = []
# refresh table display
#       self.???()

        self.handlerKiviatPlotPreprocess()
        
        return
            
        
    def handlerUpdateKiviatPlots_Buffer(self):
        '''
        Purpose: update Kiviat Plotting Specs window with buffer selection
        '''            
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerUpdateKiviatPlots_Buffer')
            
        showerror(
            'Error: not working',
            'This function is not working yet:\n' +
            'handlerUpdateKiviatPlots_Buffer'
            )
        return
            
# check if Kiviat Plot window exists
        try:
            mappedToplevelKiviatPlotPreprocess = self.toplevelKiviatPlotPreprocess.winfo_exists()
        except:
            mappedToplevelKiviatPlotPreprocess = False
            
        self.plot_X_Buffer_Kiviat = []
        self.plot_Y_Buffer_Kiviat = []
        
        jcountBuffer = 0
        self.jcountBuffer_Kiviat = 0
        self.listWhichBufferRowsAreChecked = []
#        inumWhichBufferRowsAreChecked = 0
        
        for (inum,var) in enumerate(self.varSelectAnyRow_Buffer):
            if var.get(): 
                jcountBuffer += 1
                self.listWhichBufferRowsAreChecked.append(
                    inum + 1
                        )
                        
        self.jcountBuffer_Kiviat = jcountBuffer
        
# if self.jcountBuffer is zero, show msg and return
        if not self.jcountBuffer_Kiviat:
            stringNoBufferData = (
                'No buffer data has been selected with which\n' +
                'to update Kiviat plots.\n\n' +
                'Select rows from the buffer and try again.'
                )
            print stringNoBufferData
            self.MySQL_Output(
                0,
                stringNoBufferData
                )
            showerror(
                'Error: no update',
                stringNoBufferData
                )
                
            return
        
#        self.varNumberOfStorageBufferCurves.set(self.jcountBuffer)
        
#        if self.varNumberOfStorageBufferCurves.get() <> 0:
        for indexBufferRow in self.listWhichBufferRowsAreChecked:
                index=indexBufferRow - 1
                self.plot_X_Buffer_Kiviat.append(self.bufferRowStore[index][13])
                self.plot_Y_Buffer_Kiviat.append(self.bufferRowStore[index][14]) 

# define header names taken from buffer
        self.headerNames_Y_Buffer_Kiviat = []
        self.headerNames_X_Buffer_Kiviat = []
        try:
            numBufferCurves = self.varNumberOfStorageBufferGroups_Kiviat.get()
        except:
            numBufferCurves = 0
#        if self.varNumberOfStorageBufferCurves.get():
        if numBufferCurves:
            for indexBufferRow in self.listWhichBufferRowsAreChecked:
                index=indexBufferRow - 1
                self.headerNames_Y_Buffer_Kiviat.append(
                    self.bufferRowStore[index][6] + ' (bufr row ' + str(indexBufferRow) + ')'
                    )
                self.headerNames_X_Buffer_Kiviat.append(
                    self.bufferRowStore[index][5]
                    )
                    
        if DEBUG_KIVIAT_BUFFER:                          
            print
            print '-'*50
            print ' self.headerNames_Y_Buffer_Kiviat =\n',self.headerNames_Y_Buffer_Kiviat
            print

        if not mappedToplevelKiviatPlotPreprocess:
# open X-Y Plot Specs window if it did not already exist by
# ... calling handerlPlotPreprocess
#            self.buttonTableValuesPlotFields.invoke()
            self.jcountTable_Kiviat = 0
            self.headerNames_Y_Table_Kiviat = []
            self.headerNames_X_Table_Kiviat = []
        else:
            try:
                mappedToplevelSummarize = self.toplevelSummarize.winfo_exists()
            except: 
                mappedToplevelSummarize = False
                
            if mappedToplevelSummarize:
                self.toplevelSummarize.destroy()

        self.handlerKiviatPlotPreprocess()
        
        return
        
        
    def handlerPlotKiviatSelect(self):
        '''
        Purpose:
            prepares data and labels for Kiviat plotting; 
            calls kiviat plot routine
        
        Calls:
            class Kiviat in module_KiviatMySQL_AllGroupsPerWindow
            
        Called by:
            handlerKiviatPlotPreprocess
            
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerPlotKiviatSelect')
            
        self.MySQL_Output(
            0,
            '  Database: ' + self.myDatabase + '  Table: ' +
            self.myTable
            )
            
        xwin=self.plots_xWindowLocation_Kiviat
        ywin=self.plots_yWindowLocation_Kiviat

#  re-plot in current plot window       
        replotPreviousPlot = self.varReplotInCurrentWindow_Kiviat.get()
# increase plot figure number if not checked
        if not replotPreviousPlot:
# increment the plot figure number to plot in separate window
            self.numberPylabPlotFigure_Kiviat += 1
        else:   
# do NOT increment plot figure number, but if zero, set to 1;
#   matplotlib will not plot a figure number of zero
            if self.numberPylabPlotFigure_Kiviat == 0:
                self.numberPylabPlotFigure_Kiviat = 100                

# GLOBAL PLOT PARAMETERS
        
# grid background color
        gridBackgroundColor = self.comboboxColorBackground_Kiviat.get()
        
# select plot type
#       plot_choice_group_1  = 'plot_all_groups_per_window'         all plots in one window, single or multiple plots, one group per plot
#       plot_choice_group_2  =  'plot_one_group_per_window'     one plot per window, single or multiple plots, one group per plot
#       plot_choice_group_3  = 'plot_one_curve_per_window'      all plots in one window, on selected group's curves, one curve per plot
        selectPlotType = self.varGroupsSelection_Kiviat.get()
            
# SUBTITLES (above each plot)
# spoke max value global:
# spoke labels:
# list of spoke max values
        self.labelMaxValue_Kiviat = self.justSpokeLabelsTable_Kiviat[self.indexMaxValue_Kiviat]
# title for use with max of all values
        if self.varButtonNormalizationMethod_Kiviat.get() == 'globalNorm':
            contentSubTitle_Kiviat = (
                'Normalization method: global -- uses max(' + self.labelMaxValue_Kiviat + 
                ') = ' + str(self.maxValueForAllGroupsGlobal_Kiviat)
                )
        elif self.varButtonNormalizationMethod_Kiviat.get() == 'localNorm':
            contentSubTitle_Kiviat = (
                'Normalization method: local -- uses max value of each spoke separately'
                )
        else:
            stringErrorNormalization = (
                'Normalization method is not valid.\n\n' +
                'Current method: %s\n\n' +
                'Allowed methods are either "local" or "global".\n' +
                'This is a coding error. Please contact code\n' +
                'administrator for help.\n\n' +
                'Kiviat plot process is halted.'
                ) % self.varButtonNormalizationMethod_Kiviat.get()
            print('\n' + stringErrorNormalization)
            self.MySQL_Output(
                0,
                stringErrorNormalization
                )
            try:
                showerror(
                    'Error: invalid normalization method',
                    stringErrorNormalization,
                    parent=self.toplevelKiviatPlotPreprocess
                    )
            except:
                showerror(
                    'Error: invalid normalization method',
                    stringErrorNormalization,
                    )
            return
            
# TABLE DATA
# include select curves from storage buffer if proper buttons are checked
        includeGroupFromTable = False
        if self.varNumberOfTableGroups_Kiviat.get() <> 0:
            if (
            (self.varGroupsSelection_Kiviat.get().strip() == copy.deepcopy(self.dictPlotParams_Defaults_Kiviat['plot_choice_group_1'])
                and
            self.varCheckbuttonTableData_AllGroupsPerWindow_Kiviat.get()
            )
            or
            (self.varGroupsSelection_Kiviat.get().strip() == copy.deepcopy(self.dictPlotParams_Defaults_Kiviat['plot_choice_group_2'])
                and
            self.varCheckbuttonTableData_OneGroupPerWindow_Kiviat.get()
            )
            or
            (self.varGroupsSelection_Kiviat.get().strip() == copy.deepcopy(self.dictPlotParams_Defaults_Kiviat['plot_choice_group_3'])
                and
            self.varUseTableOrStorageBuffer_OneCurvePerPlot_Kiviat.get().strip() == 'table'
            )
            ):
                includeGroupFromTable = True
           
# STORAGE BUFFER DATA
# ... NOT PRESENTLY USED
# include select cuves from storage buffer if proper buttons are checked
        includeGroupsFromStorageBuffer = False
        if self.varNumberOfStorageBufferGroups_Kiviat <> 0:
            if (
            (self.varGroupsSelection_Kiviat.get().strip() == copy.deepcopy(self.dictPlotParams_Defaults_Kiviat['plot_choice_group_1'])
                and
            self.varCheckbuttonBufferData_AllGroupsPerWindow_Kiviat.get()
            )
            or
            (self.varGroupsSelection_Kiviat.get().strip() == copy.deepcopy(self.dictPlotParams_Defaults_Kiviat['plot_choice_group_2'])
                and
            self.varCheckbuttonBufferData_OneGroupPerWindow_Kiviat.get()
            )
            or
            (self.varGroupsSelection_Kiviat.get().strip() == copy.deepcopy(self.dictPlotParams_Defaults_Kiviat['plot_choice_group_3'])
                and
            self.varUseTableOrStorageBuffer_OneCurvePerPlot_Kiviat.get().strip() == 'storage buffer'
            )
            ):
                includeGroupsFromStorageBuffer = True
                
# for now, inform user that PylotDB is not yet setup to plot Kiviat diagrams from the storage buffer
        if includeGroupsFromStorageBuffer:
            stringNoKiviatPlotsFromBuffer = (
                'PylotDB has detected settings that will try to plot\n' +
                'Kiviat charts using the storage buffer.\n\n' +
                'PylotDB is not yet setup to plot Kiviat charts\n' +
                'from the storage buffer.\n\n' +
                'Uncheck any buttons that set PylotDB to plot storage buffer\n' +
                'graphs and try again.'
                )
            print(stringNoKiviatPlotsFromBuffer)
            self.MySQL_Output(
                0,
                stringNoKiviatPlotsFromBuffer
                )
            try:
                showerror(
                    'Error: cannot plot buffer Kiviat charts',
                    stringNoKiviatPlotsFromBuffer,
                    parent=self.toplevelKiviatPlotPreprocess
                    )
            except:
                showerror(
                    'Error: cannot plot buffer Kiviat charts',
                    stringNoKiviatPlotsFromBuffer
                    )
            return
      
                    
# ---------------- ERROR CHECK -------------------------------
# ... NOT VALID FOR CURRENT CONFIGURATION
# no curves to plot if both includeGroupFromTable and includeGroupsFromStorageBuffer are False,
        if (
        includeGroupFromTable == False
        and
        includeGroupsFromStorageBuffer == False
        ):
            stringNoPlots = (
                'No options have been chosen to plot\n' +
                'Kiviat charts from either the table\n' +
                'or the storage buffer.\n\n' +
                'Select appropriate plot options and try again.'
                )
            print stringNoPlots
            self.MySQL_Output(
                0,
                stringNoPlots
                )
            try:
                showerror(
                    'Error: no plots selected',
                    stringNoPlots,
                    parent=self.toplevelKiviatPlotPreprocess,
                    )
            except:
                showerror(
                    'Error: no plots selected',
                    stringNoPlots
                    )
            return
            
        else:
# ...       if get here, everything should be ok
            pass

# ----------------- END OF ERROR CHECK -----------------------------------------

            
# if storage buffer data is to be included, find indices of checked data
        indexStorageBuffer = []
# delete these values later
        numCurvesSelectedInStorageBuffer = 0
# --- end of delete ---
        if (numCurvesSelectedInStorageBuffer and includeStorageBuffer):
            for icount,var in enumerate(self.varSelectAnyRow_Buffer):
                if var.get():
                    indexStorageBuffer.append(icount)
                    
# total number of plots
        numberOfPlots = 0
        numberOfPlotsFromTable = 0
        numberOfPlotsFromStorageBuffer = 0
# calculate total number of plots ...
# ... option 1
# ... USED BY DEFAULT
        if selectPlotType == self.dictPlotParams_Defaults_Kiviat['plot_choice_group_1']:
            if self.varCheckbuttonTableData_AllGroupsPerWindow_Kiviat.get():
                numberOfPlotsFromTable = self.varNumberOfTableGroups_Kiviat.get()
            if self.varCheckbuttonBufferData_AllGroupsPerWindow_Kiviat.get():
                numberOfPlotsFromStorageBuffer = self.varNumberOfStorageBufferGroups_Kiviat.get()
# ... option 2  
# ... NOT USED             
        elif selectPlotType == self.dictPlotParams_Defaults_Kiviat['plot_choice_group_2']:
            if self.varCheckbuttonTableData_OneGroupPerWindow_Kiviat.get():
                numberOfPlotsFromTable = self.varNumberOfTableGroups_Kiviat.get()
            if self.varCheckbuttonBufferData_OneGroupPerWindow_Kiviat.get():
                numberOfPlotsFromStorageBuffer = self.varNumberOfStorageBufferGroups_Kiviat.get()
# ... option 3    
# ... NOT USED            
        elif selectPlotType == self.dictPlotParams_Defaults_Kiviat['plot_choice_group_3']:
            if self.varUseTableOrStorageBuffer_OneCurvePerPlot_Kiviat.get().strip() == 'table':
                numberOfPlotsFromTable = self.varNumberOfTableGroups_Kiviat.get()
            else:
                numberOfPlotsFromStorageBuffer = self.varNumberOfStorageBufferGroups_Kiviat.get()
# ... if no option                
        else:
            stringPlotChoiceError = (
                'The plot type does not match the plot choice group given.\n\n' +
                'This is a code error. Please contact code administrator.'
                )
            print stringPlotChoiceError
            self.MySQL_Output(
                0,
                stringPlotChoiceError
                )
            showerror(
                'Error: improper plot type',
                stringPlotChoiceError
                )
            return
            
        numberOfPlots = numberOfPlotsFromTable + numberOfPlotsFromStorageBuffer

# form circumferential kiviat curves from columnar fields in database table        
        self.spokePlotValuesCircumferentialTable_Kiviat = [[]] 
        for numberPlot in range(numberOfPlots):
            for itemCount in range(len(self.plot_Y_Table_Kiviat[0])):
                tempList = []
                for listCount in range(len(self.plot_Y_Table_Kiviat)):
                    tempList.append(self.plot_Y_Table_Kiviat[listCount][itemCount])
                self.spokePlotValuesCircumferentialTable_Kiviat[numberPlot].append(tempList) 

        if DEBUG_KIVIAT:
            print('\n1. ' + '*'*50)
            print('\nnumber of plots = %s' % numberOfPlots)
            print('\nself.spokePlotValuesCircumferentialTable_Kiviat:')
            print(self.spokePlotValuesCircumferentialTable_Kiviat)
            
# check for "None" values
        noneSpokeValues = False
        for index in range(len(self.spokePlotValuesCircumferentialTable_Kiviat)):
            for index_inner in range(len(self.spokePlotValuesCircumferentialTable_Kiviat[0])):
                if None in self.spokePlotValuesCircumferentialTable_Kiviat[index][index_inner]:
                    noneSpokeValues = True
                
        if noneSpokeValues:
            stringNoneNotAllowed = (
                'The following list contains the value "None":\n\n' 
                )
            stringNoneNotAllowed += '  - Circumferential spoke values\n'
            stringNoneNotAllowed += (
                '\nThis list is not allowed to contain values of "None"\n' +
                'for plotting purposes.\n\n' +
                'De-select the fields containing "None" values and try again.'
                )
            showerror(
                'Error: "None" value not allowed',
                stringNoneNotAllowed,
                parent=self.toplevelKiviatPlotPreprocess
                )
            return
                
# NOTE: CHECK TO MAKE SURE THESE ARE GROUPS!!
            
# VARIABLES OF INTEREST
# from kiviat plotting specs window
#       number of groups to plot from table                        self.varNumberOfTableGroups_Kiviat
#       number of groups to plot from storage buffer               self.varNumberOfStorageBufferGroups_Kiviat
#       grid background color                                      self.comboboxColorBackground_Kiviat
#       plot subsequent plots in current window                    self.varReplotInCurrentWindow_Kiviat   # IntVar()
#       fill interior of curves                                    self.varCheckbuttonCurveFill_Kiviat     # IntVar()
#       show main title                                            self.varCheckbuttonShowTitle_Kiviat    #IntVar()
#           ... main title entry                                   self.varEntryShowTitle_Kiviat
#           ... size                                               self.comboboxFontTitle_Kiviat
#           ... color                                              self.comboboxColorTitle_Kiviat
#       show spoke labels                                          self.varShowLabels_Kiviat
#           ... size                                               self.comboboxFontLabels_Kiviat
#           ... color                                              self.comboboxColorLabels_Kiviat
#       show grids                                                 self.varShowGrid_Kiviat
#           ... labels size                                        self.comboboxFontGridLabels_Kiviat.get()
#           ... labels color                                       self.comboboxGridColorLabels_Kiviat
#           ... radial tick size                                   self.comboboxFontRadialTicks_Kiviat
#           ... radial tick color                                  self.comboboxColorRadialTicks_Kiviat
#       show legend                                                self.varCheckbuttonShowLegend_Kiviat
#           ... location                                           self.comboboxShowLegendLocation_Kiviat
#           ... size                                               self.comboboxFontLegend_Kiviat
#      
# plot group 1, 2, 3                                               self.varGroupsSelection_Kiviat = self.dictPlotParams_Defaults_Kiviat['plot_choice_group_1'], etc
# 1 :
#       ... plot group from table                                  self.varCheckbuttonTableData_AllGroupsPerWindow_Kiviat      # IntVar()
#       ... plot groups from storage buffer                        self.varCheckbuttonBufferData_AllGroupsPerWindow_Kiviat
#       ... use local maxima                                       self.varLocalOrGlobalMax_AllGroupsPerWindow_Kiviat      # StringVar
#       ... use global maxima                                          ... 'local' or 'global'
# 2:
#       ... plot group from table                                  self.varCheckbuttonTableData_OneGroupPerWindow_Kiviat       # IntVar
#       ... plot groups from storage buffer                        self.varCheckbuttonBufferData_OneGroupPerWindow_Kiviat      # IntVar
#       ... use local maxima                                       self.varLocalOrGlobalMax_OneGroupPerWindow_Kiviat       # StringVar
#       ... use global maxima                                          ... 'local' or 'global'
# 3
#       ... plot single group from table                           self.varUseTableOrStorageBuffer_OneCurvePerPlot_Kiviat      # StringVar
#       ... plot single group from storage buffer                      ... 'table' or 'storage buffer'

# from table
#      spoke labels                 self.spokeLabelsTable_Kiviat (list)
#       legend title                self.legendTitleStringTable_Kiviat (attribute)
#       legend labels               self.legendLabelStringTable_Kiviat (list)
#                   default         self.legendLabelStringTable_Kiviat_Default (list)
#       spoke values                self.spokePlotValuesCircumferentialTable_Kiviat (list of lists)
#       spoke max values local      max(self.maxValuesYColumnsLocalTable_Kiviat (list of lists)
#       spoke max values global     self.maxValuesYColumnsGlobal_Kiviat(list)
#       rows selected in table      self.rowsSelectedTable_Kiviat - 1

# Also in handlerUpdateKiviatPlots_Table, we have
#    self.headerNames_Y_Table_kiviat (spoke titles) 40291 set to self.headerNames_Y_Table_Kiviat
#    self.index_Y_Table_Kiviat (index + 1 of headerNames)
#    self.label_X_Table_Kiviat (legend title) 40324
#    columnX (column of x values for legend labels)
#    self.plot_X_Table_Kiviat (legend labels) 40607
#    self.plot_Y_Table_Kiviat (y values, in columnar list)
#    max(self.maxValuesYColumnsLocalTable_Kiviat
#    self.maxValuesYColumnsGlobal_Kiviat
#    self.rowsSelectedTable_Kiviat
#>> These are then used in 'Preview' and combined with other input to make up 
#        the entire string value, for example.

# default values (defined in 'handlerUpdateKiviatPlots_Table' and '..._Initialize'
#       legend labels - default     self.legendLabelStringTable_Kiviat_Default (list)     

# from storage buffer
# <needs to be done>

# self.varGroupsSelection_Kiviat values for
# option 1:         'plot_all_groups_per_window'
# option 2:         'plot_one_group_per_window'
# option 3:         'plot_one_curve_per_window'

# Toplevels displayed for ...
# option 1:         self.toplevelLabels_AllGroupsPerWindow_Kiviat
# option 2:         self.toplevelLabels_OneGroupPerWindow_Kiviat
# option 3:         self.toplevelLabels_OneCurvePerPlot_Kiviat

#------------------------------------------------------------
# plot option 1 -       
        if selectPlotType == self.dictPlotParams_Defaults_Kiviat['plot_choice_group_1']:
            if DEBUG_KIVIAT:
                print('\n2. ' + '*'*50)
                print('\nselectPlotOption = %s' % selectPlotType) 
                print('\nnumber of plots = %s\n' % numberOfPlots)
                print('')
                
# initialize, since following can contain both table and storage buffer values
# ...   legend title
            legendTitle = ''
# ...   legend labels
            legendLabels = []
# ...   spoke labels
            spokeLabels = []
# ...   spoke values
            spokeValues = []
# ...   spoke max values


# FROM TABLE
# determine variables, remembering that
#   'plot_choice_group_1' : 'plot_all_groups_per_window',
#   'plot_choice_group_2' : 'plot_one_group_per_window',
#   'plot_choice_group_3' : 'plot_one_curve_per_window',
# NOTE: these are defined below instead of in dictPlotParams. Reason: these are
#   defined in a separate window; if the window is closed, for example, we still
#   want at least default values to be assigned since then the Python MegaWidgets
#   won't be defined; hence, take care of this in the logic below!

# ... legend title
            if(
            self.varNumberOfTableGroups_Kiviat.get()    # number of groups to plot from table
                and
            ( (self.varGroupsSelection_Kiviat.get().strip() == copy.deepcopy(self.dictPlotParams_Defaults_Kiviat['plot_choice_group_1'])
            and
            self.varCheckbuttonTableData_AllGroupsPerWindow_Kiviat.get()   # 1. sub-option: plot group from table
            )
                or
            (self.varGroupsSelection_Kiviat.get().strip() == copy.deepcopy(self.dictPlotParams_Defaults_Kiviat['plot_choice_group_2'])
            and
            self.varCheckbuttonTableData_OneGroupPerWindow_Kiviat.get()
            ) )
            ):  
                if self.varCheckbuttonShowLegend_Kiviat.get():
                    try:
                        mapped1 = self.toplevelLabels_AllGroupsPerWindow_Kiviat.winfo_exists()
                    except:
                        mapped1 = False
                    try:
                        mapped2 = self.toplevelLabels_OneGroupPerWindow_Kiviat.winfo_exists()
                    except:
                        mapped2 = False
                    if(mapped1 or mapped2):
                        legendTitle = self.legendTitleStringTable_Kiviat 
                    else:
                        legendTitle = 'Legend'
                        
                    if DEBUG_KIVIAT:
                        print('\n3. ' + '*'*50)
                        print('mapped1, mapped2, legendTitle = %s, %s, %s' % 
                            (mapped1, mapped2, legendTitle)
                            )

# ... legend labels                        
            if legendTitle <> '':
                try:
                    mapped1 = self.toplevelLabels_AllGroupsPerWindow_Kiviat.winfo_exists()
                except:
                    mapped1 = False
                try:
                    mapped2 = self.toplevelLabels_OneGroupPerWindow_Kiviat.winfo_exists()
                except:
                    mapped2 = False
                    
                if(mapped1 or mapped2):
                    legendLabels.extend(self.legendLabelStringTable_Kiviat)
                else:
                    legendLabels.extend(self.legendLabelStringTable_Kiviat_Default)
                    
                if DEBUG_KIVIAT:
                    print('legendLabels = %s' % legendLabels)
                    
# ... spoke labels
            if self.varNumberOfTableGroups_Kiviat.get():
                try:
                    mapped1 = self.toplevelLabels_AllGroupsPerWindow_Kiviat.winfo_exists()
                except:
                    mapped1 = False
                try:
                    mapped2 = self.toplevelLabels_OneGroupPerWindow_Kiviat.winfo_exists()
                except:
                    mapped2 = False
                try:
                    mapped3 = self.toplevelLabels_OneCurvePerPlot_Kiviat.winfo_exists()
                except:
                    mapped3 = False
                    
                if(mapped1 or mapped2 or mapped3):
                    spokeLabels = self.spokeLabelsTable_Kiviat
                else:
                    spokeLabels = self.headerNames_Y_Table_Kiviat
                    
                if DEBUG_KIVIAT:
                    print('\n4. ' + '*'*50)
                    print('\nmapped1, mapped2, mapped3 = %s, %s, %s' % 
                        (mapped1, mapped2, mapped3)
                        )
                    print('\nspokeLabels = %s' % spokeLabels)

# ... spoke values, normalized with either local or global maxima
            if(
            self.varNumberOfTableGroups_Kiviat.get()
                and
            self.varGroupsSelection_Kiviat.get().strip() == self.dictPlotParams_Defaults_Kiviat['plot_choice_group_1']
                and
            self.varCheckbuttonTableData_AllGroupsPerWindow_Kiviat.get()
            ):
                spokeValues = self.spokePlotValuesCircumferentialTable_Kiviat
                if (
                self.varLocalOrGlobalMax_AllGroupsPerWindow_Kiviat.get() == 'local'
                ):

                    if DEBUG_KIVIAT:
                        print('\n5. ' + '*'*50)
                        print('spokeValues = \n%s' % spokeValues)
                        print('')
#                        print('maxValues = \n%s' % max(self.maxValuesYColumnsLocalTable_Kiviat))
                        print('maxValues = \n%s' % (self.maxValuesYColumnsLocalTable_Kiviat))
                        print('\n' + '*')
                    
                    numCurvesPerPlot = len(spokeValues[0])
                    numPointsPerCurve = len(spokeValues[0][0])
                    for numPlot in range(numberOfPlots):
                        for numCurve in range(numCurvesPerPlot):
                            for numPoint in range(numPointsPerCurve):
                                try:
                                    if self.varButtonNormalizationMethod_Kiviat.get() == 'globalNorm':
                                        denominator = self.maxValuesForEachGroupLocal_Kiviat[numPlot]
                                        if type(denominator) == int  or type(denominator) == long:
                                            denominator = float(denominator)
                                        ratio = spokeValues[numPlot][numCurve][numPoint]/denominator
                                    else:
                                        denominator = self.maxValuesYColumnsLocalTable_Kiviat[numPoint]
                                        if type(denominator) == int or type(denominator) == long:
                                            denominator = float(denominator)
                                        print('\n***** denominator = %s' % denominator)
                                        print('***** type(denominator) = %s' % type(denominator))
                                        print('*****spokeValues[][][] = %s' % spokeValues[numPlot][numCurve][numPoint])
                                        ratio = spokeValues[numPlot][numCurve][numPoint]/denominator
                                except:
                                    ratio = 0.
                                
                                if DEBUG_KIVIAT:
                                    if self.varButtonNormalizationMethod_Kiviat.get() == 'globalNorm':
                                        print('\nNormalization method: globalNorm')
                                        print('numPlot, numCurve, numPoint = %s, %s, %s' % (numPlot + 1, numCurve, numPoint))
                                        print('    spokeValue, maxValue (global), ratio = %s, %s, %s' % (
                                            spokeValues[numPlot][numCurve][numPoint],
                                            self.maxValuesForEachGroupLocal_Kiviat[numPlot],
                                            ratio,
                                            ))
                                    else:
                                        print('\nNormalization method: localNorm')
                                        print('numPlot, numCurve, numPoint = %s, %s, %s' % (numPlot + 1, numCurve, numPoint))
                                        print('    spokeValue, maxValue (local), ratio = %s, %s, %s' % (
                                            spokeValues[numPlot][numCurve][numPoint],
                                            self.maxValuesYColumnsLocalTable_Kiviat[numPoint],
                                            ratio,
                                            ))
                                            
# determine if spoke values will be equal to Y or (1-Y); sometimes, (1-Y) make for better plots
                                if self.varRadiobuttonPlotFormat_Kiviat.get() == 'asIs':
                                    spokeValues[numPlot][numCurve][numPoint] = ratio
                                elif self.varRadiobuttonPlotFormat_Kiviat.get() == 'complement':
                                    spokeValues[numPlot][numCurve][numPoint] = 1.0 - ratio
                                else:
                                    stringErrorPlotFormat = (
                                        'Selection for self.varRadiobuttonPlotFormat is\n\n' +
                                        '  %s\n\n' +
                                        'Valid values are either "asIs" or "complement".\n\n' +
                                        'This is a coding error. Please contact code administrator.\n\n' +
                                        'Kiviat plot process is halted.'
                                        ) % self.varRadiobuttonPlotFormat.get()
                                    print(stringErrorPlotFormat)
                                    self.MySQL_Output(
                                        0,
                                        stringErrorPlotFormat
                                        )
                                    try:
                                        showerror(
                                            'Error: invalid plot format',
                                            stringErrorPlotFormat,
                                            parent=self.toplevelKiviatPlotPreprocess,
                                            )
                                    except:
                                        showerror(
                                            'Error: invalid plot format',
                                            stringErrorPlotFormat,
                                            )
                                    return
                                        
                                
# local values divided by max value for each plot
#                                spokeValues[numPlot][numCurve][numPoint] = ratio
                elif (
                self.varLocalOrGlobalMax_AllGroupsPerWindow_Kiviat.get() == 'global'
                ):
# NOT CURRENTLY USED
# use global maxima to normalize data; spoke values are a list of lists; max values are just a list
                    for indexList in range(len(spokeValues)):
                        for indexItem in range(indexList):
# local values divided by global for each plot
                            spokeValues[indexList][indexItem] /= self.maxValuesYColumnsGlobal_Kiviat[indexItem]
# local values divided by max for all plots
#                            spokeValues[indexList][indexItem] /= self.maxValueForAllGroupsGlobal_Kiviat
                else:
                
                    stringNoLocalOrGlobalMaxima = (
                        'No local or global maxima choice is available.\n' +
                        'Current variables used to define this parameter are:\n\n' +
                        '  self.varLocalOrGlobalMax_AllGroupsPerWindow_Kiviat = %s\n\n' +
                        '  self.varLocalOrGlobalMax_OneGroupPerWindow_Kiviat = %s\n\n' +
                        'This indicates a possible coding error.\n\n' +
                        'Contact the code administrator about this problem.'
                        ) % (
                        self.varLocalOrGlobalMax_AllGroupsPerWindow_Kiviat.get(),
                        self.varLocalOrGlobalMax_OneGroupPerWindow_Kiviat.get()
                        )
                    print stringNoLocalOrGlobalMaxima
                    self.MySQL_Output(
                        0,
                        stringNoLocalOrGlobalMaxima
                        )
                    showerror(
                        'Error: no maxima',
                        stringNoLocalOrGlobalMaxima
                        )
                    return   
            
            if DEBUG_KIVIAT:
                print('\n6. ' + '*'*50)
                print('\nGlobal or local?   %s' % self.varLocalOrGlobalMax_AllGroupsPerWindow_Kiviat.get())
                print('\nspokeValues = \n%s' % spokeValues)
                print


# FROM STORAGE BUFFER
#  < to be done>

# change grid line style to parameter matplotlib understands
            lineStyle = self.comboboxGridLineStyle_Kiviat.get()
            if lineStyle == 'solid':
                gridLineStyle = '-'
            elif lineStyle == 'dash':
                gridLineStyle = '--'
            elif lineStyle == 'dot':
                gridLineStyle = ':'
            elif lineStyle == 'dash-dot':
                gridLineStyle = '-.'
            else:
                stringErrorGridLineStyle = (
                    'The value used for "gridLineStyle" is not allowed.\n\n' +
                    'Current value: %s\n\n' +
                    'Allowed values: solid, dash, dot, dash-dot\n\n' +
                    'Value will now default to "dot".'
                    ) % (gridLineStyle)
                print(stringErrorGridLineStyle)
                showerror(
                    'Error: invalid value',
                    stringErrorGridLineStyle
                    )
                gridLineStyle = ':'

# organize plot data from table using dict for plotData
            plotData = {}
            for numPlot in range(numberOfPlots):
# format: plot_title : list_of_plot_values_for_all_spokes_in_plot
                plotData['Plot ' + str(numPlot + 1)] = spokeValues[numPlot]
                
            if DEBUG_KIVIAT:
                print('\n7. ' + '*'*50)
                print('\n' + 'dict plotData = \n%s' % plotData)
                print('\nspokeValues (normalize) = \n%s' % spokeValues)

# setup dictionary of plot parameters         
            plotParams = {}
            plotParams = {
            # TITLE
                'plotTitle' : self.varEntryShowTitle_Kiviat.get(), # main plot title
                'showTitle' : self.varCheckbuttonShowTitle_Kiviat.get(), # main title (True/False)
                'fontsizeTitle' : int(self.comboboxFontTitle_Kiviat.get()), # sets font for title only (8-32; default 20)
                'colorTitle' : self.comboboxColorTitle_Kiviat.get(), # sets color of title
                'weightTitle' : self.comboboxFontWeightTitle_Kiviat.get(), # title weight: normal, bold
                'xTitleLocation' : float(self.comboboxXLocationTitle_Kiviat.get()), # practical range 0.1 -> 0.9
                'yTitleLocation' : float(self.comboboxYLocationTitle_Kiviat.get()), # practical range 0.1 -> 0.98
            # FIGURE
                'figureSize' : (float(self.comboboxFigureSizeWidth_Kiviat.get()),float(self.comboboxFigureSizeHeight_Kiviat.get())), 
                                # size of figure window relative to screen (default: (16,12))
            # SUBTITLES
                'showSubTitles' : self.varCheckbuttonShowSubTitle_Kiviat.get(), # individual plot titles (True/False)
                'showSubTitleContent' : contentSubTitle_Kiviat, # plot subtitle, "Normalization factor: "
                'subtitleSize' : int(self.comboboxFontSubTitle_Kiviat.get()),    # subtitle font size (8->24; default 16)
                'subtitleColor' : self.comboboxColorSubTitle_Kiviat.get(),    # subtitle color; default 'black'
                'subtitleWeight' : self.comboboxFontWeightSubTitle_Kiviat.get(),    # subtitle weight (normal, bold; default bold)
                'xSubTitleLocation' : float(self.comboboxXLocationSubTitle_Kiviat.get()),
                'ySubTitleLocation' : float(self.comboboxYLocationSubTitle_Kiviat.get()), # practical range: 1.10 -> 1.25; default 1.15; increment by .01                
            # LEGEND
                'titleLegend' : legendTitle,
                'showLegend' : self.varCheckbuttonShowLegend_Kiviat.get(), # should be True,
                'valueLegendLocation' : 'best',  # use 'bottom center'; orig values [0.9, 0.95]; seems relative (can be 'upper right')
                'valueLegendLabelSpacing' : float(self.comboboxLegendLabelSpacing_Kiviat.get()),    # can vary between 0 and 1; default 0.2; space between legend lines
                'fontsizeLegend' : int(self.comboboxLegendTitleFont_Kiviat.get()),    # can vary from 10 -> 32; default 14
                'numberOfColumnsLegend' : int(self.comboboxLegendNumColumns_Kiviat.get()), # number of columns in legend; 1 -> 3; default 1
                'paddingBorderLegend' : float(self.comboboxLegendBorderPadding_Kiviat.get()), # padding between outer part of legend box and text; default 0.8; 0 -> 1
                'modeLegend' : 'expand',    # either 'expand' across figure, or None (no quotes)
                'locationBBoxLegend' : (float(self.comboboxXLocationLegend_Kiviat.get()), float(self.comboboxYLocationLegend_Kiviat.get()) ), 
                                        # x-y location of legend bounding box
                'legendLabels' : legendLabels,
            # SPOKE LABELS
                'showSpokeLabels' : self.varShowLabels_Kiviat.get(), # if False, angles in degrees will be displayed; not helpful
                'fontsizeSpokeLabels' : int(self.comboboxFontLabels_Kiviat.get()), # font for spoke labels; 8-32; default 14
                'colorSpokeLabels' : self.comboboxColorLabels_Kiviat.get(), # color for spoke labels
                'spokeLabels' : spokeLabels, # list of spoke labels
            # BACKGROUND COLOR
                'colorBackground' : self.comboboxColorBackground_Kiviat.get(),    # plot background color; default 'lightblue'
            # INTERIOR COLOR
                'colorPlot' : self.comboboxColorInterior_Kiviat.get(), # interior color of plot; default 'white'
            # LINES
                'plotLineWidth' : float(self.comboboxLineWidth_Kiviat.get()), # vary between 1 and 10; default 2
            # GRID
                'showGrid' : self.varShowGrid_Kiviat.get(), # show grid on plots
                'gridColor' : self.comboboxGridColor_Kiviat.get(),      # color of radial and circumferential grids lines
                'gridYTickColor' : self.comboboxGridColorLabels_Kiviat.get(),   # color of numbers delineating gridStepSize
                'gridYTickFontSize' : int(self.comboboxFontGridLabels_Kiviat.get()),   # font size for grid increment numbers
                'gridLineWidth' : float(self.comboboxGridLineWidth_Kiviat.get()),      # width of radial and circumferential grid lines
                'gridLineStyle' : gridLineStyle,      # style of grid; can be ':'=dotted, '-'=solid, '--'=dashed, '|'=, '-.'=dash-dot
                'gridStepSize' : float(self.comboboxGridIncrement_Kiviat.get()),       # radial grid increments: 0.1, 0.2, or 0.5 only; default 0.5(no user input)
            # OPACITY OF FILLED REGIONS IN KIVIAT DIAGRAM
                'alphaFactor' : float(self.comboboxFillColorOpacity_Kiviat.get()), # range of 0 (clear) to 1 (opaque); default 0.2
            # SPECIFY IF RADIUS SHOULD ALWAYS BE 1, OR MAX RADIAL VALUE <= 1
                'absoluteRadius' : self.varCheckbuttonSetMaxPlotRadius_Kiviat.get(),    # if True, sets normalized circle radius to 'absoluteRadiusMax'
                                            #  if False, sets normalized radius to max value of data for each plot (floating radius)
            # SPECIFY MAX RADIUS VALUE, USED WHEN 'absoluteRadius' is True
                'absoluteRadiusMax' : float(self.comboboxSetMaxPlotRadius_Kiviat.get()),  # used when 'absoluteRadius' is True
            # PLOT DATA
                'plotData' : plotData,
                }
                
# check some values from plotParams
            if DEBUG_KIVIAT:
                print('\n***** SOME CHECKS *****')
                print('GRID:')
                print("plotParams['showGrid'] = %s" % plotParams['showGrid'])
                print("plotParams['gridColor'] = %s" % plotParams['gridColor'])
                print("plotParams['gridYTickColor'] = %s" % plotParams['gridYTickColor'])
                print("plotParams['gridYTickFontSize'] = %s" % plotParams['gridYTickFontSize'])
                print("plotParams['gridLineWidth'] = %s" % plotParams['gridLineWidth'])
                print("plotParams['gridLineStyle'] = %s" % plotParams['gridLineStyle'])
                print("plotParams['gridStepSize'] = %s" % plotParams['gridStepSize'])
                print('BACKGROUND COLOR')
                print("plotParams['colorBackground'] = %s" % plotParams['colorBackground'])
#                sys.exit()

# ALL PLOTS IN ONE WINDOW         
            module_Kiviat_1.Kiviat(
                replotPreviousPlot,             # keep previous plot
                150,                                # xwin location
                150,                                # ywin location
                self.numberPylabPlotFigure_Kiviat,  # number of Pylab plot figure number
                **plotParams                        # plot parameters
                )

# -----------------------------------------------------------------
# plot option 2 - one plot per window, single or multiple plots, one group per plot
        elif selectPlotType == self.dictPlotParams_Defaults_Kiviat['plot_choice_group_2']:
            if DEBUG_KIVIAT:
                print('\n**** selectPlotType = %s ****' % selectPlotType) 
                
            try:
                showerror(
                    'Error: not yet implemented',
                    'Choice #2 is under construction and\n' +
                    'will be implemented as soon as possible.',
                    parent=self.toplevelKiviatPlotPreprocess
                    )
            except:
                showerror(
                    'Error: not yet implemented',
                    'Choice #2 is under construction and\n' +
                    'will be implemented as soon as possible.'
                    )
            return
            
# ... spoke values, normalized with either local or global maxima
            if(
            self.varNumberOfTableGroups_Kiviat.get()
                and
            (self.varGroupsSelection_Kiviat.get().strip() == copy.deepcopy(self.dictPlotParams_Defaults_Kiviat['plot_choice_group_2'])
            and
            self.varCheckbuttonTableData_OneGroupPerWindow_Kiviat.get()
            )
            ):
                spokeValues = self.spokePlotValuesCircumferentialTable_Kiviat
                if (
                self.varLocalOrGlobalMax_OneGroupPerWindow_Kiviat.get().strip() == 'local'
                ):
# use local maxima to normalize data; both spoke values and max values are a list of lists
                    '''
                    jcount = 0
                    for list in spokeValues:
                        for index in range(len(list)):
                            spokeValues[jcount][index] /= max(self.maxValuesYColumnsLocalTable_Kiviat[jcount][index]
                        jcount += 1
                    '''
                    
                    print('\n' + '*'*50)
                    print('spokeValues = \n%s' % spokeValues)
                    print('')
                    print('maxValues = \n%s' % max(self.maxValuesYColumnsLocalTable_Kiviat))
                    print('\n' + '*')
                    
                    for indexList in range(len(spokeValues)):
                        for indexItem in range(spokeValues[0]):
                            spokeValues[indexList][indexItem] /= max(self.maxValuesYColumnsLocalTable_Kiviat[indexList][indexItem])
                   
                elif(
                self.varLocalOrGlobalMax_OneGroupPerWindow_Kiviat.get().strip() == 'global'
                ):
# use global maxima to normalize data; spoke values are a list of lists; max values are just a list
                    for indexList in range(len(spokeValues)):
                        for indexItem in range(indexList):
                            spokeValues[indexList][indexItem] /= self.maxValuesYColumnsGlobal_Kiviat[indexItem]
                else:
                    stringNoLocalOrGlobalMaxima = (
                        'No local or global maxima choice is available.\n' +
                        'Current variables used to define this parameter are:\n\n' +
                        '  self.varLocalOrGlobalMax_AllGroupsPerWindow_Kiviat = %s\n\n' +
                        '  self.varLocalOrGlobalMax_OneGroupPerWindow_Kiviat = %s\n\n' +
                        'This indicates a possible coding error.\n\n' +
                        'Contact the code administrator about this problem.'
                        ) % (
                        self.varLocalOrGlobalMax_AllGroupsPerWindow_Kiviat.get(),
                        self.varLocalOrGlobalMax_OneGroupPerWindow_Kiviat.get()
                        )
                    print stringNoLocalOrGlobalMaxima
                    self.MySQL_Output(
                        0,
                        stringNoLocalOrGlobalMaxima
                        )
                    showerror(
                        'Error: no maxima',
                        stringNoLocalOrGlobalMaxima
                        )
                    return               

# -----------------------------------------------------------------
# plot option 3 - one plot per window, single or multiple plots, one group per plot                
        elif selectPlotType == self.dictPlotParams_Defaults_Kiviat['plot_choice_group_3']:
            if DEBUG_KIVIAT:
                print('\n**** selectPlotType = %s ****' % selectPlotType) 
                
            try:
                showerror(
                    'Error: not yet implemented',
                    'Choice #3 is under construction and\n' +
                    'will be implemented as soon as possible.',
                    parent=self.toplevelKiviatPlotPreprocess
                    )
            except:
                showerror(
                    'Error: not yet implemented',
                    'Choice #3 is under construction and\n' +
                    'will be implemented as soon as possible.'
                    )
            return
# ------------------------------------------------------------------        
# ERROR        
        else:
            stringSelectError = (
                'Selection error:\n' +
                '  selection should be "plot_choice_group_1" or "2" or "3".\n' +
                '  selection = ' + selectPlotType + '\n'
                'This is a coding error. Contact code administrator.\n' +
                'The plotting process is terminated.' + '\n'
                )
            print stringSelectError
            self.MySQL_Output(
                1,
                stringSelectError
                )
            showerror(
                'Error: invalid selection value',
                '\n' + stringSelectError + '\n'
                )
                
        return
        
            
    def handlerCloseAllKiviatPlots(self):
        '''
        Purpose:
            close all plots
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'handlerCloseAllKiviatPlots')

# close all plots
        pylab.close('all')
        
        return
        
        
# ================= kiviat end ========================= 


    def infoSystem_MySQL_Access(self):
        '''
        Purpose:
            determine various user and system parameters
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'infoSystem_MySQL_Access')
        
        import time
        
#        self.processorBitWidth = platform.architecture()[0]
# python version
        try:
            self.versionPython = platform.python_version()
        except:
            self.versionPython = 'UNK'
# get server name
        serverName = self._hostMySQL_Save
# if windows ...
        if os.name == 'nt':
            self.userName = os.environ['USERNAME']
#            self.computerName = os.environ['COMPUTERNAME']
            self.computerName = socket.gethostname()
            self.operatingSystem = os.environ['OS']
#            self.processorArchitecture = os.environ['PROCESSOR_ARCHITECTURE']
#            self.processorIdentifier = os.environ['PROCESSOR_IDENTIFIER']
#            self.sessionName = os.environ['SESSIONNAME']
# if unix ...
        elif os.name == 'posix':
            self.userName = os.environ['USER']
#            self.computerName = os.environ['HOSTNAME']
            self.computerName = socket.gethostname()
            self.operatingSystem = '*nix'
#            self.processorArchitecture = 'UNK'
#            self.processorIdentifier = 'UNK'
#            self.sessionName = 'UNK'
# if unknown ...
        else:
            try:
                self.userName = os.environ['USER']
            except:
                self.userName = 'UNK'
            try:
                self.computerName = os.environ['HOSTNAME']
            except:
                self.computerName = 'UNK'
            try:
                self.operatingSystem = os.environ['OS']
            except:
                self.operatingSystem = 'UNK'
            '''
            try:
                self.processorArchitecture = os.environ['PROCESSOR_ARCHITECTURE']
            except:
                self.processorArchitecture = 'UNK'
            try:
                self.processorIdentifier = os.environ['PROCESSOR_IDENTIFIER']
            except:
                self.processorIdentifier = 'UNK'
            try:
                self.sessionName = os.environ['SESSIONNAME']
            except:
                self.sessionName = 'UNK'
            try:
                self.processorBitWidth = platform.architecture()[0]
            except:
                self.processorBitWidth = 'UNK'
            '''

# just in case the following behaves differently for windows vs. *nix....
#        if subprocess.mswindows:
        '''
        self.currentDirectory = os.getcwd().split('\\').pop()
        self.currentDirectoryFullPath = os.getcwd()
        '''
#        else:
#            self.currentDirectory=os.getcwd().split('\\').pop()

# print date
#        localDateTime = time.ctime(time.time())
        localDateTime = time.ctime()
        print '\n Date/Time: ',localDateTime
# print system info
        print('\n ... Computer name: %s' % self.computerName)
        print(' ... Username: %s' % self.userName)
#        print ' ... Session name:',self.sessionName
        print(' ... Operating system: %s' % self.operatingSystem)
        '''
        print(' ... Processor architecture: %s, %s' % 
            (self.processorArchitecture, self.processorBitWidth)
            )
        print(' ... Processor identifier: %s' % self.processorIdentifier)
        print(' ... Session name: %s' % self.sessionName)
        print(' ... Current directory: %s' % self.currentDirectory)
        '''
        print(' ... Python version: %s' % self.versionPython)
# determine if platform is 'bigEndian' or 'littleEndian'
# ... reference: p. 109, O'Reilly's "Python Standard Library"
        '''
        self.littleEndian = ord(array.array("i",[1]).tostring()[0])
        if self.littleEndian:
            print(' ... little-endian platform (x86 or x86-64 instruction sets)') # also DEC alpha
        else:
            print(' ... big-endian platform (RISC or CISC instruction sets)')
        '''
        
# days since my arbitrary start date
# ... timeStartDate = (yr, month, day, hr, min, sec, day of week, day of year, daylight savings flag)
# ...       start at Jan 1, 2011, Saturday (day 5), with no DST at this date
        timeStartDate = (2011,1,1,0,0,0,5,1,0)
        timeStartDateSinceEpoch_Seconds = time.mktime(timeStartDate)
        timeNow_Seconds = time.time()
        timeNowSinceStartDate_Days = \
            (timeNow_Seconds - timeStartDateSinceEpoch_Seconds)/3600./24. + 1
        
# send usage to database
        userName = self.userName
        serverName = self.comboServerMySQL.get()
        codeName = 'pylotdb'
        versionPython = self.versionPython
        operatingSystem = self.operatingSystem
        dayNumber = int(timeNowSinceStartDate_Days)
        dayOfWeek,month,day,time,year = localDateTime.split()
        hostName = self.computerName
        osName = os.name
# cannot capture following with pylotdb, even tho table structure would take it
        name_first = ''
        name_last = ''
        
# start thread to send stats to database
        if THREAD_STATS_MYSQLACCESS:
            if DEBUG_THREAD_STATS:
                print('\nSTART thread')
            import thread           # for starting threads
            thread.start_new_thread(
                self.threadSendMySqlAccess,
# attributes as *args
                (
                userName,
                serverName,
                name_first,
                name_last,
                codeName,
                versionPython,
                operatingSystem,
                osName,
                dayNumber,
                dayOfWeek,
                month,
                day,
                year,
                time,
                hostName,
                self.mysql_access_stats_server_valid,
                self.mysql_access_stats_server_username,
                self.mysql_access_stats_server_password,
                self.mysql_access_stats_server,
                self.mysql_access_stats_server_port,
                self.mysql_access_stats_database,
                self.mysql_access_stats_table
                )                
                 )
                
        return     

        
    def threadSendMySqlAccess(threadName,*vars):
        '''
        Purpose:
        store usage stats in a database table
        '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'threadSendMySqlAccess')
        
        if DEBUG_THREAD_STATS:
            try:
                if DEBUG_THREAD_VARS:
                    print('\nvars =')
                    print(vars)
            except:
                pass
                
# assign *args to appropriate variables
        userName = vars[0]
        serverName = vars[1]
        name_first = vars[2]
        name_last = vars[3]
        codeName = vars[4]
        versionPython = vars[5]
        operatingSystem = vars[6]
        osName = vars[7]
        dayNumber = vars[8]
        dayOfWeek = vars[9]
        month = vars[10]
        dayOfMonth = vars[11]
        year = vars[12]
        time = vars[13]
        hostName = vars[14]
        mysql_access_stats_server_valid = vars[15]
        mysql_access_stats_server_username = vars[16]
        mysql_access_stats_server_password = vars[17]
        mysql_access_stats_server = vars[18]
        mysql_access_stats_server_port = vars[19]
        mysql_access_stats_database = vars[20]
        mysql_access_stats_table = vars[21]
        
        if DEBUG_THREAD_STATS:
            print('\nDatabase Servers:')
            print('   main: %s' % serverName)
            print('   stats: %s' % mysql_access_stats_server)
        
# ... connect to stats server
        myDbConnection_Track_MySQL_Access = ''
        if mysql_access_stats_server_valid:
            try:
                myDbConnection_Track_MySQL_Access = MySQLdb.connect(
                    user=mysql_access_stats_server_username,
                    passwd=mysql_access_stats_server_password,
                    host=mysql_access_stats_server,
                    port=mysql_access_stats_server_port
                    )
            except:
                if DEBUG_THREAD_STATS:
                    stringNoConnect0 = (
                        'Cannot connect to MySQLAccess stats database due to invalid\n' +
                        'values in the pylotdb.conf file.'
                        )
                    print('\n' + stringNoConnect0 + '\n')
                    return        
        else:
# ... if values are not valid for server, just return and continue;
# ...  we don't want pylotdb stopped just because we can't capture stats
            if DEBUG_THREAD_STATS:
                stringNoConnect1 = (
                    'Cannot connect to MySQLAccess stats database due to blank\n' +
                    'or missing values in the pylotdb.conf file.'
                    )
                print('\n' + stringNoConnect1 + '\n')
            return
            
# ... if value is still blank, just return
        if myDbConnection_Track_MySQL_Access == '':
            stringNoConnect2 = (
                'Cannot connect to MySQLAccess stats database.\n' +
                ' Value for "myDbConnection_Track_MySQL_Access" is blank.\n' +
                ' Check "mysql_access..." values in pylotdb_stats.conf'
                )
            print('\n' + stringNoConnect2 + '\n')
            return
            
# ... if we make it this far, connection to stats database and table is good
        stringConnectSuccess = (
            'Connected to MySQLAccess stats database server: %s'
            ) % (
                mysql_access_stats_server
                )
        print('\n' +stringConnectSuccess)
            
# ... get a cursor handle for executing SQL commands
        cursorHandleMySQL_Track_MySQL_Access = myDbConnection_Track_MySQL_Access.cursor()
# ... turn on autocommit; else, database will not update when we want it to
        cursorHandleMySQL_Track_MySQL_Access.execute("set autocommit = 1")

# check for stats database; if it does not exist, create it
        statDatabases = []
        try:
            cursorHandleMySQL_Track_MySQL_Access.execute("SHOW DATABASES")
            statDatabases = cursorHandleMySQL_Track_MySQL_Access.fetchall() # tuple of tuples
            statDatabases_List = [item[0] for item in statDatabases]    # extract from tuples to get list
        except:
            stringCannotShowDatabases = (
                'Unable to "SHOW DATABASES" for MySQLAccess stats.'
                )
            print('\n' + stringCannotShowDatabases)
            myDbConnection_Track_MySQL_Access.close()
            return 0
            
        if DEBUG_THREAD_STATS:
            print('\nMySQLAccess statDatabases_List:')
            print(statDatabases_List)
            
        if mysql_access_stats_database not in statDatabases_List:
            stringCreateDatabase = "CREATE DATABASE " + mysql_access_stats_database
            if DEBUG_THREAD_STATS:
                print('\nstringCreateDatabase = %s' % stringCreateDatabase)
                print('\nmysql_access_stats_database = %s' % mysql_access_stats_database)
                print('\nstatDatabases = ')
                print(statDatabases)
            
            try:
                cursorHandleMySQL_Track_MySQL_Access.execute(stringCreateDatabase)
            except:
                stringCannotCreateStatsDatabase = (
                    'Unable to create MySQLAccess stats database\n' +
                    '   %s\n' 
                    ) % (
                        mysql_access_stats_database
                        )
                print('\n' + stringCannotCreateStatsDatabase)
                myDbConnection_Track_MySQL_Access.close()
                return
# 
            stringSuccess_CreateStatsDatabase = (
                'Created MySQLAccess stats database: %s'
                ) % (
                mysql_access_stats_database
                )
            print('\n' + stringSucess_CreateStatsDatabase)
            
# check for stats database table; if it does not exist, create it
        statDatabaseTables = []
        tableStats_DatabaseDotTable= mysql_access_stats_database + '.' + mysql_access_stats_table
        
        try:
            cursorHandleMySQL_Track_MySQL_Access.execute(
                "SHOW TABLES FROM " + mysql_access_stats_database
                )
            statDatabaseTables = cursorHandleMySQL_Track_MySQL_Access.fetchall()
            statDatabase_Tables_List = [item[0] for item in statDatabaseTables]
            if DEBUG_THREAD_STATS:
                print('\nMySQLAccess statDatabaseTables =')
                print(statDatabaseTables)
                print('\nMySQLAccess statDatabase_Tables_List')
                print(statDatabase_Tables_List)
        except:
                stringCannotCreateStatsDatabase = (
                    'Unable to "SHOW TABLES" from MySQLAccess stats database.' 
                    ) 
                print('\n' + stringCannotCreateStatsDatabase)
                myDbConnection_Track_MySQL_Access.close()
                return
                
        if mysql_access_stats_table not in statDatabase_Tables_List:
            commandCreateTable = 'CREATE TABLE' + ' ' + tableStats_DatabaseDotTable + ' '
            subCommand = ''
            subCommand += (
                '(' +
                'user char(25) DEFAULT NULL,' +
                'server_name char(255) DEFAULT NULL,' +
                'name_first char(255) DEFAULT NULL,' +
                'name_last char(255) DEFAULT NULL,' +
                'code char(25) DEFAULT NULL,' +
                'python_version char(25) DEFAULT NULL,' +
                'os char(25) DEFAULT NULL,' +
                'os_name char(25) DEFAULT NULL,' +
                'day_number_since_01jan2011 int(5) DEFAULT NULL,' +
                'day_of_week char(3) DEFAULT NULL,' +
                'month char(3) DEFAULT NULL,' +
                'day_of_month int(2) DEFAULT NULL,' +
                'year int(6) DEFAULT NULL,' +
                'time char(8) DEFAULT NULL,' +
                'host_name char(25) DEFAULT NULL,' 
                )
# ... field 16: add auto_index field
            subCommand += (
                'auto_index INT(12) NOT NULL AUTO_INCREMENT PRIMARY KEY )' # field 34
                )
# ... put it all together
            commandCreateTable += subCommand
            
            if DEBUG_THREAD_STATS:
                print('MySQLAccess commandCreateTable = \n')
                print(commandCreateTable)
            
            try:
                cursorHandleMySQL_Track_MySQL_Access.execute(commandCreateTable)
            except:
                stringCannotCreateStatsTable = (
                    'Unable to create MySQLAccess stats table\n' +
                    '   %s\n' 
                    ) % (
                        mysql_access_stats_table
                        )
                print('\n' + stringCannotCreateStatsTable)
                myDbConnection_Track_MySQL_Access.close()
                return
                
            stringSuccess_CreateStatsTable = (
                'Created MySQLAccess stats table: %s'
                ) % (
                mysql_access_stats_table
                )
            print('\n' + stringSuccess_CreateStatsTable)
        
# ... insert data into database
        if DEBUG_THREAD_STATS:
            print('\n >>>>> INSERTing into MySQLAccess stats table')
        stringInsert = (
            "INSERT INTO " + tableStats_DatabaseDotTable +
            " (user,server_name,name_first,name_last,code,python_version,os,os_name," +
            "day_number_since_01jan2011,day_of_week,month,day_of_month,year,time,host_name)" +                      
            " VALUES" +
            " ('%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s'," +
            " '%s', '%s')"  
            ) % (
            userName,
            serverName,
            name_first,
            name_last,
            codeName,
            versionPython,
            operatingSystem,
            osName,
            dayNumber,
            dayOfWeek,
            month,
            dayOfMonth,
            year,
            time,
            hostName
            )
        if DEBUG_THREAD_STATS:
            print('\n' + stringInsert)
            
        try:
            cursorHandleMySQL_Track_MySQL_Access.execute(
                stringInsert
                )
        except:
            if DEBUG_THREAD_STATS:
                currentModule = 'module_accessMySQL.py'
                currentMethod = 'threadSendMySqlAccess'
                stringDatabaseProblem = (
                    'For\n\n' +
                    '  Database: %s\n' +
                    '     Table: %s\n\n' +
                    'either\n\n' +
                    '1. The database and/or table specified for usage stats\n' +
                    '   do not exist.\n' +
                    '   Solution: Use PylotDB to create the missing database/table;\n' +
                    '   table structure must match the INSERT statement.\n' +
                    '2. The database INSERT command to insert data into the\n' +
                    '   database is not correct.\n\n' +
                    '   Solution: Check format of INSERT statement.\n\n' +
                    '   Module: %s\n' +
                    '   Method: %s\n\n' +
                    'Correct and try again.'
                    ) % (
                    mysql_access_stats_database,
                    mysql_access_stats_table,
                    currentModule,
                    currentMethod
                    )
                print('\n' + stringDatabaseProblem)   
            return
            
# disconnect from MySQLAccess stats server
        if DEBUG_THREAD_STATS:
            print(' >>>>> closing MySQLAccess stats server connection')
            
        print('\nMySQLAccess stats submitted')
        
        stringFlushPrivileges = (
            'FLUSH PRIVILEGES'
            )
        cursorHandleMySQL_Track_MySQL_Access.execute(stringFlushPrivileges)
        
        myDbConnection_Track_MySQL_Access.close()
        
        return        

     
    def notYetImplemented(self):
        '''
         splash screen shows that widget used to get
         here is not yet functional
         '''
        if DEBUG_PRINT_METHOD:
            print('\n** In ' + MODULE + '/' + 'notYetImplemented **')
            
        showerror(
            'Error',
            'This widget has not yet been implemented.'
            )
        return

            
        
# ===== main ===== # 
if __name__ == '__main__':
    root = Tk()
    root.geometry(
        '+%d+%d' % (x_Windows, y_Windows) 
        )
    app = AccessMySQL(root,'maroon')
    app.master.title(
       'Access MySQL servers and databases'
        )
    app.master.configure(
        bg='maroon',
        )
    app.mainloop()
    
